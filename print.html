<!DOCTYPE HTML>
<html lang="zh_CN" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust精选</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The roots aren&#x27;t deep but the seeds are planted!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">RustMagazine 中文月刊</li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item "><a href="send_word.html"><strong aria-hidden="true">2.</strong> 创刊寄语</a></li><li class="chapter-item affix "><li class="part-title">2021 年期刊</li><li class="chapter-item "><a href="chapter_1/toc.html"><strong aria-hidden="true">3.</strong> 一月刊（January）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_1/lang.html"><strong aria-hidden="true">3.1.</strong> 本月简报 | Rust官方动态</a></li><li class="chapter-item "><a href="chapter_1/hots.html"><strong aria-hidden="true">3.2.</strong> 本月简报 |社区热点</a></li><li class="chapter-item "><a href="chapter_1/projects.html"><strong aria-hidden="true">3.3.</strong> 本月简报 | 推荐项目</a></li><li class="chapter-item "><a href="chapter_1/learns.html"><strong aria-hidden="true">3.4.</strong> 本月简报 | 学习资源</a></li><li class="chapter-item "><a href="chapter_1/rust_laoke.html"><strong aria-hidden="true">3.5.</strong> 本月简报 | Rust唠嗑室本月汇总</a></li><li class="chapter-item "><a href="chapter_1/jit.html"><strong aria-hidden="true">3.6.</strong> RustChinaConf2020 精选 | 用Rust设计高性能JIT执行引擎</a></li><li class="chapter-item "><a href="chapter_1/rust_async.html"><strong aria-hidden="true">3.7.</strong> RustChinaConf2020 精选 | Rust 异步与并发</a></li><li class="chapter-item "><a href="chapter_1/1password.html"><strong aria-hidden="true">3.8.</strong> 生产实践 |「译」1password 的 Rust 实践</a></li><li class="chapter-item "><a href="chapter_1/cita_protobuf-ext.html"><strong aria-hidden="true">3.9.</strong> 生产实践 | 溪塔科技: 用Rust写Protobuf扩展</a></li><li class="chapter-item "><a href="chapter_1/rust-design-patterns/builder.html"><strong aria-hidden="true">3.10.</strong> 学习园地 | 「系列」Rust设计模式之创建者模式</a></li><li class="chapter-item "><a href="chapter_1/io_uring_and_rust.html"><strong aria-hidden="true">3.11.</strong> 学习园地 | 关于 io_uring 与 Rust 的思考</a></li><li class="chapter-item "><a href="chapter_1/graphql_in_rust/graphql_in_rust.html"><strong aria-hidden="true">3.12.</strong> 学习园地 | 「译」 GraphQL in Rust</a></li><li class="chapter-item "><a href="chapter_1/rust_ownership.html"><strong aria-hidden="true">3.13.</strong> 学习园地 | 图解 Rust 所有权与生命周期</a></li><li class="chapter-item "><a href="chapter_1/embedded_rust.html"><strong aria-hidden="true">3.14.</strong> 嵌入式领域的Rust语言</a></li><li class="chapter-item "><a href="chapter_1/rcore_intro.html"><strong aria-hidden="true">3.15.</strong> 用Rust写操作系统 | rCore OS 教程介绍 </a></li><li class="chapter-item "><a href="chapter_1/rust_security_part1.html"><strong aria-hidden="true">3.16.</strong> Rust Security 专题 | Rust生态安全漏洞总结系列 | Part 1</a></li><li class="chapter-item "><a href="chapter_1/rustc_dev_guide_zh.html"><strong aria-hidden="true">3.17.</strong> Rust编译器专题 | Rust Dev Guide 中文翻译启动招募</a></li><li class="chapter-item "><a href="chapter_1/rustc_part1.html"><strong aria-hidden="true">3.18.</strong> Rust编译器专题 | 图解 Rust 编译器与语言设计 Part 1</a></li></ol></li><li class="chapter-item "><a href="chapter_2/toc.html"><strong aria-hidden="true">4.</strong> 二月刊（February）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_2/announce.html"><strong aria-hidden="true">4.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="chapter_2/lang.html"><strong aria-hidden="true">4.2.</strong> 本月简报 | Rust官方动态</a></li><li class="chapter-item "><a href="chapter_2/hots.html"><strong aria-hidden="true">4.3.</strong> 本月简报 |社区热点</a></li><li class="chapter-item "><a href="chapter_2/projects.html"><strong aria-hidden="true">4.4.</strong> 本月简报 | 推荐项目</a></li><li class="chapter-item "><a href="chapter_2/learns.html"><strong aria-hidden="true">4.5.</strong> 本月简报 | 学习资源</a></li><li class="chapter-item "><a href="chapter_2/rust_laoke.html"><strong aria-hidden="true">4.6.</strong> 本月简报 | Rust唠嗑室本月汇总</a></li><li class="chapter-item "><a href="chapter_2/rust_zhihu.html"><strong aria-hidden="true">4.7.</strong> 知乎 Rust 圆桌年话专题问答精选</a></li><li class="chapter-item "><a href="chapter_2/huawei_rust.html"><strong aria-hidden="true">4.8.</strong> 华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景</a></li><li class="chapter-item "><a href="chapter_2/rust_trace.html"><strong aria-hidden="true">4.9.</strong> PingCAP | TiKV 高性能追踪的实现解析</a></li><li class="chapter-item "><a href="chapter_2/rust_error_handle.html"><strong aria-hidden="true">4.10.</strong> 蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考</a></li><li class="chapter-item "><a href="chapter_2/rust_error_handle_and_log.html"><strong aria-hidden="true">4.11.</strong> 华为 | Rust中的错误传递和日志记录</a></li><li class="chapter-item "><a href="chapter_2/rust_study.html"><strong aria-hidden="true">4.12.</strong> 新年新人新气象 | Rust 学习笔记</a></li><li class="chapter-item "><a href="chapter_2/cli_gameoflife.html"><strong aria-hidden="true">4.13.</strong> 「译」使用 Rust 实现命令行生命游戏</a></li><li class="chapter-item "><a href="chapter_2/actor_with_tokio.html"><strong aria-hidden="true">4.14.</strong> 「译」使用 Tokio 实现 Actor 系统</a></li><li class="chapter-item "><a href="chapter_2/rust_1.50.html"><strong aria-hidden="true">4.15.</strong> 解读 Rust 1.50 稳定版</a></li><li class="chapter-item "><a href="chapter_2/rust_2021_edition.html"><strong aria-hidden="true">4.16.</strong> 解读 Rust 2021 Edition RFC </a></li><li class="chapter-item "><a href="chapter_2/rust_wasm_frontend.html"><strong aria-hidden="true">4.17.</strong> 前端入门 ｜ Rust 和 WebAssembly </a></li><li class="chapter-item "><a href="chapter_2/rust_game_bevy_bomber.html"><strong aria-hidden="true">4.18.</strong> 实践案例 | 使用 Bevy 游戏引擎制作炸弹人</a></li><li class="chapter-item "><a href="chapter_2/io_uring_intro.html"><strong aria-hidden="true">4.19.</strong> io_uring | Linux 全新异步接口 io_uring 的 Rust 生态盘点 </a></li><li class="chapter-item "><a href="chapter_2/io_uring_async_rw.html"><strong aria-hidden="true">4.20.</strong> io_uring | 用 Rust 实现基于 io_uring 的异步随机读文件</a></li><li class="chapter-item "><a href="chapter_2/contribute_to_the_rust_part1.html"><strong aria-hidden="true">4.21.</strong> 如何为 Rust 语言做贡献 | Part 1</a></li></ol></li><li class="chapter-item "><a href="chapter_3/toc.html"><strong aria-hidden="true">5.</strong> 三月刊（March）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_3/announce.html"><strong aria-hidden="true">5.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="chapter_3/lang.html"><strong aria-hidden="true">5.2.</strong> Rust官方动态</a></li><li class="chapter-item "><a href="chapter_3/hots.html"><strong aria-hidden="true">5.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="chapter_3/projects.html"><strong aria-hidden="true">5.4.</strong> 推荐项目</a></li><li class="chapter-item "><a href="chapter_3/learns.html"><strong aria-hidden="true">5.5.</strong> 学习资源</a></li><li class="chapter-item "><a href="chapter_3/rust_laoke.html"><strong aria-hidden="true">5.6.</strong> Rust 唠嗑室本月汇总</a></li><li class="chapter-item "><a href="chapter_3/hw_rust_stratovirt.html"><strong aria-hidden="true">5.7.</strong> 华为 | 基于Rust的下一代虚拟化平台-StratoVirt</a></li><li class="chapter-item "><a href="chapter_3/hw_ndarray.html"><strong aria-hidden="true">5.8.</strong> 华为 | Rust 科学计算多维数组运算库的分析与实践</a></li><li class="chapter-item "><a href="chapter_3/hw_rust_rvm_wasm_ai.html"><strong aria-hidden="true">5.9.</strong> 华为 | 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型</a></li><li class="chapter-item "><a href="chapter_3/rust_cpu_affinity.html"><strong aria-hidden="true">5.10.</strong> 蚂蚁集团 CeresDB 团队 | Rust CPU Affinity 初探</a></li><li class="chapter-item "><a href="chapter_3/rust_rdma.html"><strong aria-hidden="true">5.11.</strong> DatenLord | Rust实现RDMA</a></li><li class="chapter-item "><a href="chapter_3/async-vision-doc.html"><strong aria-hidden="true">5.12.</strong> 建立 Async Rust 的共同愿景</a></li><li class="chapter-item "><a href="chapter_3/how-our-aws-rust-team-will-contribute-to-rusts-future-successes.html"><strong aria-hidden="true">5.13.</strong> Niko | 我们的 AWS Rust 团队将如何为 Rust 未来的成功做出贡献</a></li><li class="chapter-item "><a href="chapter_3/no_std_binary.html"><strong aria-hidden="true">5.14.</strong> no_std 环境下的可执行文件</a></li><li class="chapter-item "><a href="chapter_3/ink.html"><strong aria-hidden="true">5.15.</strong> 用 Rust 写智能合约 | Hello, Ink!  </a></li><li class="chapter-item "><a href="chapter_3/reservoir.html"><strong aria-hidden="true">5.16.</strong> 「算法」蓄水池算法改进 - 面向抽奖场景保证等概率性</a></li><li class="chapter-item "><a href="chapter_3/rust-mysql.html"><strong aria-hidden="true">5.17.</strong> Rust中使用MySQL</a></li><li class="chapter-item "><a href="chapter_3/rust-design-pattern-factory.html"><strong aria-hidden="true">5.18.</strong> 「系列」Rust设计模式 ｜ 工厂模式</a></li><li class="chapter-item "><a href="chapter_3/rust_vs_pandas.html"><strong aria-hidden="true">5.19.</strong> 「译」数据操作：Rust vs Pandas</a></li><li class="chapter-item "><a href="chapter_3/Unsafe_Rust_How_and_when_not_to_use_it.html"><strong aria-hidden="true">5.20.</strong> 「译」Unsafe Rust 的取舍</a></li><li class="chapter-item "><a href="chapter_3/Rhythm-game-in-Rust-using-bevy.html"><strong aria-hidden="true">5.21.</strong> 「译」基于 Rust 用 Bevy 实现节奏大师游戏</a></li><li class="chapter-item "><a href="chapter_3/arenas-in-rust.html"><strong aria-hidden="true">5.22.</strong> 「译」Arenas in Rust</a></li><li class="chapter-item "><a href="chapter_3/toy-front-end-for-llvm-write-in-rust.html"><strong aria-hidden="true">5.23.</strong> 「译」用 Rust 编写 LLVM 的玩具编译器</a></li><li class="chapter-item "><a href="chapter_3/rust-to-system-essence-concurrent.html"><strong aria-hidden="true">5.24.</strong> 透过 Rust 探索系统的本原：并发篇</a></li><li class="chapter-item "><a href="chapter_3/rust-to-system-essence-safety.html"><strong aria-hidden="true">5.25.</strong> 透过 Rust 探索系统的本原：安全篇</a></li><li class="chapter-item "><a href="chapter_3/contribute_to_the_rust_part2.html"><strong aria-hidden="true">5.26.</strong> 如何为 Rust 语言做贡献 | Part 2</a></li></ol></li><li class="chapter-item "><a href="chapter_4/toc.html"><strong aria-hidden="true">6.</strong> 四月刊（April）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_4/announce.html"><strong aria-hidden="true">6.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="chapter_4/info.html"><strong aria-hidden="true">6.2.</strong> Rust 资讯来源汇总</a></li><li class="chapter-item "><a href="chapter_4/lang.html"><strong aria-hidden="true">6.3.</strong> 官方动态</a></li><li class="chapter-item "><a href="chapter_4/hots.html"><strong aria-hidden="true">6.4.</strong> 社区热点</a></li><li class="chapter-item "><a href="chapter_4/events.html"><strong aria-hidden="true">6.5.</strong> 活动回顾</a></li><li class="chapter-item "><a href="chapter_4/jobs.html"><strong aria-hidden="true">6.6.</strong> 本月招聘</a></li><li class="chapter-item "><a href="chapter_4/safe_system.html"><strong aria-hidden="true">6.7.</strong> 论文鉴赏 | 使用 Rust 进行安全系统编程</a></li><li class="chapter-item "><a href="chapter_4/safe_drop.html"><strong aria-hidden="true">6.8.</strong> 论文鉴赏 | SafeDrop：通过静态数据流分析检测Rust程序的内存释放错误</a></li><li class="chapter-item "><a href="chapter_4/event_os_design.html"><strong aria-hidden="true">6.9.</strong> 学界动态</a></li><li class="chapter-item "><a href="chapter_4/hw_stratovirt.html"><strong aria-hidden="true">6.10.</strong> 华为 | StratoVirt 地址空间管理-基于Rust的实现与优化</a></li><li class="chapter-item "><a href="chapter_4/hw_bin_opt.html"><strong aria-hidden="true">6.11.</strong> 华为 | Rust 编译后二进制大小和常用优化方式</a></li><li class="chapter-item "><a href="chapter_4/ant_async_os_opt.html"><strong aria-hidden="true">6.12.</strong> 蚂蚁集团 | 异步化OS：利用Rustasyncawait提升10x性能-Rust</a></li><li class="chapter-item "><a href="chapter_4/ant_trait.html"><strong aria-hidden="true">6.13.</strong> 蚂蚁集团 | Trait 使用及实现分析</a></li><li class="chapter-item "><a href="chapter_4/zhihu_simd_rucene.html"><strong aria-hidden="true">6.14.</strong> 知乎 | 基于 SIMD 指令优化 Rucene</a></li><li class="chapter-item "><a href="chapter_4/datenlord_io_uring.html"><strong aria-hidden="true">6.15.</strong> Datenlord | Rust 异步实现 io_uring </a></li><li class="chapter-item "><a href="chapter_4/rust_ffi.html"><strong aria-hidden="true">6.16.</strong> PingCAP | 使用 Rust FFI </a></li><li class="chapter-item "><a href="chapter_4/libp2p_ipfs.html"><strong aria-hidden="true">6.17.</strong> Netwarp | libp2p-rs与IPFS-Rust </a></li><li class="chapter-item "><a href="chapter_4/google_android_rust.html"><strong aria-hidden="true">6.18.</strong> Google | 在 Android 平台使用 Rust</a></li><li class="chapter-item "><a href="chapter_4/meili_search.html"><strong aria-hidden="true">6.19.</strong> MeiliSearch | 开源搜索引擎</a></li><li class="chapter-item "><a href="chapter_4/learn.html"><strong aria-hidden="true">6.20.</strong> 学习资源</a></li><li class="chapter-item "><a href="chapter_4/a-primer-on-rusts-result-type.html"><strong aria-hidden="true">6.21.</strong> 【译】Rust 的 Result 类型基础</a></li><li class="chapter-item "><a href="chapter_4/faq.html"><strong aria-hidden="true">6.22.</strong> 常见问题汇总</a></li><li class="chapter-item "><a href="chapter_4/tips.html"><strong aria-hidden="true">6.23.</strong> 语言技巧</a></li><li class="chapter-item "><a href="chapter_4/try_trait_v2.html"><strong aria-hidden="true">6.24.</strong> RFC 介绍 | try-trait v2</a></li><li class="chapter-item "><a href="chapter_4/2021_edition_preview.html"><strong aria-hidden="true">6.25.</strong> 【官宣】Rust 2021 Edition 计划</a></li><li class="chapter-item "><a href="chapter_4/rustc_edit_distance_and_typo_checker.html"><strong aria-hidden="true">6.26.</strong> 用 rustc 源码实现拼写错误候选词建议</a></li><li class="chapter-item "><a href="chapter_4/nom_url.html"><strong aria-hidden="true">6.27.</strong> 使用 nom 解析 url</a></li><li class="chapter-item "><a href="chapter_4/facade.html"><strong aria-hidden="true">6.28.</strong> 真实世界的设计模式 | 外观模式（Facade Pattern）</a></li><li class="chapter-item "><a href="chapter_4/rust-to-system-essence-raii.html"><strong aria-hidden="true">6.29.</strong> Rust 探索系统本原 | RAII </a></li><li class="chapter-item "><a href="chapter_4/rust-to-system-essence-lang.html"><strong aria-hidden="true">6.30.</strong> Rust 探索系统本原 | 编程语言 </a></li><li class="chapter-item "><a href="chapter_4/rust-to-system-essence-memory.html"><strong aria-hidden="true">6.31.</strong> Rust 探索系统本原 | 内存管理 </a></li><li class="chapter-item "><a href="chapter_4/rust-to-system-essence-network.html"><strong aria-hidden="true">6.32.</strong> Rust 探索系统本原 | 网络 </a></li><li class="chapter-item "><a href="chapter_4/contribute_to_the_rust_part3.html"><strong aria-hidden="true">6.33.</strong> 如何为 Rust 语言做贡献 | Part 3 </a></li><li class="chapter-item "><a href="chapter_4/improve-std-slice-binary-search.html"><strong aria-hidden="true">6.34.</strong> 优化 Rust 标准库的 binary_search</a></li><li class="chapter-item "><a href="chapter_4/github_trending.html"><strong aria-hidden="true">6.35.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="chapter_4/tool_libs.html"><strong aria-hidden="true">6.36.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="chapter_4/frameworks.html"><strong aria-hidden="true">6.37.</strong> 推荐项目 |  框架引擎</a></li><li class="chapter-item "><a href="chapter_4/tensorbase.html"><strong aria-hidden="true">6.38.</strong> 开源产品 | TensorBase，基于Rust的现代化开源数据仓库</a></li><li class="chapter-item "><a href="chapter_4/zenoh.html"><strong aria-hidden="true">6.39.</strong> 开源产品 | eclipse zenoh 助力雾计算和边缘计算</a></li><li class="chapter-item "><a href="chapter_4/unsafe_rust_tips.html"><strong aria-hidden="true">6.40.</strong> Unsafe Rust 编码技巧 | Part 1</a></li></ol></li><li class="chapter-item "><a href="chapter_5/toc.html"><strong aria-hidden="true">7.</strong> 五月刊（May）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_5/announce.html"><strong aria-hidden="true">7.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="chapter_5/lang.html"><strong aria-hidden="true">7.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="chapter_5/hots.html"><strong aria-hidden="true">7.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="chapter_5/events.html"><strong aria-hidden="true">7.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="chapter_5/jobs.html"><strong aria-hidden="true">7.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="chapter_5/six-years-of-rust.html"><strong aria-hidden="true">7.6.</strong> 官方 | Rust 发布六周年</a></li><li class="chapter-item "><a href="chapter_5/rusts-most-unrecognized-contributor.html"><strong aria-hidden="true">7.7.</strong> Rust 贡献名单上的无名英雄</a></li><li class="chapter-item "><a href="chapter_5/pl.html"><strong aria-hidden="true">7.8.</strong> 漫谈编程语言的设计和实现</a></li><li class="chapter-item "><a href="chapter_5/hw_StratoVirt_vcpu.html"><strong aria-hidden="true">7.9.</strong> 华为 | StratoVirt VCPU管理-Rust线程同步的实现</a></li><li class="chapter-item "><a href="chapter_5/rust-memory-troubleshootting.html"><strong aria-hidden="true">7.10.</strong> 蚂蚁集团 ｜ 如何在生产环境排查 Rust 内存占用过高问题</a></li><li class="chapter-item "><a href="chapter_5/rust-epoll-rdma.html"><strong aria-hidden="true">7.11.</strong> Datenlord | Rust实现RDMA异步编程（一）：基于epoll实现RDMA 异步操作</a></li><li class="chapter-item "><a href="chapter_5/facebook_with_rust.html"><strong aria-hidden="true">7.12.</strong> Facebook | 应用 Rust 简史</a></li><li class="chapter-item "><a href="chapter_5/rust_grpc_load_balancing.html"><strong aria-hidden="true">7.13.</strong> Truelayer | Rust 中的 gRPC 负载均衡</a></li><li class="chapter-item "><a href="chapter_5/learn.html"><strong aria-hidden="true">7.14.</strong> 学习资源</a></li><li class="chapter-item "><a href="chapter_5/Things_you_can_not_do_in_Rust.html"><strong aria-hidden="true">7.15.</strong> Rust 中无法办到的事情(以及如何替代)</a></li><li class="chapter-item "><a href="chapter_5/proc_macro_workshop_guide_for_builder_project.html"><strong aria-hidden="true">7.16.</strong> Rust过程宏系列教程 | Proc Macro Workshop 之 Builder 实现</a></li><li class="chapter-item "><a href="chapter_5/running_rust_on_android.html"><strong aria-hidden="true">7.17.</strong> 在 Android 中运行 Rust </a></li><li class="chapter-item "><a href="chapter_5/ink_01.html"><strong aria-hidden="true">7.18.</strong> Rust 与 区块链 | ink! 编程实战（一）: 初识 ink!</a></li><li class="chapter-item "><a href="chapter_5/faq.html"><strong aria-hidden="true">7.19.</strong> 常见问题汇总</a></li><li class="chapter-item "><a href="chapter_5/tips.html"><strong aria-hidden="true">7.20.</strong> 语言技巧</a></li><li class="chapter-item "><a href="chapter_5/rust-gat.html"><strong aria-hidden="true">7.21.</strong> 了解一点关于泛型关联类型(GAT)的事</a></li><li class="chapter-item "><a href="chapter_5/rust-runtime-and-ABI.html"><strong aria-hidden="true">7.22.</strong> Rust Runtime 与 ABI</a></li><li class="chapter-item "><a href="chapter_5/cache_and_recursion_memoization.html"><strong aria-hidden="true">7.23.</strong> 借鉴数据库缓存解决动态规划难题</a></li><li class="chapter-item "><a href="chapter_5/kernel_huge_page_subsystem.html"><strong aria-hidden="true">7.24.</strong> Rust 与 OS | 一种有效的页表系统抽象设计</a></li><li class="chapter-item "><a href="chapter_5/rpi_os.html"><strong aria-hidden="true">7.25.</strong> 学习笔记 ｜ 树莓派 Rust 嵌入式操作系统 之 驱动：GPIO 和 UART</a></li><li class="chapter-item "><a href="chapter_5/rust-to-system-essence-lang-generic.html"><strong aria-hidden="true">7.26.</strong> 透过 Rust 探索系统的本原：泛型</a></li><li class="chapter-item "><a href="chapter_5/github_trending.html"><strong aria-hidden="true">7.27.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="chapter_5/tool_libs.html"><strong aria-hidden="true">7.28.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="chapter_5/frameworks.html"><strong aria-hidden="true">7.29.</strong> 推荐项目 |  框架引擎</a></li><li class="chapter-item "><a href="chapter_5/rust-security-part-2.html"><strong aria-hidden="true">7.30.</strong> Rust生态安全漏洞总结系列 | Part 2</a></li><li class="chapter-item "><a href="chapter_5/rust-makes-malware-stronger.html"><strong aria-hidden="true">7.31.</strong> Rust 与 安全 | Rust 让恶意软件也变强了</a></li></ol></li><li class="chapter-item "><a href="chapter_6/toc.html"><strong aria-hidden="true">8.</strong> 六月刊（June）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_6/announce.html"><strong aria-hidden="true">8.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="chapter_6/lang.html"><strong aria-hidden="true">8.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="chapter_6/hots.html"><strong aria-hidden="true">8.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="chapter_6/events.html"><strong aria-hidden="true">8.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="chapter_6/jobs.html"><strong aria-hidden="true">8.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="chapter_6/rust-not-a-company.html"><strong aria-hidden="true">8.6.</strong> Rust与开源 ｜ Rust 不是一家公司</a></li><li class="chapter-item "><a href="chapter_6/open-source-mental-health.html"><strong aria-hidden="true">8.7.</strong> 开源与心理健康</a></li><li class="chapter-item "><a href="chapter_6/rust-report.html"><strong aria-hidden="true">8.8.</strong> 三万言｜2021 年 Rust 行业调研报告</a></li><li class="chapter-item "><a href="chapter_6/webassmebly-security.html"><strong aria-hidden="true">8.9.</strong> 华为 | WebAssembly 安全性调研</a></li><li class="chapter-item "><a href="chapter_6/hw_StratoVirt_balloon.html"><strong aria-hidden="true">8.10.</strong> 华为 | StratoVirt - 基于Rust的 balloon 功能实践</a></li><li class="chapter-item "><a href="chapter_6/ant-rust-data-layout.html"><strong aria-hidden="true">8.11.</strong> 蚂蚁集团 ｜ Rust 数据内存布局</a></li><li class="chapter-item "><a href="chapter_6/rust-lockfree.html"><strong aria-hidden="true">8.12.</strong> Datenlord | Rust 语言无锁数据结构的内存管理</a></li><li class="chapter-item "><a href="chapter_6/docker-wasm.html"><strong aria-hidden="true">8.13.</strong> SecondState | 用 Docker 工具管理 Rust 函数</a></li><li class="chapter-item "><a href="chapter_6/custom-clippy.html"><strong aria-hidden="true">8.14.</strong> 华为 | 如何定制 Cargo Clippy </a></li><li class="chapter-item "><a href="chapter_6/static_analysis_custom_clippy_lint.html"><strong aria-hidden="true">8.15.</strong> 定制静态分析 lint 检查规则</a></li><li class="chapter-item "><a href="chapter_6/write-rust-lints-without-forking-clippy.html"><strong aria-hidden="true">8.16.</strong> 无需 fork Clippy 就可以编写 Rust lints</a></li><li class="chapter-item "><a href="chapter_6/learn.html"><strong aria-hidden="true">8.17.</strong> 学习资源</a></li><li class="chapter-item "><a href="chapter_6/proc_macro_workshop_guide_for_builder_project.html"><strong aria-hidden="true">8.18.</strong> Rust过程宏系列教程 | Proc Macro Workshop 之 Debug </a></li><li class="chapter-item "><a href="chapter_6/rust_study_part_4.html"><strong aria-hidden="true">8.19.</strong> Rust 学习笔记系列｜ Part 4</a></li><li class="chapter-item "><a href="chapter_6/rust_study_part_5.html"><strong aria-hidden="true">8.20.</strong> Rust 学习笔记系列｜ Part 5</a></li><li class="chapter-item "><a href="chapter_6/rust_study_part_6.html"><strong aria-hidden="true">8.21.</strong> Rust 学习笔记系列｜ Part 6</a></li><li class="chapter-item "><a href="chapter_6/rust_study_part_7.html"><strong aria-hidden="true">8.22.</strong> Rust 学习笔记系列｜ Part 7</a></li><li class="chapter-item "><a href="chapter_6/parser-combinator.html"><strong aria-hidden="true">8.23.</strong> 用 Rust 学习解析器组合子 (combinator)</a></li><li class="chapter-item "><a href="chapter_6/web3-part1.html"><strong aria-hidden="true">8.24.</strong> 对Web3.0概念的梳理</a></li><li class="chapter-item "><a href="chapter_6/rabits.html"><strong aria-hidden="true">8.25.</strong> Rbatis ORM 2.0 | 零开销编译时动态SQL的探索</a></li><li class="chapter-item "><a href="chapter_6/github_trending.html"><strong aria-hidden="true">8.26.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="chapter_6/tool_libs.html"><strong aria-hidden="true">8.27.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="chapter_6/frameworks.html"><strong aria-hidden="true">8.28.</strong> 推荐项目 |  框架引擎</a></li></ol></li><li class="chapter-item "><a href="chapter_7/toc.html"><strong aria-hidden="true">9.</strong> 七月刊（July）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chapter_7/announce.html"><strong aria-hidden="true">9.1.</strong> 发刊通告</a></li><li class="chapter-item "><a href="chapter_7/lang.html"><strong aria-hidden="true">9.2.</strong> 官方动态</a></li><li class="chapter-item "><a href="chapter_7/hots.html"><strong aria-hidden="true">9.3.</strong> 社区热点</a></li><li class="chapter-item "><a href="chapter_7/events.html"><strong aria-hidden="true">9.4.</strong> 活动回顾</a></li><li class="chapter-item "><a href="chapter_7/jobs.html"><strong aria-hidden="true">9.5.</strong> 本月招聘</a></li><li class="chapter-item "><a href="chapter_7/rust_china_conf_2021.html"><strong aria-hidden="true">9.6.</strong> RustChinaConf 2021 议题征集开放申请</a></li><li class="chapter-item "><a href="chapter_7/paper-rust-vs-c.html"><strong aria-hidden="true">9.7.</strong> 论文导读 | 性能与生产力 : Rust vs C </a></li><li class="chapter-item "><a href="chapter_7/hw-rust-name-mangling.html"><strong aria-hidden="true">9.8.</strong> 华为 | Rust 调用约定和名称修饰规则介绍</a></li><li class="chapter-item "><a href="chapter_7/ant-futures-compat.html"><strong aria-hidden="true">9.9.</strong> 蚂蚁集团 | Futures 0.1 和 0.3 兼容层的分析与应用</a></li><li class="chapter-item "><a href="chapter_7/lark-rust-wasm-sqlite.html"><strong aria-hidden="true">9.10.</strong> 字节跳动 ｜ 飞书 Rust 实践 之 SQLite 适配 WASM </a></li><li class="chapter-item "><a href="chapter_7/rust-epoll-rdma-part2.html"><strong aria-hidden="true">9.11.</strong> Datenlord | Rust实现RDMA异步编程（二）</a></li><li class="chapter-item "><a href="chapter_7/how-we-improved-the-performance-of-our-rust-app.html"><strong aria-hidden="true">9.12.</strong> Zellij 的性能优化</a></li><li class="chapter-item "><a href="chapter_7/learn.html"><strong aria-hidden="true">9.13.</strong> 学习资源</a></li><li class="chapter-item "><a href="chapter_7/rusts-standard-library-traits.html"><strong aria-hidden="true">9.14.</strong> 【完整】Rust 标准库 Trait 指南</a></li><li class="chapter-item "><a href="chapter_7/coercion_in_rust.html"><strong aria-hidden="true">9.15.</strong> Rust 中的隐式类型转换</a></li><li class="chapter-item "><a href="chapter_7/tokio-task-scheduler.html"><strong aria-hidden="true">9.16.</strong> Tokio Internals 之 任务调度</a></li><li class="chapter-item "><a href="chapter_7/about-rust-features.html"><strong aria-hidden="true">9.17.</strong> 为什么你不应该沉迷于 Rust 的“特性”</a></li><li class="chapter-item "><a href="chapter_7/rust-no-std.html"><strong aria-hidden="true">9.18.</strong> Rust no-std 工程实践</a></li><li class="chapter-item "><a href="chapter_7/dynamic_analyzing_tools.html"><strong aria-hidden="true">9.19.</strong> Rust 内存错误调试和动态分析工具分享</a></li><li class="chapter-item "><a href="chapter_7/macroquad_game.html"><strong aria-hidden="true">9.20.</strong> 使用Macroquad在Android设备上发布游戏</a></li><li class="chapter-item "><a href="chapter_7/trampoline-kernel.html"><strong aria-hidden="true">9.21.</strong> 跨空间跳板内核</a></li><li class="chapter-item "><a href="chapter_7/trait-upcasting-part1.html"><strong aria-hidden="true">9.22.</strong> Trait Upcasting 系列 ｜ Part I</a></li><li class="chapter-item "><a href="chapter_7/github_trending.html"><strong aria-hidden="true">9.23.</strong> GitHub 趋势榜</a></li><li class="chapter-item "><a href="chapter_7/tool_libs.html"><strong aria-hidden="true">9.24.</strong> 推荐项目 ｜ 基础工具库</a></li><li class="chapter-item "><a href="chapter_7/frameworks.html"><strong aria-hidden="true">9.25.</strong> 推荐项目 |  框架引擎</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">10.</strong> 八月刊（August）| 待发布</div></li><li class="chapter-item "><div><strong aria-hidden="true">11.</strong> 九月刊（September）| 待发布</div></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> 十月刊（October）| 待发布</div></li><li class="chapter-item "><div><strong aria-hidden="true">13.</strong> 十一月刊（November）| 待发布</div></li><li class="chapter-item "><div><strong aria-hidden="true">14.</strong> 十二月刊（December）| 待发布</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust精选</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/RustMagazine/rust_magazine_2021" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust语言开源杂志2021" id="rust语言开源杂志2021">Rust语言开源杂志（2021）</a></h1>
<p><strong>The roots aren't deep but the seeds are planted!</strong></p>
<p><img src="./image/rust_magazine3.png" alt="logo" /></p>
<p>为了丰富 Rust 社区成员的学习文化生活而特别推出此刊！</p>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/">GitHub Page 阅读</a></li>
<li><a href="https://www.yuque.com/chaosbot/rust_magazine_2021">语雀阅读</a></li>
<li><a href="https://github.com/RustMagazine/rust_magazine_2021">仓库地址</a></li>
</ul>
<h3><a class="header" href="#pdf-下载" id="pdf-下载">PDF 下载</a></h3>
<p>2021 上半年集合 PDF： <a href="https://github.com/RustMagazine/rust_magazine_2021/releases/tag/0.5">下载</a></p>
<h3><a class="header" href="#如何订阅本刊-rss-" id="如何订阅本刊-rss-">如何订阅本刊 RSS ?</a></h3>
<ol>
<li>
<p>订阅地址：<a href="https://rustmagazine.github.io/rust_magazine_2021/rss.xml">https://rustmagazine.github.io/rust_magazine_2021/rss.xml</a></p>
</li>
<li>
<p>复制订阅地址到你最喜欢的订阅工具开始订阅。</p>
</li>
</ol>
<hr />
<h3><a class="header" href="#发刊渠道" id="发刊渠道">发刊渠道</a></h3>
<pre class="mermaid">graph TD
    A[RustMagazine] --&gt;|每月最后一天| B(发刊)
    B --&gt; C{阅读渠道}
    C --&gt; |GitHub Page| D[GitHub]
    C --&gt;|Rustcc| E[Rust中文论坛/公众号]
    C --&gt;|Rust视界| F[Telegram]
    C --&gt;|掘金| G[技术社区]
    C --&gt;|语雀| H[在线文档]
</pre>
<h3><a class="header" href="#编辑小组" id="编辑小组">编辑小组</a></h3>
<ul>
<li>
<p>张汉东（Chaos）</p>
</li>
<li>
<p><a href="https://www.yuque.com/lidongjies">李冬杰</a></p>
</li>
<li>
<p>柴杰</p>
</li>
<li>
<p><a href="https://github.com/DaviRain-Su">苏胤榕（DaviRain）</a></p>
</li>
<li>
<p>聂雷海（大海）</p>
</li>
<li>
<p>严炳（ryan）</p>
</li>
<li>
<p><a href="https://github.com/wangshengfei/">橘梦</a></p>
</li>
<li>
<p>高宪凤</p>
</li>
<li>
<p>杨楚天（yct21）</p>
</li>
<li>
<p>Matrixtang</p>
</li>
<li>
<p>m1zzx2 </p>
</li>
<li>
<p><a href="https://github.com/NiZerin">NiZerin</a> </p>
</li>
<li>
<p>&lt;其他成员招募位&gt; 招募条件见下方</p>
</li>
</ul>
<h3><a class="header" href="#编辑招募条件" id="编辑招募条件">编辑招募条件</a></h3>
<ul>
<li>热爱 Rust 语言</li>
<li>有时间参与编辑文章</li>
<li>有学习的心态</li>
</ul>
<p>有意者请联系。</p>
<h3><a class="header" href="#发刊渠道-1" id="发刊渠道-1">发刊渠道</a></h3>
<ul>
<li><a href="https://rustcc.cn">Rustcc 中文社区</a></li>
<li><a href="https://t.me/rust_daily_news">Rust 视界 Tg Channel</a></li>
<li><a href="https://juejin.cn/user/123560414944158">掘金</a></li>
<li><a href="https://talk.citahub.com">CITAHub社区</a></li>
</ul>
<h3><a class="header" href="#支持公司和高校" id="支持公司和高校">支持公司和高校</a></h3>
<p>感谢以下公司和高校大力支持 RustMagazine并贡献内容，排名不分先后。</p>
<ul>
<li>华为</li>
<li>PingCAP</li>
<li>蚂蚁集团</li>
<li>溪塔科技</li>
<li>国汽智控</li>
<li>清华大学</li>
<li>期待更多</li>
</ul>
<h3><a class="header" href="#特别感谢" id="特别感谢">特别感谢</a></h3>
<ul>
<li>Rustcc 中文社区</li>
<li>《Rust 日报》小组全体成员</li>
<li>《Rust 唠嗑室》组织者和全体参与者</li>
</ul>
<h3><a class="header" href="#许可" id="许可">许可</a></h3>
<p><img src="./image/cc.png" alt="cc" /></p>
<p>本电子杂志采用「<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-Hans">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)许可协议</a>」进行许可，非商业性转载请注明出处，其他需求请与我们联系。</p>
<h1><a class="header" href="#创刊寄语" id="创刊寄语">创刊寄语</a></h1>
<p><em>作者：张汉东</em></p>
<p><strong>The roots aren't deep but the seeds are planted!</strong></p>
<p>自从<code>2015</code>年<code>5</code>月<code>15</code>号 <code>Rust 1.0</code> 稳定版发布以来，<code>Rust</code>发展已经经历了五个半年头。</p>
<p>头三个年头，<code>Rust</code>发展是缓慢的。直到<code>Rust 2018 Edition</code>发布开始，<code>Rust</code>便逐渐开始走入各大企业。我在<code>2018</code>年发起《<code>Rust</code>日报》之初，全球范围内应用<code>Rust</code>的动态还是寥寥无几，我还在发愁去哪里寻找<code>Rust</code>的动态。但是到了<code>2020</code>年底，《<code>Rust</code>日报》已经不再为<code>Rust</code>动态而发愁，几乎每天都会有新的项目和文章冒出来，覆盖了<code>Rust</code>应用领域的方方面面。足以见证<code>Rust</code>的发展趋势。</p>
<p>然而，这些<code>Rust</code>动态，有<code>90%</code>都是出自国外社区。其实近两年，<code>Rust</code>在国内也陆陆续续有一些公司开始采用，国内也逐渐看了一些优秀的<code>Rust</code>学习原创文章。在去年 <code>RustChinaConf2020</code>大会上，我们也看到了很多国内公司和开源社区的个人项目。然而，目前国内各大应用<code>Rust</code>的公司和<code>Rust</code>社区都还缺乏很多原创的精品输出，或者，有很多精品输出，还被隐藏在互联网信息洪流中，未被我们发现。</p>
<p>在当前的这种背景环境下，办一份电子杂志的想法就由此诞生了。所以，各位<code>Rustacean</code>们，《<code>Rust</code>中文精选》今天创刊了！</p>
<p>《<code>Rust</code>中文精选》的目标就是要连接公司、社区、高校和个体，挖掘更多国内的<code>Rust</code>领域的精品原创内容，让大家沟通有无。《<code>Rust</code>中文精选》将是永久开源和非商业化的。</p>
<p><img src="./image/rustmagazine-connect.png" alt="rustmagzine_connect" /></p>
<p>《<code>Rust</code>中文精选》每月最后一天正式发刊，提供三种阅读方式：</p>
<ul>
<li>在线阅读。大家可以通过我们指定的渠道找到本刊的阅读入口，点击链接可直接在线阅读。暂时是通过<code>GitHub Page</code>，回头找时间在 <code>Gitee</code> 上面发布。</li>
<li>本地阅读。你也可以通过本刊源码仓库直接获取杂志，在本地执行<code>mdbook build &amp;&amp; mdbook watch --open</code> 就可阅读。</li>
<li>PDF 电子版。可以通过GitHub仓库和指定渠道下载。</li>
</ul>
<p>本刊内容希望涵盖且不限于以下内容：</p>
<ul>
<li><strong>Rust 本月简报</strong>。 从《<code>Rust</code> 日报》中摘录和整理本月的亮点。</li>
<li><strong>Rust in Production</strong>。介绍 <code>Rust</code> 在企业内的一些生产实践和心得。</li>
<li><strong>开源项目</strong>。从应用到实现原理和细节，介绍 <code>Rust</code> 的一些优秀开源项目。</li>
<li><strong>Rust 语言</strong>。 分享 <code>Rust</code> 语言概念、技巧、设计模式、工程实践等心得经验。</li>
<li><strong>Rust 编译器</strong>。分享 <code>Rust</code> 编译器整体架构、实现细节、贡献。</li>
<li><strong>Rust Security</strong>。分享 <code>Rust</code> 语言及生态中的一些安全漏洞诞生的原因和解决方案。</li>
<li><strong>游戏开发</strong>。分享 <code>Rust</code> 游戏开发和学习的方方面面。</li>
<li><strong>操作系统</strong>。分享 <code>Rust</code> 操作系统开发和学习的方方面面。</li>
<li><strong>嵌入式 Rust</strong>。分享 <code>Rust</code> 嵌入式开发中的点点滴滴。</li>
<li><strong>分布式开发</strong>。分享 <code>Rust</code> 在分布式领域的实践。</li>
<li><strong>网络开发</strong>。分享 <code>Rust</code> 网络开发领域的方方面面。</li>
<li><strong>云原生</strong>。分享 <code>Rust</code> 在云原生领域的实践。</li>
<li><strong>前端开发</strong>。 分享 <code>Rust</code> 和 <code>WebAssembly</code> 在前端的应用实践。</li>
<li><strong>图形化开发</strong>。分享 <code>Rust</code> 在 图形化开发方面的实践。</li>
<li><strong>大数据/人工智能</strong>。分享 <code>Rust</code> 在 大数据和人工智能开发方面的实践。</li>
<li><strong>Rust 算法</strong>。用 <code>Rust</code> 刷算法是什么体验？</li>
</ul>
<p>希望大家能踊跃投稿和参与编辑。可以直接给本刊<code>GitHub</code>仓库发<code>PR</code>，哪怕不一定能被入选，也可以发出你的声音！每个月一期，意味着你每个月精下心来创作一份精品文章，用来总结你在公司的实践和学习<code>Rust</code>的心得。</p>
<p>也希望越来越多的公司参与到期刊内容建设中来，对公司而言，不仅仅是经验分享，更是一种技术文化输出。</p>
<p><strong>在这浮躁的年代，希望这份期刊能帮助你找回技术的初心和野望。</strong></p>
<h1><a class="header" href="#一月刊" id="一月刊">一月刊</a></h1>
<p><img src="chapter_1/../image/rust_magazine3.png" alt="logo" /></p>
<h3><a class="header" href="#本月社区动态简报" id="本月社区动态简报">本月社区动态简报</a></h3>
<p>精选自《Rust日报》</p>
<ul>
<li><a href="chapter_1/./lang.html">Rust官方动态</a></li>
<li><a href="chapter_1/./hots.html">社区热点</a></li>
<li><a href="chapter_1/./projects.html">推荐项目</a></li>
<li><a href="chapter_1/./learns.html">学习资源</a></li>
<li><a href="chapter_1/./rust_laoke.html">Rust 唠嗑室本月汇总</a></li>
</ul>
<h3><a class="header" href="#rustchinaconf-2020-专题" id="rustchinaconf-2020-专题">RustChinaConf 2020 专题</a></h3>
<ul>
<li><a href="chapter_1/./jit.html">RustChinaConf2020 精选 | 用Rust设计高性能JIT执行引擎</a></li>
<li><a href="chapter_1/./rust_async.html">RustChinaConf2020 精选 | Rust 异步与并发</a></li>
</ul>
<h3><a class="header" href="#rust-in-production" id="rust-in-production">Rust in Production</a></h3>
<ul>
<li><a href="chapter_1/./1password.html">「翻译」1password 的 Rust 实践</a></li>
<li><a href="chapter_1/./cita_protobuf-ext.html">溪塔科技: 用Rust写Protobuf扩展</a></li>
</ul>
<h3><a class="header" href="#学习园地" id="学习园地">学习园地</a></h3>
<ul>
<li><a href="chapter_1/./rust-design-patterns/builder.html">「系列」Rust设计模式</a></li>
<li><a href="chapter_1/./io_uring_and_rust.html">关于 io_uring 与 Rust 的思考</a></li>
<li><a href="chapter_1/./graphql_in_rust/graphql_in_rust.html">GraphQL in Rust</a></li>
<li><a href="chapter_1/./rust_ownership.html">图解 Rust 所有权与生命周期</a></li>
</ul>
<h3><a class="header" href="#嵌入式-rust-专题" id="嵌入式-rust-专题">嵌入式 Rust 专题</a></h3>
<ul>
<li><a href="chapter_1/./embedded_rust.html">嵌入式领域的Rust语言</a></li>
</ul>
<h3><a class="header" href="#操作系统专题" id="操作系统专题">操作系统专题</a></h3>
<ul>
<li><a href="chapter_1/./rcore_intro.html">用<code>Rust</code>写操作系统 | 清华 rCore OS 教程介绍 </a></li>
</ul>
<h3><a class="header" href="#rust-security-专题" id="rust-security-专题">Rust Security 专题</a></h3>
<ul>
<li><a href="chapter_1/./rust_security_part1.html"><code>Rust</code>生态安全漏洞总结系列 | Part1</a></li>
</ul>
<h3><a class="header" href="#rust-编译器专题" id="rust-编译器专题">Rust 编译器专题</a></h3>
<ul>
<li><a href="chapter_1/./rustc_dev_guide_zh.html">Rustc Dev Guide 中文翻译启动</a></li>
<li><a href="chapter_1/./rustc_part1.html">图解 Rust 编译器与语言设计 | Part 1</a></li>
</ul>
<h1><a class="header" href="#本月简报官方动态" id="本月简报官方动态">本月简报：官方动态</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>专题编辑：张汉东</li>
</ul>
<hr />
<h2><a class="header" href="#rust-149-稳定版发布" id="rust-149-稳定版发布">Rust 1.49 稳定版发布</a></h2>
<p>2020年最后一天，Rust 1.49 稳定版发布了。稳定版 Rust 发布周期为六周一次。</p>
<p>值得关注的更新：</p>
<ul>
<li><code>aarch64-unknown-linux-gnu</code> 升级为<code>Tier 1</code>。</li>
<li><code>aarch64-apple-darwin</code> 和<code>aarch64-pc-windows-msvc</code> 得到<code>Tier 2</code> 级别的支持。</li>
<li>单元测试中线程中的print输出将会被捕获，默认不会在控制台打印出来了。如果不需要捕获，需要添加--nocapture参数。</li>
<li><code>union</code>支持 <code>impl Drop trait</code> 了
支持使用<code>ref</code>关键字让解构的字段不再被move 而是被借用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main(){
    let person = Person {
    name: String::from(&quot;Alice&quot;),
    age: 20,
    };

    // `name` is moved out of person, but `age` is referenced.
    let Person { name, ref age } = person;
    println!(&quot;{} {}&quot;, name, age);
}

</code></pre></pre>
<p><a href="https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html">https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html</a></p>
<h2><a class="header" href="#rust-将不再支持-windows-xp" id="rust-将不再支持-windows-xp">Rust 将不再支持 Windows XP</a></h2>
<p>目标i686-pc-windows-msvc和x86_64-pc-windows-msvc是个怪胎。它们对Windows 7+有Tier 1支持，但对Windows XP也有Tier 3支持。这是Firefox需要在XP上运行时的遗留问题。然而在他们放弃XP支持后的几年里，尽管偶尔会有修复，但大多都是任由它过期了。</p>
<p>因此有人建议，正式放弃这个Tier 3支持状态，可以更好地反映出目前对XP的实际支持程度，不再让一个Tier 1目标背负着实际上不支持Tier 3目标的担忧。</p>
<p>只要LLVM和他们的链接器仍然支持XP目标，移除官方的XP支持不会阻止任何人编译到XP（减去std）。</p>
<p>对Windows 7以上的目标的影响将是移除工作区和一个支持XP的运行时兼容性层。此外，还有可能使用更现代的API，而这些API可能曾经因为兼容性问题而被避免。</p>
<p>如果在未来，有人积极支持XP，那么最好的办法是为此创建一个新的目标。这可以从其自身的优点出发，而且它的开发不会影响到一级平台的开发。</p>
<p>官方团队接受了该建议。</p>
<p><a href="https://github.com/rust-lang/compiler-team/issues/378">https://github.com/rust-lang/compiler-team/issues/378</a></p>
<h2><a class="header" href="#rustup-宣布发布-1230-版本" id="rustup-宣布发布-1230-版本">Rustup 宣布发布 1.23.0 版本</a></h2>
<p>官方发布 1.23.0 版本，其中最激动人心的改变就是支持 Apple M1 设备。大家可以安心的买 M1 了！</p>
<p><a href="https://blog.rust-lang.org/2020/11/27/Rustup-1.23.0.html">原文链接</a></p>
<h2><a class="header" href="#rust-官方知名开发者陆续入职巨头科技公司" id="rust-官方知名开发者陆续入职巨头科技公司">Rust 官方知名开发者陆续入职巨头科技公司</a></h2>
<p><strong>Niko Matsakis，Esteband K 入职 Amazon</strong></p>
<p>Niko Matsakis 入职 Amazon 担任 Rust 团队的技术主管。</p>
<pre><code>Niko的博客链接: https://smallcultfollowing.com/babysteps/blog/2020/12/30/the-more-things-change/
</code></pre>
<p>Esteband K 入职 Amazon 研究 Rust 编译器和相关工具。</p>
<pre><code>Twitter 链接：https://mobile.twitter.com/ekuber/status/1345218814087053312
</code></pre>
<p><strong>Patrick Walton 入职 Facebook</strong></p>
<p>Patrick Walton 将领导 Facebook 的新 Rust 团队，致力于为 Rust 社区改善其编译器和生态。</p>
<pre><code>Twitter 链接：https://twitter.com/pcwalton/status/1345094455712333824
</code></pre>
<h2><a class="header" href="#futures-rs-039-发布" id="futures-rs-039-发布">futures-rs 0.3.9 发布</a></h2>
<ul>
<li>把<code>pin-project</code>这个<code>crate</code>替换成了<code>pin-project-lite</code>, 在<code>--no-default-features</code>的情况下大幅提高了编译速度.</li>
<li>增加了几个新的API方法
<ul>
<li>stream::repeat_with</li>
<li>StreamExt::unzip</li>
<li>sink::unfold</li>
<li>SinkExt::feed</li>
</ul>
</li>
</ul>
<p>链接：<a href="https://github.com/rust-lang/futures-rs/releases/tag/0.3.9">https://github.com/rust-lang/futures-rs/releases/tag/0.3.9</a></p>
<h2><a class="header" href="#rust-异常处理小组的工作范围是什么" id="rust-异常处理小组的工作范围是什么">Rust 异常处理小组的工作范围是什么？</a></h2>
<p>该小组的主要重点是继续进行小组成立前的错误处理相关工作。为此而努力系统地解决与错误处理相关的问题，以及消除阻碍RFC停滞不前的障碍。</p>
<p>在小组成立的最初几次会议上，制定了一些短期和长期目标，这些目标主要围绕下面三个主题：</p>
<ul>
<li>使 <code>Error</code> trait 在生态中应用更加普及。</li>
<li>提升错误处理的开发体验。</li>
<li>编写更多的关于错误处理的学习资源。</li>
</ul>
<p>下面具体来说。</p>
<p><strong>建立统一的标准<code>Error</code> trait。</strong></p>
<p><code>Error</code> trait 从 <code>1.0</code>开始就存在了，并暴露了两个方法。<code>Error::description</code>和<code>Error::cause</code>。由于它最初的构造，由于一些原因，它太过拘谨。<code>Failure</code> crate通过导出Fail trait解决了Error trait的许多缺点。</p>
<p>在这一点上，加强<code>std::error::Error</code> trait，使其可以作为<code>Error</code> trait被整个Rust社区采用，自2018年8月RFC 2504被合并以来，一直是一个持续的过程。</p>
<p>这个过程还涉及稳定许多<code>Error</code> trait API和<code>crates</code>，截至本文撰写时，这些API和crates只在Nightly使用。这些包括backtrace和chain方法，这两种方法对于处理错误类型非常有用。如果你有兴趣关注或贡献这项工作，请看一下这个问题。</p>
<p>另一个相关的举措是将<code>Error</code> trait迁移到核心，这样它就可以更广泛地用于不同的场景（比如在FFI或嵌入式上下文中）。</p>
<p><strong>增加通过回溯（backtrace）类型进行迭代的能力</strong></p>
<p>到目前为止，<code>backtrace</code> 类型只实现了<code>Display</code>和<code>Debug</code>特征。这意味着使用回溯类型的唯一方法是打印出来，这不是很理想。一个能够提供迭代堆栈框架的迭代器API将使用户能够控制他们的反向跟踪如何被格式化，这是一个必要的步骤，将<code>std::backtrace::Backtrace</code>支持添加到像<code>color-backtrace</code>这样的箱子中。</p>
<p>在研究了如何解决这个问题的策略后，我们发现回溯箱已经有了一个框架方法，可以很好地实现<code>Iterator</code> API。在std中公开一个相同的方法应该是一个相对简单的考验。</p>
<p>我们已经为此开了一个<code>[PR](https://github.com/rust-lang/rust/pull/78299)</code>，如果有人想看的话，可以去看看。</p>
<p><strong>通用成员访问</strong></p>
<p>目前，当我们想要获取一些与错误相关的额外上下文时，需要调用一些特定的方法来获取该上下文。例如，如果要查看一个错误的回溯，我们会调用回溯方法： <code>let backtrace = some_error.backtrace();</code>。这种方法的问题是，它不可能支持在<code>std</code>之外定义的类型。即使是存在于<code>std</code>内的类型，也需要定义一个方法来访问每个各自的类型，这使得事情变得很麻烦，而且更难维护。</p>
<p>顾名思义，通用成员访问，当它得到实现时，是一种类型无关的方法，可以从<code>Error</code> trait对象中访问不同的上下文。这有个类比示例，当你要把一个字符串解析成一个数字的时候，用这样的方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ten = &quot;10&quot;.parse::&lt;i32&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>或者通过迭代器来collect生成的内容时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

let a_to_z_set = ('a'..='z').collect::&lt;HashSet&lt;_&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>跟上面用法类似，您可以通过指定错误的类型ID来访问某个上下文片段。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let span_trace = some_error.context::&lt;&amp;SpanTrace&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>这可以用来获取与错误相关的其他上下文，如错误的回溯、错误的来源、状态码、替代的格式化表示（如&amp;dyn Serialize）。</p>
<p>这个功能将使我们计划在以后添加的其他功能成为可能，比如提供一种方法来报告程序中错误来源的所有位置，以及提供一种除了显示和调试之外的更一致的错误报告格式。</p>
<p>Jane在推动这些想法上做了很多工作。你可以查看相关的<a href="https://github.com/rust-lang/rfcs/pull/2895">RFC</a>。</p>
<p><strong>编写一本<code>Rust</code>错误处理最佳实践的书</strong></p>
<p>最后但并非最不重要的一点是，围绕创作<a href="https://github.com/rust-lang/project-error-handling">The Rust Error Book</a>的团队引起了很多兴趣。 本书的目的是根据各自的用例来整理和交流不同的错误处理最佳实践。 这可能包括FFI用例，或有关从程序返回错误代码的最佳实践。</p>
<p>这是一项持续不断的工作，在接下来的几周和几个月中将会看到许多进步！</p>
<p><strong>脚注</strong></p>
<ul>
<li><code>Error::description</code>方法只支持字符串片段，这意味着创建包含附加上下文的动态错误信息是不直接的。这个方法被弃用，改用<code>Display</code>。</li>
<li><code>Error::cause</code>方法，现在被称为<code>Error::source</code>，并没有强制要求错误具有 &quot;静态生命周期&quot;，这意味着 downcasting 错误源是不可能的，这使得使用动态错误处理程序来处理错误变得更加困难。</li>
</ul>
<h2><a class="header" href="#rustdoc-性能提升" id="rustdoc-性能提升">Rustdoc 性能提升</a></h2>
<p>有两个PR明确地旨在提高rustdoc的性能：</p>
<ul>
<li>Rustdoc：缓存已解析的链接<a href="https://github.com/rust-lang/rust/pull/77700">＃77700</a>。该<code>PR</code>将文档生成的链接的时间缩短了 <code>90%</code>。</li>
<li>不要在文档内链接中寻找覆盖实现（blanket-impls）<a href="https://github.com/rust-lang/rust/pull/79682">＃79682</a>。因为它从来没有起过作用，并且已经引起了严重的性能问题。</li>
</ul>
<p>Rustdoc 团队还清理了一些技术债务。比如 <code>jyn514</code> 不久前注意到，Rustdoc中的大部分工作都是重复的: 实际上有三种不同的抽象语法树(ast)！一个用于doctree，一个用于clean，还有一个是编译器使用的原始HIR。Rustdoc花费了大量的时间在它们之间进行转换。大部分的速度改进来自于完全去掉部分AST。</p>
<p>文章里也介绍了Rustdoc的工作原理：</p>
<ul>
<li>运行编译器的某些部分以获得需要的信息。</li>
<li>删除编译器提供的不需要的信息（例如，如果一个项目是doc(hidden)，就不需要它）。这一部分有很多话要说，也许会再写一篇博文来详细介绍。</li>
<li><code>doctree pass</code>，它在编译器的某些项目上添加了一些<code>rustdoc</code>需要的额外信息。</li>
<li><code>clean pass</code>将编译器类型转换为<code>rustdoc</code>类型：基本上，它将所有内容都转换为 &quot;可打印 &quot;内容。</li>
<li>渲染（render）通证，然后生成所需的输出（HTML 或，在Nightly，JSON）</li>
</ul>
<p>更多内容： <a href="https://blog.rust-lang.org/inside-rust/2021/01/15/rustdoc-performance-improvements.html">https://blog.rust-lang.org/inside-rust/2021/01/15/rustdoc-performance-improvements.html</a></p>
<h2><a class="header" href="#nightly的reference已上线const-generics的文档" id="nightly的reference已上线const-generics的文档">Nightly的Reference已上线Const Generics的文档</a></h2>
<p>Const Generics 计划在1.50版进入stable，官方今天在nightly的Reference上已更新好相关文档。</p>
<p>链接：<a href="https://doc.rust-lang.org/nightly/reference/items/generics.html#const-generics">https://doc.rust-lang.org/nightly/reference/items/generics.html#const-generics</a></p>
<h2><a class="header" href="#nightly-edition-guide-文档增加了-rust-2021-edition-小节" id="nightly-edition-guide-文档增加了-rust-2021-edition-小节">Nightly Edition Guide 文档增加了 Rust 2021 Edition 小节</a></h2>
<p>内容还在逐步更新，可以先关注。</p>
<p>链接： <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-next/index.html">https://doc.rust-lang.org/nightly/edition-guide/rust-next/index.html</a></p>
<h2><a class="header" href="#rfc-2945--c-unwind-abi-支持相关情况" id="rfc-2945--c-unwind-abi-支持相关情况">RFC 2945 : &quot;C unwind&quot; ABI 支持相关情况</a></h2>
<p>官方 FFI-Unwind 项目工作组已经将 RFC 2945 合并了。该 RFC 描述了对 &quot;C unwind&quot; ABI 的支持。</p>
<p>RFC 概要：</p>
<blockquote>
<p>引入了一个新的<code>ABI</code>字符串“<code>C-unwind</code>”，以支持从其他语言(如c++)到Rust框架的<code>unwind</code>，以及从<code>Rust</code>到其他语言的<code>unwind</code>。此外，当<code>unwind</code>操作以“non <code>Rust</code>”、“non <code>C-unwind</code>”ABI到达<code>Rust</code>函数边界时，我们为之前未定义的有限几种情况定义了行为。作为该规范的一部分，我们引入了术语“Plain Old Frame”(POF)。POF帧不会挂起析构函数，可以轻松地释放析构函数。这个RFC没有定义被外部异常展开的Rust框架中的catch unwind行为。</p>
</blockquote>
<p>引入动机：</p>
<blockquote>
<p>有些Rust项目需要跨语言展开以提供所需的功能。 一个主要的例子是<code>Wasm</code>解释器，包括<code>Lucet</code>和<code>Wasmer</code>项目。</p>
<p>还有一些现有的<code>Rust</code> crate（尤其是围绕libpng和libjpeg C库的包装器）会在<code>C</code>帧之间出现混乱。 这种展开的安全性取决于Rust的展开机制与<code>GCC</code>，<code>LLVM</code>和<code>MSVC</code>中的本机异常机制之间的兼容性。 尽管使用了兼容的展开机制，但是当前的<code>rustc</code>实现假定“extern <code>C</code>”函数无法展开，这允许LLVM在这种展开构成未定义行为的前提下进行优化。</p>
<p>之前已经在其他RFC（包括＃2699和＃2753）上讨论了对此功能的需求。</p>
</blockquote>
<p>RFC 2945: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md">https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md</a></p>
<p>现在 FFI-unwind 工作组正在为<code>C-unwind</code> ABI 指定新的行为（覆盖之前的未定义的行为），<a href="https://github.com/rust-lang/rust/pull/76570">RFC 2945 实现PR</a>。</p>
<p>然而，在起草 &quot;<code>C unwind</code> &quot; RFC 时，工作组发现围绕<code>longjmp</code>和类似函数的现有保证可以改进。虽然这与<code>unwind</code>并没有严格的关系，但它们有着密切的联系：它们都是 <code>non-local</code> 的控制流机制，防止函数正常返回。由于<code>Rust</code>项目的目标之一是让<code>Rust</code>与现有的<code>C</code>系语言互操作，而这些控制流机制在实践中被广泛使用，工作组认为<code>Rust</code>必须对它们有一定程度的支持。</p>
<p>这篇博文将解释该问题。如果你有兴趣帮助指定这种行为，欢迎参与!</p>
<p>官方博文地址：<a href="https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html">https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html</a></p>
<h2><a class="header" href="#rust-playground-支持-vim-模式" id="rust-playground-支持-vim-模式">Rust Playground 支持 vim 模式</a></h2>
<p>Rust Playground <code>vim</code> 模式，可以通过输入 <code>:w</code> 回车运行编译，非常棒的使用体验。</p>
<h1><a class="header" href="#本月简报--社区热点" id="本月简报--社区热点">本月简报 | 社区热点</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：Rust 日报小组</li>
</ul>
<h2><a class="header" href="#async-std-v190-发布" id="async-std-v190-发布">Async-std v1.9.0 发布</a></h2>
<p>这个版本发布了稳定的 <code>async_std::channel</code> 子模块，并引入了 tokio v1.0 的功能，同时，移除了不赞成使用的<code>sync::channel</code>类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_std::channel;

let (sender, receiver) = channel::unbounded();

assert_eq!(sender.send(&quot;Hello&quot;).await, Ok(()));
assert_eq!(receiver.recv().await, Ok(&quot;Hello&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>链接，<a href="https://github.com/async-rs/async-std/releases/tag/v1.9.0">https://github.com/async-rs/async-std/releases/tag/v1.9.0</a></p>
<h2><a class="header" href="#deno-in-2020" id="deno-in-2020">Deno in 2020</a></h2>
<p>一直很火热的 Deno 官方最近发布了 Deno 的<a href="https://deno.land/posts/deno-in-2020">大事记表</a>。
其中 1 月份进行了将 libdeno 替换成 rusty_v8 的工作。之前是使用 libdeno（C++ 写的） 来进行绑定 V8 的操作。现在替换成 Rust 原生实现的 rusty_v8。并且 rusty_v8 是一个单独的 Rust crate。</p>
<h2><a class="header" href="#the-rust-on-raspberry-pi-pico-charity-live-stream" id="the-rust-on-raspberry-pi-pico-charity-live-stream">The Rust on Raspberry Pi Pico Charity Live Stream</a></h2>
<p>在树莓派上写 Rust 是一种怎样的体验？最近一位国外友人就尝试这么做了，并且进行了直播。具体详情可以<a href="https://www.reddit.com/r/rust/comments/l39jdo/the_rust_on_raspberry_pi_pico_charity_live_stream/">戳此链接</a>。
Rust 在嵌入式开发领域还是有非常大的潜力的。</p>
<p>想要看更多关于 Rust 的流媒体视频，可以关注这个项目 <a href="https://github.com/jamesmunns/awesome-rust-streaming">awesome-rust-streaming</a></p>
<h2><a class="header" href="#sequoia-pgp-发布-10-版本" id="sequoia-pgp-发布-10-版本">Sequoia PGP 发布 1.0 版本</a></h2>
<p>2018 年，三位 GnuPG 开发者开始着手开发 Sequoia，这是 OpenPGP 在 Rust 中的实现版本。OpenPGP 是一种非专有协议，为加密消息、签名、私钥和用于交换公钥的证书定义了统一标准。</p>
<p>通过<a href="https://sequoia-pgp.org/blog/2020/12/16/202012-1.0/">官方博客</a>可以看出团队对当前版本对于安全性的思考和对未来下一步的规划。</p>
<h2><a class="header" href="#firecracker" id="firecracker">Firecracker</a></h2>
<p>Firecracker 是一种开源虚拟化技术，专门用于创建和管理安全的，多租户容器和基于功能的服务。</p>
<p><a href="https://github.com/firecracker-microvm/firecracker">项目地址</a></p>
<h2><a class="header" href="#rust-gui-编程介绍" id="rust-gui-编程介绍">Rust GUI 编程介绍</a></h2>
<p>Rust GUI 方面的介绍以及目前 Rust GUI 库的现阶段状况</p>
<p><a href="https://dev.to/davidedelpapa/rust-gui-introduction-a-k-a-the-state-of-rust-gui-libraries-as-of-january-2021-40gl#comments">原文链接</a></p>
<h2><a class="header" href="#facebook-使用-rust-的简单介绍" id="facebook-使用-rust-的简单介绍">Facebook 使用 Rust 的简单介绍</a></h2>
<p>该 twitter 快速的介绍了 Rust 在 facebook 中的使用历程:</p>
<p>2017 年开始应用于一个资源控制项目，后来证明性能和稳定性都比 C++好。
之后，更多的工程师开始使用 Rust 在各种项目中，例如 Diem，Hack，Mononoke。
在 dev tools 中证明 Rust 可行之后, 开始在后端和手机应用中使用 Rust
很多工程师来自 python 和 javascript 语言，Rust 的强类型和高性能让这些工程师不再挣扎于运行时的 bug。
为了让 Rust 更广泛的使用，设立了一个专门的 Rust 小组来支持其他的工程师在不同的项目中使用 Rust。 该小组同时在 Rust 社区中也非常活跃，贡献代码。</p>
<p><a href="https://twitter.com/alexvoica/status/1350049393471324161">原文链接</a></p>
<h2><a class="header" href="#时隔一年-tower-终于发布新版本啦" id="时隔一年-tower-终于发布新版本啦">时隔一年 tower 终于发布新版本啦</a></h2>
<p>Tower 是一个模块化和可重用组件库，用于构建健壮的网络客户端和服务器。上一个版本 0.3.1 版本是 2020 年 1 月 17 发布的，新版本 0.4.0 是 2021 年 1 月 7 号发布的，这个版本包含了大量改动，包括使用了 tokio 1.0，将所有的中间件转移到了 tower crate，改造，添加了中间件 API。</p>
<p>不过这次变更并没有核心 Service 或者 Layer trait，所以新版本还是依赖着 tower- service 0.3 和 tower- layer 0.3，因此新版本是兼容使用这两个 crate 的库的。更多发布细节请移步下面的链接。</p>
<p><a href="https://github.com/tower-rs/tower/releases/tag/tower-0.4.0">原文链接</a></p>
<p><a href="https://crates.io/crates/tower/0.4.0">项目地址</a></p>
<h2><a class="header" href="#rust-search-extension-110-发布" id="rust-search-extension-110-发布">Rust Search Extension 1.1.0 发布</a></h2>
<p><a href="https://rust.extension.sh/">Rust Search Extension</a> 发布了最新版，同时也突破了 500 个 star，感谢大家的支持！这个版本主要功能如下：</p>
<ul>
<li>! 搜索改成了 docs.rs，!! 改成了 crates.io。</li>
<li>给 Rust 仓库的 release 页面增加了目录菜单。</li>
<li>Rust 标准库文档页面和源码页面所有 &quot;since&quot; 和 &quot;issue&quot; 标签分别会链接到仓库的 release 页面对应的版本和 GitHub 对应的 issue 页。</li>
</ul>
<h2><a class="header" href="#为什么-2021-年将成为系统程序员的-rust-年" id="为什么-2021-年将成为系统程序员的-rust-年">为什么 2021 年将成为系统程序员的 Rust 年？</a></h2>
<p>Gartner 今天的一篇博文报道了“Rust”：近年来，Rust 获得了很多粉丝，并且有充分的理由。Rust 旨在成为满足系统编程需求的 C++ 的可靠替代品。</p>
<p><a href="https://blogs.gartner.com/manjunath-bhat/2021/01/03/why-2021-will-be-a-rusty-year-for-system-programmers/">原文链接</a></p>
<h2><a class="header" href="#open-source-security-inc宣布为rust的gcc前端提供资金" id="open-source-security-inc宣布为rust的gcc前端提供资金">Open Source Security, Inc.宣布为Rust的GCC前端提供资金</a></h2>
<p>Open Source Security, Inc.宣布为Rust的GCC前端提供资金
开源安全公司（Open Source Security，Inc）自豪地宣布，它为Rust的GCC前端的全职和公共开发工作提供了资金。在此博客文章中，作者将详细介绍我们参与的动机以及公众将因这项努力而获得的利益。</p>
<p>原文链接 : <a href="https://opensrcsec.com/open_source_security_announces_rust_gcc_funding">https://opensrcsec.com/open_source_security_announces_rust_gcc_funding</a></p>
<h2><a class="header" href="#rust-gui框架的全调研" id="rust-gui框架的全调研">Rust GUI框架的全调研</a></h2>
<p>这篇文章对几乎目前Rust社区较为流行的GUI框架做了整体的调研，druid和iced表现还不错。</p>
<ul>
<li>原文链接： <a href="https://www.boringcactus.com/2020/08/21/survey-of-rust-gui-libraries.html">https://www.boringcactus.com/2020/08/21/survey-of-rust-gui-libraries.html</a></li>
<li>AreWeGuiYet 网站也可以看到 GUI 相关信息：<a href="https://www.areweguiyet.com/">https://www.areweguiyet.com/</a></li>
<li><a href="https://dev.to/davidedelpapa/rust-gui-introduction-a-k-a-the-state-of-rust-gui-libraries-as-of-january-2021-40gl#comments">另一篇<code>GUI</code>调研文章</a></li>
</ul>
<h2><a class="header" href="#redox-os-最近公布了2020年的财务明细" id="redox-os-最近公布了2020年的财务明细">Redox OS 最近公布了2020年的财务明细。</a></h2>
<p>主要的收入是通过捐赠，包括Patreon网站，paypal,和接收到的一些比特币和以太坊。 《Redox OS Summer of Code》是主要的支出预算，其他网站服务的支出，包括亚马逊的EC2，Jenkins服务器，Gitlab服务。</p>
<p>开源项目的明细能做到公开、明细还是非常值得社区学习的。</p>
<p>原文链接: <a href="https://www.redox-os.org/news/finances-2020/">https://www.redox-os.org/news/finances-2020/</a></p>
<h2><a class="header" href="#rust-官方团队-wesley-wiser-宣布入职微软" id="rust-官方团队-wesley-wiser-宣布入职微软">Rust 官方团队 Wesley Wiser 宣布入职微软</a></h2>
<p>From Twitter:</p>
<blockquote>
<p>Wesley Wiser: I'm very pleased to announce that I will be joining @Microsoftto work on the @rustlang compiler team they are forming!</p>
</blockquote>
<p>Wesley Wiser 在 twitter 宣布：加入微软，并且为「微软组织的<code>Rust</code>编译器团队」工作。Wesley Wiser 在 2020 年 12 月刚出任 官方 Rust 编译器团队 co-Leader。</p>
<p>到目前为止，编译器的三大 Leader ：Niko 和 Felix 去了亚马逊，Wesley Wiser 去了微软。之前 Facebook 也在招人组建 Rust 编译器团队，侧面反应出大厂们对 Rust 正在做战略布局。</p>
<p>原文链接：<a href="https://twitter.com/wesleywiser/status/1354896012113022984">https://twitter.com/wesleywiser/status/1354896012113022984</a></p>
<h1><a class="header" href="#本月简报--推荐项目" id="本月简报--推荐项目">本月简报 | 推荐项目</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
</ul>
<h2><a class="header" href="#微软rust-for-windows" id="微软rust-for-windows">「微软」Rust for Windows</a></h2>
<ul>
<li><a href="https://github.com/microsoft/windows-rs">仓库链接</a></li>
<li><a href="https://microsoft.github.io/windows-docs-rs/doc/bindings/windows">文档链接</a></li>
<li><a href="https://crates.io/crates/windows">crate 链接</a></li>
</ul>
<p>这个仓库是 1 月 20 日微软发布的官方 Win32 API crate。</p>
<p>过去用 rust 为 Windows 开发应用程序时，若要调用 Win32 API，必须使用 <a href="https://github.com/retep998/winapi-rs">winapi-rs</a> 这样的 wrapper 库，此类库需要社区去人工维护和 Win32 API 的绑定。
为了改善这点，微软通过 <a href="https://github.com/microsoft/win32metadata">win32metadata</a> 项目来加强对 C/C++ 以外的编程语言的支持（<a href="https://blogs.windows.com/windowsdeveloper/2021/01/21/making-win32-apis-more-accessible-to-more-languages/">相关链接</a>），
其中就包括对 rust 的支持。</p>
<p>现在已经有使用该库实现的<a href="https://github.com/robmikh/minesweeper-rs">扫雷</a>程序, 除此之外，也有微软工程师发布了一些<a href="https://github.com/kennykerr/samples-rs">示例项目</a>。</p>
<h2><a class="header" href="#czkawka" id="czkawka">Czkawka</a></h2>
<ul>
<li><a href="https://github.com/qarmin/czkawka">仓库链接</a></li>
<li><a href="https://www.reddit.com/r/linux/comments/kjcbva/czkawka_200_multithread_support_similar_images/">reddit 讨论</a></li>
</ul>
<p><em>Czkawka</em> 是一个多平台的空间清理应用，可用于找出系统中的重复的文件、空文件夹、临时文件等。</p>
<p>项目采用 gtk3/gtk-rs 开发 GUI 部分, 同时也提供 CLI 程序。</p>
<p><img src="https://user-images.githubusercontent.com/41945903/103371136-fb9cae80-4ace-11eb-8d72-7b4c8ac44260.png" alt="czkawka" /></p>
<h2><a class="header" href="#artichoke" id="artichoke">Artichoke</a></h2>
<ul>
<li><a href="https://www.artichokeruby.org/">项目主页</a></li>
<li><a href="https://twitter.com/artichokeruby">推特主页</a></li>
<li><a href="https://github.com/artichoke/artichoke">仓库链接</a></li>
<li><a href="https://www.youtube.com/watch?v=QMni48MBqFw&amp;list=PLE7tQUdRKcyZDE8nFrKaqkpd-XK4huygU&amp;index=37">rubyconf 2019 上的相关演讲</a></li>
</ul>
<p><em>Artichoke</em> 是一个由 rust 开发的 ruby 实现，可以将 ruby 代码编译至 WebAssembly。</p>
<p>当前 Artichoke 依然依赖于 mruby backend，在与 mruby 进行 FFI 交互的同时，改进某些 Kernel 和库函数的实现。例如 <a href="https://github.com/artichoke/artichoke/tree/trunk/artichoke-backend/src/extn/core/regexp">regex</a> 部分就是由 rust 实现的。</p>
<p>作者表示在未来会开发出一个纯 rust 的实现。</p>
<h2><a class="header" href="#linfa" id="linfa">linfa</a></h2>
<ul>
<li><a href="https://github.com/rust-ml/linfa">仓库链接</a></li>
<li><a href="https://docs.rs/linfa/0.3.0/linfa/">文档链接</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/e4wh8c/linfa_taking_ml_to_production_with_rust_a_25x/">reddit 讨论</a></li>
</ul>
<p><em>linfa</em> 是一个机器学习的框架和工具集，其设计参照了 python 的 <code>scikit-learn</code> 库。</p>
<p>关于 rust 在机器学习方面的生态系统，可以参考 <a href="http://www.arewelearningyet.com/">arewelearningyet</a>。</p>
<h2><a class="header" href="#async-trait-static" id="async-trait-static">async-trait-static</a></h2>
<ul>
<li><a href="https://github.com/tiannian/async-trait-static">仓库链接</a></li>
<li><a href="https://docs.rs/async-trait-static/0.1.4/async_trait_static/">文档链接</a></li>
</ul>
<p><em>async-trait-static</em> 是一个用于在 trait 中声明 async 方法的库，可以在 <code>no_std</code> 下使用。</p>
<p>由于 rustc 的限制，<a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">要在 trait 中写出 async 方法是很困难的</a>。
针对这个问题，dtolnay 实现了 <a href="https://github.com/dtolnay/async-trait">async-trait</a>，将 <code>async fn</code> 的返回类型转化为 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code>。</p>
<p>async-trait-static 则采用了 GAT 来实现这个功能，无需用到 trait object。</p>
<p>当前 rust 的 GAT 依然不够完善，因此该库还是有些功能是缺失的。</p>
<h2><a class="header" href="#regexm" id="regexm">regexm</a></h2>
<ul>
<li><a href="https://github.com/TaKO8Ki/regexm">仓库链接</a></li>
<li><a href="https://docs.rs/regexm/0.1.0-beta.1/regexm/">文档链接</a></li>
<li><a href="https://github.com/TaKO8Ki/regexm/tree/main/examples">示例</a></li>
</ul>
<p><em>regexm</em> 是一个用于对正则表达式进行模式匹配的库：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let text1 = &quot;2020-01-01&quot;;
    regexm::regexm!(match text1 {
        r&quot;^\d{4}$&quot; =&gt; println!(&quot;y&quot;),
        r&quot;^\d{4}-\d{2}$&quot; =&gt; println!(&quot;y-m&quot;),
        // block
        r&quot;^\d{4}-\d{2}-\d{2}$&quot; =&gt; {
            let y_m_d = &quot;y-m-d&quot;;
            println!(&quot;{}&quot;, y_m_d);
        }
        _ =&gt; println!(&quot;default&quot;),
    });
}
</code></pre></pre>
<h2><a class="header" href="#swc" id="swc">swc</a></h2>
<ul>
<li><a href="https://swc.rs/">项目主页</a></li>
<li><a href="https://github.com/swc-project/swc">仓库链接</a></li>
</ul>
<p><em>swc</em> 是一个 typescript/javascript 的 transpiler，在运行速度上，单核比 babel 快 4 倍，4 核比 babel 快 70 倍，同时也具有 treeshaking 的功能。</p>
<p><em>swc</em> 被用于 deno 项目中，用于类型擦除。 swc 的作者是一名 97 年的大二学生，如今已经获得了 Deno 官方的顾问合同。</p>
<h2><a class="header" href="#rlink-rs" id="rlink-rs">rlink-rs</a></h2>
<p><em>国产项目</em></p>
<ul>
<li><a href="https://github.com/rlink-rs/rlink-rs">仓库链接</a></li>
</ul>
<p>rlink-rs是基于rust实现的流式计算引擎，用来作为Apache Flink的替代方案。</p>
<p>相对于在线业务，rlink-rs更关注海量数据的离线流式处理场景，提升吞吐能力、降低资源消耗。其特点是针对exactly once提供计算和输出两种语义；基于特殊的exactly once输出语义，结合rust内存管理模型，实现大部分场景的全内存计算，解决state和checkpoint引起的重量级IO操作。</p>
<p>rlink-rs的目标是成为一个计算驱动引擎，允许基于DAG定制你自己的计算流程、实现自己的计算语义。</p>
<p>目前状态：主要针对flink流计算这块做对比。已经实现基本窗口计算流程。</p>
<p>希望能从社区得到关于流引擎设计方面的帮助：</p>
<p>1.因为rust语言不如Java动态语言可以反射，在用户api上不那么优雅。
2.只是想在语义上实现类似flink的api，实现上还是想走一条新的路线，毕竟flink有历史包袱，它的实现我们不需要100%参考。</p>
<h2><a class="header" href="#rapier-2021的路线图" id="rapier-2021的路线图">Rapier 2021的路线图</a></h2>
<p>Rapier 是一个完全免费的开源物理引擎，可用于游戏，动画和机器人，完全使用 Rust 编程语言编写。 它着重于性能，可移植性和跨平台确定性（可选）。</p>
<p>Rapier 团队希望到2021年年底，Rapier 具有游戏物理引擎所期望的所有功能，实现流行的 C++ 物理引擎，比如：Box2d，Bullet Physics 和 PhysX 等同等的功能， 但是不打算在 GPU 上支持运行物理仿真。</p>
<p>2021 路线图链接：<a href="https://www.dimforge.com/blog/2021/01/01/physics-simulation-with-rapier-2021-roadmap/">https://www.dimforge.com/blog/2021/01/01/physics-simulation-with-rapier-2021-roadmap/</a></p>
<h2><a class="header" href="#psst使用rust和druid构建的第三方spotify客户端" id="psst使用rust和druid构建的第三方spotify客户端">Psst：使用Rust和Druid构建的第三方Spotify客户端</a></h2>
<ul>
<li><a href="https://github.com/jpochyla/psst">仓库链接</a></li>
</ul>
<p>Psst 是一款GUI的快速Spotify客户端，不带Electron，内置Rust。</p>
<p><a href="https://www.reddit.com/r/rust/comments/ksgtk7/druid_v070/">Druid</a>是一个原生Rust GUI库，支持Windows，macOS，Linux，之前是xi-editor的一部分。</p>
<h2><a class="header" href="#slotmap-10-released" id="slotmap-10-released">slotmap: 1.0 released</a></h2>
<ul>
<li><a href="https://github.com/orlp/slotmap">仓库链接</a></li>
</ul>
<p>slotmap 提供了三种 map 的实现, SlotMap, HopSlotMap 和 DenseSlotMap.</p>
<p>增加,删除,查询均为O(1)复杂度,而且额外开销非常低. 非常适合存储需要稳定和安全引用的 objects, 例如游戏中的 entities, graph 中的 nodes.</p>
<h2><a class="header" href="#rust-的-webdriver库" id="rust-的-webdriver库">Rust 的 WebDriver库</a></h2>
<ul>
<li><a href="https://github.com/stevepryde/thirtyfour">仓库链接</a></li>
</ul>
<p>Thirtyfour是一个用于Rust的Selenium / WebDriver库，用于自动化网站UI测试。</p>
<p>它支持完整的W3C WebDriver规范。经过Chrome和Firefox的测试，尽管任何与W3C兼容的WebDriver都可以使用。</p>
<h2><a class="header" href="#webrtcrs" id="webrtcrs">webrtc.rs</a></h2>
<ul>
<li><a href="https://webrtc.rs/">官网</a></li>
<li><a href="https://github.com/webrtc-rs/webrtc">仓库链接</a></li>
</ul>
<p>用 Rust 重写 Pion WebRTC (http://Pion.ly)。目前 v1.0 仍然处于开发中，欢迎开源贡献者提PR。</p>
<h2><a class="header" href="#rust中的科学计算" id="rust中的科学计算">Rust中的科学计算</a></h2>
<ul>
<li><a href="https://aftix.xyz/home/bacon/">文章链接</a></li>
<li><a href="https://github.com/aftix/bacon">仓库链接</a></li>
</ul>
<p>这篇文章中作者分享了在课余时间用Rust重写生物膜仿真过程中遇到的问题。</p>
<p>由于crates.io上找不到SciPy的代替品，作者自己实现了一个bacon-sci。</p>
<h2><a class="header" href="#shadow-rs-0514-支持自定义钩子" id="shadow-rs-0514-支持自定义钩子">shadow-rs 0.5.14 支持自定义钩子</a></h2>
<ul>
<li><a href="https://github.com/baoyachi/shadow-rs">仓库链接</a></li>
</ul>
<p>shadow-rs是一个使得程序能在运行时读取到编译过程中信息的库，这些信息包括：</p>
<ul>
<li>Cargo.toml 中的项目版本</li>
<li>依赖信息</li>
<li>git commit</li>
<li>编译中用到的Rust工具链</li>
<li>build类型，debug版还是release版</li>
</ul>
<p>之前想要增加加自定义信息会很麻烦，在0.5.14支持了自定义钩子后就容易多啦。</p>
<h2><a class="header" href="#ballista分布式计算平台" id="ballista分布式计算平台">Ballista：分布式计算平台</a></h2>
<ul>
<li><a href="https://github.com/ballista-compute/ballista">仓库链接</a></li>
</ul>
<p>Ballista 用 Rust 实现的概念验证分布式计算平台，使用 Apache Arrow 作为内存模型。它建立在一种体系结构之上，这种体系结构允许将其他编程语言作为一级公民进行支持，而不需要为序列化付出代价。</p>
<h2><a class="header" href="#德国亚琛工业大学研究项目rustyhermit-介绍" id="德国亚琛工业大学研究项目rustyhermit-介绍">德国亚琛工业大学研究项目：RustyHermit 介绍</a></h2>
<ul>
<li><a href="https://rust-osdev.com/showcase/rusty-hermit/">RustyHermit 介绍文章</a></li>
</ul>
<p>相关链接：</p>
<ul>
<li><a href="https://os.phil-opp.com/">Phil-Opp OS 教程</a></li>
<li><a href="https://github.com/hermitcore/libhermit-rs">libhermit-rs</a></li>
<li><a href="https://github.com/hermitcore/rusty-hermit">rusty-hermit</a></li>
</ul>
<p>RustyHermit 是一个 Unikernel（我理解这就是  Unique-Kernel 的缩写，独立内核？）。 Unikernel 被认为是有可能改变未来云生态格局的技术。</p>
<p>Unikernel是使用libOS(library os)构建的具有专门用途的单地址空间机器镜像。为了支撑程序的运行，开发者从模块栈中选择最小的类库集合，构建对应的OS。类库和应用代码、配置文件一起构建成固定用途的镜像，可以直接运行在hypervisor或者硬件上而无需Linux或者Windows这样的操作系统。所以，也有人称它为下一代容器技术。</p>
<p>Unikernel 其最大的卖点就是在，没有用户空间与内核空间之分，只有一个连续的地址空间。这样使得 Unikernel 中只能运行一个应用，而且对于运行的应用而言，没有硬件抽象可言，所有的逻辑，包括应用逻辑和操作硬件的逻辑，都在一个地址空间中。</p>
<p>但是目前 Unikernel 仍然出于研究阶段。</p>
<p>RustyHermit 是依赖于 libhermit-rs（库操作系统）实现的。</p>
<p>这两个项目都出自 亚琛工大，有意思的是，它们都是基于著名的 Rust实现操作系统教程phil-opp 衍生实现的。</p>
<h2><a class="header" href="#用-rust-编写现代操作系统" id="用-rust-编写现代操作系统">用 Rust 编写现代操作系统</a></h2>
<p><a href="https://github.com/theseus-os/Theseus">仓库链接</a></p>
<p>Theseus 是从Rust编写的新操作系统，尝试使用新颖的OS结构，更好的状态管理以及如何将OS职责（如资源管理）转移到编译器中。</p>
<p>我们一直在不断改进操作系统，包括其故障恢复能力，以提供更高的系统可用性而没有冗余，以及更轻松，更随意的实时演进和运行时灵活性。尽管仍然是一个不完整的原型，但我们认为These修斯将对高端嵌入式系统或边缘数据中心环境很有用。请参阅我们的已发表论文，以获取有关These修斯的设计原理和实现理念的更多信息，以及我们避免状态泄漏现象或尽可能减轻其影响的目标。</p>
<h2><a class="header" href="#evcxr-a-rust-repl-的解决方案" id="evcxr-a-rust-repl-的解决方案">Evcxr: A Rust REPL 的解决方案</a></h2>
<p>并且它还包含了 Jupyter Kernel 指南</p>
<p>该项目挂在 Google 的 GitHub 组织下。</p>
<ul>
<li><a href="https://github.com/google/evcxr">仓库链接</a></li>
<li><a href="https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb">Jupyter Kernel 指南</a></li>
</ul>
<h2><a class="header" href="#findomain-可提供子域监视服务" id="findomain-可提供子域监视服务">Findomain: 可提供子域监视服务</a></h2>
<ul>
<li><a href="https://github.com/Findomain/Findomain">仓库链接</a></li>
</ul>
<p>该服务可提供：目录模糊处理/端口扫描/漏洞发现（使用Nuclei），等等。 </p>
<p>允许您使用多个顶级工具（OWASP Amass，Sublist3r，Assetfinder和Subfinder）监视目标域，并在出现新的子域时将警报发送到Discord，Slack，Telegram，电子邮件或推送通知（Android / iOS / Smart Watch / Desktop）。 </p>
<p>您唯一要做的就是使用您的电子邮件地址（如果适用）或/和webhooks / Telegram聊天信息配置文件，然后将域放入另一个文件中。</p>
<p>一旦完成，您便拥有了一个完全自动化的子域监视服务，可以让您 包含最新发现的新子域，主机IP，HTTP状态，HTTP网站的屏幕快照，开放端口，子域CNAME等。 您所有的数据都安全地保存在关系数据库中，您可以随时请求转储数据。</p>
<h2><a class="header" href="#weylus让你的平板电脑用作电脑上的图形平板触摸屏" id="weylus让你的平板电脑用作电脑上的图形平板触摸屏">Weylus：让你的平板电脑用作电脑上的图形平板/触摸屏</a></h2>
<p>特点：</p>
<ul>
<li>用平板电脑控制鼠标</li>
<li>将屏幕镜像到平板电脑上</li>
</ul>
<p>上述功能在所有操作系统上都可以使用，但<code>Weylus</code>在<code>Linux</code>上效果最好。<code>Linux</code>上的其他功能有：</p>
<ul>
<li>
<p>支持手写笔/笔（支持压力和倾斜）。</p>
</li>
<li>
<p>多点触控。用支持多点触控的软件试试，- 比如Krita，你就会知道了。</p>
</li>
<li>
<p>捕捉特定的窗口，并只对其进行绘制。</p>
</li>
<li>
<p>更快的屏幕镜像</p>
</li>
<li>
<p>硬件加速视频编码</p>
</li>
<li>
<p>平板电脑作为第二屏幕</p>
</li>
<li>
<p><a href="https://github.com/H-M-H/Weylus">仓库链接</a></p>
</li>
</ul>
<h1><a class="header" href="#本月简报学习资源" id="本月简报学习资源">本月简报：学习资源</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：Rust 日报小组</li>
</ul>
<h2><a class="header" href="#rust-design-patterns-book" id="rust-design-patterns-book">🎈Rust Design Patterns Book</a></h2>
<p>非官方好书系列, 再次安利! Rust Design Patterns Book. 作者最近更新了很多东西。</p>
<p>看下翻译的中文引言吧。</p>
<h4><a class="header" href="#引言" id="引言">引言</a></h4>
<h4><a class="header" href="#设计模式" id="设计模式">设计模式</a></h4>
<p>在开发程序中，我们必须解决许多问题。一个程序可以看作是一个问题的解决方案。它也可以被看作是许多不同问题的解决方案的集合。所有这些解决方案共同解决一个更大的问题。</p>
<h4><a class="header" href="#在rust中的设计模式" id="在rust中的设计模式">在Rust中的设计模式</a></h4>
<p>有许多问题的形式是相同的，由于事实上，rust不是面向对象设计，模式不同于其他面向对象程序设计语言，虽然细节是不同的，因为他们有相同的形式，他们可以解决使用相同的基本方法。</p>
<p><a href="https://rust-unofficial.github.io/patterns/patterns/index.html">设计模式</a>是解决编写软件时常见问题的方法。</p>
<p><a href="https://rust-unofficial.github.io/patterns/anti_patterns/index.html">反模式</a>是解决这些相同问题的方法。</p>
<p>然而，尽管设计模式给我们带来了好处，反模式却带来了更多的问题。</p>
<p><a href="https://rust-unofficial.github.io/patterns/idioms/index.html">惯用法</a>，是编码是要遵守的指南，他们是社区的社区规范，你可以破他们，但如果你这样做，你应该有一个很好的理由。</p>
<p>TODO: 说明为什么Rust是一个有点特殊功能要素，类型系统，借用检查。</p>
<p><a href="https://rust-unofficial.github.io/patterns/">book 链接</a></p>
<h2><a class="header" href="#异步书翻译更新啦" id="异步书翻译更新啦">🎈异步书翻译更新啦</a></h2>
<p>这次翻译新增了第八章-关于生态的叙述（<a href="https://github.com/EthanYuan">@EthanYuan</a>) 以及第九章http服务器项目（<a href="https://github.com/huangjj27">@huangjj27</a>), 欢迎来指正错误或贡献~</p>
<p><a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">english book link</a></p>
<p><a href="https://huangjj27.github.io/async-book/index.html">中文翻译链接</a></p>
<p>​</p>
<h2><a class="header" href="#manning的rust新书refactoring-to-rust" id="manning的rust新书refactoring-to-rust">🎈Manning的Rust新书《Refactoring to Rust》</a></h2>
<p>这本书正在MEAP阶段，目前才更新了3章，感兴趣的同学可以看看。</p>
<p><a href="https://www.manning.com/books/refactoring-to-rust">Refactoring to Rust</a></p>
<h2><a class="header" href="#rust-书籍宝库" id="rust-书籍宝库">🎈Rust 书籍宝库</a></h2>
<p><a href="https://www.reddit.com/user/glynnormington/">glynnormington</a>整理了网络上大部分有关rust的mdbook，有官方的，也有非官方的。值得注意的一点是大家关注的rust宏小册很多人以为一直没有更新，但是其实有另一个团队重新在原来的基础上，更新了新的版本，目前已收录到该书库中。</p>
<p><a href="https://lborb.github.io/book/title-page.html">Rust 书籍宝库</a></p>
<p><a href="https://www.reddit.com/r/rust/comments/kwiwb8/the_little_book_of_rust_books/">Read More on reddit</a></p>
<h2><a class="header" href="#使用rust-编写一门语言" id="使用rust-编写一门语言">🎈使用Rust 编写一门语言</a></h2>
<p>有关使用<a href="https://rust-lang.org/">Rust</a>编程语言制作称为<a href="https://github.com/arzg/eldiro">Eldiro</a>的编程语言的系列文章。</p>
<p><a href="https://arzg.github.io/lang/">原文链接</a></p>
<h2><a class="header" href="#rust-错误处理-python-同学专用" id="rust-错误处理-python-同学专用">Rust 错误处理: python 同学专用</a></h2>
<p>本文是python同学专用，介绍了python日常中的错误处理以及如何在rust中达到类似效果和最佳实践。</p>
<p><a href="https://theomn.com/rust-error-handling-for-pythonistas/">原文链接</a></p>
<h2><a class="header" href="#其他语言调用rust---c" id="其他语言调用rust---c">🎈其他语言调用Rust - C++</a></h2>
<p>作者选择Rust作为运行时库的实现语言，并且希望使同一库可用于不同的编程语言。</p>
<p>最初，选择从对三种语言的支持开始：</p>
<ul>
<li><strong>Rust</strong>：因为这是我们的实现语言。</li>
<li><strong>C ++</strong>：这是我们熟悉的低级语言，仍然是嵌入式设备领域中最成熟的语言之一。</li>
<li><strong>JavaScript / TypeScript</strong>：因为它是一种非常流行的动态语言。</li>
</ul>
<p><img src="https://sixtyfps.io/blog/expose-rust-library-to-other-languages/diagrams.png" alt="img" /></p>
<p>Rust库（也称为板条箱) 分为两部分，共享实现板条箱和精简惯用的API条板箱。</p>
<p>对于JavaScript，我们使用<a href="https://github.com/neon-bindings/neon">Neon</a>公开API。Neon使我们能够方便地编写JavaScript API和创建NPM包。</p>
<p>C ++部分更具挑战性。</p>
<p><a href="https://sixtyfps.io/blog/expose-rust-library-to-other-languages.html">原文链接</a></p>
<h2><a class="header" href="#使用-rust-创建一个模拟器-part-1" id="使用-rust-创建一个模拟器-part-1">🎈使用 Rust 创建一个模拟器: part 1</a></h2>
<p>这个系列中，作者会通过神经网络和遗传算法制作一个进化模拟器。</p>
<p>作者首先会介绍神经网络和遗传算法是如何工作的，然后会使用Rust来实现他们，并且编译成WebAssembly，下图是一个预览图。</p>
<p>教程地址： <a href="https://pwy.io/en/posts/learning-to-fly-pt1/">https://pwy.io/en/posts/learning-to-fly-pt1/</a></p>
<h2><a class="header" href="#rust陷阱-reprtransparent" id="rust陷阱-reprtransparent">🎈Rust陷阱: repr(transparent)</a></h2>
<p>repr(transparent)可以让类似struct Foo(i32)和i32有同样的内存分布方式。他作用范围非常具体，只能有一个非 0 size 的字段。</p>
<p>本文章介绍了如何使用repr(transparent)以及一些陷阱。</p>
<p>原文链接：<a href="https://jack.wrenn.fyi/blog/semver-snares-transparent/">https://jack.wrenn.fyi/blog/semver-snares-transparent/</a></p>
<h2><a class="header" href="#unsafe-rust该如何或何时使用它" id="unsafe-rust该如何或何时使用它">🎈Unsafe Rust：该如何或何时使用它</a></h2>
<p>本文包含了以下内容：</p>
<ul>
<li>关于 Unsafe Rust 的五点迷思</li>
<li>什么时候不该用 Unsafe 的代码</li>
<li>处理未初始化的内存</li>
<li>内部可变性</li>
<li>内在动机</li>
<li>内联汇编</li>
<li>FFi</li>
<li>编写Unsafe Rust时候应该使用的工具</li>
</ul>
<p>原文链接：<a href="https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/">https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/</a></p>
<h2><a class="header" href="#mozilla-如何导出-rust-组件给-kotlin" id="mozilla-如何导出-rust-组件给-kotlin">🎈Mozilla: 如何导出 Rust 组件给 Kotlin</a></h2>
<p>Mozilla应用服务平台这个仓库中提供了一个login组件可以很好地展示这个示例。</p>
<p>概要：</p>
<p>假设你已经的组件在./src/目录下编写了一个不错的Rust核心代码。</p>
<p>首先，你需要将Rust API扁平化为一组FFI绑定，通常是在 <code>./ffi/ </code>目录下。使用 <code>ffi_support</code> crate来帮助实现这个功能，这将涉及到在核心Rust代码中实现一些特性。</p>
<p>接下来，你需要编写消耗<code>FFI</code>的<code>Kotlin</code>代码，通常是在<code>./android/</code>目录下。这段代码应该使用<code>JNA</code>通过共享库加载编译后的<code>Rust</code>代码，并将其作为一个漂亮的安全且易于使用的<code>Kotlin API</code>暴露出来。</p>
<p>似乎我们很可能在这里提供一个有用的模板来让你入门。但我们还没有这样做。</p>
<p>最后，将你的包添加到<code>android-components repo</code>中。</p>
<p>文章还回答了一些导出过程中的问题。</p>
<p>原文链接：<a href="https://github.com/mozilla/application-services/blob/020a3eb831da8cd9d21978e3d1fb7af3a6ffcfea/docs/howtos/exposing-rust-components-to-kotlin.md">https://github.com/mozilla/application-services/blob/020a3eb831da8cd9d21978e3d1fb7af3a6ffcfea/docs/howtos/exposing-rust-components-to-kotlin.md</a></p>
<h2><a class="header" href="#入门教程用rust写一个todo应用" id="入门教程用rust写一个todo应用">入门教程：用Rust写一个todo应用</a></h2>
<p>在这篇教程里，作者依照javscript的传统，教你用Rust写一个todo应用。 你会学到：</p>
<ul>
<li>Rust中的错误处理</li>
<li>Option的使用</li>
<li>Struct和impl</li>
<li>终端输入输出</li>
<li>文件操作</li>
<li>所有权和借用</li>
<li>模式匹配</li>
<li>迭代器和闭包</li>
<li>使用外部crate</li>
</ul>
<p>链接：<a href="https://www.freecodecamp.org/news/how-to-build-a-to-do-app-with-rust/">https://www.freecodecamp.org/news/how-to-build-a-to-do-app-with-rust/</a></p>
<h2><a class="header" href="#libhunt-根据reddit-被提及状态展示-rust-库的热度" id="libhunt-根据reddit-被提及状态展示-rust-库的热度">🎈LibHunt: 根据reddit 被提及状态展示 rust 库的热度</a></h2>
<p>LibHunt根据reddit上大家提及到库的热度来排序出一些热门的rust库.</p>
<p>对于调研阶段的同学来说,是一个很好的工具.</p>
<p>libhunt的主页地址: <a href="https://www.libhunt.com/lang/rust">https://www.libhunt.com/lang/rust</a></p>
<h2><a class="header" href="#用-rust-实现一个-rest-client" id="用-rust-实现一个-rest-client">🎈用 Rust 实现一个 Rest Client</a></h2>
<p>这是 <code>Zero To Production In Rust</code> 的这本书中的一个示例。在本文，作者演示了：</p>
<ul>
<li>如何使用reqwests来写一个REST API client。</li>
<li>如何来使用wiremock来进行测试。</li>
</ul>
<p>原文链接: <a href="https://www.lpalmieri.com/posts/how-to-write-a-rest-client-in-rust-with-reqwest-and-wiremock/">https://www.lpalmieri.com/posts/how-to-write-a-rest-client-in-rust-with-reqwest-and-wiremock/</a></p>
<h2><a class="header" href="#太素os基于-riscv-架构的-rust-系统内核实现中文教程和源码" id="太素os基于-riscv-架构的-rust-系统内核实现中文教程和源码">🎈太素OS：基于 RISCV 架构的 Rust 系统内核实现（中文）教程和源码</a></h2>
<p>构建于QEMU 之上，适合学习</p>
<ul>
<li>源码： <a href="https://github.com/belowthetree/TisuOS">https://github.com/belowthetree/TisuOS</a></li>
<li>教程： <a href="https://www.zhihu.com/column/c_1118934193425629184">https://www.zhihu.com/column/c_1118934193425629184</a></li>
</ul>
<h2><a class="header" href="#译asyncawait二-futures" id="译asyncawait二-futures">【译】Async/Await（二）—— Futures</a></h2>
<p>新的文章翻译来啦。</p>
<p>来自：公众号：「Rust 碎碎念」，翻译 by：Praying</p>
<ul>
<li>翻译链接： <a href="https://mp.weixin.qq.com/s/OL7_usSmY_gAZzYYydyr8A">https://mp.weixin.qq.com/s/OL7_usSmY_gAZzYYydyr8A</a></li>
<li>原文链接：<a href="https://os.phil-opp.com/async-await/#multitasking">https://os.phil-opp.com/async-await/#multitasking</a></li>
</ul>
<h2><a class="header" href="#rust-programming-language-the-ultimate-guide" id="rust-programming-language-the-ultimate-guide">Rust Programming Language: The Ultimate Guide</a></h2>
<p>这篇文章中作者从伪代码出发，一步步教你实现一个爱情计算器。</p>
<p>作者称这是线上最通俗易懂的Rust入门指南，你怎么认为呢？快来试试吧。</p>
<p>链接：<a href="https://masteringbackend.com/posts/rust-programming-the-ultimate-guide">https://masteringbackend.com/posts/rust-programming-the-ultimate-guide</a></p>
<h2><a class="header" href="#rust-initial-thoughts" id="rust-initial-thoughts">Rust: Initial thoughts</a></h2>
<p>作者分享了自己刚开始学Rust的一些想法和与其它语言的对比。</p>
<p><a href="https://dev.to/hb/rust-initial-thoughts-4jka">原文链接</a></p>
<h2><a class="header" href="#关于futurejoin设计的思考" id="关于futurejoin设计的思考">关于Future::join设计的思考</a></h2>
<p>这篇文章中作者分享了关于如何将<code>Future::{try_}join</code>和<code>{try_}join!</code>以一种更一致的形式加入标准库中的思考，以及对于const-eval可能起到的作用的讨论。</p>
<p><a href="https://blog.yoshuawuyts.com/future-join-and-const-eval/">原文链接</a></p>
<h3><a class="header" href="#rust-教程-从头开始学-rust" id="rust-教程-从头开始学-rust">Rust 教程: 从头开始学 Rust</a></h3>
<p>Rust越来越被更多的人喜爱，很多小伙伴也想入坑。这篇教程可以帮助零基础的小伙伴了解 Rust。</p>
<p><img src="https://www.educative.io/api/page/5328531525992448/image/download/6018549143830528" alt="img" /></p>
<p><a href="https://www.educative.io/blog/rust-tutorial-from-scratch">原文链接</a></p>
<h3><a class="header" href="#ref-vs--in-variables" id="ref-vs--in-variables">ref vs &amp; in variables</a></h3>
<p>帖子讨论了ref和&amp;的使用，哪个使用更好。</p>
<p><a href="https://www.reddit.com/r/rust/comments/l451ux/ref_vs_in_variables/">原文链接</a></p>
<h3><a class="header" href="#在rust中包装错误" id="在rust中包装错误">在Rust中包装错误</a></h3>
<p>在开发时错误处理是必须，有时错误处理非常糟糕，文章中提高了warp Error提高体验。</p>
<p><a href="https://edgarluque.com/blog/wrapping-errors-in-rust">原文链接</a></p>
<p><a href="https://www.reddit.com/r/rust/comments/l3x6p0/wrapping_errors_in_rust/">on reddit</a></p>
<h1><a class="header" href="#本月简报--rust-唠嗑室本月汇总" id="本月简报--rust-唠嗑室本月汇总">本月简报 | Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
</ul>
<h2><a class="header" href="#rust-唠嗑室第-16-期---tensorbase-高性能数据仓库" id="rust-唠嗑室第-16-期---tensorbase-高性能数据仓库">《Rust 唠嗑室》第 16 期 - tensorbase 高性能数据仓库</a></h2>
<p><strong>时间</strong>: 2021/01/05 20:30-21:30</p>
<p><strong>主讲人</strong>：金明剑</p>
<p><strong>内容</strong>：金明剑老师在 RustChinaConf2020 上分享了《<a href="https://www.bilibili.com/video/BV1Yy4y1e7zR?p=25">基于 Rust 构建高性能新型开源数据仓库</a>》，很多人感兴趣 <a href="https://github.com/tensorbase/tensorbase">Tensorbase</a> 的技术内幕，这次唠嗑室一起来聊 Tensorbase。</p>
<p><a href="https://www.bilibili.com/video/BV1TA411H7ap">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<p><a href="https://www.bilibili.com/video/BV1Yy4y1e7zR">RustChinaConf2020 大会合集</a></p>
<hr />
<h2><a class="header" href="#rust-唠嗑室第-17-期---用-rust-写-protobuf-扩展" id="rust-唠嗑室第-17-期---用-rust-写-protobuf-扩展">《Rust 唠嗑室》第 17 期 - 用 Rust 写 Protobuf 扩展</a></h2>
<p><strong>时间</strong>: 2021/01/19 20:30-21:30</p>
<p><strong>主讲人</strong>：宁志伟</p>
<p><strong>内容</strong>：</p>
<p><a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Protocol Buffers</a> (简称 Protobuf ) ，是 Google 出品的序列化框架，与开发语言无关，和平台无关。具有体积小，速度快，扩展性好，与 <a href="https://en.wikipedia.org/wiki/GRPC">gRPC</a> 搭配好，支持的语言多等特点，是目前应用最广泛的序列化框架。</p>
<p><a href="https://github.com/cita-cloud">CITA-Cloud</a> 是一个以区块链技术为基础，融合云原生技术的柔性集成开放平台。区块链部分提供了非常灵活的微服务架构，可以适应各种各样的企业应用场景。</p>
<p>CITA-Cloud 计划提供一个框架，方便用户自定义交易和区块等核心数据结构。使用 Protobuf 的扩展能力，用户只需用 Protobuf 描述数据结构，框架会自动生成相关代码，得到一个定制的区块链。</p>
<p>这次主要来聊聊 Protobuf 扩展的原理，以及 Rust 已有的相关的库。最后通过一个 <a href="https://github.com/rink1969/proto_desc_printer">Demo</a> 展示如何使用 Rust 来写 Protobuf 扩展。</p>
<p><a href="https://www.bilibili.com/video/BV1Ff4y1k7Bo">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<p><a href="https://github.com/cita-cloud">CITA-Cloud</a></p>
<p><a href="https://cita-cloud-docs.readthedocs.io/zh_CN/latest/">CITA-Cloud 文档</a></p>
<p><a href="https://github.com/cita-cloud/cita_cloud_proto">cita_cloud_proto</a></p>
<p><a href="https://github.com/dropbox/pb-jelly">Dropbox-pb-jelly</a></p>
<p><a href="https://github.com/stepancheg/rust-protobuf/">rust-protobuf</a></p>
<p><a href="https://crates.io/crates/prost">Prost</a></p>
<p><a href="https://github.com/rink1969/proto_desc_printer">Demo 代码</a></p>
<h1><a class="header" href="#rustchinaconf2020-精选--jit-开发实践" id="rustchinaconf2020-精选--jit-开发实践">RustChinaConf2020 精选 | JIT 开发实践</a></h1>
<p>说明：本文为视频演讲文字版，编者听录的时候可能会出现一些误差，欢迎指正。</p>
<p>后期编辑: 大海，编程爱好者，对技术充满热情。</p>
<p><strong>讲师:</strong></p>
<p><a href="https://github.com/losfair">周鹤洋</a>是<code>wasmer</code>核心开发者，南航2018级本科生，主要掌握编译/OS/VM/微架构等技术，2017年开始使用Rust.</p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1Yy4y1e7zR?p=18">https://www.bilibili.com/video/BV1Yy4y1e7zR?p=18</a></p>
<h3><a class="header" href="#jit技术含义及应用场合" id="jit技术含义及应用场合">JIT技术含义及应用场合</a></h3>
<p>​	JIT技术全名为 Just-In-Time compilation，翻译为&quot;即时编译&quot;，是在运行期进行编译的方法，是将源代码或更常见的字节码到机器码的转换，然后直接执行的方法。JIT技术主要应用在各种语言的虚拟机上。在其他场合，比如动态链接器，会在运行之前动态重启程序，对它进行链接; 在linux 内核中, ebpf技术和5.10版本最新引入的static calls机制都使用了类似JIT的机制。</p>
<p>​	以虚拟机(VM)为例来简单介绍下JIT技术的应用。VM技术，可以大致分为三类，简单的解释器，优化的解释器和即时编译。简单的解释器，类似wasmi，由于对标准的实现非常好，导致没有资源去做优化，没有为运行效率做优化。其次是优化解释器，比如CPython,wasm3,BEAM(erlang 解释器). 而第三种则包括绝大多数高性能运行时虚拟机，JVM，CLR，V8，LuaJIT，Wasmer，Wasmtime.</p>
<p>​	虚拟机主要应用于当我们需要执行的目标代码格式与机器指令格式不一致时，需要翻译处理的情况。然而当出现我们无法直接静态地翻译到目标机器指令的特性，比如说动态特性( javascript的一些动态约束)，硬件层面难以实现的沙盒特性，比如WebAssembly的内存隔离, 不同的指令集，比如从riscv动态编译到aarch64或者x86-64指令集情况下，我们就需要使用二进制翻译器去进行Jit编译。</p>
<p>​	jit的优点很明显，可以让程序更效率地运行，可以① 动态优化代码②高效支持语言动态特性和安全要求③ 在一些特殊场合比如static call机制和动态链接器，支持运行环境的初始化操作来避免运行时的大量开销。</p>
<p>​	<strong>我们现在从动态优化方面来讲述jit相对传统静态编译的关键点。</strong></p>
<p><img src="chapter_1/../image/Jan_Jit7.PNG" alt="" /></p>
<center>图1 不同引擎在各JIT优化级别所采用的编译器后端</center>
<p>​	如图1所示，以JavaScriptCore,V8,Wasmer三个引擎为例，他们均实现了用户可以自由选择后端的操作或者在运行时自动在不同后端间切换的方式，使得可以支持编译优化从低优化级别切换到高优化级别，并且经过未经优化代码的时候，再切换回去的操作。</p>
<p>​	这里动态优化的流程是我们通过不断Profile,追踪运行状态，去编译优化等级更高的代码，同时编译开销变大，也会做deoptimize操作，当优化的代码做一些错误的假设时，我们就需要回滚。</p>
<p><strong>而用来实现动态切换优化级别的主要技术是OSR技术 ，即栈上替换(on-stack replacement).</strong></p>
<p><img src="chapter_1/../image/Jan_Jit1.PNG" alt="" /></p>
<center>图2 切换优化等级:OSR</center>
<p>​	让我们来看看OSR技术的简易流程。如图2所示，调用栈出现了左边的假想情况时，函数Baz代码优化从解释执行提升到 jit级别1 时， 运行时就会触发函数baz的编译，一旦编译完成，则会发生调用栈的重构，使得 原调用栈中所有函数Baz的记录映射到Jit级别1 的堆栈结构上，使得在原来状态基础之上，以Jit级别1的机器码上继续运行。代价 是 提升了计算的复杂度。</p>
<p>​	我曾经的一个工作，  在wasmer中实现的OSR技术。 OSR入口动态加载Image,在OSR退出的时候把image提取出来(从调用栈到wasm抽象表示，回到另一种优化等级的wasmer调用栈内的结构。(<font color=red>8:39</font>)</p>
<p><img src="chapter_1/../image/Jan_Jit2.PNG" alt="" /></p>
<center>图3 动态切换机制实例随时间变化的性能曲线</center>
<p>​	图3则是我当时项目benchmark的表现。在图3中，singlepass是我编写的编译最快，运行最慢的后端。llvm是优化等级最高的后端。红线为使用LLVM后端的性能曲线，蓝线为前面2s左右使用singlepass后端，后面使用llvm后端的性能曲线。</p>
<p>​	如果我们直接用llvm编译的话，我们就需要在程序执行之前，在测试程序中等待2s左右。如果我们引入动态切换机制，在程序启动时可以先使用编译快，但执行满的引擎去做执行，当优化等级高的编译器准备好之后，就动态地切换执行流，得到二者的平衡。红线和蓝线后面没有重合，只是由于我们在蓝线上针对一些做了一些额外操作,性能理论上还是一样的。</p>
<p>​	**我要介绍的第二钟动态优化技术 是 内联缓存inline caching。**我了解到有两种典型的用例。</p>
<ol>
<li>
<p>一些动态语言中的method lookup （方法查找）</p>
<pre><code class="language-javascript">for (let x of list){
    document.write(x); // method lookup
}
</code></pre>
<p>​	其中write函数是可以被动态重写的，但是这种情况发生的概率非常小，所以说我们在运行时可以假设它不变，去编译生成机器码。当假设不成立的时候，回滚。本来需要从哈希表中查找该方法，对缓存不友好，运行速度慢。</p>
<p>​	所以我们可以直接对该指令映射为一个缓存槽(slot)，把write函数对应的某些标记和write函数地址写入，检查运行条件是否符合，符合就可以直接执行，避免哈希表查找的开销，否则进行回滚。</p>
</li>
<li>
<p>RISC-V二进制翻译</p>
<p><img src="chapter_1/../image/Jan_Jit8.PNG" alt="" /></p>
<center>图4  RISC-V 二进制翻译代码示例 </center>
</li>
</ol>
<p>​	在RISC-V当中，主要有访存指令和跳转指令会涉及到较大的内存结构查找开销。</p>
<p>​	① 对于全系统模拟的访存指令(load/store)，需要在内存管理单元钟进行tlb lookup，用软件实现非常慢，遍历4层页表。或者在一些高层次结构的模拟时，在b-tree结构去查找内存空间，效率也很低。</p>
<p>​	对于这种指令，我们可以对指令关联一个缓存槽，当该指令第一次需求查表的时候，将查表预期的虚拟地址范围和真实物理地址  写入到缓存槽中，以后每次执行到该指令时，我们就直接用缓存信息直接提取内存信息即可。</p>
<p>​	② 如图4，jalr指令，间接跳转指令的例子。对于这种指令，除了需要mmu lookup , 还需要查找Jit 翻译，即被翻译后的字节码(translation lookup)，共两层查找。 而内联缓存技术就可以消除这两层查找的开销。</p>
<p>让我来介绍一下关于内联缓存我所做的简单应用吧。 rvjt-aa64项目 是我所完成的riscv到aarch64的jit引擎(<a href="https://github.com/losfair/rvjit-aa64">rvjit-aa64</a>)</p>
<p><img src="chapter_1/../image/Jan_Jit3.PNG" alt="" /></p>
<center>图5 rvjit-aa64 快速路径(从内存加载数据)</center>
<p>​	图5展示了访存指令的快速路径，可以看见我们分配了关于上界和下界的两个缓存槽。检查目标虚拟地址是否位于预期界限当中，如果在范围内，就直接加载，不用回滚到解释执行了。否则就走慢速路径，执行查表处理。</p>
<p><img src="chapter_1/../image/Jan_Jit4.PNG" alt="" /></p>
<center>图6 rvjit-aa64慢速路径(从内存加载数据)</center>
<p>​	图6展示了访存指令的慢速路径。当发生<code>load/store miss</code>时，我们就会针对地址addr进行查表， 检查读写权限和相关信息，如果可以的话就将其写入缓存槽内，下次就可以快速执行。</p>
<p>​	<strong>接下来我来介绍有关内存安全方面的内容。</strong></p>
<p>​	我们知道rust作为一个以安全性著称的语言，保证safe代码内存安全。所以我们就需要在运行时通过动态的机制确保内存安全。</p>
<p>​	我以空指针检查和访问越界检查为例来介绍Jit如何确保内存安全。</p>
<p>​	①空指针检查:</p>
<p>​	比如在java,c#这类有空指针的语言中，我们会遇到一个很常见的情况。当引用为空的时候，我们不应该对它解引用并且成功。我们应该检查它是否为空，如果为空，应该产生异常而非解引用。一个显而易见的方法是<code>if (a == null){ throw Exception(...)}</code>，但这样开销很大。如同下面代码所展示的，在<code>mov</code>指令前需要插入<code>cmp</code>和<code>je</code>指令，就会增加额外的分支预测的开销。</p>
<pre><code class="language-assembly">1: 1 cmp $0, %rdi
2: je null_pointer_exception 
3: mov %rdi,16(rsp)
...

null_pointer_exception:
	call host_npe_handler
	...
</code></pre>
<p>​	所以我们可以尝试一些别的方法。利用硬件trap机制，访问空指针时，从第三行mov指令直接trap到sigsegv异常(以Linux为例)，从而让硬件去检查我们的指针有效性。</p>
<p>​	②访问越界检查</p>
<p>​	对于webassembly中线性内存访问 的处理也可以使用trap机制,比如wasmer和wasmtime的处理方法是，直接分配6GB的虚拟地址空间，只对其中有webassembly分配的区域去做映射。一旦访问到存在映射区域以外的区域时,就会抛出异常,被sigsegv处理器捕获。这样是以慢速路径中的时间增加为代价去换取快速路径上的开销,因为慢速路径钟加入了sigsegv异常处理机制，而快速路径则不再需要界限判断。</p>
<p>​	当然具体的细节会复杂一些，比如wasmer中一段代码,采用Unix信号处理同步异常.调用low level的system api去绑定,关联这些异常信号到处理器上,处理器会分发,然后进一步找出路径.</p>
<p>​	<strong>最后我们来介绍一下linux kernel中运用到jit方法的一些技术。</strong></p>
<p>​	①比如ebpf,是一种允许用户代码安全接入内核的机制. 他有interpreter和jit两种实现方式.大多数主流架构都是用Jit实现.</p>
<p><img src="chapter_1/../image/Jan_Jit5.PNG" alt="" /></p>
<center>图7  Retpoline, Static call机制处理间接跳转的简要代码</center>
<p>​		②linux 5.10引入的static call机制。 在此之前，为了缓解 spectre 系列漏洞,特别是spectre v2 漏洞,我们会采用retpoline技术.</p>
<p>依赖于RSB(Return Stack Buffer), 它的目的是所有间接调用不经过分支目标缓存(Branch Target Buffer),这样保证攻击无法生效. </p>
<p>​	为方便大家理解Retpoline原理，我这里参考了<a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/03/24/retpoline">retpoline: 原理与部署</a>一文来作原理的解释。如图7所示，jmp指令通过rax值进行间接跳转，在original方式下，CPU会询问indirect branch preditor。如果有攻击者之前训练过该分支，就会导致CPU跳转执行特定代码。而retpoline机制阻止CPU的投机执行。在Retpoline方式下，</p>
<p>​	①执行<code>call L2</code>后，会将<code>lfence</code>地址压栈，并填充到Return Stack Buffer(RSB)，然后跳转到L2位置。</p>
<p>​	②<code>mov %rax, (%rsp)</code>指令将间接跳转地址(<code>*%rax</code>)放到栈顶，此时栈顶地址和RSB中地址不同。</p>
<p>​	③此时对于<code>ret</code>指令如果CPU投机执行时，会使用第一步中放入RSB中的地址，而<code>lfence</code>，<code>jmp L1</code>指令会导致一个死循环。</p>
<p>​	④CPU发现内存栈上的返回地址和RSB投机地址不同，所以投机执行终止，跳转到<code>*%rax</code></p>
<p>​	这样Retpoline机制就避免了CPU的投机执行。	</p>
<p>​	但是在 linux内核中我们发现,有很多pattern的间接调用目标是一定的,比如虚表所以我们会把它装化成两次直接调用,第二次直接调用代码使用jit重写,如图7  <code>_trampoline</code>所示, 这样我们消除了spectre v2的可能性, 而且也减少了间接调用的开销(因为使用了直接调用)</p>
<h3><a class="header" href="#在我的项目中是否应该使用jit" id="在我的项目中是否应该使用jit">在我的项目中是否应该使用jit?</a></h3>
<p><img src="chapter_1/../image/Jan_Jit6.PNG" alt="" /></p>
<center>图8 wasm引擎执行效率与工程复杂度的表现</center>
<p>​	如图8所示，wasm3虽然是一个解释器，但是相较于Wasmer,LLVM(最好的wasmer jit实现)性能低了10倍，对于解释器来说，是一个非常好的性能表现。并且wasm3的工程复杂度也低了许多。</p>
<p>​	考虑到 执行效率与工程复杂性的关系, 工程复杂性低,意味着出现的Bug数量少, 项目代码也就更安全.。所以对于安全要求高的话,就需要 谨慎考虑jit.	</p>
<p>​	在今年linux内核中 ebpf jit发现了两个LPE bug(CVE-2020-8835, CVE-2020-27194), 即使在使用开发人员众多的linux内核中，较小的语言ebpf当中仍出现了比较严重的bug, 这说明Jit编译器工程复杂度很高,需要团队巨大的资源支持维护.</p>
<h3><a class="header" href="#用rust实现jit的体验" id="用rust实现jit的体验">用rust实现jit的体验</a></h3>
<p>​	使用过程宏 处理汇编很方便, 编写一些Low  level的jit体验非常好. rust语言作为源语言去实现目标语言的编译,无法保证其语言之外的安全性,这可以说是一种局限性吧.rust语言相对于c和c++还是比较有优势的.</p>
<h2><a class="header" href="#提问环节" id="提问环节">提问环节</a></h2>
<p>问题1: (猜测: 图3使用的Benchenmark使用了hashmap吗？)</p>
<p>回答: 我使用的Benchmark用hashmap会慢50%左右, 因为hashmap对缓存不友好。</p>
<p>问题2: 在jit空指针检查中，将普通的软件判断替换成trap，变成硬件中断，会提升效率吗？</p>
<p>回答:  trap可以类比为rust当中panic,比如数组越界等,在绝大多数情况下都会执行快速路径,当程序出现bug才会执行trap路径.</p>
<p>问题3: 有关内存越界的问题，如果a内存和b内存相邻，a内存已经被映射了，此时越界访问到b内存，这个检查是否失效？</p>
<p>回答: 因为我们在内联缓存中，存储了上界与下界的缓存。我们会对访问的内存比较上界和下界，如果越界就排除在外了。对于这里的比较开销，我们经过一层的比较，对缓存是友好的，并且相较于查表，开销很大。</p>
<p>问题4: wasmer如何兼容x86和arm指令集?</p>
<p>回答:  我们使用的编译器后端<a href="https://crates.io/crates/wasmer-compiler-singlepass">singlepass</a>和llvm后端都是支持arm指令的.</p>
<p><strong>补充</strong>:  通过硬件来提高jit的性能</p>
<p>wasmer 在运行时会做一些检查,比如跳转时要查询某个表,然后在表中找到目标地址,然后跳转.这样我们就需要在代码中做分支处理. 如果在risc-v Physical Memory Protection (PMP)的扩展下,就可以在一些情况避免上面查表的开销. 而苹果m1 中兼容x86的机制,通过硬件上添加一个x86 的<a href="https://www.cs.utexas.edu/%7Ebornholt/post/memory-models.html">total store ordering</a> (TSO)开关去使用x86内存顺序,提升模拟效率. 同时我们可以看到，arm指令集这几个版本也引入了支持javascript-operations 的一些指令，可以使得我们常用的一些jit目标语言提高执行效率。</p>
<p>参考文章:</p>
<ol>
<li><a href="https://github.com/terenceli">Terenceli</a>  <a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/03/24/retpoline">retpoline: 原理与部署</a></li>
<li><a href="https://www.infoq.com/profile/Sergio-De-Simone/">Sergio De Simone</a>  <a href="https://www.infoq.com/news/2020/11/rosetta-2-translation/">How x86 to arm64 Translation Works in Rosetta 2</a></li>
</ol>
<p>​</p>
<h1><a class="header" href="#rustchinaconf2020-精选--rust-异步与并发" id="rustchinaconf2020-精选--rust-异步与并发">RustChinaConf2020 精选 | Rust 异步与并发</a></h1>
<p>说明：本文为视频演讲文字版，编者听录的时候可能会出现一些误差，欢迎指正。</p>
<p>讲师：赖智超 - Onchain 区块链架构师</p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1Yy4y1e7zR?p=14">https://www.bilibili.com/video/BV1Yy4y1e7zR?p=14</a></p>
<p>后期编辑：李冬杰，阿里巴巴淘系技术部，花名齐纪。</p>
<p>————————</p>
<h2><a class="header" href="#自我介绍" id="自我介绍">自我介绍</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-1.png" alt="自我介绍" /></p>
<p>大家好，今天我跟大家分享一下 Rust 的异步模型，以及实现这个模型时面临的一些并发方面的挑战。首先介绍一下 Rust 在我们公司的应用情况，我们公司在区块链是布局比较早的，现在大概成立有四年多了，目前我们公司主要还是 golang 为核心的技术栈，但是在 Rust 方面我们也在积极探索，有一些应用的实践。首先我们的区块链支持 wasm 虚拟机，使用 Rust 基于 cranelift/wasmtime 实现了 JIT 的版本，目前已经运行了一年多了。有了 wasm 虚拟机的支持后，我们也在智能合约和配套的工具链上下了功夫，目前团队智能合约开发首选 Rust，它具有开发效率高和迭代速度快的优点，前些天统计我们使用 Rust 开发的智能合约代码已经上 10 万了。还有密码学库，我们也是用的 Rust。</p>
<ol>
<li>区块链 wasm JIT 虚拟机：基于 cranelift/wasmtime;</li>
<li>智能合约开发库和配套的工具链：目前合约开发都首选 Rust，开发效率高，迭代速度快；</li>
<li>密码学库；</li>
</ol>
<h2><a class="header" href="#同步任务多线程池" id="同步任务多线程池">同步任务多线程池</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-2.png" alt="同步任务多线程池" /></p>
<p>为了讲解异步编程模型，我们先来看一看大家都比较熟悉的同步任务多线程池的实现，一个比较典型的实现如 PPT 左图所示，有一个全局的队列（Global Task Queue），由用户调用 <code>spawn</code> 把任务压到全局队列，全局队列关联着一个或者多个 <code>worker</code> 线程，每个工作线程都会轮询的从全局队列中把任务拿出来执行，用代码实现也比较简单。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use crossbeam::channel::{unbounded, Sender};
use once_cell::sync::Lazy;

type Task = Box&lt;dyn FnOnce() + Send + 'static&gt;;

static QUEUE: Lazy&lt;Sender&lt;Task&gt;&gt; = Lazy::new(|| {
    let (sender, reciver) = unbounded::&lt;Task&gt;();
    for _ in 0..4 {
        let recv = reciver.clone();
        thread::spawn(|| {
            for task in recv {
                task();
            }
        })
    }
    sender
});

fn spawn&lt;F&gt;(task: F) where F: FnOnce() + Send + 'static {
    QUEUE.send(Box::new(task)).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>首先我们在第5行代码定义了什么叫做同步任务，因为同步任务的话只需要执行一次就行了，所以是 <code>FnOnce()</code>，因为这个任务是从用户线程 push 
到全局队列，跨线程到工作线程，所以需要有<code>Send</code>约束和 <code>static</code> 生命周期，然后封装到 Box 中。第 8 行构建了一个并发的队列，起了 4 
个线程，每个线程拿到队列的接收端，然后在一个循环中执行 task，当然执行 task 的过程可能会 panic，这里为了演示我就没有处理。第17行 <code>sender</code> 就保存着在全局静态变量 QUEUE 上，当用户调用 <code>spawn</code>时，拿到 <code>QUEUE</code> 调用 <code>send</code> 方法，将任务 push 到队列中。</p>
<h2><a class="header" href="#异步任务的多线程" id="异步任务的多线程">异步任务的多线程</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-3.png" alt="异步任务的多线程" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Task = Box&lt;dyn FnMut() -&gt; bool + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>接下来我们看一下异步任务的多线程池，首先定义不能立即完成，需要多次执行的任务为异步任务，因此 <code>FnOnce()</code> 就不满足了，需要使用 
<code>FnMut </code>，它返回的结果是个布尔值，表示是否执行完任务。但是这样定义就有个问题，如果这个函数没有被工作线程执行完，工作线程就不知道接下来该怎么办了，如果一直等着直到这个任务能够执行，全局队列中的其他任务就不能被执行；直接扔掉这个任务也不行。因此Rust的设计用了一个很巧妙的办法，<code>Exector</code> 就不关心这个任务什么时候好，在执行的时候创建一个 <code>Waker</code>，然后告诉 task，“如果你什么时候好了，可以通过 <code>Waker</code> 把它重新放到全局队列里去” 以便再次执行，这样的话 Task 的定义就多出了 <code>Waker</code> 参数，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Task = Box&lt;dyn FnMut(&amp;Waker) -&gt; bool + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这样异步任务执行没有 ready 的时候，可以将拿到 <code>Waker</code> 注册到能监控任务状态的 <code>Reactor</code> 中，如 ioepoll、timer 等，<code>Reactor</code> 发现任务 ready 后调用 <code>Waker</code> 把任务放到全局队列中。</p>
<h3><a class="header" href="#异步任务的多线程-executor" id="异步任务的多线程-executor">异步任务的多线程 Executor</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-4.png" alt="异步任务的多线程 Executor" /></p>
<p>在Rust中，对于异步计算的标准定义是Future trait</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}

pub trait Future {
    type Output;
    fn poll(&amp;mut self, cx: &amp;Waker) -&gt; Poll&lt;Self::Output&gt;;
    // fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>poll 方法返回的是一个枚举类型 <code>Poll</code>，它和返回布尔值是类似的，只不过语义会更清晰一些，如果没好的话就返回一个 <code>Pending</code>，好了的话就返回一个 
<code>Ready</code>。标准库里用的不是<code>&amp;mut self</code>，而是<code>Pin&lt;&amp;mut Self&gt;</code>，因为 30 分钟讲不完，所以在这里先跳过。下面就是整个异步任务多线程的模型图：</p>
<p><img src="chapter_1/../image/rust-china-config-async-5.png" alt="异步任务的多线程 Executor" /></p>
<p>首先用户通过 <code>spawn</code> 函数把异步任务 push 到全局队列里去，然后工作线程会拿到 task 执行，并且创建一个 <code>Waker</code>，传给执行的 <code>Future</code>，如果任务执行完成了，那就 
ok 了；如果没执行完成，<code>Future</code> 负责把 <code>Waker</code> 注册到 <code>Reactor</code> 上面，<code>Reactor</code> 负责监听事件，收到事件后会把 <code>Waker</code> 唤醒，把 task 
放到全局队列中，这样下次其他线程可以拿到这个 task 继续执行，这样循环重复直到任务执行完毕。</p>
<h3><a class="header" href="#waker-接口的要求" id="waker-接口的要求">Waker 接口的要求</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-6.png" alt="Waker 使用方" /></p>
<p><code>Waker</code> 在这个过程中充当着十分重要的角色，我们来看一下 Waker 的接口需要满足哪些要求：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Waker {
    pub fn wake(self);
}

impl Clone for Waker;

impl Send for Waker;

impl Sync for Waker;
<span class="boring">}
</span></code></pre></pre>
<p>对于使用方的要求，首先 <code>Waker</code> 本身是唤醒的功能，所以它要提供一个 <code>wake</code> 方法。异步任务可能会关心多个事件源，比如说定时器、IO，也就是说 <code>Waker</code> 可能对应不同的 
<code>Reactor</code>，因为 <code>Future</code> 在 <code>poll</code> 的时候只是传了一个 <code>Waker</code>，现在要把 <code>Waker</code> 注册到多个 <code>Reactor</code> 上，就需要 <code>clone</code>。然后 
<code>Executor</code> 和 <code>Waker</code> 可能不在一个线程里面，<code>Waker</code> 需要跨线程发送到 <code>Reactor</code> 上面，所以也就需要一个 <code>Send</code> 
的约束。最后多个事件源可能同时调用这个 <code>Waker</code>，这里就存在并发调用的问题，要满足并发调用的话就需要实现<code>Sync</code>约束。这是对 <code>Waker</code> 使用方的要求。</p>
<p><img src="chapter_1/../image/rust-china-config-async-7.png" alt="Waker 提供方" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Waker {
    pub unsafe fn from_raw(waker: RawWaker) -&gt; Waker
}

pub struct RawWaker {
    data: *const (),
    vtable: &amp;'static RawWakerTable,
}

pub struct RawWakerTable {
    clone: unsafe fn(*const ()) -&gt; RawWaker,
    wake: unsafe fn(*const ()),
    wake_by_ref: unsafe fn(*const ()),
    drop: unsafe fn(*const ())
}
<span class="boring">}
</span></code></pre></pre>
<p>不同的 <code>Executor</code> 有不同的内部实现，而 <code>Waker</code> 又是一个公共统一的 API。有的<code>Executor</code>有一个全局队列，有的是一个线程局部队列，有的 
<code>Executor</code> 可能只支持单个 task 的执行，因此他们的唤醒机制是完全不一样的。要构造统一的 <code>Waker</code> 必然涉及多态，Rust 中是采用自定义虚表的方式实现的，通过 
<code>RawWaker</code> 来构造 <code>Waker</code>，<code>RawWaker</code> 有个数据字段，和一个静态的虚表，不同的 <code>Executor</code> 就是要把这些虚表中的方法全部实现，</p>
<h3><a class="header" href="#waker-实现需要考虑的并发问题" id="waker-实现需要考虑的并发问题">Waker 实现需要考虑的并发问题</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-8.png" alt="Waker 实现需要考虑的并发问题" /></p>
<p><code>Waker</code> 在实现上可能会有一些并发上的问题，我们先说第一个问题，<code>wake</code> 调用之间的并发，需要保证只将任务push执行队列一次。如果有两(多)个 <code>Reactor</code> 同时执行 
<code>Waker::wake</code> 的话，两个 <code>Reactor</code> 都成功把任务 push 到全局队列里去，如果第一次push的让线程 A 拿到了，第二次pushed让线程 B 拿到了，线程 A 和 B 
现在同时调用<code>poll</code>，因为 <code>poll</code> 本身 <code>Self</code> 参数是 <code>&amp;mut self</code> 的，也就是说是互斥的，这样就会造成线程安全问题。</p>
<p>第二个问题，<code>wake</code> 调用和 <code>poll</code> 之间的并发，一个任务正在执行<code>poll</code>，但是之前调用<code>poll</code>的时候把已经<code>Waker</code>注册到一个 <code>Reactor</code> 中，这个 <code>Reactor</code> 
突然好了，现在它调用<code>Waker::wake</code>试图把任务push到并发队列里去，如果push能成功的话，那么另一个线程从队列里取到任务，并尝试调用<code>poll</code>，而当前这个任务又在<code>poll </code>的过程中，因此会导致和上面一样的并发问题。</p>
<p><code>async-task</code> 完美的解决了这些并发问题，并且它提供了十分优雅的 API，我把<a href="https://zhuanlan.zhihu.com/p/92679351">源码解析</a>放在了知乎上面，大家有兴趣可以看一下。</p>
<h3><a class="header" href="#异步任务多线程-executor" id="异步任务多线程-executor">异步任务多线程 Executor</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-9.png" alt="异步任务多线程 Executor" /></p>
<p>如果用 <code>async-task</code> 处理这个问题，代码应该是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use crossbeam::channel::{unbounded, Sender};
use once_cell::sync::Lazy;
use async_task;

static QUEUE: Lazy&lt;Sender&lt;async_task::Task&lt;()&gt;&gt;&gt; = Lazy::new(|| {
    let (sender, reciver) = unbounded::&lt;Task&gt;();
    for _ in 0..4 {
        let recv = reciver.clone();
        thread::spawn(|| {
            for task in recv {
                task();
            }
        })
    }
    sender
});

fn spawn&lt;F, R&gt;(future: F) -&gt; async_task::JoinHandle&lt;R, ()&gt; 
where 
    F: Future&lt;Output = R&gt; + Send + 'static,
    R: Send + 'static,
{
    let schedule = |task| QUEUE.send(task).unwrap();
    let (task, handle) = async_task::spawn(future, schedule, ());
    task.schedule();
    handle
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看到和之前的同步任务多线程池相比，工作线程的代码基本一致，<code>spawn</code> 函数有一些区别。使用 <code>async_task</code> 很简单实现了异步任务多线程池的处理。</p>
<h3><a class="header" href="#future-和-reactor-之间的并发" id="future-和-reactor-之间的并发">Future 和 Reactor 之间的并发</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-10.png" alt="Future 和 Executor 之间的并发" /></p>
<p><code>Future</code> 如果<code>poll</code>的时候没有好的话，它负责把 <code>Waker</code> 注册到 <code>Reactor</code> 里去，这里面会有一个 <code>Waker</code> 过期的问题。第一次调用 <code>poll</code> 和第二次调用 
<code>poll</code> 时，<code>Executor</code> 传的 <code>Waker</code> 可能不是同一个，只有最新的 <code>Waker</code> 能把 task 唤醒，老的 <code>Waker</code> 就唤不醒，这样导致的问题是每次 <code>poll</code> 
的时候都要把 <code>waker</code> 更新到 <code>Reactor</code> 里，以确保能够唤醒 task。</p>
<p>比如上图中的例子，<code>Future</code> 同时对两个事件感兴趣，对应着两个 <code>Reactor</code>。<code>Future</code> 在 <code>poll</code> 的时候需要向 Reactor1 注册 <code>waker</code>，也要向 
Reactor2 注册 <code>waker</code>，当它下次 <code>poll</code> 的时候每次都要把两个 <code>waker</code> 更新，那么现在问题来了，<code>Future</code> 的 <code>poll</code> 执行在 <code>Executor</code> 线程，<code>Reactor</code> 执行在 <code>Reactor</code> 线程，一个线程往里面写，另一个线程试图从里面读，并发问题就出现了。为了处理这个问题，最简单的方式就是加一把锁，每个 <code>Reactor</code> 都要加锁解锁，这个操作本身就比较复杂，比较耗时。</p>
<p><img src="chapter_1/../image/rust-china-config-async-11.png" alt="AtomicWaker" /></p>
<p><code>AtomicWaker</code> 完美处理了这个问题，它通过单生产者多消费者的模式，将 <code>waker</code> 放到 <code>AtomicWaker</code> 里面，<code>AtomicWaker</code> 被多个 <code>Reactor</code> 
共享，<code>Waker</code>只需要更新一次，所有 <code>Reactor</code> 就能拿到最新的 <code>waker</code>。</p>
<h2><a class="header" href="#future-的可组合性" id="future-的可组合性">Future 的可组合性</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-12.png" alt="Future 的可组合性" /></p>
<p>异步任务本身是可以组合的，比如发起一个 HTTPS 请求涉及查询 DNS 拿到 IP，建立 TLS 
链接，发送请求数据，拿到响应数据，过程中的每一步都是异步任务，把这些异步任务组合到一起就是一个大的异步任务。 <code>Future</code>本身设计也是可组合的，比如下面的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>future1
    .map(func)
    .then(func_return_future)
    .join(future2);
<span class="boring">}
</span></code></pre></pre>
<p>因为 <code>Future</code> 要执行的话必须发到 <code>Executor</code> 里面，因此上面的代码还没有发到 <code>Executor</code> 里面去，所以它本身是没有执行的。上面的代码等于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Join::new(
    Then::new(
        Map::new(future1, func), 
        func_return_future
    ), 
    future2
);
<span class="boring">}
</span></code></pre></pre>
<p>它是一个声明式的，最终会产生一个结构体，是一个如上图所示的树形结构，当整个任务丢到 <code>Executor</code> 里去执行的时候，<code>poll</code> 方法 <code>Future</code> 的树根结点开始，执行到叶子节点，最底层的叶子节点 futrue 是专门跟 <code>Reactor</code> 打交道的，所以大部分开发者是不需要关心 <code>Reactor</code> 的，因此可能对 <code>Reactor</code> 概念可能了解不多。</p>
<p>当一个叶子节点没好的时候，它会把传下来的 <code>waker</code> 注册到 <code>Reactor</code> 里面去。当<code>Reactor</code> 发现任务可以继续推进了，会调用 <code>waker</code> 把 任务
放入到全局队列中，某个线程拿到任务后，会重新从根节点 poll。以上就是整个的执行过程。</p>
<h3><a class="header" href="#joinn-组合的效率" id="joinn-组合的效率">JoinN 组合的效率</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-13.png" alt="JoinN 组合的效率" /></p>
<p>上面的 <code>Future</code> 组合模型涉及到一个 <code>JoinN</code> 组合的效率问题，问题是怎么产生的呢？<code>waker</code> 只用于唤醒整个task，但是没有携带任何唤醒信息，比如 task 
是怎么被唤醒的。<code>JoinN</code> 负责把多个 <code>Future</code> 组合在一起同时并发的执行，<code>Join4</code> 把 4 个 <code>Future</code> 组合，每次 <code>poll</code> 
的时候挨个去执行子 <code>Future</code>，如果没有好的话就会注册到 <code>Reactor</code> 里面，假设第二个突然就好了，下一次 <code>poll</code> 时，Join4 
并不知道自己为什么被唤醒了，只能挨个再遍历一遍 <code>Future</code>，但其实第一、三、四都是浪费掉的。</p>
<p><img src="chapter_1/../image/rust-china-config-async-14.png" alt="Waker 的拦截和包装" /></p>
<p>怎么解决这个问题呢？<code>futures-rs</code> 里面有一个 <code>FuturesUnordered</code> 专门处理这个事情，可以管理成千上万个子 <code>Future</code>，它内置了一个并发队列，维护已经 
ready 的子 <code>Future</code>。当 <code>Executor</code> 在 <code>poll</code> 整个任务的时候，它只遍历并发队列，挨个拿出来执行，执行的时候并不是把 <code>waker</code> 
原封不动的传下去，而是进行了一次包装拦截：<code>wake</code>调用的时候，它会先把 <code>Future</code> 添加到自己的ready队列里面去，再去通知<code>Executor</code>的全局队列，<code>Executor</code> 
下次再 
<code>poll</code> 
的时候直接从内置的并发队列去执行 <code>Future</code>，这样能达到效率最大化。</p>
<h2><a class="header" href="#异步任务之间的同步" id="异步任务之间的同步">异步任务之间的同步</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-15.png" alt="异步任务之间的同步" /></p>
<p>传统多个线程之间也有同步的需求，比如说锁。异步任务之间也不可能是完全隔离的，它们之间可能做一些消息的交互，我们比较一下线程和 Task 之间的区别：</p>
<table><thead><tr><th></th><th>线程</th><th>Task</th></tr></thead><tbody>
<tr><td>睡眠</td><td>thread::park</td><td>return Pending</td></tr>
<tr><td>唤醒</td><td>thread::unpark</td><td>Waker::wake</td></tr>
<tr><td>获取方式</td><td>thread::current()</td><td>poll的参数</td></tr>
</tbody></table>
<p>线程如果想暂停工作可以调用 <code>thread::park</code>，task想暂停工作可以直接 <code>return Pending</code>；线程可以通过 <code>thread::unpark</code> 唤醒，task 
需要调用 <code>Waker::wake</code>；获取方式上，线程直接调用 <code>thread::current</code>，task 是通过 <code>poll</code> 的参数拿到 <code>waker</code>。</p>
<h3><a class="header" href="#异步任务之间的同步-mutex" id="异步任务之间的同步-mutex">异步任务之间的同步 Mutex</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-16.png" alt="异步任务之间的同步 Mutex" /></p>
<p><code>Mutex</code> 数据结构里面有一个数据字段，表示要锁的数据，一个 <code>locked</code> 
原子变量表示有没有被锁住，还有一个等待队列，异步任务想拿锁却没有拿到，它就只能进入等待队列里面，等着别人去通知它。先看一下拿锁的过程，如果 <code>waker</code> 拿到锁之前 <code>locked</code> 是 
false，表示拿锁成功了，如果没拿到失败了的话，就只能等，把 <code>waker</code> 丢到等待队列里。拿到锁的任务想释放这把锁的时候，把 <code>locked</code> 改成 false，并从等待队列中拿一个 
<code>waker</code> 出来，去唤醒相应的task。</p>
<p>这里跟大家讲一个很多人误区的地方，很多人认为异步任务里面是必须要用异步锁的，同步锁有阻塞就不行，这是不对的。大部分的等待队列的实现都是用了同步锁，也就是说 <code>Mutex</code> 
也不是完全异步的，它本身有个同步锁在里面。如果你在应用里面只是想保护一段数据，对共享的数据做点加减操作，那么应该用 std 
里面的同步锁，因为用异步锁的话，更新内部的等待队列需要加同步锁，这个开销可能比你直接用同步锁更新共享数据还要复杂很多。</p>
<p>那么什么时候用异步锁呢？在保护 IO 资源的时候，当你的锁需要跨越多个 <code>.await</code>，时间差的比较大的时候，那应该优先使用异步锁。</p>
<h3><a class="header" href="#异步任务之间的同步-oneshot" id="异步任务之间的同步-oneshot">异步任务之间的同步 Oneshot</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-17.png" alt="异步任务之间的同步 Oneshot" /></p>
<p><code>Oneshot</code> 是做什么事情的呢？它负责在两个线程之间传递一个数据，一个 task 在执行，另一个 task 在等待，前者执行完会通过 <code>Oneshot</code> 把数据传递给后者。图上所示就是 <code>Oneshot</code> 的数据结构，<code>state</code> 中纪录了很多元信息，比如数据是否已经写了，<code>sender</code> 是否应析构掉了，<code>TxWaker</code> 是否已经存了，<code>RxWaker</code> 是否已经存了，<code>receiver</code> 是否已经 <code>drop</code> 掉了。</p>
<p>发送端发送数据的时候，首先在修改state前， data是完全由 <code>sender</code> 自由访问的，写完 data 后把 <code>state</code> 状态改掉，表示这个 data 已经写完了。然后把接收端的 
<code>RxWaker</code> 取出来然后唤醒，唤醒之后 task 下次执行就可以把数据拿到了。如果 <code>sender</code> 没有发送数据，现在要把它析构掉，析构时要注意接收端还在一直等，因此 <code>sender</code> 
析构是也要把 <code>state</code> 修改掉，把相关的 <code>RxWaker</code> 唤醒，通知 <code>reciver</code> 不要再等了。</p>
<p>接收端的实现是一个 <code>Future</code>，它本身在 <code>poll</code> 的时候会读取 <code>state</code>，如果有数据那就说明发送端数据已经写完了，直接读取数据。如果没有数据的话就要等待，把它的 
<code>waker</code> 存在 <code>Oneshot</code> 的 <code>RxWaker</code> 里面，同时也更新相应的 <code>state</code>，表示接收端的 <code>RxWaker</code> 已经存在。接收端在 <code>drop</code> 的时候，也要通知 
<code>sender</code>，表示“我现在对你的数据没有兴趣了，你可以不用继续计算下去&quot;，所以接受端在 drop 的时候也要修改 <code>state</code>，从 <code>Oneshot</code> 里面拿到发送端的 
<code>TxWaker</code>，把发送端唤醒。</p>
<h3><a class="header" href="#异步任务之间的同步-waitgroup" id="异步任务之间的同步-waitgroup">异步任务之间的同步 WaitGroup</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-18.png" alt="异步任务之间的同步 WaitGroup" /></p>
<p>接下来讲一下我自己实现的 <code>WaitGroup</code>，它在 golang 里面是非常常见的。它可以构造出多个子任务，等待所有的子任务完成后，再继续执行下去，下面是一个演示代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use waitgroup::WaitGroup;
use async_std::task;

async {
    let wg = WaitGroup::new();
    for _ in 0..100 {
        let w = wg.worker();
        task::spawn(async move {
            drop(w);
        });
    }
    wg.wait().await;
}
<span class="boring">}
</span></code></pre></pre>
<p>首先先构造一个 <code>WaitGroup</code>，然后创建 100 个 <code>worker</code>，在每个任务执行完后，只要把 <code>worker</code> drop 掉，就说明任务已经完成了。然后 <code>WaitGroup</code> 
等到所有的子任务完成后继续执行。下面介绍一下它的实现，其实比较简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Inner {
    waker: AtomicWaker,
}

impl Drop for Inner {
    fn drop(&amp;mut self) {
        self.waker.wake();
    }
}

pub struct Worker {
    inner: Arc&lt;Inner&gt;,
}

pub struct WaitGroup {
    inner: Weak&lt;Inner&gt;
}

impl Future for WaitGroup {
    type Output = ();

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        match self.inner.upgrade() {
            Some(inner) =&gt; {
                inner.waker.register(cx.waker());
                Poll::Pending
            }
            None =&gt; Poll::Ready(())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>注意到如果某一个 <code>worker</code> 完成了 task，它并不需要去唤醒 <code>Waker</code>，<code>WaitGroup</code> 只关心所有任务都结束了，只需要让最后一个 <code>worker</code> 去唤醒 
<code>waker</code>。什么时候是最后一个 <code>worker</code> 呢？我们可以借用标准库里的 <code>Arc</code>，<code>Arc</code> 是一个共享引用，当所有的 <code>Arc</code> 
强引用都销毁的时候，就会析构内部的数据，只要在 <code>Arc</code> 包装的数据的 <code>drop</code> 方法里面把 <code>waker</code> 唤醒就可以了。</p>
<p><code>WaitGroup</code> 持有一个弱引用，所有的 <code>Worker</code> 都持有强引用，<code>WaitGroup</code> 在 <code>poll</code> 
的时候试图把弱引用升级成强引用，如果升级失败了，说明所有的强引用都没了，也就是任务都执行完了，就可以返回 <code>Ready</code>。如果升级成功了，说明现在至少还有一个强引用，那就把 <code>waker</code> 注册到 <code>AtomicWaker</code> 里面。这里有一个边界条件，在升级结束的瞬间，所有的 <code>worker</code> 全部 <code>drop</code> 掉了，这时还不会调用 
<code>wake</code>，因为在升级成功时，会产生一个临时的强引用 
<code>inner</code>，这时更新waker后，在这个临时的强引用销毁的时候调用 <code>drop</code>，然后调用 <code>waker.wake()</code> 把任务唤醒，因此不会丢失通知。整个过程就完整了。</p>
<h1><a class="header" href="#生产实践-译1password-的-rust-实践" id="生产实践-译1password-的-rust-实践">生产实践 |「译」1password 的 Rust 实践</a></h1>
<hr />
<p><a href="https://serokell.io/blog/rust-in-production-1password">英文原文</a></p>
<p>Rust已经风靡编程语言界。自2015年发布1.0版本以来，它一直是最受喜爱的编程语言之一，拥有一批忠实的开发者和贡献者。</p>
<p>为何 Rust 在软件开发者中会如此受宠？为了解答这个疑问，我们踏上了一段关于 Rust 软件开发的新旅程。我们将采访一些在重要项目中使用 Rust 的技术人员。这些重要项目涉及但不限于手机应用、服务程序、初创公司的最小可行化产品。</p>
<p>在本系列的第一期中，我们采访了 <a href="https://1password.com/">1Password</a> 的工程副总裁 Michael Fey。他们为什么选择 Rust 做开发？Rust 给安全软件带来了哪些好处？如果你想使用 Rust 开发类似的软件，应该关注哪些库？如果你想知道这些问题的答案，请继续阅读。</p>
<p><strong>你能给我们介绍下关于公司和你的一些情况吗?</strong></p>
<p>1Password 是一款已经被数百万人和70,000家企业采用的优秀的密码管理软件，用于保护他们的敏感数据。它支持主流浏览器、桌面和移动设备. 它能帮助你记住所有你没有必要去记住的密码。</p>
<p>我是 1Password 客户端开发的工程副总裁。如果您曾在 Mac、Windows PC、iPhone、iPad、Android 手机、平板电脑或浏览器中使用过1Password，那么您就使用了我们团队开发的软件。从2004年开始，我们就专注于打造这款软件。这是一款体验绝佳的安全产品，为此我们感到非常自豪。</p>
<p><img src="chapter_1/../image/password.jpg" alt="" /></p>
<p><strong>你能谈谈 1Password 的技术栈吗？你们的代码中有多大一部分是用 Rust 编写的?</strong></p>
<p>我们在 1Password 中使用Rust已经有好几年了。我们的 Windows 团队是这项工作的领头羊。Windows版的1Password 7 中大约 70% 的代码是用 Rust 编写的。我们还在2019年底把 1Password Brian (一种浏览器填充逻辑的引擎) 从 Go 移植到 Rust，然后把 Rust 编译为 WebAssembly，最后再部署到浏览器插件中。这样我们就可以利用到 WebAssembly 的速度和性能。</p>
<p>它们得益于产品采用了Rust，在过去几年我们取得了巨大成功。现在我们正在对几乎整个产品线进行重写，Rust 在其中扮演主要角色。我们正在使用 Rust 创建一个headless 1Password 应用: 把所有的业务逻辑、加密解密、数据库访问、服务器通信等统统包裹到一个薄薄的 UI 层中，然后作为原生应用部署到系统中。</p>
<p><strong>1Password 采用 Rust 的原因是什么，是看中它的高性能或类型/内存安全吗？</strong></p>
<p>最初吸引我们使用 Rust 的主要原因之一是内存安全; Rust 可以增强我们对保护客户数据安全的信心，这无疑让我们兴奋不已。不过，除了内存安全之外，我们对Rust生态系统的喜爱还有很多。没有传统的运行时是一个显著的性能优势；例如，我们不再担心垃圾收集器的性能开销。Rust提供了一种 &quot;程序正确性 &quot;的形式和许多针对运行时未定义行为的保证。强类型系统在编译时会强制保证这些规则。仔细地将应用逻辑与Rust的强类型规则对齐，使API难以被误用。同时，因为不需要对约束和不变量进行运行时检查，所以可以写出简洁的代码。在程序执行之前，编译器就可以保证: 不存在无效的运行时代码路径, 不会因此产生程序异常。因为运行时状态验证更少，所以写出的代码会更干净、更高效、更内聚、质量也更高。与其他语言相比，Rust 很少需要运行时调试。如果能编译通过，你就可以相当确定它不会表现出未定义行为。它可能不是你想要的，但它会是 &quot;正确的&quot;</p>
<p>Rust 的另一个非常强大却常被忽视的特性是程序化宏系统[1]。它使我们能够编写一种工具：可以自动将 Rust 中定义的类型与我们的客户端语言 (Swift、Kotlin和 TypeScript) 共享。这种工具的输出会自动处理序列化/反序列化过程。这意味着客户端开发人员在与 Rust 库交互时，可以继续使用他们选择的语言进行编程，同时又可以消除使用 FFI 进行 JSON 解析的烦恼。除了上述这些益处，我们还能获得每一种目标语言在编译期类型检查的好处。我们已经把这个工具集成到持续集成服务器中，这意味着对Rust模型的改变会导致客户端应用程序的编译失败，而这些失败情况会在代码评审中被发现。</p>
<p>这个工具已经成为我们开发过程中不可或缺的组成部分，让我们的进度比以前快得多。一旦我们的类型在Rust中被定义，我们就能立即在客户端语言中生成等价类型。这使我们的开发人员能够专注于解决问题。而不必去捋模版代码，再使用 FFI 进行通信</p>
<p><strong>Rust对开发像1Password这样以安全为中心的应用程序的支持（库和其他）有多好？</strong></p>
<p>对于实现安全软件的大部分基础组件来说，那是绰绰有余的。有两个大型的、突出的密码学平台( <a href="https://github.com/briansmith/ring">ring</a>  和<a href="https://github.com/RustCrypto">Rust Crypto</a> 组)，它们提供了丰富的功能。正如我在前面提到的，用 Rust 编写程序会让你对内存的使用充满信心，也让你更难意外引入与内存相关的漏洞。还有一个很好的系统，用来跟踪Rust crates中不时出现的漏洞：<a href="https://rustsec.org/">RustSec</a> 数据库。它是由其他 Rust 开发者提供的社区资源，并且经常更新。此外，Rust 和 Cargo 还包含了 batteries-included 测试框架。这意味着你总是有一种容易的方式来编写单元测试套件，以保证关键代码(比如加密函数)的正确性。</p>
<p>如果存在 Rust 原生安全库，那当然是最理想的 (而且它们会及时出现) 。如果没有也不必担心，我们还有其他选项：使用C语言或原生平台库中的一些东西。在我们的Rust代码中，我们将这一点发挥得淋漓尽致，比如调用生物识别解锁的原生实现（Touch ID、Face ID、Windows Hello）和特定平台的设置实现(比如苹果平台上的NSUserDefaults)。</p>
<p><strong>其中有什么特别的Rust库是你想介绍一下的吗？</strong></p>
<p>当然有。1Password 使用了 Tokio、Hyper/Reqwest、Ring 和Neon。得益于这些 Rust 库，我们才能完成这个雄心勃勃的项目。你也应该看看我们在 <a href="http://crates.io/">crates.io</a> 上的 <a href="https://crates.io/crates/password-rules-parser">密码规则解析器</a>  。它主要基于苹果支持的规范。他们的工具和文档可以在 <a href="https://developer.apple.com/password-rules/">这里</a> 找到。</p>
<p><strong>在用 Rust 开发 1Password 的过程中，遇到的最大挑战是什么？</strong></p>
<p>我们团队中的许多人都是Rust的新手，他们经历了典型的学习曲线，这与它的内存管理和所有权模型有关。我们还发现编译时间很长；我们的CPU和风扇肯定会受到锻炼。😄</p>
<p><strong>你对结果满意吗？</strong></p>
<p>绝对满意</p>
<p><strong>你有什么关键的心得想跟我们的观众分享吗？</strong></p>
<p>如果你是Rust的新手，请从小处着手，并在此基础上进行改进。我们在刚开始的时候进行了大量的实验，试图找到基于Rust的最佳解决方案。当你的实验成功后，回顾一下你过去使用其他语言的工作方式，看看你的代码能否从Rust的理念中获益。</p>
<p>如果你是1Password的新用户，今天就可以通过这个链接注册，家庭和个人账户第一年可以节省50%的费用。如果你正在做一个开源项目，你可以免费获得一个1Password Teams账户。请前往我们的 GitHub 仓库了解更多信息。</p>
<p>附录</p>
<p>[1]  指的是<a href="https://github.com/1Password/typeshare">typeshare</a>. 它的功能是把一些用rust 写的结构体生成为其他语言的结构体，比如下面的rust 的一个struct</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
struct Teacher {
    name: String,
    age: u64,
    id: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>转化为typescript的变成如下:</p>
<pre><code class="language-typescript">export interface Teacher {
    name: string;
    age: number;
    id: number;
}
</code></pre>
<p>它同时支持typescript,swift,java. 它把Rust写的struct生成了团队其他中定义各语言结构体的规范。所以该规范也只是1password团队内部定义domain层的规范。不一定适合其他团队。</p>
<p>[2]  另一款开源的密码管理器<a href="https://bitwarden.com/">bitwarden</a>.  也有rust 实现后台<a href="https://github.com/dani-garcia/bitwarden_rs">bitwarden_rs</a>.  有兴趣可以进一步阅读。</p>
<hr />
<p>译者简介：</p>
<p>柴杰，中国科学技术大学集成电路工程专业，在读硕士研究生。兴趣与专长为虚拟内存系统、分布式系统。</p>
<p>审校：</p>
<ul>
<li>严炳（ryan），算法，大数据开发从业者，喜欢和有开源精神的人一起共事。</li>
</ul>
<h1><a class="header" href="#溪塔科技-用rust写protobuf扩展" id="溪塔科技-用rust写protobuf扩展">溪塔科技: 用Rust写Protobuf扩展</a></h1>
<p>作者： 宁志伟</p>
<p>本文为《Rust 唠嗑室》第 17 期 - 《用 Rust 写 Protobuf 扩展》的文字版本。</p>
<hr />
<h2><a class="header" href="#protobuf" id="protobuf">Protobuf</a></h2>
<p><code>Protocol Buffers</code> (简称 <code>Protobuf</code> ) ，是 <code>Google</code> 出品的序列化框架，与开发语言无关，和平台无关。具有体积小，速度快，扩展性好，与 <code>gRPC</code> 搭配好，支持的语言多等特点，是目前应用最广泛的序列化框架。</p>
<p>使用场景一般是在微服务架构中，用来定义微服务之间的 <code>gRPC</code> 接口，以及相关的参数/返回值等数据结构的定义。</p>
<p>通过官方的编译器 <code>protoc</code> 以及相应的插件可以方便的生成不同语言的实现代码。这样不同的微服务可以使用不同的开发语言，同时还能顺利进行交互。</p>
<h2><a class="header" href="#cita-cloud中的protobuf" id="cita-cloud中的protobuf"><code>CITA-Cloud</code>中的<code>Protobuf</code></a></h2>
<p><code>CITA-Cloud</code> 采用了<a href="https://cita-cloud-docs.readthedocs.io/zh_CN/latest/blockchain.html">微服务架构</a>，因此也采用了 <code>Protobuf</code> 和 <code>gRPC</code> 的组合。</p>
<p>但是因为 <code>Protobuf</code> 语言无关的特性和广泛的应用，使得其具有抽象和通用的特点。因此也可以把 <code>Protobuf</code> 当作一种建模语言来使用，<a href="https://zhuanlan.zhihu.com/p/162839054">参见文章</a>。</p>
<p><code>CITA-Cloud</code> 目前是在<a href="https://github.com/cita-cloud/cita_cloud_proto">协议</a>中直接把交易和区块等数据结构固定下来的。但是最近的思考发现，其中的很多字段都是为了实现某种应用层面的协议而存在的。比如交易中的 <code>nonce</code> 字段就是为了实现应用层面的去重协议。</p>
<p>因此，后续计划提供一个框架，方便用户自定义交易和区块等核心数据结构，以及相关的处理函数。但是 <code>Protobuf</code> 通常只能生成数据结构，以及相关的 <code>get/set</code> 等模式比较固定的代码，如果要生成复杂的成员函数，就需要一些扩展能力。</p>
<h2><a class="header" href="#protobuf扩展" id="protobuf扩展"><code>Protobuf</code>扩展</a></h2>
<p><code>Protobuf</code> 的扩展能力可以分为两种： <code>Protobuf</code> 本身的扩展和 <code>Protobuf</code> 插件。</p>
<p><code>Protobuf</code> 其实是个标准的编译器架构。我们可以把 <code>.proto </code>文件视作源码，官方的 <code>protoc</code> 编译器可以对应到编译器前端。</p>
<p><code>protoc</code> 接收一个或者一批 <code>.proto</code> 文件作为输入，解析之后输出一种中间描述格式，对应编译器中的 <code>IR</code> 。</p>
<p>但是有意思的是，这种中间描述格式是二进制的，其结构依旧由 <code>Protobuf</code> 本身描述。详细可以参见<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto">descriptor.proto</a>。</p>
<p><code>Protobuf</code> 插件可以对应到编译器后端，接收中间描述格式，解析其中的信息，据此生成具体语言的代码。</p>
<p>这里其实有个非常有意思的问题。插件在解析中间描述格式的数据时，因为这种格式是由 <code>descriptor.proto</code> 描述的，所以得先有个插件能把 <code>descriptor.proto</code> 生成开发插件所使用的开发语言的代码。</p>
<p>上面的话有点绕，举个具体的例子。比如我想用 <code>Rust</code> 实现一个插件，假如目前还没有 <code>Protobuf</code> 相关的 <code>Rust</code> 库，那就没办法用 <code>Rust</code> 代码来解析 <code>descriptor.proto</code> 对应的中间描述格式的数据，也就没法实现插件了。</p>
<p>这个问题其实就对应编译器里的自举问题。比如，想用 <code>Rust</code> 来写 <code>Rust</code> 编译器，那么一开始就是个死结了。解决办法也很简单，最开始的 <code>Rust</code> 编译器是用 <code>Ocaml</code> 实现的，然后就可以用 <code>Rust</code> 来写 <code>Rust</code> 编译器，实现编译器的 <code>Rust</code> 代码用前面 <code>Ocaml</code> 实现的版本去编译就可以解决自举问题了。</p>
<p><code>Protobuf</code> 这里也是同样的，官方提供了 <code>Java/Go/C++/Python</code> 等版本的实现，可以先用这些语言来过渡。</p>
<p>另外一种扩展方式是 <code>Protobuf</code> 本身提供了语法上的<a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">扩展机制</a>。这个功能可以对应到编程语言提供的宏等元编程功能。</p>
<p><code>Protobuf</code> 这个扩展能力有点类似<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266265125480448"><code>AOP</code></a>，可以方便的在已经定义的 <code>Message</code> 中增加一些成员。</p>
<p>更有意思的是，前面提到过，所有的 <code>.proto</code> 文件，经过 <code>protoc </code>之后，会被转换成由 <code>descriptor.proto</code> 对应的中间描述格式。而 <code>descriptor.proto</code> 中的 <code>Message</code> 也同样支持上述扩展功能，因此可以实现一种类似全局 <code>AOP</code> 的功能。</p>
<p>通过扩展 <code>descriptor.proto</code> 中的 <code>Message</code> ，可以实现给所有的 <code>Message</code> 都加一个 <code>option</code> 这样的操作。</p>
<h2><a class="header" href="#rust中相关的库" id="rust中相关的库"><code>Rust</code>中相关的库</a></h2>
<p><code>dropbox</code> 实现了一个 <code>Protobuf </code>库<a href="https://github.com/dropbox/pb-jelly"><code>pb-jelly</code></a>，它就是用 <code>Python</code> 来实现生成 <code>Rust</code> 代码部分的功能。具体实现其实比较简单，就是在拼 <code>Rust</code> 代码字符串。</p>
<p><a href="https://github.com/stepancheg/rust-protobuf"><code>rust-protobuf</code></a>是一个实现比较完整的 <code>Protobuf</code> 库，支持 <code>gRPC</code> 和相关的扩展能力。其中实现分为两部分，生成数据结构 <code>Rust</code> 代码的插件和生成 <code>gRPC</code> 相关代码的插件。具体实现封装的稍微好了一点，但是基本上还是在拼 <code>Rust</code> 代码字符串。</p>
<p><a href="https://github.com/danburkert/prost"><code>prost</code></a>是一个比较新的 <code>Protobuf</code> 库实现。功能上有点欠缺，不支持扩展。库本身只支持生成数据结构的<code>Rust</code> 代码。生成 <code>gRPC</code> 相关代码的功能在<a href="https://github.com/hyperium/tonic"><code>tonic-build</code></a>里，这个有点奇怪。</p>
<p>但是 <code>prost</code> 采用了很多新的技术。前面提到，插件只会生成数据结构相关的 <code>get/set</code> 等模式比较固定的代码， <code>prost</code> 实现了一个 <code>derive</code> 来自动给数据结构增加这些成员函数，这样生成的 <code>Rust</code> 代码就大大简化了，<a href="https://github.com/cita-cloud/cita_cloud_proto/blob/master/src/common.rs">参见例子</a>。</p>
<p>这也跟编译器架构能对应上：一个选择是把编译器后端做的很复杂，直接生成所有的代码，运行时比较薄；另外一个选择是编译器后端做的很简单，生成的代码也简单，但是运行时比较厚重。</p>
<p>另外 <code>gRPC</code> 相关的代码比较复杂， <code>tonic-build</code> 在生成的时候用了<a href="https://github.com/dtolnay/quote"><code>quote</code></a>库，提供类似<code> Rust</code> 代码语法树上的 <code>sprintf</code> 方法的功能，不管是便利性还是代码的可读性都比之前两个库好很多。</p>
<h2><a class="header" href="#后续计划" id="后续计划">后续计划</a></h2>
<p>后续计划使用 <code>Protobuf</code> 及其扩展能力，实现一个框架，不但用来描述交易和区块等核心数据结构，也以一种可配置的方式生成一些比较复杂的相关代码。</p>
<p>最重要的第一步就是要能解析出 <code>Protobuf</code> 扩展相关的信息，因为正常的 <code>.proto</code> 文件只能用于描述数据结构，扩展的 <code>option</code> 是唯一可以赋值的地方。</p>
<p>目前实现了一个<a href="https://github.com/rink1969/proto_desc_printer"><code>proto_desc_printer</code></a>，可以解析中间描述格式，特别是其中的扩展信息。</p>
<p>后续可以在这个基础上去做代码生成部分的工作，这里可以从 <code>prost</code> 吸取很多好的经验。</p>
<hr />
<p>作者简介：</p>
<p>宁志伟</p>
<p>溪塔科技首席架构师
首个微服务架构区块链<code>CITA</code> 首席架构师，区块链+云原生框架 <code>CITA-Cloud</code> 设计者。前阿里巴巴、华为技术专家，超过 <code>10</code> 年分布式系统架构设计，编程语言和虚拟机方面工作经验。</p>
<ul>
<li>
<p>Blog   : <a href="https://rink1969.github.io/">https://rink1969.github.io</a></p>
</li>
<li>
<p>GitHub : <a href="https://github.com/rink1969">https://github.com/rink1969</a></p>
</li>
<li>
<p>为国产自主云原生区块链<code>CITA-Cloud</code>点赞<a href="https://github.com/cita-cloud/cita_cloud_proto">https://github.com/cita-cloud/cita_cloud_proto
</a></p>
</li>
</ul>
<p>后期编辑：</p>
<p><a href="https://github.com/higker">丁 烁(Jarvib Ding)</a>，Rust 爱好者。</p>
<h1><a class="header" href="#建造者模式builder" id="建造者模式builder">建造者模式（Builder)</a></h1>
<h2><a class="header" href="#概述" id="概述">概述</a></h2>
<p>构建者模式是一种设计模式，提供一种灵活的解决方案，已解决面向对象程序设计中的各种对象创建问题。Builder设计模式的目的是将复杂对象的构造与其表示分离开来。是&quot;是四人帮&quot;设计模式之一[wiki]。建造者模式是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<p>定义：Builder设计模式的目的是将复杂对象的构造与其表示分离开来。通过这样做，同样的构造过程可以创建不同的表示。</p>
<h2><a class="header" href="#历史" id="历史">历史</a></h2>
<p>假如有一个复杂的对象，需要对其进行构造时需要对诸多成员变量和嵌套对象进行繁杂的初始化工作。有时这些初始化代码通常深藏于一个包含众多参数且让人看不懂的构造函数中；或者这些代码散落在客户端代码的多个位置。</p>
<ol>
<li>例如，创建一个房子，不同种类的房子有不同的风格，为每一种类型的房子创建一个子类，这可能会导致程序变得过于复杂。</li>
<li>或者无需生成子类，但是需要创建一个包括所有可能参数的超级构造函数，并用它来控制房屋对象的创建。这样虽然可以避免生成子类，但是会造成当拥有大量输入参数的构造函数不是每次都要全部用上。通常情况下，绝大部分的参数都没有使用，这使得对于构造函数的调用十分不简洁。</li>
</ol>
<h2><a class="header" href="#建造者模式-的使用" id="建造者模式-的使用">建造者模式 的使用</a></h2>
<p>建造者模式建议将对象构造的代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。每次创建对象时，都需要通过生成器对象执行一系列步骤。重点在于无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤。</p>
<h2><a class="header" href="#适用场景" id="适用场景">适用场景</a></h2>
<ul>
<li>使用建造者设计模式可以避免“重叠构造函数”的出现。
<ul>
<li>假设复杂函数中有十几个可选参数，那么调用这些函数会非常不方便，因此需要重载这个构造函数，新建几个只有较少参数的简化版本。</li>
<li>建造者设计模式让你可以分步骤生成对象，而且允许你仅适用必须的步骤。</li>
</ul>
</li>
<li>当使用代码创建不同形式的产品时，可使用生成器模式
<ul>
<li>如果你需要创建各种形式的产品，他们的制造过程相似且仅有细节上的差异，此时可使用生成器模式。</li>
<li>基本生成器接口中定义了所有可能的制造步骤，具体生成器将实现这些步骤来制造特定形式的产品。</li>
</ul>
</li>
<li>使用构造者模式构造其他复杂对象
<ul>
<li>构造者模式让你能分步骤构造产品，你可以延迟执行某些步骤而不会影响最终产品。</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#优点" id="优点">优点</a></h2>
<ul>
<li>可以分步骤创建对象，暂缓创建步骤或者递归运行创建步骤。</li>
<li>生成不同形式的产品，你可以复用相同的制造代码</li>
<li>单一职责原则，可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<h2><a class="header" href="#缺点" id="缺点">缺点</a></h2>
<p>由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。</p>
<h2><a class="header" href="#描述" id="描述">描述</a></h2>
<p>通过使用构建者助手创建一个对象。</p>
<h2><a class="header" href="#例子" id="例子">例子</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    println!(&quot;foo = {:?}&quot;, foo);
    println!(&quot;foo from builfer = {:?}&quot;, foo_from_builder);
}

#[derive(Debug, PartialEq)]
pub struct Foo {
    // lots of complicated fields
    bar : String,
}

pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new() -&gt; Self {
        // set the minimally required fields of Foo.
        Self {
            bar: String::from(&quot;x&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // set the name on the builder iteself,
        // and return the builder by value.
        self.bar = bar;
        self 
    }
    // if we can get away with not consuming the builder here, that is an 
    // advantage. It means we can use the FooBuilder as a template for constructing many Foo.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from Foo the FooBuilder, applying all settings in FooBuilder to Foo. 
        Foo { bar: self.bar }
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Rust 编程之道. P234
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
    fn new() -&gt; CircleBuilder {
        CircleBuilder {
            x: 0.0, y: 0.0, radius: 1.0,
        }
    }
}

impl CircleBuilder {
    fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.x = coordinate;
        self
    }
    fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.y = coordinate;
        self
    }
    fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn build(&amp;self) -&gt; Circle {
        Circle {
            x: self.x, y: self.y, radius: self.radius,
        }
    }
}

fn main() {
  let c = Circle::new().x(1.0).y(2.0).radius(2.0).build();
  println!(&quot;area = {:?}&quot;, c.area());
  println!(&quot;c.x = {:?}&quot;, c.x);
  println!(&quot;c.y = {:?}&quot;, c.y);
}
</code></pre></pre>
<h2><a class="header" href="#动机" id="动机">动机</a></h2>
<p>当你需要许多不同的构造函数或者当构造有副作用时，这种方法有用。</p>
<h2><a class="header" href="#优点-1" id="优点-1">优点</a></h2>
<p>将构造方法与其他方法分离。</p>
<p>防止构造函数的扩散</p>
<p>可用于单次初始化以及更加复杂的构造。</p>
<h2><a class="header" href="#缺点-1" id="缺点-1">缺点</a></h2>
<p>比直接创建结构对象或简单的的构造函数更复杂。</p>
<h2><a class="header" href="#讨论" id="讨论">讨论</a></h2>
<p>这种模式在Rust（以及简单对象）中比在其他许多语言中更常见，这是因为Rust缺乏重载。由于你只能使用给定名称的单个方法，因此在Rust中使用多个构造函数要比C++、Java或其他语言好。</p>
<p>这种模式通常用于构建器对象本身就很有用的地方，而不仅仅是一个构建器。例如：std::process::Command 是Child的构建器。在这种情况下，不使用T和TBuilder的命名模式。</p>
<p>该示例通过值获取并返回生成器。接受并返回构建器作为可变引用通常更符合人体工程学（并且更有效）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut fb = FooBuilder::new();
fb.a();
fb.b();
let f = fb.builder();
<span class="boring">}
</span></code></pre></pre>
<p>以及FooBuilder::new().a().b().builder()样式。</p>
<h2><a class="header" href="#参见" id="参见">参见</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html">Description in the style guide</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>, a crate for automatically implementing this pattern while avoiding the boilerplate.</li>
<li><a href="https://rust-unofficial.github.io/patterns/idioms/ctor.html">Constructor pattern</a> for when construction is simpler.</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern (wikipedia)</a></li>
<li><a href="https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder">Construction of complex values</a></li>
<li>Rust编程之道 ch7,p234</li>
</ul>
<h2><a class="header" href="#项目中的使用" id="项目中的使用">项目中的使用</a></h2>
<h3><a class="header" href="#tokio-中的建造者模式-struct-a-hrefhttpsdocsrstokio110tokioindexhtmltokioaa-hrefhttpsdocsrstokio110tokioruntimeindexhtmlruntimeaa-hrefhttpsdocsrstokio110tokioruntimestructbuilderhtmlbuildera" id="tokio-中的建造者模式-struct-a-hrefhttpsdocsrstokio110tokioindexhtmltokioaa-hrefhttpsdocsrstokio110tokioruntimeindexhtmlruntimeaa-hrefhttpsdocsrstokio110tokioruntimestructbuilderhtmlbuildera">Tokio 中的建造者模式 Struct <a href="https://docs.rs/tokio/1.1.0/tokio/index.html">tokio</a>::<a href="https://docs.rs/tokio/1.1.0/tokio/runtime/index.html">runtime</a>::<a href="https://docs.rs/tokio/1.1.0/tokio/runtime/struct.Builder.html">Builder</a></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Builder {
    /// Runtime type
    kind: Kind,

    /// Whether or not to enable the I/O driver
    enable_io: bool,

    /// Whether or not to enable the time driver
    enable_time: bool,

    /// The number of worker threads, used by Runtime.
    ///
    /// Only used when not using the current-thread executor.
    worker_threads: Option&lt;usize&gt;,

    /// Cap on thread usage.
    max_blocking_threads: usize,

    /// Name fn used for threads spawned by the runtime.
    pub(super) thread_name: ThreadNameFn,

    /// Stack size used for threads spawned by the runtime.
    pub(super) thread_stack_size: Option&lt;usize&gt;,

    /// Callback to run after each thread starts.
    pub(super) after_start: Option&lt;Callback&gt;,

    /// To run before each worker thread stops
    pub(super) before_stop: Option&lt;Callback&gt;,

    /// Customizable keep alive timeout for BlockingPool
    pub(super) keep_alive: Option&lt;Duration&gt;,
}

pub fn new_current_thread() -&gt; Builder // 设置current thread 类型
//Returns a new builder with the current thread scheduler selected.
//Configuration methods can be chained on the return value.

pub fn new_multi_thread() -&gt; Builder // 设置 multi thread 类型
//This is supported on crate feature rt-multi-thread only.
//Returns a new builder with the multi thread scheduler selected.
//Configuration methods can be chained on the return value.

pub fn enable_all(&amp;mut self) -&gt; &amp;mut Self
// Enables both I/O and time drivers.
// Doing this is a shorthand for calling enable_io and enable_time individually. If additional components are added to Tokio in the future, enable_all will include these future components.

pub fn worker_threads(&amp;mut self, val: usize) -&gt; &amp;mut Self // 设置的runtime 用于工作的线程数
// Sets the number of worker threads the Runtime will use.
// This should be a number between 0 and 32,768 though it is advised to keep this value on the smaller side.

pub fn max_blocking_threads(&amp;mut self, val: usize) -&gt; &amp;mut Self // 设置生成的用于阻塞操作的线程最大数
//Specifies limit for threads spawned by the Runtime used for blocking operations.
//Similarly to the worker_threads, this number should be between 1 and 32,768.
//The default value is 512.
//Otherwise as worker_threads are always active, it limits additional threads (e.g. for blocking annotations).

pub fn thread_name(&amp;mut self, val: impl Into&lt;String&gt;) -&gt; &amp;mut Self // 设置线程的名字
//Sets name of threads spawned by the Runtime's thread pool.
//The default name is &quot;tokio-runtime-worker&quot;.

// .....

pub fn build(&amp;mut self) -&gt; Result&lt;Runtime&gt; // 构造出tokio中的runtime结构
//Creates the configured Runtime.
//The returned Runtime instance is ready to spawn tasks.

//etc..

//example
// build runtime
let runtime = Builder::new_multi_thread()
                .worker_threads(4)
                .thread_name(&quot;my-custom-name&quot;)
                .thread_stack_size(3 * 1024 * 1024)
                .build()
                .unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>从Builder的build函数可以知道Builder结构是Runtime的辅助结构体用来帮助构造Runtime的。</p>
<h2><a class="header" href="#futures-中的建造者设计模式-struct-a-hrefhttpsdocsrsfutures0312futuresindexhtmlfuturesaa-hrefhttpsdocsrsfutures0312futuresexecutorindexhtmlexecutoraa-hrefhttpsdocsrsfutures0312futuresexecutorstructthreadpoolbuilderhtmlthreadpoolbuildera" id="futures-中的建造者设计模式-struct-a-hrefhttpsdocsrsfutures0312futuresindexhtmlfuturesaa-hrefhttpsdocsrsfutures0312futuresexecutorindexhtmlexecutoraa-hrefhttpsdocsrsfutures0312futuresexecutorstructthreadpoolbuilderhtmlthreadpoolbuildera">Futures 中的建造者设计模式 Struct <a href="https://docs.rs/futures/0.3.12/futures/index.html">futures</a>::<a href="https://docs.rs/futures/0.3.12/futures/executor/index.html">executor</a>::<a href="https://docs.rs/futures/0.3.12/futures/executor/struct.ThreadPoolBuilder.html">ThreadPoolBuilder</a></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A general-purpose thread pool for scheduling tasks that poll futures to
/// completion.
///
/// The thread pool multiplexes any number of tasks onto a fixed number of
/// worker threads.
///
/// This type is a clonable handle to the threadpool itself.
/// Cloning it will only create a new reference, not a new threadpool.
///
/// This type is only available when the `thread-pool` feature of this
/// library is activated.
#[cfg_attr(docsrs, doc(cfg(feature = &quot;thread-pool&quot;)))]
pub struct ThreadPool {
    state: Arc&lt;PoolState&gt;,
}

/// Thread pool configuration object.
///
/// This type is only available when the `thread-pool` feature of this
/// library is activated.
#[cfg_attr(docsrs, doc(cfg(feature = &quot;thread-pool&quot;)))]
pub struct ThreadPoolBuilder {
    pool_size: usize,
    stack_size: usize,
    name_prefix: Option&lt;String&gt;,
    after_start: Option&lt;Arc&lt;dyn Fn(usize) + Send + Sync&gt;&gt;,
    before_stop: Option&lt;Arc&lt;dyn Fn(usize) + Send + Sync&gt;&gt;,
}


struct PoolState {
    tx: Mutex&lt;mpsc::Sender&lt;Message&gt;&gt;,
    rx: Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;,
    cnt: AtomicUsize,
    size: usize,
}

enum Message {
    Run(Task),
    Close,
}

impl ThreadPoolBuilder {
    /// Create a default thread pool configuration.
    ///
    /// See the other methods on this type for details on the defaults.
    pub fn new() -&gt; Self {
        Self {
            pool_size: cmp::max(1, num_cpus::get()),
            stack_size: 0,
            name_prefix: None,
            after_start: None,
            before_stop: None,
        }
    }

    /// Set size of a future ThreadPool
    ///
    /// The size of a thread pool is the number of worker threads spawned. By
    /// default, this is equal to the number of CPU cores.
    ///
    /// # Panics
    ///
    /// Panics if `pool_size == 0`.
    pub fn pool_size(&amp;mut self, size: usize) -&gt; &amp;mut Self {
        assert!(size &gt; 0);
        self.pool_size = size;
        self
    }

    /// Set stack size of threads in the pool, in bytes.
    ///
    /// By default, worker threads use Rust's standard stack size.
    pub fn stack_size(&amp;mut self, stack_size: usize) -&gt; &amp;mut Self {
        self.stack_size = stack_size;
        self
    }

    /// Set thread name prefix of a future ThreadPool.
    ///
    /// Thread name prefix is used for generating thread names. For example, if prefix is
    /// `my-pool-`, then threads in the pool will get names like `my-pool-1` etc.
    ///
    /// By default, worker threads are assigned Rust's standard thread name.
    pub fn name_prefix&lt;S: Into&lt;String&gt;&gt;(&amp;mut self, name_prefix: S) -&gt; &amp;mut Self {
        self.name_prefix = Some(name_prefix.into());
        self
    }

    /// Execute the closure `f` immediately after each worker thread is started,
    /// but before running any tasks on it.
    ///
    /// This hook is intended for bookkeeping and monitoring.
    /// The closure `f` will be dropped after the `builder` is dropped
    /// and all worker threads in the pool have executed it.
    ///
    /// The closure provided will receive an index corresponding to the worker
    /// thread it's running on.
    pub fn after_start&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self
        where F: Fn(usize) + Send + Sync + 'static
    {
        self.after_start = Some(Arc::new(f));
        self
    }

    /// Execute closure `f` just prior to shutting down each worker thread.
    ///
    /// This hook is intended for bookkeeping and monitoring.
    /// The closure `f` will be dropped after the `builder` is droppped
    /// and all threads in the pool have executed it.
    ///
    /// The closure provided will receive an index corresponding to the worker
    /// thread it's running on.
    pub fn before_stop&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self
        where F: Fn(usize) + Send + Sync + 'static
    {
        self.before_stop = Some(Arc::new(f));
        self
    }
	
  	// 从ThreadBuilder的create函数可以看到ThreadPoolBuilder根据配置采纳数创建ThreadPool， 是ThreadPool的辅助结构体 
    /// Create a [`ThreadPool`](ThreadPool) with the given configuration.
    pub fn create(&amp;mut self) -&gt; Result&lt;ThreadPool, io::Error&gt; {
        let (tx, rx) = mpsc::channel();
        let pool = ThreadPool {
            state: Arc::new(PoolState {
                tx: Mutex::new(tx),
                rx: Mutex::new(rx),
                cnt: AtomicUsize::new(1),
                size: self.pool_size,
            }),
        };

        for counter in 0..self.pool_size {
            let state = pool.state.clone();
            let after_start = self.after_start.clone();
            let before_stop = self.before_stop.clone();
            let mut thread_builder = thread::Builder::new();
            if let Some(ref name_prefix) = self.name_prefix {
                thread_builder = thread_builder.name(format!(&quot;{}{}&quot;, name_prefix, counter));
            }
            if self.stack_size &gt; 0 {
                thread_builder = thread_builder.stack_size(self.stack_size);
            }
            thread_builder.spawn(move || state.work(counter, after_start, before_stop))?;
        }
        Ok(pool)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>从ThreadBuilder的create函数可以看到ThreadPoolBuilder根据配置采纳数创建ThreadPool， 是ThreadPool的辅助结构体 </p>
<h2><a class="header" href="#surf中的建造者设计模式" id="surf中的建造者设计模式">Surf中的建造者设计模式</a></h2>
<pre><pre class="playground"><code class="language-rust">/// Request Builder
///
/// Provides an ergonomic way to chain the creation of a request.
/// This is generally accessed as the return value from `surf::{method}()`,
/// however [`Request::builder`](crate::Request::builder) is also provided.
///
/// # Examples
///
/// ```rust
/// use surf::http::{Method, mime::HTML, Url};
/// # #[async_std::main]
/// # async fn main() -&gt; surf::Result&lt;()&gt; {
/// let mut request = surf::post(&quot;https://httpbin.org/post&quot;)
///     .body(&quot;&lt;html&gt;hi&lt;/html&gt;&quot;)
///     .header(&quot;custom-header&quot;, &quot;value&quot;)
///     .content_type(HTML)
///     .build();
///
/// assert_eq!(request.take_body().into_string().await.unwrap(), &quot;&lt;html&gt;hi&lt;/html&gt;&quot;);
/// assert_eq!(request.method(), Method::Post);
/// assert_eq!(request.url(), &amp;Url::parse(&quot;https://httpbin.org/post&quot;)?);
/// assert_eq!(request[&quot;custom-header&quot;], &quot;value&quot;);
/// assert_eq!(request[&quot;content-type&quot;], &quot;text/html;charset=utf-8&quot;);
/// # Ok(())
/// # }
/// ```
///
/// ```rust
/// use surf::http::{Method, Url};
/// # #[async_std::main]
/// # async fn main() -&gt; surf::Result&lt;()&gt; {
/// let url = Url::parse(&quot;https://httpbin.org/post&quot;)?;
/// let request = surf::Request::builder(Method::Post, url).build();
/// # Ok(())
/// # }
/// ```

pub struct RequestBuilder {
    /// Holds the state of the request.
    req: Option&lt;Request&gt;,
    /// Hold an optional Client.
    client: Option&lt;Client&gt;,
    /// Holds the state of the `impl Future`.
    fut: Option&lt;BoxFuture&lt;'static, Result&lt;Response&gt;&gt;&gt;,
}

impl RequestBuilder {
    /// Create a new instance.
    ///
    /// This method is particularly useful when input URLs might be passed by third parties, and
    /// you don't want to panic if they're malformed. If URLs are statically encoded, it might be
    /// easier to use one of the shorthand methods instead.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// use surf::http::{Method, Url};
    ///
    /// let url = Url::parse(&quot;https://httpbin.org/get&quot;)?;
    /// let req = surf::RequestBuilder::new(Method::Get, url).build();
    /// # Ok(()) }
    /// ```
    pub fn new(method: Method, url: Url) -&gt; Self {
        Self {
            req: Some(Request::new(method, url)),
            client: None,
            fut: None,
        }
    }

    pub(crate) fn with_client(mut self, client: Client) -&gt; Self {
        self.client = Some(client);
        self
    }

    /// Sets a header on the request.
    ///
    /// # Examples
    ///
    /// ```
    /// let req = surf::get(&quot;https://httpbin.org/get&quot;).header(&quot;header-name&quot;, &quot;header-value&quot;).build();
    /// assert_eq!(req[&quot;header-name&quot;], &quot;header-value&quot;);
    /// ```
    pub fn header(mut self, key: impl Into&lt;HeaderName&gt;, value: impl ToHeaderValues) -&gt; Self {
        self.req.as_mut().unwrap().insert_header(key, value);
        self
    }

    /// Sets the Content-Type header on the request.
    ///
    /// # Examples
    ///
    /// ```
    /// # use surf::http::mime;
    /// let req = surf::post(&quot;https://httpbin.org/post&quot;).content_type(mime::HTML).build();
    /// assert_eq!(req[&quot;content-type&quot;], &quot;text/html;charset=utf-8&quot;);
    /// ```
    pub fn content_type(mut self, content_type: impl Into&lt;Mime&gt;) -&gt; Self {
        self.req
            .as_mut()
            .unwrap()
            .set_content_type(content_type.into());
        self
    }

    /// Sets the body of the request.
    ///
    /// # Examples
    ///
    /// ```
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// use serde_json::json;
    /// let mut req = surf::post(&quot;https://httpbin.org/post&quot;).body(json!({ &quot;any&quot;: &quot;Into&lt;Body&gt;&quot;})).build();
    /// assert_eq!(req.take_body().into_string().await.unwrap(), &quot;{\&quot;any\&quot;:\&quot;Into&lt;Body&gt;\&quot;}&quot;);
    /// # Ok(())
    /// # }
    /// ```
    pub fn body(mut self, body: impl Into&lt;Body&gt;) -&gt; Self {
        self.req.as_mut().unwrap().set_body(body);
        self
    }

    /// Set the URL querystring.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use serde::{Deserialize, Serialize};
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// #[derive(Serialize, Deserialize)]
    /// struct Index {
    ///     page: u32
    /// }
    ///
    /// let query = Index { page: 2 };
    /// let mut req = surf::get(&quot;https://httpbin.org/get&quot;).query(&amp;query)?.build();
    /// assert_eq!(req.url().query(), Some(&quot;page=2&quot;));
    /// assert_eq!(req.url().as_str(), &quot;https://httpbin.org/get?page=2&quot;);
    /// # Ok(()) }
    /// ```
    pub fn query(mut self, query: &amp;impl Serialize) -&gt; std::result::Result&lt;Self, Error&gt; {
        self.req.as_mut().unwrap().set_query(query)?;

        Ok(self)
    }

    /// Submit the request and get the response body as bytes.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// let bytes = surf::get(&quot;https://httpbin.org/get&quot;).recv_bytes().await?;
    /// assert!(bytes.len() &gt; 0);
    /// # Ok(()) }
    /// ```
    pub async fn recv_bytes(self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        let mut res = self.send().await?;
        Ok(res.body_bytes().await?)
    }

    /// Submit the request and get the response body as a string.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// let string = surf::get(&quot;https://httpbin.org/get&quot;).recv_string().await?;
    /// assert!(string.len() &gt; 0);
    /// # Ok(()) }
    /// ```
    pub async fn recv_string(self) -&gt; Result&lt;String&gt; {
        let mut res = self.send().await?;
        Ok(res.body_string().await?)
    }

    /// Submit the request and decode the response body from json into a struct.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use serde::{Deserialize, Serialize};
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// #[derive(Deserialize, Serialize)]
    /// struct Ip {
    ///     ip: String
    /// }
    ///
    /// let uri = &quot;https://api.ipify.org?format=json&quot;;
    /// let Ip { ip } = surf::get(uri).recv_json().await?;
    /// assert!(ip.len() &gt; 10);
    /// # Ok(()) }
    /// ```
    pub async fn recv_json&lt;T: serde::de::DeserializeOwned&gt;(self) -&gt; Result&lt;T&gt; {
        let mut res = self.send().await?;
        Ok(res.body_json::&lt;T&gt;().await?)
    }

    /// Submit the request and decode the response body from form encoding into a struct.
    ///
    /// # Errors
    ///
    /// Any I/O error encountered while reading the body is immediately returned
    /// as an `Err`.
    ///
    /// If the body cannot be interpreted as valid json for the target type `T`,
    /// an `Err` is returned.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use serde::{Deserialize, Serialize};
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// #[derive(Deserialize, Serialize)]
    /// struct Body {
    ///     apples: u32
    /// }
    ///
    /// let url = &quot;https://api.example.com/v1/response&quot;;
    /// let Body { apples } = surf::get(url).recv_form().await?;
    /// # Ok(()) }
    /// ```
    pub async fn recv_form&lt;T: serde::de::DeserializeOwned&gt;(self) -&gt; Result&lt;T&gt; {
        let mut res = self.send().await?;
        Ok(res.body_form::&lt;T&gt;().await?)
    }
		
  	// 从build函数可以知道最后RequestBuilder是Request的辅助结构体，用来构造返回Request
  	// 这个函数返回的是Request
    /// Return the constructed `Request`.
    pub fn build(self) -&gt; Request {
        self.req.unwrap()
    }

    /// Create a `Client` and send the constructed `Request` from it.
    pub async fn send(mut self) -&gt; Result&lt;Response&gt; {
        self.client
            .take()
            .unwrap_or_else(Client::new_shared_or_panic)
            .send(self.build())
            .await
    }
}
</code></pre></pre>
<p>从build函数可以知道最后RequestBuilder是Request的辅助结构体，用来构造返回Request</p>
<h2><a class="header" href="#reqwest中的建造者设计模式" id="reqwest中的建造者设计模式">Reqwest中的建造者设计模式</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A request which can be executed with `Client::execute()`.
pub struct Request {
    method: Method,
    url: Url,
    headers: HeaderMap,
    body: Option&lt;Body&gt;,
    timeout: Option&lt;Duration&gt;,
}

/// A builder to construct the properties of a `Request`.
///
/// To construct a `RequestBuilder`, refer to the `Client` documentation.
#[must_use = &quot;RequestBuilder does nothing until you 'send' it&quot;]
pub struct RequestBuilder {
    client: Client,
    request: crate::Result&lt;Request&gt;,
}

impl Request {
    /// Constructs a new request.
    #[inline]
    pub fn new(method: Method, url: Url) -&gt; Self {
        Request {
            method,
            url,
            headers: HeaderMap::new(),
            body: None,
            timeout: None
        }
    }

    /// Get the method.
    #[inline]
    pub fn method(&amp;self) -&gt; &amp;Method {
        &amp;self.method
    }

    /// Get a mutable reference to the method.
    #[inline]
    pub fn method_mut(&amp;mut self) -&gt; &amp;mut Method {
        &amp;mut self.method
    }

    /// Get the url.
    #[inline]
    pub fn url(&amp;self) -&gt; &amp;Url {
        &amp;self.url
    }

    /// Get a mutable reference to the url.
    #[inline]
    pub fn url_mut(&amp;mut self) -&gt; &amp;mut Url {
        &amp;mut self.url
    }

    /// Get the headers.
    #[inline]
    pub fn headers(&amp;self) -&gt; &amp;HeaderMap {
        &amp;self.headers
    }

    /// Get a mutable reference to the headers.
    #[inline]
    pub fn headers_mut(&amp;mut self) -&gt; &amp;mut HeaderMap {
        &amp;mut self.headers
    }

    /// Get the body.
    #[inline]
    pub fn body(&amp;self) -&gt; Option&lt;&amp;Body&gt; {
        self.body.as_ref()
    }

    /// Get a mutable reference to the body.
    #[inline]
    pub fn body_mut(&amp;mut self) -&gt; &amp;mut Option&lt;Body&gt; {
        &amp;mut self.body
    }

    /// Get the timeout.
    #[inline]
    pub fn timeout(&amp;self) -&gt; Option&lt;&amp;Duration&gt; {
        self.timeout.as_ref()
    }

    /// Get a mutable reference to the timeout.
    #[inline]
    pub fn timeout_mut(&amp;mut self) -&gt; &amp;mut Option&lt;Duration&gt; {
        &amp;mut self.timeout
    }

    /// Attempt to clone the request.
    ///
    /// `None` is returned if the request can not be cloned, i.e. if the body is a stream.
    pub fn try_clone(&amp;self) -&gt; Option&lt;Request&gt; {
        let body = match self.body.as_ref() {
            Some(ref body) =&gt; Some(body.try_clone()?),
            None =&gt; None,
        };
        let mut req = Request::new(self.method().clone(), self.url().clone());
        *req.timeout_mut() = self.timeout().cloned();
        *req.headers_mut() = self.headers().clone();
        req.body = body;
        Some(req)
    }

    pub(super) fn pieces(self) -&gt; (Method, Url, HeaderMap, Option&lt;Body&gt;, Option&lt;Duration&gt;) {
        (self.method, self.url, self.headers, self.body, self.timeout)
    }
}

impl RequestBuilder {
    pub(super) fn new(client: Client, request: crate::Result&lt;Request&gt;) -&gt; RequestBuilder {
        let mut builder = RequestBuilder { client, request };

        let auth = builder
            .request
            .as_mut()
            .ok()
            .and_then(|req| extract_authority(&amp;mut req.url));

        if let Some((username, password)) = auth {
            builder.basic_auth(username, password)
        } else {
            builder
        }
    }

    /// Add a `Header` to this Request.
    pub fn header&lt;K, V&gt;(self, key: K, value: V) -&gt; RequestBuilder
    where
        HeaderName: TryFrom&lt;K&gt;,
        &lt;HeaderName as TryFrom&lt;K&gt;&gt;::Error: Into&lt;http::Error&gt;,
        HeaderValue: TryFrom&lt;V&gt;,
        &lt;HeaderValue as TryFrom&lt;V&gt;&gt;::Error: Into&lt;http::Error&gt;, 
    {
        self.header_sensitive(key, value, false)
    }

    /// Add a `Header` to this Request with ability to define if header_value is sensitive.
    fn header_sensitive&lt;K, V&gt;(mut self, key: K, value: V, sensitive: bool) -&gt; RequestBuilder
    where
        HeaderName: TryFrom&lt;K&gt;,
        &lt;HeaderName as TryFrom&lt;K&gt;&gt;::Error: Into&lt;http::Error&gt;,
        HeaderValue: TryFrom&lt;V&gt;,
        &lt;HeaderValue as TryFrom&lt;V&gt;&gt;::Error: Into&lt;http::Error&gt;,
    {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            match &lt;HeaderName as TryFrom&lt;K&gt;&gt;::try_from(key) {
                Ok(key) =&gt; match &lt;HeaderValue as TryFrom&lt;V&gt;&gt;::try_from(value) {
                    Ok(mut value) =&gt; {
                        value.set_sensitive(sensitive);
                        req.headers_mut().append(key, value);
                    }
                    Err(e) =&gt; error = Some(crate::error::builder(e.into())),
                },
                Err(e) =&gt; error = Some(crate::error::builder(e.into())),
            };
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Add a set of Headers to the existing ones on this Request.
    ///
    /// The headers will be merged in to any already set.
    pub fn headers(mut self, headers: crate::header::HeaderMap) -&gt; RequestBuilder {
        if let Ok(ref mut req) = self.request {
            crate::util::replace_headers(req.headers_mut(), headers);
        }
        self
    }

    /// Enable HTTP basic authentication.
    pub fn basic_auth&lt;U, P&gt;(self, username: U, password: Option&lt;P&gt;) -&gt; RequestBuilder
    where
        U: fmt::Display,
        P: fmt::Display,
    {
        let mut header_value = b&quot;Basic &quot;.to_vec();
        {
            let mut encoder = Base64Encoder::new(&amp;mut header_value, base64::STANDARD);
            // The unwraps here are fine because Vec::write* is infallible.
            write!(encoder, &quot;{}:&quot;, username).unwrap();
            if let Some(password) = password {
                write!(encoder, &quot;{}&quot;, password).unwrap();
            }
        }

        self.header_sensitive(crate::header::AUTHORIZATION, header_value, true)
    }

    /// Enable HTTP bearer authentication.
    pub fn bearer_auth&lt;T&gt;(self, token: T) -&gt; RequestBuilder
    where
        T: fmt::Display,
    {
        let header_value = format!(&quot;Bearer {}&quot;, token);
        self.header_sensitive(crate::header::AUTHORIZATION, header_value, true)
    }

    /// Set the request body.
    pub fn body&lt;T: Into&lt;Body&gt;&gt;(mut self, body: T) -&gt; RequestBuilder {
        if let Ok(ref mut req) = self.request {
            *req.body_mut() = Some(body.into());
        }
        self
    }

    /// Enables a request timeout.
    ///
    /// The timeout is applied from when the request starts connecting until the
    /// response body has finished. It affects only this request and overrides
    /// the timeout configured using `ClientBuilder::timeout()`.
    pub fn timeout(mut self, timeout: Duration) -&gt; RequestBuilder {
        if let Ok(ref mut req) = self.request {
            *req.timeout_mut() = Some(timeout);
        }
        self
    }

    /// Sends a multipart/form-data body.
    ///
    /// ```
    /// # use reqwest::Error;
    ///
    /// # async fn run() -&gt; Result&lt;(), Error&gt; {
    /// let client = reqwest::Client::new();
    /// let form = reqwest::multipart::Form::new()
    ///     .text(&quot;key3&quot;, &quot;value3&quot;)
    ///     .text(&quot;key4&quot;, &quot;value4&quot;);
    ///
    ///
    /// let response = client.post(&quot;your url&quot;)
    ///     .multipart(form)
    ///     .send()
    ///     .await?;
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = &quot;multipart&quot;)]
    pub fn multipart(self, mut multipart: multipart::Form) -&gt; RequestBuilder {
        let mut builder = self.header(
            CONTENT_TYPE,
            format!(&quot;multipart/form-data; boundary={}&quot;, multipart.boundary()).as_str(),
        );

        builder = match multipart.compute_length() {
            Some(length) =&gt; builder.header(CONTENT_LENGTH, length),
            None =&gt; builder,
        };

        if let Ok(ref mut req) = builder.request {
            *req.body_mut() = Some(multipart.stream())
        }
        builder
    }

    /// Modify the query string of the URL.
    ///
    /// Modifies the URL of this request, adding the parameters provided.
    /// This method appends and does not overwrite. This means that it can
    /// be called multiple times and that existing query parameters are not
    /// overwritten if the same key is used. The key will simply show up
    /// twice in the query string.
    /// Calling `.query([(&quot;foo&quot;, &quot;a&quot;), (&quot;foo&quot;, &quot;b&quot;)])` gives `&quot;foo=a&amp;foo=b&quot;`.
    ///
    /// # Note
    /// This method does not support serializing a single key-value
    /// pair. Instead of using `.query((&quot;key&quot;, &quot;val&quot;))`, use a sequence, such
    /// as `.query(&amp;[(&quot;key&quot;, &quot;val&quot;)])`. It's also possible to serialize structs
    /// and maps into a key-value pair.
    ///
    /// # Errors
    /// This method will fail if the object you provide cannot be serialized
    /// into a query string.
    pub fn query&lt;T: Serialize + ?Sized&gt;(mut self, query: &amp;T) -&gt; RequestBuilder {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            let url = req.url_mut();
            let mut pairs = url.query_pairs_mut();
            let serializer = serde_urlencoded::Serializer::new(&amp;mut pairs);

            if let Err(err) = query.serialize(serializer) {
                error = Some(crate::error::builder(err));
            }
        }
        if let Ok(ref mut req) = self.request {
            if let Some(&quot;&quot;) = req.url().query() {
                req.url_mut().set_query(None);
            }
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Send a form body.
    pub fn form&lt;T: Serialize + ?Sized&gt;(mut self, form: &amp;T) -&gt; RequestBuilder {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            match serde_urlencoded::to_string(form) {
                Ok(body) =&gt; {
                    req.headers_mut().insert(
                        CONTENT_TYPE,
                        HeaderValue::from_static(&quot;application/x-www-form-urlencoded&quot;),
                    );
                    *req.body_mut() = Some(body.into());
                }
                Err(err) =&gt; error = Some(crate::error::builder(err)),
            }
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Send a JSON body.
    ///
    /// # Optional
    ///
    /// This requires the optional `json` feature enabled.
    ///
    /// # Errors
    ///
    /// Serialization can fail if `T`'s implementation of `Serialize` decides to
    /// fail, or if `T` contains a map with non-string keys.
    #[cfg(feature = &quot;json&quot;)]
    pub fn json&lt;T: Serialize + ?Sized&gt;(mut self, json: &amp;T) -&gt; RequestBuilder {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            match serde_json::to_vec(json) {
                Ok(body) =&gt; {
                    req.headers_mut()
                        .insert(CONTENT_TYPE, HeaderValue::from_static(&quot;application/json&quot;));
                    *req.body_mut() = Some(body.into());
                }
                Err(err) =&gt; error = Some(crate::error::builder(err)),
            }
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Disable CORS on fetching the request.
    ///
    /// # WASM
    ///
    /// This option is only effective with WebAssembly target.
    ///
    /// The [request mode][mdn] will be set to 'no-cors'.
    ///
    /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/Request/mode
    pub fn fetch_mode_no_cors(self) -&gt; RequestBuilder {
        self
    }
  
 
		// 从RequestBuilder的build函数可以知道，RequestBuilder是用来帮助构造Request的辅助结构体
    /// Build a `Request`, which can be inspected, modified and executed with
    /// `Client::execute()`.
    pub fn build(self) -&gt; crate::Result&lt;Request&gt; {
        self.request
    }

    /// Constructs the Request and sends it to the target URL, returning a
    /// future Response.
    ///
    /// # Errors
    ///
    /// This method fails if there was an error while sending request,
    /// redirect loop was detected or redirect limit was exhausted.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use reqwest::Error;
    /// #
    /// # async fn run() -&gt; Result&lt;(), Error&gt; {
    /// let response = reqwest::Client::new()
    ///     .get(&quot;https://hyper.rs&quot;)
    ///     .send()
    ///     .await?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn send(self) -&gt; impl Future&lt;Output = Result&lt;Response, crate::Error&gt;&gt; {
        match self.request {
            Ok(req) =&gt; self.client.execute_request(req),
            Err(err) =&gt; Pending::new_err(err),
        }
    }

    /// Attempt to clone the RequestBuilder.
    ///
    /// `None` is returned if the RequestBuilder can not be cloned,
    /// i.e. if the request body is a stream.
    ///
    /// # Examples
    ///
    /// ```
    /// # use reqwest::Error;
    /// #
    /// # fn run() -&gt; Result&lt;(), Error&gt; {
    /// let client = reqwest::Client::new();
    /// let builder = client.post(&quot;http://httpbin.org/post&quot;)
    ///     .body(&quot;from a &amp;str!&quot;);
    /// let clone = builder.try_clone();
    /// assert!(clone.is_some());
    /// # Ok(())
    /// # }
    /// ```
    pub fn try_clone(&amp;self) -&gt; Option&lt;RequestBuilder&gt; {
        self.request
            .as_ref()
            .ok()
            .and_then(|req| req.try_clone())
            .map(|req| RequestBuilder {
                client: self.client.clone(),
                request: Ok(req),
            })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>从RequestBuilder的build函数可以知道，RequestBuilder是用来帮助构造Request的辅助结构体。</p>
<p>参考链接：</p>
<p>https://docs.rs/tokio/1.1.0/tokio/runtime/struct.Builder.html</p>
<p>https://docs.rs/reqwest/0.11.0/src/reqwest/async_impl/request.rs.html#36-39</p>
<p>https://github.com/http-rs/surf/blob/31315743b91ff003231183c1ec5a3cd2b698c58a/src/request_builder.rs</p>
<p>https://docs.rs/futures/0.3.12/futures/executor/struct.ThreadPoolBuilder.html</p>
<h1><a class="header" href="#关于-io_uring-与-rust-的思考" id="关于-io_uring-与-rust-的思考">关于 io_uring 与 Rust 的思考</a></h1>
<p>作者：王徐旸 </p>
<hr />
<p>io_uring 是 Linux 5.x 时代加入的一套全新的异步机制，被钦定为 Linux 异步的未来。</p>
<p>本文将探讨在 Rust 中安全封装 io_uring 的一系列设计问题，并提出一些可能的解决方案。</p>
<h2><a class="header" href="#io_uring-的工作方式" id="io_uring-的工作方式">io_uring 的工作方式</a></h2>
<p>io_uring 分为两个队列，提交队列 SQ (Submission Queue) 和完成队列 CQ (Completion Queue)。提交队列存放正在等待执行的异步任务，完成队列存放完成事件。</p>
<p>io_uring 的结构由内核分配，用户态通过 mmap 拿到相关结构的内存访问权限，这样就能让内核态与用户态共享内存，绕过系统调用双向传递数据。</p>
<p>概念工作流程具有三个阶段</p>
<ol>
<li>准备：应用程序获取一些提交队列项 SQE (Submission Queue Entry)，将每个异步任务分别设置到每个 SQE 中，用操作码、参数初始化。</li>
<li>提交：应用程序向 SQ 中推入一些需要提交的 SQE，通过一次系统调用告诉内核有新的任务，或者让内核不停轮询来获取任务。</li>
<li>收割：应用程序从 CQ 中取得一些完成队列事件 CQE (Completion Queue Event)，通过 user_data 识别并唤醒应用程序中的线程/协程，传递返回值。</li>
</ol>
<p>epoll 是 Reactor 模型的实现，而 io_uring 是 Proactor 模型的实现。</p>
<p>这意味着基于 epoll 设计的程序难以直接迁移到 io_uring。</p>
<p><strong>问题 1</strong>: 改变异步模型并不是一件容易的事，除非以部分性能为代价抹平差异。</p>
<p><strong>问题 2</strong>: io_uring 需要较高版本的内核，现阶段，应用程序不得不考虑在没有 io_uring 高版本特性时要怎么回退 (fallback)。</p>
<h2><a class="header" href="#io_uring-的约束" id="io_uring-的约束">io_uring 的约束</a></h2>
<p>在阻塞同步模型和非阻塞同步模型(如 epoll)中，用户态 IO 操作是一锤子买卖，无需担心生存期。</p>
<p>但 io_uring 是 Proactor，是非阻塞异步模型，对资源的生存期有所约束。</p>
<p>以 read 为例，它有 fd 和 buf 两个资源参数，当准备 IO 操作时，我们需要把 fd、buf 指针和 count 填入 SQE，并且<strong>保证在内核完成或取消该任务之前，fd 和 buf 都必须有效</strong>。</p>
<h3><a class="header" href="#fd-意外替换" id="fd-意外替换">fd 意外替换</a></h3>
<pre><code class="language-c">fd = 6, buf = 0x5678;
准备 SQE;
close fd = 6;
open -&gt; fd = 6;
提交 SQE;
内核执行 IO;
</code></pre>
<p>在提交 SQE 之前，应用程序“不小心”关闭又打开了文件，这将导致 IO 操作意外地被执行到一个完全无关的文件上。</p>
<h3><a class="header" href="#栈内存-uaf" id="栈内存-uaf">栈内存 UAF</a></h3>
<pre><code class="language-c">char stack_buf[1024];
fd = 6, buf = &amp;stack_buf;
准备 SQE;
提交 SQE;
函数返回;
内核执行 IO;
</code></pre>
<p>内核执行的 IO 会操作已被释放的栈上内存，出现“释放后使用”(use-after-free) 漏洞。</p>
<h3><a class="header" href="#堆内存-uaf" id="堆内存-uaf">堆内存 UAF</a></h3>
<pre><code class="language-c">char* heap_buf = malloc(1024);
fd = 6, buf = heap_buf;
准备 SQE;
提交 SQE;
执行其他代码出错;
free(heap_buf);
函数返回错误码;
内核执行 IO;
</code></pre>
<p>内核执行的 IO 会使用已被释放的堆上内存，又一个 UAF 漏洞。</p>
<h3><a class="header" href="#移动后使用" id="移动后使用">移动后使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Buf&lt;T&gt;(T);
let mut buf1: Buf&lt;[u8;1024]&gt; = Buf([0;1024]);
fd = 6, buf = buf1.0.as_mut_ptr();
unsafe {
    准备 SQE;
}
提交 SQE;
let buf2 = Box::new(buf1);
内核执行 IO;
<span class="boring">}
</span></code></pre></pre>
<p>当内核执行 IO 时，buf1 已被移动，指针失效。出现“移动后使用”的漏洞，本文称为 UAM 漏洞。</p>
<h3><a class="header" href="#取消后使用" id="取消后使用">取消后使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() -&gt; io::Result&lt;()&gt; {
    let mut buf1: [u8;1024] = [0;1024];
    fd = 6, buf = buf1.as_mut_ptr();
    unsafe {
        准备 SQE;
    }
    提交 SQE;
    bar().await
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 的 async 函数会生成无栈协程，栈变量保存在一个结构体中。如果这个结构体被析构，底层的叶 Future 就会被析构，同时取消异步操作。</p>
<p>然而析构函数是同步的，<strong>当协程析构时，内核仍然可能正在占用缓冲区来执行 IO</strong>。如果不做处理，就会出现 UAF 漏洞。</p>
<h3><a class="header" href="#关闭后使用" id="关闭后使用">关闭后使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>准备 SQE;
提交 SQE;
io_uring_queue_exit(&amp;ring)
???
<span class="boring">}
</span></code></pre></pre>
<p>内核在 io_uring_queue_exit 之后会立即取消正在执行的 IO 吗？</p>
<p>// TODO: 找到答案</p>
<p>如果会立即取消，那么用户态程序也无法得到取消事件，无法唤醒任务或释放资源。</p>
<p>如果不会立即取消，那么内核对资源的占用会超出 io_uring 实例的生存期，带来更加麻烦的问题。</p>
<p>这似乎说明 io_uring 实例必须为 static 生存期，与线程本身活得一样长。或者采取某种引用计数的方式，推迟 exit 时机。</p>
<h2><a class="header" href="#具有-rust-特色的-io_uring" id="具有-rust-特色的-io_uring">具有 Rust 特色的 io_uring</a></h2>
<p>Rust 的底线是内存安全，不允许出现内存安全漏洞或数据竞争。Rust 的所有权规则为此提供了很好的保障。</p>
<h3><a class="header" href="#迁移所有权" id="迁移所有权">迁移所有权</a></h3>
<p>“迁移所有权” 是本文中自行创造的概念，它表示要进行某个操作就必须放弃对参数的所有权，把参数的所有权“迁移”到其他地方。</p>
<p>当使用 io_uring 时，相当于内核持有资源的所有权。用户态必须放弃对资源的控制权，除非它可以安全地并发操作。IO 操作完成或取消时，内核占用的所有资源会被返还给用户态。</p>
<p>但内核不可能真的去持有所有权，实际上是由异步运行时来存储这些资源，并模拟出“迁移所有权”的模型。</p>
<p><code>BufRead</code> trait 表示一个包含内部缓冲区的可读取类型。<code>BufReader&lt;File&gt;</code> 是一个典型用法。</p>
<p><code>BufReader&lt;File&gt;</code> 可以匹配 io_uring 的工作模式。</p>
<pre><code>准备 fd, buf
准备 SQE
提交 SQE
等待唤醒
拿到返回值
回收 fd, buf
暴露 buf 的共享引用
</code></pre>
<p><strong>问题 3</strong>: 当 Future 被取消时，buf 仍然被内核占用，<code>BufReader&lt;File&gt;</code> 处于无效状态。再次进行 IO 时，它只能选择死亡。</p>
<p>想象这样一个底层 Future</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Read&lt;F, B&gt;
where
    F: AsRawFd + 'static,
    B: AsMut&lt;[u8]&gt; + 'static,
{
    fd: F,
    buf: B,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>buf 可以是 <code>[u8; N]</code>，也满足 <code>AsMut&lt;[u8]&gt; + 'static</code>，但它不能被取指针传递给 io_uring。</p>
<p>buf 在这个 Future 被析构时失效，不满足 io_uring 的约束。</p>
<p>修复方案有两种：在准备 SQE 之前就把 fd 和 buf 都移动到堆上，或者限制 buf 为可安全逃逸的缓冲区类型。</p>
<h3><a class="header" href="#堆分配" id="堆分配">堆分配</a></h3>
<p>如果要在准备 SQE 之前确保 fd 和 buf 不会被析构，只能堆分配了。</p>
<p>这样 fd 和 buf 在 IO 操作完成或取消之前就不会被移动或析构，保证了有效性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Read&lt;F, B&gt;
where
    F: AsRawFd + 'static,
    B: AsMut&lt;[u8]&gt; + 'static,
{
    state: ManualDrop&lt;Box&lt;State&lt;F, B&gt;&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>然而，大部分时候 buf 都是指向堆上动态大小缓冲区的智能指针，为指针本身去堆分配是不太值得的，要提高效率必须以某种方式实现自定义分配器。</p>
<h3><a class="header" href="#逃逸" id="逃逸">逃逸</a></h3>
<p>通常的“逃逸分析”是分析对象的动态范围，如果对象有可能离开函数作用域，就把它分配到堆上。</p>
<p>本文提出的“逃逸”是指让结构体成员逃脱析构，转移到一个稳定的地方。</p>
<p>可安全逃逸的缓冲区类型在移动时不会改变缓冲区的内存地址。</p>
<p><code>[u8;N]</code> 在移动时完全改变了缓冲区的地址范围，而 <code>Box&lt;[u8]&gt;</code> 和 <code>Vec&lt;u8&gt;</code> 不会改变。</p>
<p><code>SmallVec&lt;[u8;N]&gt;</code> 在容量不大于 N 时会把数据存储在栈上，过大时存储在堆上。</p>
<p><code>Box&lt;[u8]&gt;</code> 和 <code>Vec&lt;u8&gt;</code> 作为缓冲区可以安全逃逸，<code>[u8;N]</code> 和 <code>SmallVec&lt;[u8;N]&gt;</code> 不可以。</p>
<p>如果限制 buf 为可安全逃逸的缓冲区类型，那么在最理想的情况下，进行 IO 操作时不需要系统调用，不需要额外的堆分配，缓冲区由调用者控制，几乎完美。</p>
<p><strong>问题 4</strong>: 如何在不传染 unsafe 的情况下表达这种约束？</p>
<p>定义一个 unsafe trait 自然省事，但无法对所有符合条件的缓冲区通用，还可能受孤儿规则影响，让用户必须去写 newtype 或 unsafe。</p>
<p>可以意识到，这里的“安全逃逸”和 <code>Pin</code> 的概念有某种相关，有没有办法联系起来？</p>
<h3><a class="header" href="#send" id="send">Send</a></h3>
<p>io_uring 的收割可以由本线程做，也可以由一个专门的驱动线程做。</p>
<p>目前 SQ 不支持多线程提交，全局共享需要上锁。io_uring 更匹配每个线程自带一个 ring 的实现。</p>
<p>考虑这样一个 Future，当它析构时，里面的资源会逃逸到堆上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Read&lt;F, B&gt;
where
    F: AsRawFd + 'static,
    B: EscapedBufMut + 'static,
{
    fd: F,
    buf: B,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>如果由全局驱动线程做最终析构，那么资源就会从当前线程转移到驱动线程，这需要资源满足 Send。</p>
<p>如果由本线程做最终析构，那么资源不需要转移，可以不满足 Send。</p>
<p><strong>问题 5</strong>: 收割和析构策略也会影响 API 的泛型约束，如何设计合适的 API？</p>
<h3><a class="header" href="#拷贝" id="拷贝">拷贝</a></h3>
<p>缓冲区必须能在 Future 析构之后保持有效，这意味着我们无法把临时的 <code>&amp;mut [u8]</code> 或 <code>&amp;[u8]</code> 传入 io_uring，无法做原地读取或写入。</p>
<p>而 epoll 可以等待 fd 可读或可写后，再原地读取或写入。</p>
<p>无论如何，把缓冲区放在堆上这一步是不可避免的，区别在于缓冲区是由异步类型本身来控制还是由调用者来控制。</p>
<p>让调用者来控制缓冲区，能避免额外拷贝，但会加大安全审查的难度，必须限制传入的缓冲区具有良好的行为。</p>
<p>异步类型内置缓冲区，会增加额外拷贝，但安全性由库的作者保证，减小了出现漏洞的可能性。</p>
<p><strong>问题6</strong>: io_uring 加大了实现用户态零拷贝的难度。</p>
<h2><a class="header" href="#生态" id="生态">生态</a></h2>
<p><a href="https://github.com/ringbahn/uring-sys">uring-sys</a>： liburing 的绑定。</p>
<p><a href="https://github.com/ringbahn/iou">iou</a>：Rust 风格的低层 io_uring 接口。</p>
<p><a href="https://github.com/ringbahn/ringbahn">ringbahn</a>：实验性的 io_uring 高层封装</p>
<p><a href="https://github.com/ringbahn/maglev">maglev</a>：实验性的 io_uring 异步驱动/运行时</p>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<p>划个重点</p>
<p><strong>问题 1</strong>: epoll 是 Reactor 模型的实现，而 io_uring 是 Proactor 模型的实现。改变异步模型并不是一件容易的事，除非以性能为代价抹平差异。</p>
<p><strong>问题 2</strong>: io_uring 需要较高版本的内核，现阶段，应用程序不得不考虑在没有 io_uring 高版本特性时要怎么回退 (fallback)。</p>
<p><strong>问题 3</strong>: 当 Future 被取消时，buf 仍然被内核占用，异步类型可能处于无效状态。再次进行 IO 时，它只能选择死亡。</p>
<p><strong>问题 4</strong>: 如果选择限制 buf 为可安全逃逸的缓冲区类型，如何在不传染 unsafe 的情况下表达这种约束？</p>
<p><strong>问题 5</strong>: 收割和析构策略也会影响 API 的泛型约束，如何设计合适的 API？</p>
<p><strong>问题 6</strong>: io_uring 加大了实现用户态零拷贝的难度。</p>
<p>如果不考虑最高性能，我们有各种方案来封装一个能用的 io_uring 库。</p>
<p>如果不考虑通用，我们可以在自己的程序中谨慎地用 io_uring，锁死类型。</p>
<p>Rust 对安全、性能、通用的追求给封装 io_uring 带来了较高的难度。</p>
<p><a href="https://github.com/ringbahn/ringbahn">ringbahn</a> 的设计思路是其中一种可能的方向。社区还需要探索什么才是最完美的设计。</p>
<h2><a class="header" href="#扩展阅读" id="扩展阅读">扩展阅读</a></h2>
<p><a href="http://kernel.dk/io_uring.pdf">Efficient IO with io_uring</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/62682475">AIO 的新归宿：io_uring</a></p>
<p><a href="http://icebergu.com/archives/go-iouring">Go 与异步 IO - io_uring 的思考</a></p>
<p><a href="https://without.boats/blog/io-uring/">Notes on io-uring</a></p>
<p><a href="https://without.boats/blog/ringbahn/">Ringbahn: a safe, ergonomic API for io-uring in Rust</a></p>
<p><a href="https://without.boats/blog/ringbahn-ii/">Ringbahn II: the central state machine</a></p>
<p><a href="https://without.boats/blog/ringbahn-iii/">Ringbahn III: A deeper dive into drivers</a></p>
<p><a href="https://github.com/axboe/liburing/issues/109">feature requests: submit requests from any thread</a></p>
<hr />
<p>本文首发于知乎专栏 「<a href="https://zhuanlan.zhihu.com/p/346219893">Rust 日常</a>」</p>
<p>作者简介：</p>
<p>王徐旸，大三学生，2018 年开始学习和使用 Rust 语言，造轮子爱好者。</p>
<p>GitHub ID: <a href="https://github.com/Nugine">Nugine</a></p>
<h1><a class="header" href="#学习园地--译-graphql-in-rust" id="学习园地--译-graphql-in-rust">学习园地 | 「译」 GraphQL in Rust</a></h1>
<h2><a class="header" href="#译者序" id="译者序">译者序</a></h2>
<p>Roman Kudryashov(<a href="https://romankudryashov.com">博客</a>)是一名来自莫斯科的资深后端开发人员，在日常工作中用Rust/Java/Kotlin来完成服务的持久层，微服务之间的集成等工作。在<code>Async-graphql</code>的开发过程中给予了非常多的<a href="https://github.com/async-graphql/async-graphql/issues?q=is%3Aissue+author%3Arkudryashov">帮助</a>，然后根据这些经验总结出来这篇入门教程（<a href="https://romankudryashov.com/blog/2020/12/graphql-rust/">英文原版</a>）。</p>
<p>译者老油条（<a href="https://github.com/sunli829">孙黎</a>），<code>Async-graphql</code>库作者，连续创业者，处女座码农，之前日常工作由C++和Golang完成，两年前一个偶然的机会邂逅Rust语言，并不由自主的爱上了它，之后再也没有碰过其它编程语言，工作中用Rust语言完成所有的事情，是不折不扣的Rust语言狂热粉丝。Rust是我这么多年编程生涯中真正遇到的完美编程语言，无GC，并发安全以及类似Python等脚本语言才提供的高级语法，让我产生给它做一些力所能及的贡献的想法，<a href="https://github.com/sunli829/nvg">nvg</a>和<a href="https://github.com/sunli829/xactor">Xactor</a>是刚学Rust不久之后的小试牛刀，而<a href="https://github.com/async-graphql/async-graphql">Async-graphql</a>是Rust 1.39异步稳定之后的产物。</p>
<p><em>学习Rust的过程很艰辛，需要保持一颗修行的心，当你能够越过那一座座阻碍在面前的高山，也许才能够发现它真正的美好。</em></p>
<h2><a class="header" href="#目录" id="目录">目录</a></h2>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AD%A6%E4%B9%A0%E5%9B%AD%E5%9C%B0--%E8%AF%91-graphql-in-rust">学习园地 | 「译」 GraphQL in Rust</a>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%AF%91%E8%80%85%E5%BA%8F">译者序</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E4%BB%8B%E7%BB%8D">介绍</a>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%A6%82%E8%A7%88">概览</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%8A%80%E6%9C%AF%E6%A0%88">技术栈</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E4%BE%9D%E8%B5%96%E5%BA%93">依赖库</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD">核心功能</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">查询和类型定义</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%A7%A3%E5%86%B3n1%E9%97%AE%E9%A2%98">解决N+1问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89">接口定义</a>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%87%8F">自定义标量</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AE%9A%E4%B9%89%E5%8F%98%E6%9B%B4mutation">定义变更(Mutation)</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AE%9A%E4%B9%89%E8%AE%A2%E9%98%85subscription">定义订阅(Subscription)</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#graphql%E5%AE%A2%E6%88%B7%E7%AB%AF">GraphQL客户端</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#api%E5%AE%89%E5%85%A8">API安全</a>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%A4%8D%E6%9D%82%E5%BA%A6">限制查询的深度和复杂度</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%AE%A4%E8%AF%81">认证</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E9%89%B4%E6%9D%83">鉴权</a></li>
</ul>
</li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE">定义枚举</a>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86">日期处理</a></li>
</ul>
</li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%94%AF%E6%8C%81apollofederation">支持ApolloFederation</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#apolloserver">ApolloServer</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92">数据库交互</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%BF%90%E8%A1%8C%E5%92%8Capi%E6%B5%8B%E8%AF%95">运行和API测试</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%AE%A2%E9%98%85%E6%B5%8B%E8%AF%95">订阅测试</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#cicd">CI/CD</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E7%BB%93%E8%AE%BA">结论</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5">有用的链接</a></li>
</ul>
</li>
</ul>
<p>在今天的文章中，我将描述如何使用Rust及其生态系统创建GraphQL后端服务。 本文提供了创建GraphQL API时最常见任务的实现示例。最后，将使用Apollo Server和Apollo Federation将三个微服务组合为一个端点。 这使客户端可以同时从任意数量的源中获取数据，而无需知道哪些数据来自哪个源。</p>
<h2><a class="header" href="#介绍" id="介绍">介绍</a></h2>
<h3><a class="header" href="#概览" id="概览">概览</a></h3>
<p>在功能方面，所描述的项目与我上一篇文章中所描述的非常相似，但是现在它是使用Rust编写的。 该项目的架构如下所示：</p>
<p><img src="chapter_1/graphql_in_rust/architecture.png" alt="architecture" /></p>
<p>架构的每个组件都回答了在实现GraphQL API时可能出现的几个问题。整个模型包括有关太阳系中的行星及其卫星的数据。该项目具有多模块结构，并包含以下模块：</p>
<ul>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/planets-service">planets-service</a> (Rust)</p>
</li>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/satellites-service">satellites-service</a> (Rust)</p>
</li>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/auth-service">auth-service</a> (Rust)</p>
</li>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/apollo-server">apollo-server</a> (JS)</p>
</li>
</ul>
<p>在Rust中有两个库来创建GraphQL后端：<a href="https://github.com/graphql-rust/juniper">Juniper</a>和<a href="https://github.com/async-graphql/async-graphql">Async-graphql</a>，但是只有后者支持Apollo Federation，因此我在项目中选择了它（Juniper中的Federation支持存在未解决的<a href="https://github.com/graphql-rust/juniper/issues/376">问题</a>）。 这两个库都遵循<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/">代码优先</a>方法。</p>
<p>同样，PostgreSQL用于持久层实现，<a href="https://jwt.io/">JWT</a>用于认证，而Kafka用于消息传递。</p>
<h3><a class="header" href="#技术栈" id="技术栈">技术栈</a></h3>
<p>下表总结了该项目中使用的主要技术栈：</p>
<table><thead><tr><th>类型</th><th>名字</th><th>网站</th><th>代码仓库</th></tr></thead><tbody>
<tr><td>语言</td><td>Rust</td><td><a href="https://www.rust-lang.org/">link</a></td><td><a href="https://github.com/rust-lang/rust">link</a></td></tr>
<tr><td>GraphQL服务端库</td><td>Async-graphql</td><td><a href="https://async-graphql.github.io/async-graphql/zh-CN/index.html">link</a></td><td><a href="https://github.com/async-graphql/async-graphql">link</a></td></tr>
<tr><td>GraphQL网关</td><td>Apollo Server</td><td><a href="https://www.apollographql.com/docs/apollo-server/">link</a></td><td><a href="https://github.com/apollographql/apollo-server">link</a></td></tr>
<tr><td>Web框架</td><td>Actix-web</td><td><a href="https://actix.rs/">link</a></td><td><a href="https://github.com/actix/actix-web">link</a></td></tr>
<tr><td>数据库</td><td>PostgreSQL</td><td><a href="https://www.postgresql.org/">link</a></td><td><a href="https://github.com/postgres/postgres">link</a></td></tr>
<tr><td>消息队列</td><td>Apache Kafka</td><td><a href="https://kafka.apache.org/">link</a></td><td><a href="https://github.com/apache/kafka">link</a></td></tr>
<tr><td>容器编排</td><td>Docker Compose</td><td><a href="https://docs.docker.com/compose/">link</a></td><td><a href="https://github.com/docker/compose">link</a></td></tr>
</tbody></table>
<p>另外还有一些需要依赖的Rust库:</p>
<table><thead><tr><th>类型</th><th>名字</th><th>网站</th><th>代码仓库</th></tr></thead><tbody>
<tr><td>ORM</td><td>Diesel</td><td><a href="https://diesel.rs/">link</a></td><td><a href="https://github.com/diesel-rs/diesel">link</a></td></tr>
<tr><td>Kafka客户端</td><td>rust-rdkafka</td><td><a href="https://crates.io/crates/rdkafka">link</a></td><td><a href="https://github.com/fede1024/rust-rdkafka">link</a></td></tr>
<tr><td>密码哈希库</td><td>argonautica</td><td><a href="https://crates.io/crates/argonautica">link</a></td><td><a href="https://github.com/bcmyers/argonautica">link</a></td></tr>
<tr><td>JWT</td><td>jsonwebtoken</td><td><a href="https://crates.io/crates/jsonwebtoken">link</a></td><td><a href="https://github.com/Keats/jsonwebtoken">link</a></td></tr>
<tr><td>测试</td><td>Testcontainers-rs</td><td><a href="https://crates.io/crates/testcontainers">link</a></td><td><a href="https://github.com/testcontainers/testcontainers-rs">link</a></td></tr>
</tbody></table>
<h3><a class="header" href="#开发工具" id="开发工具">开发工具</a></h3>
<p>要在本地启动项目，你只需要<code>Docker Compose</code>。 如果没有<code>Docker</code>，可能需要安装以下内容：</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust</a></li>
<li><a href="https://diesel.rs/guides/getting-started/">Diesel CLI</a> (运行 <code>cargo install diesel_cli --no-default-features --features postgres</code>)</li>
<li><a href="https://releases.llvm.org/download.html">LLVM</a>(<code>argonautica</code>依赖)</li>
<li><a href="https://cmake.org/install/">CMake</a> (<code>rust-rdkafka</code>依赖)</li>
<li><a href="https://www.postgresql.org/download/">PostgreSQL</a></li>
<li><a href="https://kafka.apache.org/quickstart">Apache Kafka</a></li>
<li><a href="https://www.npmjs.com/get-npm">npm</a></li>
</ul>
<h3><a class="header" href="#实现" id="实现">实现</a></h3>
<p><em>清单1. 根<code>Cargo.toml</code>指定三个应用和一个库:</em></p>
<p>根<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/Cargo.toml">Cargo.toml</a></p>
<pre><code class="language-toml">[workspace]
members = [
    &quot;auth-service&quot;,
    &quot;planets-service&quot;,
    &quot;satellites-service&quot;,
    &quot;common-utils&quot;,
]
</code></pre>
<p>让我们从<a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/planets-service">planets-service</a>开始。</p>
<h3><a class="header" href="#依赖库" id="依赖库">依赖库</a></h3>
<p>这是Cargo.toml：</p>
<p><em>清单2. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/Cargo.toml">Cargo.toml</a></em></p>
<pre><code class="language-toml">[package]
name = &quot;planets-service&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
common-utils = { path = &quot;../common-utils&quot; }
async-graphql = &quot;2.4.3&quot;
async-graphql-actix-web = &quot;2.4.3&quot;
actix-web = &quot;3.3.2&quot;
actix-rt = &quot;1.1.1&quot;
actix-web-actors = &quot;3.0.0&quot;
futures = &quot;0.3.8&quot;
async-trait = &quot;0.1.42&quot;
bigdecimal = { version = &quot;0.1.2&quot;, features = [&quot;serde&quot;] }
serde = { version = &quot;1.0.118&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.60&quot;
diesel = { version = &quot;1.4.5&quot;, features = [&quot;postgres&quot;, &quot;r2d2&quot;, &quot;numeric&quot;] }
diesel_migrations = &quot;1.4.0&quot;
dotenv = &quot;0.15.0&quot;
strum = &quot;0.20.0&quot;
strum_macros = &quot;0.20.1&quot;
rdkafka = { version = &quot;0.24.0&quot;, features = [&quot;cmake-build&quot;] }
async-stream = &quot;0.3.0&quot;
lazy_static = &quot;1.4.0&quot;

[dev-dependencies]
jsonpath_lib = &quot;0.2.6&quot;
testcontainers = &quot;0.9.1&quot;
</code></pre>
<p><code>Async-graphql</code>是GraphQL服务端库，<code>Actix-web</code>是Web服务框架，而<code>Async-graphql-actix-web</code>提供它们之间的集成。</p>
<h3><a class="header" href="#核心功能" id="核心功能">核心功能</a></h3>
<p>我们转到<code>main.rs</code>：</p>
<p><em>清单3. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/main.rs">main.rs</a></em></p>
<pre><pre class="playground"><code class="language-rust">#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    dotenv().ok();
    let pool = create_connection_pool();
    run_migrations(&amp;pool);

    let schema = create_schema_with_context(pool);

    HttpServer::new(move || App::new()
        .configure(configure_service)
        .data(schema.clone())
    )
        .bind(&quot;0.0.0.0:8001&quot;)?
        .run()
        .await
}
</code></pre></pre>
<p>这里，使用<code>lib.rs</code>中定义的功能配置环境和HTTP服务器：</p>
<p><em>清单4. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">lib.rs</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn configure_service(cfg: &amp;mut web::ServiceConfig) {
    cfg
        .service(web::resource(&quot;/&quot;)
            .route(web::post().to(index))
            .route(web::get().guard(guard::Header(&quot;upgrade&quot;, &quot;websocket&quot;)).to(index_ws))
            .route(web::get().to(index_playground))
        );
}

async fn index(schema: web::Data&lt;AppSchema&gt;, http_req: HttpRequest, req: Request) -&gt; Response {
    let mut query = req.into_inner();

    let maybe_role = common_utils::get_role(http_req);
    if let Some(role) = maybe_role {
        query = query.data(role);
    }

    schema.execute(query).await.into()
}

async fn index_ws(schema: web::Data&lt;AppSchema&gt;, req: HttpRequest, payload: web::Payload) -&gt; Result&lt;HttpResponse&gt; {
    WSSubscription::start(Schema::clone(&amp;*schema), &amp;req, payload)
}

async fn index_playground() -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_type(&quot;text/html; charset=utf-8&quot;)
        .body(playground_source(GraphQLPlaygroundConfig::new(&quot;/&quot;).subscription_endpoint(&quot;/&quot;)))
}

pub fn create_schema_with_context(pool: PgPool) -&gt; Schema&lt;Query, Mutation, Subscription&gt; {
    let arc_pool = Arc::new(pool);
    let cloned_pool = Arc::clone(&amp;arc_pool);
    let details_batch_loader = Loader::new(DetailsBatchLoader {
        pool: cloned_pool
    }).with_max_batch_size(10);

    let kafka_consumer_counter = Mutex::new(0);

    Schema::build(Query, Mutation, Subscription)
        .data(arc_pool)
        .data(details_batch_loader)
        .data(kafka::create_producer())
        .data(kafka_consumer_counter)
        .finish()
}
<span class="boring">}
</span></code></pre></pre>
<p>这些函数执行以下操作：</p>
<ul>
<li><code>index</code> - 处理GraphQL<a href="https://graphql.org/learn/queries/">查询和变更</a></li>
<li><code>index_ws</code> - 处理GraphQL<a href="https://www.apollographql.com/docs/react/data/subscriptions/">订阅</a></li>
<li><code>index_playground</code> - 提供Graph Playground IDE</li>
<li><code>create_schema_with_context</code> - 使用可在运行时访问的全局上下文数据（例如数据库连接池）创建GraphQL模式</li>
</ul>
<h3><a class="header" href="#查询和类型定义" id="查询和类型定义">查询和类型定义</a></h3>
<p>让我们考虑如何定义查询：</p>
<p><em>清单5. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">定义查询</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl Query {
    async fn get_planets(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Vec&lt;Planet&gt; {
        repository::get_all(&amp;get_conn_from_ctx(ctx)).expect(&quot;Can't get planets&quot;)
            .iter()
            .map(|p| { Planet::from(p) })
            .collect()
    }

    async fn get_planet(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
        find_planet_by_id_internal(ctx, id)
    }

    #[graphql(entity)]
    async fn find_planet_by_id(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
        find_planet_by_id_internal(ctx, id)
    }
}

fn find_planet_by_id_internal(ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
    let id = id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't get id from String&quot;);
    repository::get(id, &amp;get_conn_from_ctx(ctx)).ok()
        .map(|p| { Planet::from(&amp;p) })
}
<span class="boring">}
</span></code></pre></pre>
<p>每个查询都使用<code>repository</code>从数据库获取数据并将获得的记录转换为GraphQL DTO（这使我们可以保留每个结构的单一职责）。 可以从任何GraphQL IDE访问<code>get_planets</code>和<code>get_planet</code>查询，例如：</p>
<p><em>清单6. 查询示例</em></p>
<pre><code class="language-graphql">{
  getPlanets {
    name
    type
  }
}
</code></pre>
<p><code>Planet</code>对象定义如下：</p>
<p><em>清单7. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">GraphQL类型定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct Planet {
    id: ID,
    name: String,
    planet_type: PlanetType,
}

#[Object]
impl Planet {
    async fn id(&amp;self) -&gt; &amp;ID {
        &amp;self.id
    }

    async fn name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }

    /// From an astronomical point of view
    #[graphql(name = &quot;type&quot;)]
    async fn planet_type(&amp;self) -&gt; &amp;PlanetType {
        &amp;self.planet_type
    }

    #[graphql(deprecation = &quot;Now it is not in doubt. Do not use this field&quot;)]
    async fn is_rotating_around_sun(&amp;self) -&gt; bool {
        true
    }

    async fn details(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Details {
        let loader = ctx.data::&lt;Loader&lt;i32, Details, DetailsBatchLoader&gt;&gt;().expect(&quot;Can't get loader&quot;);
        let planet_id = self.id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't convert id&quot;);
        loader.load(planet_id).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们为每个字段定义一个Resolver。另外，在某些字段中，指定了描述（Rust文档注释）和弃用原因。 这些将显示在GraphQL IDE中。</p>
<h3><a class="header" href="#解决n1问题" id="解决n1问题">解决N+1问题</a></h3>
<p>如果<code>Planet</code>的<code>details</code>函数的实现是直接从数据库中查询对应<code>id</code>的<code>planet</code>对象则将导致N+1问题，如果你发出这样的请求：</p>
<p><em>清单8: 可能消耗过多资源的GraphQL请求的示例</em></p>
<pre><code class="language-graphql">{
  getPlanets {
    name
    details {
      meanRadius
    }
  }
}
</code></pre>
<p>这将对每个<code>plant</code>对象的<code>details</code>字段执行单独的SQL查询，因为<code>details</code>是与<code>planet</code>关联的类型，并存储在其自己的表中。</p>
<p>但借助<code>Async-graphql</code>的<a href="https://github.com/graphql/dataloader">DataLoader</a>实现，可以将Resolver定义如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn details(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;Details&gt; {
    let data_loader = ctx.data::&lt;DataLoader&lt;DetailsLoader&gt;&gt;().expect(&quot;Can't get data loader&quot;);
    let planet_id = self.id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't convert id&quot;);
    let details = data_loader.load_one(planet_id).await?;
    details.ok_or_else(|| &quot;Not found&quot;.into())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>data_loader</code>是通过以下方式定义的应用程序范围的对象：</p>
<p><em>清单10. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">DataLoader定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let details_data_loader = DataLoader::new(DetailsLoader {
    pool: cloned_pool
}).max_batch_size(10)
<span class="boring">}
</span></code></pre></pre>
<p><code>DetailsLoader</code>的实现：</p>
<p>_清单11. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">DetailsLoader定义</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DetailsLoader {
    pub pool: Arc&lt;PgPool&gt;
}

#[async_trait::async_trait]
impl Loader&lt;i32&gt; for DetailsLoader {
    type Value = Details;
    type Error = Error;

    async fn load(&amp;self, keys: &amp;[i32]) -&gt; Result&lt;HashMap&lt;i32, Self::Value&gt;, Self::Error&gt; {
        let conn = self.pool.get().expect(&quot;Can't get DB connection&quot;);
        let details = repository::get_details(keys, &amp;conn).expect(&quot;Can't get planets' details&quot;);

        Ok(details.iter()
            .map(|details_entity| (details_entity.planet_id, Details::from(details_entity)))
            .collect::&lt;HashMap&lt;_, _&gt;&gt;())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>此方法有助于我们防止N+1问题，因为每个<code>DetailsLoader.load</code>调用仅执行一个SQL查询，返回多个<code>DetailsEntity</code>。</p>
<h1><a class="header" href="#接口定义" id="接口定义">接口定义</a></h1>
<p>GraphQL接口及其实现通过以下方式定义：</p>
<p><em>清单12. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">GraphQL接口定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Interface, Clone)]
#[graphql(
    field(name = &quot;mean_radius&quot;, type = &quot;&amp;CustomBigDecimal&quot;),
    field(name = &quot;mass&quot;, type = &quot;&amp;CustomBigInt&quot;),
)]
pub enum Details {
    InhabitedPlanetDetails(InhabitedPlanetDetails),
    UninhabitedPlanetDetails(UninhabitedPlanetDetails),
}

#[derive(SimpleObject, Clone)]
pub struct InhabitedPlanetDetails {
    mean_radius: CustomBigDecimal,
    mass: CustomBigInt,
    /// In billions
    population: CustomBigDecimal,
}

#[derive(SimpleObject, Clone)]
pub struct UninhabitedPlanetDetails {
    mean_radius: CustomBigDecimal,
    mass: CustomBigInt,
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里你还可以看到，如果该对象没有任何复杂Resolver的字段，则可以使用<code>SimpleObject</code>宏来实现。</p>
<h3><a class="header" href="#自定义标量" id="自定义标量">自定义标量</a></h3>
<p>这个项目包含两个自定义标量定义的示例，两者都是数字类型的包装器（因为由于<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">孤儿规则</a>，你无法在外部类型上实现外部特征）。包装器的实现如下：</p>
<p><em>清单 13. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">自定义标量: 包装BigInt</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct CustomBigInt(BigDecimal);

#[Scalar(name = &quot;BigInt&quot;)]
impl ScalarType for CustomBigInt {
    fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; {
        match value {
            Value::String(s) =&gt; {
                let parsed_value = BigDecimal::from_str(&amp;s)?;
                Ok(CustomBigInt(parsed_value))
            }
            _ =&gt; Err(InputValueError::expected_type(value)),
        }
    }

    fn to_value(&amp;self) -&gt; Value {
        Value::String(format!(&quot;{:e}&quot;, &amp;self))
    }
}

impl LowerExp for CustomBigInt {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let val = &amp;self.0.to_f64().expect(&quot;Can't convert BigDecimal&quot;);
        LowerExp::fmt(val, f)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><em>清单 14. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">自定义标量: 包装BigDecimal</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct CustomBigDecimal(BigDecimal);

#[Scalar(name = &quot;BigDecimal&quot;)]
impl ScalarType for CustomBigDecimal {
    fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; {
        match value {
            Value::String(s) =&gt; {
                let parsed_value = BigDecimal::from_str(&amp;s)?;
                Ok(CustomBigDecimal(parsed_value))
            }
            _ =&gt; Err(InputValueError::expected_type(value)),
        }
    }

    fn to_value(&amp;self) -&gt; Value {
        Value::String(self.0.to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>前一个示例还支持使用指数表示大数。</p>
<h3><a class="header" href="#定义变更mutation" id="定义变更mutation">定义变更(Mutation)</a></h3>
<p>变更定义如下：</p>
<p><em>清单 15. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">定义变更</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutation;

#[Object]
impl Mutation {
    #[graphql(guard(RoleGuard(role = &quot;Role::Admin&quot;)))]
    async fn create_planet(&amp;self, ctx: &amp;Context&lt;'_&gt;, planet: PlanetInput) -&gt; Result&lt;Planet, Error&gt; {
        let new_planet = NewPlanetEntity {
            name: planet.name,
            planet_type: planet.planet_type.to_string(),
        };

        let details = planet.details;
        let new_planet_details = NewDetailsEntity {
            mean_radius: details.mean_radius.0,
            mass: BigDecimal::from_str(&amp;details.mass.0.to_string()).expect(&quot;Can't get BigDecimal from string&quot;),
            population: details.population.map(|wrapper| { wrapper.0 }),
            planet_id: 0,
        };

        let created_planet_entity = repository::create(new_planet, new_planet_details, &amp;get_conn_from_ctx(ctx))?;

        let producer = ctx.data::&lt;FutureProducer&gt;().expect(&quot;Can't get Kafka producer&quot;);
        let message = serde_json::to_string(&amp;Planet::from(&amp;created_planet_entity)).expect(&quot;Can't serialize a planet&quot;);
        kafka::send_message(producer, message).await;

        Ok(Planet::from(&amp;created_planet_entity))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Mutation.create_planet</code>输入参数需要定义以下结构：</p>
<p><em>清单 16: <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">定义输入类型</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(InputObject)]
struct PlanetInput {
    name: String,
    #[graphql(name = &quot;type&quot;)]
    planet_type: PlanetType,
    details: DetailsInput,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>create_planet</code>受<code>RoleGuard</code>保护，可确保只有具有<code>Admin</code>角色的用户才能访问它。要执行变异，如下所示：</p>
<pre><code class="language-graphql">mutation {
  createPlanet(
    planet: {
      name: &quot;test_planet&quot;
      type: TERRESTRIAL_PLANET
      details: { meanRadius: &quot;10.5&quot;, mass: &quot;8.8e24&quot;, population: &quot;0.5&quot; }
    }
  ) {
    id
  }
}
</code></pre>
<p>你需要从<code>auth-service</code>获得JWT，并指定<code>Authorization</code>作为HTTP请求的标头（稍后将对此进行描述）。</p>
<h3><a class="header" href="#定义订阅subscription" id="定义订阅subscription">定义订阅(Subscription)</a></h3>
<p>在上面的Mutation定义中，你可以看到在<code>planet</code>创建过程中发送了一条消息：</p>
<p><em>清单 18. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">发送消息到Kafka</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let producer = ctx.data::&lt;FutureProducer&gt;().expect(&quot;Can't get Kafka producer&quot;);
let message = serde_json::to_string(&amp;Planet::from(&amp;created_planet_entity)).expect(&quot;Can't serialize a planet&quot;);
kafka::send_message(producer, message).await;
<span class="boring">}
</span></code></pre></pre>
<p>使用者可以通过监听Kafka订阅将事件通知给API客户端：</p>
<p><em>清单 19. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">订阅定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Subscription;

#[Subscription]
impl Subscription {
    async fn latest_planet&lt;'ctx&gt;(&amp;self, ctx: &amp;'ctx Context&lt;'_&gt;) -&gt; impl Stream&lt;Item=Planet&gt; + 'ctx {
        let kafka_consumer_counter = ctx.data::&lt;Mutex&lt;i32&gt;&gt;().expect(&quot;Can't get Kafka consumer counter&quot;);
        let consumer_group_id = kafka::get_kafka_consumer_group_id(kafka_consumer_counter);
        let consumer = kafka::create_consumer(consumer_group_id);

        async_stream::stream! {
            let mut stream = consumer.start();

            while let Some(value) = stream.next().await {
                yield match value {
                    Ok(message) =&gt; {
                        let payload = message.payload().expect(&quot;Kafka message should contain payload&quot;);
                        let message = String::from_utf8_lossy(payload).to_string();
                        serde_json::from_str(&amp;message).expect(&quot;Can't deserialize a planet&quot;)
                    }
                    Err(e) =&gt; panic!(&quot;Error while Kafka message processing: {}&quot;, e)
                };
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>订阅可以像查询(Query)和变更(Mutation)一样使用：</p>
<p><em>清单 20. 订阅使用例子</em></p>
<pre><code class="language-graphql">subscription {
  latestPlanet {
    id
    name
    type
    details {
      meanRadius
    }
  }
}
</code></pre>
<p>订阅的URL是<code>ws://localhost:8001</code>。</p>
<h3><a class="header" href="#集成测试" id="集成测试">集成测试</a></h3>
<p>查询和变更的测试可以这样写：</p>
<p><em>清单 21. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">查询测试</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_get_planets() {
    let docker = Cli::default();
    let (_pg_container, pool) = common::setup(&amp;docker);

    let mut service = test::init_service(App::new()
        .configure(configure_service)
        .data(create_schema_with_context(pool))
    ).await;

    let query = &quot;
        {
            getPlanets {
                id
                name
                type
                details {
                    meanRadius
                    mass
                    ... on InhabitedPlanetDetails {
                        population
                    }
                }
            }
        }
        &quot;.to_string();

    let request_body = GraphQLCustomRequest {
        query,
        variables: Map::new(),
    };

    let request = test::TestRequest::post().uri(&quot;/&quot;).set_json(&amp;request_body).to_request();

    let response: GraphQLCustomResponse = test::read_response_json(&amp;mut service, request).await;

    fn get_planet_as_json(all_planets: &amp;serde_json::Value, index: i32) -&gt; &amp;serde_json::Value {
        jsonpath::select(all_planets, &amp;format!(&quot;$.getPlanets[{}]&quot;, index)).expect(&quot;Can't get planet by JSON path&quot;)[0]
    }

    let mercury_json = get_planet_as_json(&amp;response.data, 0);
    common::check_planet(mercury_json, 1, &quot;Mercury&quot;, &quot;TERRESTRIAL_PLANET&quot;, &quot;2439.7&quot;);

    let earth_json = get_planet_as_json(&amp;response.data, 2);
    common::check_planet(earth_json, 3, &quot;Earth&quot;, &quot;TERRESTRIAL_PLANET&quot;, &quot;6371.0&quot;);

    let neptune_json = get_planet_as_json(&amp;response.data, 7);
    common::check_planet(neptune_json, 8, &quot;Neptune&quot;, &quot;ICE_GIANT&quot;, &quot;24622.0&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果查询的一部分可以在另一个查询中重用，则可以使用<a href="https://graphql.org/learn/queries/#fragments">片段(Fragment)</a>：</p>
<p><em>清单 22. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">查询测试（使用片段）</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PLANET_FRAGMENT: &amp;str = &quot;
    fragment planetFragment on Planet {
        id
        name
        type
        details {
            meanRadius
            mass
            ... on InhabitedPlanetDetails {
                population
            }
        }
    }
&quot;;

#[actix_rt::test]
async fn test_get_planet_by_id() {
    ...

    let query = &quot;
        {
            getPlanet(id: 3) {
                ... planetFragment
            }
        }
        &quot;.to_string() + PLANET_FRAGMENT;

    let request_body = GraphQLCustomRequest {
        query,
        variables: Map::new(),
    };

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>要使用<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">变量</a>，你可以通过以下方式编写测试：</p>
<p><em>清单 23. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">查询测试（使用片段和变量）</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_get_planet_by_id_with_variable() {
    ...

    let query = &quot;
        query testPlanetById($planetId: String!) {
            getPlanet(id: $planetId) {
                ... planetFragment
            }
        }&quot;.to_string() + PLANET_FRAGMENT;

    let jupiter_id = 5;
    let mut variables = Map::new();
    variables.insert(&quot;planetId&quot;.to_string(), jupiter_id.into());

    let request_body = GraphQLCustomRequest {
        query,
        variables,
    };

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个项目中，<code>Testcontainers-rs</code>库用于准备测试环境，创建一个临时PostgreSQL数据库。</p>
<h3><a class="header" href="#graphql客户端" id="graphql客户端">GraphQL客户端</a></h3>
<p>你可以使用上一部分中的代码段来创建外部GraphQL API的客户端。另外，有一些库可用于此目的，例如<code>graphql-client</code>，但我还没有使用它们。</p>
<h3><a class="header" href="#api安全" id="api安全">API安全</a></h3>
<p>GraphQL API有一些不同程度的安全威胁（请参阅此<a href="https://leapgraph.com/graphql-api-security">清单</a>以了解更多信息），让我们考虑其中的一些方面。</p>
<h4><a class="header" href="#限制查询的深度和复杂度" id="限制查询的深度和复杂度">限制查询的深度和复杂度</a></h4>
<p>如果<code>Satellite</code>对象容纳<code>planet</code>字段，则可能有以下查询：</p>
<p><em>清单 24. 昂贵查询的例子</em></p>
<pre><code class="language-graphql">{
  getPlanet(id: &quot;1&quot;) {
    satellites {
      planet {
        satellites {
          planet {
            satellites {
              ... # 更深的嵌套！
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>为了使这样的查询无效，我们可以指定：</p>
<p><em>清单 25. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">限制查询深度和复杂度的例子</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_schema_with_context(pool: PgPool) -&gt; Schema&lt;Query, Mutation, Subscription&gt; {
    ...

    Schema::build(Query, Mutation, Subscription)
        .limit_depth(3)
        .limit_complexity(15)

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>请注意，如果你指定深度或复杂度限制，则API文档可能不能在GraphQL IDE中显示，这是因为IDE尝试执行具有相当深度和复杂度的自省查询。</p>
<h4><a class="header" href="#认证" id="认证">认证</a></h4>
<p>使用<code>argonautica</code>和<code>jsonwebtoken</code>库在<code>auth-service</code>中实现此功能。 前一个库负责使用<a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a>算法对用户的密码进行哈希处理。<strong>身份验证和授权功能仅用于演示，请针对生产用途进行更多研究。</strong></p>
<p>让我们看看登录的实现方式：</p>
<p><em>清单 26. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/auth-service/src/graphql.rs">实现登录</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutation;

#[Object]
impl Mutation {

    async fn sign_in(&amp;self, ctx: &amp;Context&lt;'_&gt;, input: SignInInput) -&gt; Result&lt;String, Error&gt; {
        let maybe_user = repository::get_user(&amp;input.username, &amp;get_conn_from_ctx(ctx)).ok();

        if let Some(user) = maybe_user {
            if let Ok(matching) = verify_password(&amp;user.hash, &amp;input.password) {
                if matching {
                    let role = AuthRole::from_str(user.role.as_str()).expect(&quot;Can't convert &amp;str to AuthRole&quot;);
                    return Ok(common_utils::create_token(user.username, role));
                }
            }
        }

        Err(Error::new(&quot;Can't authenticate a user&quot;))
    }
}

#[derive(InputObject)]
struct SignInInput {
    username: String,
    password: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以在<code>utils</code><a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/auth-service/src/utils.rs">模块</a>中查看<code>verify_password</code>函数的实现，在<code>common_utils</code><a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/common-utils/src/lib.rs">模块</a>中查看<code>create_token</code>函数的实现。如你所料，<code>sign_in</code>函数将颁发JWT，该JWT可进一步用于其他服务中的授权。</p>
<p>要获得JWT，你需要执行以下变更：</p>
<p><em>清单 27. 获取JWT</em></p>
<pre><code class="language-graphql">mutation {
  signIn(input: { username: &quot;john_doe&quot;, password: &quot;password&quot; })
}
</code></pre>
<p>使用 <em>john_doe/password</em> ，将获得的JWT用于在进一步的请求中，可以访问受保护的资源（请参阅下一节）。</p>
<h4><a class="header" href="#鉴权" id="鉴权">鉴权</a></h4>
<p>要请求受保护的数据，你需要以<code>Authorization：Bearer $ JWT</code>格式向HTTP请求中添加标头。 <code>index</code>函数将从请求中提取用户的角色，并将其添加到查询数据中：</p>
<p><em>清单 28. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">角色提取</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn index(schema: web::Data&lt;AppSchema&gt;, http_req: HttpRequest, req: Request) -&gt; Response {
    let mut query = req.into_inner();

    let maybe_role = common_utils::get_role(http_req);
    if let Some(role) = maybe_role {
        query = query.data(role);
    }

    schema.execute(query).await.into()
}
<span class="boring">}
</span></code></pre></pre>
<p>以下属性应用于先前定义的<code>create_planet</code>变更：</p>
<p><em>清单 29. 使用字段守卫</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[graphql(guard(RoleGuard(role = &quot;Role::Admin&quot;)))]
<span class="boring">}
</span></code></pre></pre>
<p>这个守卫自身实现如下：</p>
<p><em>清单 30. 守卫实现</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RoleGuard {
    role: Role,
}

#[async_trait::async_trait]
impl Guard for RoleGuard {
    async fn check(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        if ctx.data_opt::&lt;Role&gt;() == Some(&amp;self.role) {
            Ok(())
        } else {
            Err(&quot;Forbidden&quot;.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样如果你未指定角色，则服务器将返回<code>Forbidden</code>的消息。</p>
<h3><a class="header" href="#定义枚举" id="定义枚举">定义枚举</a></h3>
<p>GraphQL枚举可以通过以下方式定义：</p>
<p><em>清单 31. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/satellites-service/src/graphql.rs">定义枚举</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
struct Satellite {
    ...
    life_exists: LifeExists,
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, Enum, EnumString)]
#[strum(serialize_all = &quot;SCREAMING_SNAKE_CASE&quot;)]
pub enum LifeExists {
    Yes,
    OpenQuestion,
    NoData,
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#日期处理" id="日期处理">日期处理</a></h4>
<p><code>Async-graphql</code>支持<code>chrono</code>库中的日期/时间类型，因此你可以照常定义以下字段：</p>
<p><em>清单 32. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/satellites-service/src/graphql.rs">日期字段定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
struct Satellite {
    ...
    first_spacecraft_landing_date: Option&lt;NaiveDate&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#支持apollofederation" id="支持apollofederation">支持ApolloFederation</a></h3>
<p><code>satellites-service</code>的目的之一是演示如何在两个（或多个）服务中解析分布式GraphQL<a href="https://www.apollographql.com/docs/federation/entities/">实体</a>（<code>Planet</code>），然后通过Apollo Server对其进行访问。</p>
<p><code>Plant</code>类型之前是通过<code>planets-service</code>定义的：</p>
<p><em>清单 33. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">在<code>planets-service</code>里定义<code>Planet</code>类型</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct Planet {
    id: ID,
    name: String,
    planet_type: PlanetType,
}
<span class="boring">}
</span></code></pre></pre>
<p>另外，在<code>planets-service</code>中，<code>Planet</code>类型是一个实体：</p>
<p>_清单 34. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs"><code>Planet</code>实体定义</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl Query {
    #[graphql(entity)]
    async fn find_planet_by_id(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
        find_planet_by_id_internal(ctx, id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>satellites-service</code>向<code>Planet</code>对象扩展了<code>satellites</code>字段：</p>
<p><em>清单 35. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/satellites-service/src/graphql.rs"><code>satellites-service</code>中<code>Plant</code>对象的扩展</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Planet {
    id: ID
}

#[Object(extends)]
impl Planet {
    #[graphql(external)]
    async fn id(&amp;self) -&gt; &amp;ID {
        &amp;self.id
    }

    async fn satellites(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Vec&lt;Satellite&gt; {
        let id = self.id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't get id from String&quot;);
        repository::get_by_planet_id(id, &amp;get_conn_from_ctx(ctx)).expect(&quot;Can't get satellites of planet&quot;)
            .iter()
            .map(|e| { Satellite::from(e) })
            .collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>你还应该为扩展类型提供查找函数（此处只是创建了<code>Planet</code>的新实例）：</p>
<p><em>清单 36. <code>Planet</code>对象的查找函数</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl Query {

    #[graphql(entity)]
    async fn get_planet_by_id(&amp;self, id: ID) -&gt; Planet {
        Planet { id }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Async-graphql</code>生成两个附加查询（<code>_service</code>和<code>_entities</code>），这些查询将由Apollo Server使用。这些查询是内部查询，也就是说Apollo Server不会公开这些查询。当然，具有Apollo Federation支持的服务仍可以独立运行。</p>
<h3><a class="header" href="#apolloserver" id="apolloserver">ApolloServer</a></h3>
<p>Apollo Server和Apollo Federation可以实现两个主要目标：</p>
<ul>
<li>
<p>创建单个端点以访问由多个服务提供的GraphQL API</p>
</li>
<li>
<p>从分布式服务创建单个GraphQL模式</p>
</li>
</ul>
<p>也就是说即使你不使用联合实体，前端开发人员也可以使用单个端点而不是多个端点，使用起来更加的方便。</p>
<p>还有一种创建单个GraphQL模式的方法，即<a href="https://www.graphql-tools.com/docs/schema-stitching/">模式缝合</a>，但是我没有使用这种方法。</p>
<p>该模块包括以下代码：</p>
<p><em>清单 37. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/apollo-server/package.json">元信息和依赖</a></em></p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;api-gateway&quot;,
  &quot;main&quot;: &quot;gateway.js&quot;,
  &quot;scripts&quot;: {
    &quot;start-gateway&quot;: &quot;nodemon gateway.js&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;concurrently&quot;: &quot;5.3.0&quot;,
    &quot;nodemon&quot;: &quot;2.0.6&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@apollo/gateway&quot;: &quot;0.21.3&quot;,
    &quot;apollo-server&quot;: &quot;2.19.0&quot;,
    &quot;graphql&quot;: &quot;15.4.0&quot;
  }
}
</code></pre>
<p>_清单 38. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/apollo-server/gateway.js">Apollo Server定义</a></p>
<pre><code class="language-javascript">const {ApolloServer} = require(&quot;apollo-server&quot;);
const {ApolloGateway, RemoteGraphQLDataSource} = require(&quot;@apollo/gateway&quot;);

class AuthenticatedDataSource extends RemoteGraphQLDataSource {
    willSendRequest({request, context}) {
        if (context.authHeaderValue) {
            request.http.headers.set('Authorization', context.authHeaderValue);
        }
    }
}

let node_env = process.env.NODE_ENV;

function get_service_url(service_name, port) {
    let host;
    switch (node_env) {
        case 'docker':
            host = service_name;
            break;
        case 'local': {
            host = 'localhost';
            break
        }
    }

    return &quot;http://&quot; + host + &quot;:&quot; + port;
}

const gateway = new ApolloGateway({
    serviceList: [
        {name: &quot;planets-service&quot;, url: get_service_url(&quot;planets-service&quot;, 8001)},
        {name: &quot;satellites-service&quot;, url: get_service_url(&quot;satellites-service&quot;, 8002)},
        {name: &quot;auth-service&quot;, url: get_service_url(&quot;auth-service&quot;, 8003)},
    ],
    buildService({name, url}) {
        return new AuthenticatedDataSource({url});
    },
});

const server = new ApolloServer({
    gateway, subscriptions: false, context: ({req}) =&gt; ({
        authHeaderValue: req.headers.authorization
    })
});

server.listen({host: &quot;0.0.0.0&quot;, port: 4000}).then(({url}) =&gt; {
    console.log(`🚀 Server ready at ${url}`);
});
</code></pre>
<p>如果以上代码可以简化，请随时与我联系以进行更改。</p>
<p><code>apollo-service</code>中的授权工作如先前Rust服务所述（你只需指定<code>Authorization</code>标头及其值）即可。</p>
<p>如果采用<a href="https://www.apollographql.com/docs/federation/federation-spec/">Federation规范</a>，则可以将用任何语言或框架编写的应用程序作为下游服务添加到Apollo Server。这个<a href="https://www.apollographql.com/docs/federation/other-servers/">文档</a>中提供了提供此类支持的库列表。</p>
<p>在实现此模块时，我遇到了一些限制：</p>
<ul>
<li>
<p>Apollo Gateway<a href="https://github.com/apollographql/apollo-server/issues/3357">不支持订阅</a>（但它们仍可在独立的Rust GraphQL应用程序中使用）</p>
</li>
<li>
<p>试图扩展GraphQL接口的服务需要<a href="https://github.com/apollographql/apollo-server/issues/2849">了解具体的实现</a></p>
</li>
</ul>
<h3><a class="header" href="#数据库交互" id="数据库交互">数据库交互</a></h3>
<p>持久层是使用PostgreSQL和Diesel实现的。如果你不在本地使用Docker，你应该在每个服务的文件夹中运行<code>diesel setup</code>。这将创建一个空数据库，然后将应用Migrations创建表和插入数据。</p>
<h3><a class="header" href="#运行和api测试" id="运行和api测试">运行和API测试</a></h3>
<p>如前面所述，对于在本地启动项目，你有两个选择。</p>
<ul>
<li>
<p>使用Docker Compose (<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/docker-compose.yml">docker-compose.yml</a>)</p>
<p>这里也有两个选择</p>
<ul>
<li>
<p>开发模式 （使用本地生成的镜像）</p>
<p><code>docker-compose up</code></p>
</li>
<li>
<p>生产模式 （使用已发布的镜像）</p>
<p><code>docker-compose -f docker-compose.yml up</code></p>
</li>
</ul>
</li>
<li>
<p>不使用Docker</p>
<p>用<code>cargo run</code>启动每个服务，然后启动Apollo Server:</p>
<ul>
<li>进入 <code>apollo-server</code> 目录</li>
<li>定义 <code>NODE_ENV</code> 环境变量， 例如<code>set NODE_ENV=local</code>(Windows)</li>
<li><code>npm install</code></li>
<li><code>npm run start-gateway</code></li>
</ul>
</li>
</ul>
<p>当<code>apollo-server</code>成功运行应该输出以下信息:</p>
<p><em>清单 39. Apollo Server启动日志</em></p>
<pre><code>[nodemon] 2.0.6
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node gateway.js`
Server ready at http://0.0.0.0:4000/
</code></pre>
<p>你可以在浏览器中打开<code>http://localhost:4000</code>，并使用内置的Playground IDE。</p>
<p><img src="chapter_1/graphql_in_rust/playground.png" alt="playground" /></p>
<p>在这里你可以执行下游服务中定义的查询、变更和订阅。另外，这些服务也都有自己的Playground IDE。</p>
<h3><a class="header" href="#订阅测试" id="订阅测试">订阅测试</a></h3>
<p>要测试订阅是否正常工作，可以在GraphQL IDE中打开两个Tab，第一个请求如下。</p>
<p><em>清单 40. 订阅请求</em></p>
<pre><code class="language-graphql">subscription {
  latestPlanet {
    name
    type
  }
}
</code></pre>
<p>第二个请求指定如上所述的<code>Authorization</code>标头，并执行这样的变更。</p>
<p><em>清单 41. 变更请求</em></p>
<pre><code class="language-graphql">mutation {
  createPlanet(
    planet: {
      name: &quot;Pluto&quot;
      type: DWARF_PLANET
      details: { meanRadius: &quot;1188&quot;, mass: &quot;1.303e22&quot; }
    }
  ) {
    id
  }
}
</code></pre>
<p>订阅的客户端会收到<code>Plant</code>创建的通知。</p>
<p><img src="chapter_1/graphql_in_rust/subscription-demo.gif" alt="subscription-demo" /></p>
<h3><a class="header" href="#cicd" id="cicd">CI/CD</a></h3>
<p>CI/CD是使用GitHub Actions（<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/.github/workflows/workflow.yml">workflow</a>）配置的，它可以运行应用程序的测试，构建它们的Docker镜像，并在Google Cloud Platform上部署它们。</p>
<p>你可以在<a href="http://graphql-rust.romankudryashov.com/">这里</a>试试已部署的服务。</p>
<p><strong>注意：</strong> 在<code>生产</code>环境下，为了防止更改初始数据，密码与前面指定的不同。</p>
<h3><a class="header" href="#结论" id="结论">结论</a></h3>
<p>在这篇文章中，我考虑了如何解决在Rust中开发GraphQL API时可能出现的最常见问题。此外，我还展示了如何将使用Rust开发的GraphQL微服务API结合起来，以提供统一的GraphQL接口。在这样的架构中，一个实体可以分布在几个微服务之间，它是通过Apollo Server、Apollo Federation和Async-graphql库来实现的。项目的源代码在<a href="https://github.com/rkudryashov/graphql-rust-demo">GitHub</a>上。如果你发现文章或源代码中有任何错误，欢迎<a href="chapter_1/graphql_in_rust/rskudryashov@gmail.com">联系</a>我。谢谢阅读!</p>
<h3><a class="header" href="#有用的链接" id="有用的链接">有用的链接</a></h3>
<ul>
<li><a href="https://graphql.org/">graphql.org</a></li>
<li><a href="https://spec.graphql.org/">spec.graphql.org</a></li>
<li><a href="https://graphql.org/learn/best-practices/">graphql.org/learn/best-practices</a></li>
<li><a href="https://www.howtographql.com/">howtographql.com</a></li>
<li><a href="https://github.com/async-graphql/async-graphql">Async-graphql</a></li>
<li><a href="https://async-graphql.github.io/async-graphql/zh-CN/index.html">Async-graphql使用手册</a></li>
<li><a href="https://github.com/chentsulin/awesome-graphql">Awesome GraphQL</a></li>
<li><a href="https://github.com/APIs-guru/graphql-apis">Public GraphQL APIs</a></li>
<li><a href="https://github.com/apollographql/federation-demo">Apollo Federation demo</a></li>
</ul>
<h1><a class="header" href="#图解-rust-所有权与生命周期" id="图解-rust-所有权与生命周期">图解 Rust 所有权与生命周期</a></h1>
<p>作者：肖猛</p>
<p>后期编辑：高宪凤</p>
<hr />
<p>作者简介：</p>
<p>肖猛</p>
<p>二十年从桌面到云端到嵌入式的软件架构经验，跨通讯、游戏、金融、智能网联汽车多个行业，领域系统分析专家、全栈软件架构专家。</p>
<p>目前致力于智能驾驶基础软件开发。历任吉利亿咖通自动驾驶软件平台总监，国汽智控自动驾驶软件研发总监。对在汽车领域推广 Rust 技术栈有浓厚兴趣，并有实际的量产实践。</p>
<hr />
<h2><a class="header" href="#1引言" id="1引言">1.引言</a></h2>
<p><strong>所有权</strong>与<strong>生命周期</strong>是  <code>Rust</code>  语言非常核心的内容。其实不仅仅是 <code>Rust</code> 有这两个概念，在<code>C/C++</code> 中也一样是存在的。而几乎所有的内存安全问题也源于对所有权和生命周期的错误使用。只要是不采用垃圾回收来管理内存的程序语言，都会有这个问题。只是 <code>Rust</code> 在语言级明确了这两个概念，并提供了相关的语言特性让用户可以显式控制所有权的转移与生命周期的声明。同时编译器会对各种错误使用进行检查，提高了程序的内存安全性。</p>
<p>所有权和生命周期其涉及的语言概念很多，本文主要是对梳理出与“所有权与生命周期”相关的概念，并使用  <code>UML</code> 的类图表达概念间的关系，帮助更好的理解和掌握。</p>
<p><strong>图例说明</strong></p>
<p>本文附图都是 <code>UML</code> 类图，<code>UML</code> 类图可以用来表示对概念的分析。表达概念之间的依赖、继承、聚合、组成等关系。图中的每一个矩形框都是一个语义概念，有的是抽象的语言概念，有的是 <code>Rust</code> 库中的结构和 <code>Trait</code>。</p>
<p>所有图中使用的符号也只有最基础的几个。图 1 对符号体系做简单说明，主要解释一下表达概念之间的关系的符号语言。</p>
<div align=center>
    <img width="544" height="306" src="chapter_1/./rust_ownership/rust_ownership_1.jpg">
</div>
<center>图 1UML 符号</center>
<p><strong>依赖关系：</strong></p>
<p>依赖是 <code>UML</code> 中最基础的关系语义。 以带箭头的虚线表示，<code>A</code> 依赖与 <code>B</code> 表达如下图。直观理解可以是 <code>A</code> “看的见” <code>B</code>，而 <code>B</code> 可以对 <code>A</code> 一无所知。比如在代码中 结构体 <code>A</code> 中有 结构体 <code>B</code> 的成员变量，或者 <code>A</code> 的实现代码中有 <code>B</code> 的局部变量。这样如果找不到 <code>B</code>，<code>A</code> 是无法编译通过的。</p>
<p><strong>关联关系：</strong></p>
<p>一条实线连接表示两个类型直接有关联，有箭头表示单向&quot;可见&quot;,无箭头表示相互之间可见。关联关系也是一种依赖，但是更具体。有时候两个类型之间的关联关系太复杂，需要用一个类型来表达，叫做关联类型，如例图中的 <code>H</code>.</p>
<p><strong>聚合与组成：</strong></p>
<p>聚合与组成都是表示的是整体和部分的关系。差别在于“聚合”的整体与部分可以分开，部分可以在多个整体之间共享。而“组成”关系中整体对部分有更强的独占性，部分不能被拆开，部分与整体有相同的生命周期。</p>
<p><strong>继承与接口实现：</strong></p>
<p>继承与接口实现都是一种泛化关系，<code>C</code> 继承自 <code>A</code>，表示 <code>A</code> 是更泛化的概念。<code>UML</code> 中各种关系语义也可以用 <code>UML</code> 自身来表达，如图 2：“关联”和“继承”都是“依赖”的具体体现方式。</p>
<div align=center>
    <img width="544" height="306" src="chapter_1/./rust_ownership/rust_ownership_2.jpg">
</div>
<center>图 2用 UML表达UML自身</center>
<p><strong>总图</strong></p>
<p>图 3 是本文的总图，后续各节分局部介绍。
<img src="chapter_1/./rust_ownership/rust_ownership_3.png"></p>
<center>图 3Rust 所有权与生命周期总图</center>
<h2><a class="header" href="#2所有权与生命周期期望解决的问题" id="2所有权与生命周期期望解决的问题">2.所有权与生命周期期望解决的问题</a></h2>
<p>我们从图中间部分开始看起，所谓“所有权”是指对一个变量拥有了一块“内存区域”。这个内存区域，可以在堆上，可以在栈上，也可以在代码段，还有些内存地址是直接用于 <code>I/O</code> 地址映射的。这些都是内存区域可能存在的位置。</p>
<p>在高级语言中，这个内存位置要在程序中要能被访问，必然就会与一个或多个变量建立关联关系（低级语言如汇编语言，可以直接访问内存地址）。也就是说，通过这一个或多个变量，就能访问这个内存地址。</p>
<p>这就引出三个问题：</p>
<ol>
<li>内存的不正确访问引发的内存安全问题</li>
<li>由于多个变量指向同一块内存区域导致的数据一致性问题</li>
<li>由于变量在多个线程中传递，导致的数据竞争的问题</li>
</ol>
<p>由第一个问题引发的内存安全问题一般有 5 个典型情况：</p>
<ul>
<li>使用未初始化的内存</li>
<li>对空指针解引用</li>
<li>悬垂指针(使用已经被释放的内存)</li>
<li>缓冲区溢出</li>
<li>非法释放内存(释放未分配的指针或重复释放指针)</li>
</ul>
<img src="chapter_1/./rust_ownership/rust_ownership_4.jpg">
<center>图 4变量绑定与内存安全的基本概念</center>
<p>这些问题在 <code>C/C++</code> 中是需要开发者非常小心的自己处理。 比如我们可以写一段 <code>C++</code> 代码，把这五个内存安全错误全部犯一遍。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

struct Point {
	int x;
	int y;
};

Point* newPoint(int x,int y) {
	Point p { .x=x,.y=y };
	return &amp;p; //悬垂指针
}

int main() {
	int values[3]= { 1,2,3 };
	std::cout&lt;&lt;values[0]&lt;&lt;&quot;,&quot;&lt;&lt;values[3]&lt;&lt;std::endl; //缓冲区溢出

	Point *p1 = (Point*)malloc(sizeof(Point));
	std::cout&lt;&lt;p1-&gt;x&lt;&lt;&quot;,&quot;&lt;&lt;p1-&gt;y&lt;&lt;std::endl; //使用未初始化内存

	Point *p2 = newPoint(10,10); //悬垂指针
	delete p2; //非法释放内存

	p1 = NULL;
	std::cout&lt;&lt;p1-&gt;x&lt;&lt;std::endl; //对空指针解引用
	return 0;
}
</code></pre>
<p>这段代码是可以编译通过的，当然，编译器还是会给出警告信息。这段代码也是可以运行的，也会输出信息，直到执行到最后一个错误处“对空指针解引用时”才会发生段错误退出。</p>
<p><code>Rust</code> 的语言特性为上述问题提供了解决方案，如下表所示：</p>
<table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody>
<tr><td><div style="width: 200px">使用未初始化的内存</div></td><td></td></tr>
<tr><td>编译器禁止变量读取未赋值变量</td><td></td></tr>
<tr><td><div style="width: 200px">对空指针解引用</div></td><td></td></tr>
<tr><td>使用 Option<T> 枚举替代空指针</td><td></td></tr>
<tr><td><div style="width: 200px">悬垂指针</div></td><td></td></tr>
<tr><td>生命周期标识与编译器检查</td><td></td></tr>
<tr><td><div style="width: 200px">缓冲区溢出</div></td><td></td></tr>
<tr><td>编译器检查，拒绝超越缓冲区边界的数据访问</td><td></td></tr>
<tr><td><div style="width: 200px">非法释放内存</div></td><td></td></tr>
<tr><td>语言级的 RAII 机制，只有唯一的所有者才有权释放内存</td><td></td></tr>
<tr><td><div style="width: 200px">多个变量修改同一块内存区域</div></td><td></td></tr>
<tr><td>允许多个变量借用所有权，但是同一时间只允许一个可变借用</td><td></td></tr>
<tr><td><div style="width: 200px">变量在多个线程中传递时的安全问题</div></td><td></td></tr>
<tr><td>对基本数据类型用 Sync 和 Send 两个 Trait 标识其线程安全特性，即能否转移所有权或传递可变借用，把这作为基本事实。再利用泛型限定语法和 Trait impl 语法描述出类型线程安全的规则。编译期间使用类似规则引擎的机制，基于基本事实和预定义规则为用户代码中的跨线程数据传递做推理检查。</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#3变量绑定与所有权的赋予" id="3变量绑定与所有权的赋予">3.变量绑定与所有权的赋予</a></h2>
<p><code>Rust</code> 中为什么叫“变量绑定”而不叫“变量赋值&quot;。我们先来看一段 <code>C++</code> 代码，以及对应的 <code>Rust</code> 代码。</p>
<p>C++:</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
int main()
{
	int a = 1;
	std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;   /* 输出 0x62fe1c */
	a = 2;
	std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;   /* 输出 0x62fe1c */
}
</code></pre>
<p>Rust:</p>
<pre><code class="language-Rust">fn main() {
	let a = 1;
	println!(&quot;a:{}&quot;,a);     // 输出1
	println!(&quot;&amp;a:{:p}&quot;,&amp;a); // 输出0x9cf974
	//a=2;                  // 编译错误，不可变绑定不能修改绑定的值
	let a = 2;              // 重新绑定
	println!(&quot;&amp;a:{:p}&quot;,&amp;a); // 输出0x9cfa14地址发生了变化
	let mut b = 1;          // 创建可变绑定
	println!(&quot;b:{}&quot;,b);     // 输出1
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfa6c
	b = 2;
	println!(&quot;b:{}&quot;,b);     // 输出2
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfa6c地址没有变化
	let b = 2;              // 重新绑定新值
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfba4地址发生了变化
}
</code></pre>
<p>我们可以看到，在 <code>C++</code> 代码中，变量 <code>a</code> 先赋值为 1，后赋值为 2，但其地址没有发生变化。<code>Rust</code> 代码中，<code>a</code> 是一个不可变绑定，执行<code>a=2</code>动作被编译器拒绝。但是可以使用 <code>let</code> 重新绑定，但这时 <code>a</code> 的地址跟之前发生了变化，说明 a 被绑定到了另一个内存地址。<code>b</code> 是一个可变绑定，可以使用<code>b = 2</code>重新给它指向的内存赋值，<code>b</code> 的地址不变。但使用 <code>let</code> 重新绑定后，<code>b</code> 指向了新的内存区域。</p>
<p>可以看出，&quot;赋值&quot; 是将值写入变量关联的内存区域，&quot;绑定&quot; 是建立变量与内存区域的关联关系，<code>Rust</code> 里，还会把这个内存区域的所有权赋予这个变量。</p>
<p>不可变绑定的含义是：将变量绑定到一个内存地址，并赋予所有权，通过该变量只能读取该地址的数据，不能修改该地址的数据。对应的，可变绑定就可以通过变量修改关联内存区域的数据。从语法上看，有 <code>let</code> 关键字是绑定, 没有就是赋值。</p>
<p>这里我们能看出 <code>Rust</code> 与 <code>C++</code> 的一个不同之处。<code>C++</code> 里是没有“绑定”概念的。<code>Rust</code> 的变量绑定概念是一个很关键的概念，它是所有权的起点。有了明确的绑定才有了所有权的归属，同时解绑定的时机也确定了资源释放的时机。</p>
<p>所有权规则：</p>
<ul>
<li>每一个值都有其所有者变量</li>
<li>同一时间所有者变量只能有一个</li>
<li>所有者离开作用域，值被丢弃(释放/析构)</li>
</ul>
<p>作为所有者，它有如下权利：</p>
<ul>
<li>控制资源的释放</li>
<li>出借所有权</li>
<li>转移所有权</li>
</ul>
<h2><a class="header" href="#4所有权的转移" id="4所有权的转移">4.所有权的转移</a></h2>
<p>所有者的重要权利之一就是“转移所有权”。这引申出三个问题：</p>
<ol>
<li>为什么要转移？</li>
<li>什么时候转移？</li>
<li>什么方式转移？</li>
</ol>
<p>相关的语言概念如下图。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_5.jpg">
<center>图 5所有权转移</center>
<p><strong>为什么要转移所有权？</strong>
我们知道，C/C++/Rust 的变量关联了某个内存区域，但变量总会在表达式中进行操作再赋值给另一个变量，或者在函数间传递。实际上期望被传递的是变量绑定的内存区域的内容，如果这块内存区域比较大，复制内存数据到给新的变量就是开销很大的操作。所以需要把所有权转移给新的变量，同时当前变量放弃所有权。所以归根结底，转移所有权还是为了性能。</p>
<p><strong>所有权转移的时机总结下来有以下两种情况：</strong></p>
<ol>
<li>位置表达式出现在值上下文时转移所有权</li>
<li>变量跨作用域传递时转移所有权</li>
</ol>
<p>第一条规则是一个精确的学术表达，涉及到位置表达式，值表达式，位置上下文，值上下文等语言概念。它的简单理解就是各种各样的赋值行为。能明确指向某一个内存区域位置的表达式是位置表达式，其它的都是值表达式。各种带有赋值语义的操作的左侧是位置上下文，右侧是值上下文。</p>
<p>当位置表达式出现在值上下文时，其程序语义就是要把这边位置表达式所指向的数据赋给新的变量，所有权发生转移。</p>
<p>第二条规则是“变量跨作用域时转移所有权”。</p>
<p>图上列举出了几种常见的跨作用域行为，能涵盖大多数情况，也有简单的示例代码</p>
<ul>
<li>变量被花括号内使用</li>
<li>match 匹配</li>
<li>if let 和 While let</li>
<li>移动语义函数参数传递</li>
<li>闭包捕获移动语义变量</li>
<li>变量从函数内部返回</li>
</ul>
<p>为什么变量跨作用域要转移所有权？在 <code>C/C++</code> 代码中，是否转移所有权是程序员自己隐式或显式指定的。</p>
<p>试想，在 <code>C/C++</code> 代码中，函数 <code>Fun1</code> 在栈上创建一个 类型 <code>A</code> 的实例 <code>a</code>， 把它的指针 <code>&amp;a</code> 传递给函数 <code>void fun2(A* param)</code> 我们不会希望 <code>fun2</code> 释放这个内存，因为 <code>fun1</code> 返回时，栈上的空间会自动被释放。</p>
<p>如果 <code>fun1</code> 在堆上创建 <code>A</code> 的实例 <code>a</code>， 把它的指针 <code>&amp;a</code> 传递给函数 <code>fun2(A* param)</code>,那么关于 <code>a</code> 的内存空间的释放，<code>fun1</code> 和 <code>fun2</code> 之间需要有个商量，由谁来释放。<code>fun1</code> 可能期望由 <code>fun2</code> 来释放，如果由 <code>fun2</code> 释放，则 <code>fun2</code> 并不能判断这个指针是在堆上还是栈上。归根结底，还是谁拥有 <code>a</code> 指向内存区的所有权问题。 <code>C/C++</code> 在语言层面上并没有强制约束。<code>fun2</code> 函数设计的时候，需要对其被调用的上下文做假定，在文档中对对谁释放这个变量的内存做约定。这样编译器实际上很难对错误的使用方式给出警告。</p>
<p><code>Rust</code> 要求变量在跨越作用域时明确转移所有权，编译器可以很清楚作用域边界内外哪个变量拥有所有权，能对变量的非法使用作出明确无误的检查，增加的代码的安全性。</p>
<p><strong>所有权转移的方式有两种：</strong></p>
<ul>
<li>移动语义-执行所有权转移</li>
<li>复制语义-不执行转移，只按位复制变量</li>
</ul>
<p>这里我把 ”复制语义“定义为所有权转移的方式之一，也就是说“不转移”也是一种转移方式。看起来很奇怪。实际上逻辑是一致的，因为触发复制执行的时机跟触发转移的时机是一致的。只是这个数据类型被打上了 <code>Copy</code> 标签 <code>trait</code>, 在应该执行转移动作的时候，编译器改为执行按位复制。</p>
<p><code>Rust</code> 的标准库中为所有基础类型实现的 <code>Copy Trait</code>。</p>
<p>这里要注意，标准库中的</p>
<pre><code class="language-Rust"> impl&lt;T: ?Sized&gt; Copy for &amp;T {}
</code></pre>
<p>为所有引用类型实现了 <code>Copy</code>, 这意味着我们使用引用参数调用某个函数时，引用变量本身是按位复制的。标准库没有为可变借用 <code>&amp;mut T</code> 实现“Copy” <code>Trait</code> , 因为可变借用只能有一个。后文讲闭包捕获变量的所有权时我们可以看到例子。</p>
<h2><a class="header" href="#5所有权的借用" id="5所有权的借用">5.所有权的借用</a></h2>
<p>变量拥有一个内存区域所有权，其所有者权利之一就是“出借所有权”。</p>
<p>与出借所有权相关的概念关系如图 6</p>
<img src="chapter_1/./rust_ownership/rust_ownership_6.jpg">
<center>图 6出借所有权</center>
<p>拥有所有权的变量借出其所有权有“引用”和“智能指针”两种方式：</p>
<ul>
<li>
<p>引用（包含可变借用和不可变借用)</p>
</li>
<li>
<p>智能指针</p>
<ul>
<li>独占式智能指针 <code>Box&lt;T&gt;</code></li>
<li>非线程安全的引用计数智能指针 <code>Rc&lt;T&gt;</code></li>
<li>线程安全的引用计数智能指针 <code>Arc&lt;T&gt;</code></li>
<li>弱指针 <code>Weak&lt;T&gt;</code></li>
</ul>
</li>
</ul>
<p>引用实际上也是指针，指向的是实际的内存位置。</p>
<p>借用有两个重要的安全规则：</p>
<ol>
<li>代表借用的变量，其生命周期不能比被借用的变量(所有者)的生命周期长</li>
<li>同一个变量的可变借用只能有一个</li>
</ol>
<p>第一条规则就是确保不出现“悬垂指针”的内存安全问题。如果这条规则被违反，例如：变量 <code>a</code> 拥有存储区域的所有权，变量 <code>b</code> 是 <code>a</code> 的某种借用形式，如果 <code>b</code> 的生命周期比 <code>a</code> 长，那么 <code>a</code> 被析构后存储空间被释放，而 <code>b</code> 仍然可以使用，则 <code>b</code> 就成为了悬垂指针。</p>
<p>第二条是不允许有两个可变借用，避免出现数据一致性问题。</p>
<pre><code class="language-Rust">Struct Foo{v:i32}
fn main(){
    let mut f = Foo{v:10};
    let im_ref = &amp;f;        // 获取不可变引用
    let mut_ref = &amp; mut f;  // 获取可变引用
    //println!(&quot;{}&quot;,f.v);
    //println!(&quot;{}&quot;,im_ref.v);
    //println!(&quot;{}&quot;,mut_ref.v);
}
</code></pre>
<p>变量 <code>f</code> 拥有值的所有权，<code>im_ref</code> 是其不可变借用，<code>mut_ref</code> 是其可变借用。以上代码是可以编译过去的，但是这几个变量都没有被使用，这种情况下编译器并不禁止你同时拥有可变借用和不可变借用。最后的三行被注释掉的代码(6,7,8)使用了这些变量。打开一行或多行这些注释的代码，编译器会报告不同形式的错误：</p>
<table><thead><tr><th>开放注释行</th><th>编译器报告</th></tr></thead><tbody>
<tr><td>6</td><td>正确</td></tr>
<tr><td>7</td><td>第 5 行错误：不能获得 f 的可变借用，因为已经存在不可变借用</td></tr>
<tr><td>8</td><td>正确</td></tr>
<tr><td>6, 7</td><td>第 5 行错误：不能获得 f 的可变借用，因为已经存在不可变借用</td></tr>
<tr><td>6,8</td><td>第 6 行错误：不能获得 f 的不可变借用，因为已经存在可变借用</td></tr>
</tbody></table>
<p><strong>对&quot;借用&quot; 的抽象表达</strong></p>
<p><code>Rust</code> 的核心包中有两个泛型 <code>trait</code> ，<a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">core::borrow::Borrow</a> 与 <a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html">core::borrow::BorrowMut</a>，可以用来表达&quot;借用&quot;的抽象含义，分别代表可变借用和不可变借用。
前面提到，“借用”有多种表达形式 <code>（&amp;T,Box&lt;T&gt;，Rc&lt;T&gt; 等等）</code>，在不同的使用场景中会选择合适的借用表达方式。它们的抽象形式就可以用 <a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">core::borrow::Borrow</a> 来代表. 从类型关系上， <code>Borrow</code> 是&quot;借用&quot; 概念的抽象形式。从实际应用上，某些场合我们希望获得某个类型的“借用”，同时希望能支持所有可能的“借用”形式，<code>Borrow Trait</code> 就有用武之地。</p>
<p>Borrow 的定义如下：</p>
<pre><code class="language-Rust">pub trait Borrow&lt;Borrowed: ?Sized&gt; {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
</code></pre>
<p>它只有一个方法，要求返回指定类型的引用。</p>
<p><code>Borrow</code> 的文档中有提供例子</p>
<pre><code class="language-Rust">use std::borrow::Borrow;

fn check&lt;T: Borrow&lt;str&gt;&gt;(s: T) {
    assert_eq!(&quot;Hello&quot;, s.borrow());
}

fn main(){
    let s: String = &quot;Hello&quot;.to_string(); 
    check(s);

    lets: &amp;str = &quot;Hello&quot;; 
    check(s);
}
</code></pre>
<p><code>check</code> 函数的参数表示它希望接收一个 “str”类型的任何形式的“借用”，然后取出其中的值与 “Hello”进行比较。</p>
<p>标准库中为 <code>String</code> 类型实现了 <code>Borrow&lt;str&gt;</code>,代码如下</p>
<pre><code class="language-Rust">impl Borrow&lt;str&gt; for String{
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str{
        &amp;self[..]
    }
}
</code></pre>
<p>所以 <code>String</code> 类型可以作为 <code>check</code> 函数的参数。</p>
<p>从图上可以看出，标准库为所有类型 <code>T</code> 实现了 <code>Borrow Trait</code>, 也为 <code>&amp;T</code> 实现了 <code>Borrow Trait</code>。</p>
<p>代码如下 ，这如何理解。</p>
<pre><code class="language-Rust">impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for T {
    fn borrow(&amp;self) -&gt; &amp;T { // 是 fn borrow(self: &amp;Self）的缩写，所以 self 的类型就是 &amp;T
        self
    }
}

impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for &amp;T {
    fn borrow(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
</code></pre>
<p>这正是 <code>Rust</code> 语言很有意思的地方，非常巧妙的体现了语言的一致性。既然 <code>Borrow&lt;T&gt;</code> 的方法是为了能获取 <code>T</code> 的引用，那么类型 <code>T</code> 和 <code>&amp;T</code> 当然也可以做到这一点。在 <code>Borrow for T</code> 的实现中，</p>
<p><code>fn borrow(&amp;self)-&gt;&amp;T</code> 是 <code>fn borrow(self: &amp;Self)-&gt;&amp;T</code> 的缩写，所以 <code>self</code> 的类型就是 <code>&amp;T</code>,可以直接被返回。在 <code>Borrow for &amp;T</code> 的实现中，<code>fn borrow(&amp;self)-&gt;&amp;T</code> 是 <code>fn borrow(self: &amp;Self)-&gt;&amp;T</code> 的缩写，所以 <code>self</code> 的类型就是 <code>&amp;&amp;T</code>, 需要被两次解引用得到 <code>T</code>, 再返回其引用。</p>
<p>智能指针 <code>Box&lt;T&gt;</code>,<code>Rc&lt;T&gt;</code>,<code>Arc&lt;T&gt;</code>,都实现了 <code>Borrow&lt;T&gt;</code> ，其获取 <code>&amp;T</code> 实例的方式都是两次解引用在取引用。<code>Weak&lt;T&gt;</code> 没有实现 <code>Borrow&lt;T&gt;</code>, 它需要升级成 <code>Rc&lt;T&gt;</code> 才能获取数据。</p>
<h2><a class="header" href="#6生命周期参数" id="6生命周期参数">6.生命周期参数</a></h2>
<p>变量的生命周期主要跟变量的作用域有关，在大部分程序语言中都是隐式定义的。<code>Rust</code> 中能显式声明变量的生命周期参数，这是非常独特的设计，其语法特性在其他语言也是不太可能见到的。以下是生命周期概念相关的图示。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_7.jpg">
<center>图 7生命周期</center>
<p><strong>生命周期参数的作用</strong></p>
<p>生命周期参数的核心作用就是解决悬垂指针问题。就是让编译器帮助检查变量的生命周期，防止出现变量指向的内存区域被释放后，变量仍然可以使用的问题。那么什么情况下会让编译器无法判断生命周期，而必须引入一个特定语法来对生命周期进行标识？</p>
<p>我们来看看最常见的悬垂指针问题，函数以引用方式返回函数内部的局部变量：</p>
<pre><code class="language-Rust">struct V{v:i32}
 
fn bad_fn() -&gt; &amp;V{  //编译错误：期望一个命名的生命周期参数
    let a = V{v:10};
    &amp;a
}
let  res = bad_fn();
</code></pre>
<p>这个代码是一个典型的悬垂指针错误，<code>a</code> 是函数内的局部变量，函数返回后 <code>a</code> 就被销毁，把 <code>a</code> 的引用赋值给 <code>res</code> ，如果能执行成功，<code>res</code> 绑定的就是未定义的值。</p>
<p>但编译器并不是报告悬垂指针错误，而是说返回类型 <code>&amp;V</code> 没有指定生命周期参数。<code>C++</code> 的类似代码编译器会给出悬垂指针的警告（警告内容:局部变量的地址被返回了）。</p>
<p>那我们指定一个生命周期参数看看：</p>
<pre><code class="language-Rust">fn bad_fn&lt;'a&gt;() -&gt; &amp;'a V{
    let a = V{v:10};
    let ref_a = &amp;a;
    ref_a   //编译错误：不能返回局部变量的引用
}
</code></pre>
<p>这次编译器报告的是悬垂指针错误了。那么编译器的分析逻辑是什么？</p>
<p>首先我们明确一下 <font color=#fa8919>'a 在这里的精确语义到底是什么？</font></p>
<p>函数将要返回的引用会代表一个内存数据，这个数据有其生命周期范围，<code>'a</code> 参数是对这个生命周期范围提出的要求。就像 <code>&amp;V</code> 是对返回值类型提的要求类似，<strong>'a 是对返回值生命周期提的要求</strong>。编译器需要检查的就是实际返回的数据，其生命是否符合要求。</p>
<p>那么 <font color=#fa8919>'a 参数对返回值的生命周期到底提出了什么要求？</font></p>
<p>我们先区分一下&quot;函数上下文&quot;和“调用者上下文”，函数上下文是指函数体内部的作用域范围，调用者上下文是指该函数被调用的位置。上述的悬垂指针错误其实并不会影响函数上下文范围的程序执行，出问题的地方是调用者上下文拿到一个无效引用并使用时，会出现不可预测的错误。</p>
<p>函数返回的引用会在“调用者上下文”中赋予某个变量，如：</p>
<pre><code class="language-Rust">let res = bod_fn();
</code></pre>
<p><code>res</code> 获得了返回的引用, 函数内的 <code>ref_a</code> 引用会按位复制给变量 <code>res</code> （标准库中 <code>impl&lt;T: ?Sized&gt; Copy for &amp;T {}</code> 指定了此规则）<code>res</code> 会指向 函数内 <code>res_a</code> 同样的数据。为了保证将来在调用者上下文不出悬垂指针，编译器真正要确保的是 <code>res</code> 所指向的数据的生命周期，不短于 <code>res</code> 变量自己的生命周期。否则如果数据的生命周期短，先被释放，<code>res</code> 就成为悬垂指针。</p>
<p>可以把这里的 <code>'a</code> 参数理解为调用者上下文中接收函数返回值的变量 <code>res</code> 的生命周期，那么 <code>'a</code> 对函数体内部返回引用的要求是：<strong>返回引用所指代数据的生命周期不短于 'a ，也就是不短于调用者上下文接收返回值的变量的生命周期。</strong></p>
<p>上述例子中函数内 <code>ref_a</code> 指代的数据生命周期就是函数作用域，函数返回前，数据被销毁，生命周期小于调用者上下文的 <code>res</code>, 编译器根据 返回值的生命周期要求与实际返回值做比较，发现了错误。</p>
<p>实际上，返回的引用或者是静态生命周期，或者是根据函数输入的引用参数通过运算变换得来的，否则都是这个结果，因为都是对局部数据的引用。</p>
<p><strong>静态生命周期</strong></p>
<p>看函数</p>
<pre><code class="language-Rust">fn get_str&lt;'a&gt;() -&gt; &amp;'a str {
    let s = &quot;hello&quot;;
    s
}
</code></pre>
<p>这个函数可以编译通过，返回的引用虽然不是从输入参数推导，不过是静态生命周期，可以通过检查。</p>
<p>因为静态生命周期可以理解为“无穷大”的语义，实际是跟进程的生命周期一致，也就是在程序运行期间始终有效。</p>
<p><code>Rust</code> 的字符串字面量是存储在程序代码中，程序加载后在代码空间，始终有效。可以通过一个简单试验验证这一点：</p>
<pre><code class="language-Rust">let s1=&quot;Hello&quot;;
println!(&quot;&amp;s1:{:p}&quot;, &amp;s1);//&amp;s1:0x9cf918

let s2=&quot;Hello&quot;;
println!(&quot;&amp;s2:{:p}&quot;,&amp;s2);//&amp;s2:0x9cf978
//s1,s2是一样的值但是地址不一样，是两个不同的引用变量

let ptr1: *const u8 = s1.as_ptr();
println!(&quot;ptr1:{:p}&quot;, ptr1);//ptr1:0x4ca0a0

let ptr2: *const u8 = s2.as_ptr();
println!(&quot;ptr2:{:p}&quot;, ptr2);//ptr2:0x4ca0a0
</code></pre>
<p><code>s1</code>,<code>s2</code> 的原始指针都指向同一个地址，说明编译器为 &quot;Hello&quot; 字面量只保存了一份拷贝，所有引用都指向它。</p>
<p><code>get_str</code> 函数中静态生命周期长于返回值要求的<code>'a</code>，所以是合法的。</p>
<p>如果把 <code>get_str</code> 改成</p>
<pre><code class="language-Rust">fn get_str&lt;'a&gt;() -&gt; &amp;'static str
</code></pre>
<p>即把对返回值生命周期的要求改为无穷大，那就只能返回静态字符串引用了。</p>
<p><strong>函数参数的生命周期</strong></p>
<p>前面的例子为了简单起见，没有输入参数，这并不是一个典型的情况。大多数情况下，函数返回的引用是根据输入的引用参数通过运算变换而来。比如下面的例子：</p>
<pre><code class="language-Rust">fn  remove_prefix&lt;'a&gt;(content:&amp;'a str,prefix:&amp;str) -&gt; &amp;'a str{
    if content.starts_with(prefix){
        let start:usize = prefix.len();
        let end:usize = content.len();
        let sub = content.get(start..end).unwrap();
        sub
    }else{
        content
    }
}
let  s = &quot;reload&quot;;
let sub = remove_prefix(&amp;s0,&quot;re&quot;);
println!(&quot;{}&quot;,sub); // 输出: load
</code></pre>
<p><code>remove_prefix</code> 函数从输入的 <code>content</code> 字符串中判断是否有 <code>prefix</code> 代表的前缀。 如果有就返回 <code>content</code> 不包含前缀的切片，没有就返回 <code>content</code> 本身。</p>
<p>无论如何这个函数都不会返回前缀 <code>prefix</code> ，所以 <code>prefix</code> 变量不需要指定生命周期。</p>
<p>函数两个分支返回的都是通过 <code>content</code> 变量变换出来的，并作为函数的返回值。所以 <code>content</code> 必须标注生命周期参数，编译器要根据 <code>content</code> 的生命周期参数与返回值的要求进行比较，判断是否符合要求。即：<strong>实际返回数据的生命周期，大于或等于返回参数要求的生命周期。</strong></p>
<p>前面说到，我们把返回参数中指定的生命周期参数 <code>'a</code> 看做调用者上下文中接收返回值的变量的生命周期，在这个例子中就是字符串引用 <code>sub</code>，<font color=#fa8919>那么输入参数中的 'a 代表什么意思 ？</font></p>
<p>这在 <code>Rust</code> 语法设计上是一个很让人困惑的地方，输入参数和输出参数的生命周期都标志为 <code>'a</code> ，似乎是要求两者的生命周期要求一致，但实际上并不是这样。</p>
<p>我们先看看如果输入参数的生命周期跟输出参数期待的不一样是什么情况，例如下面两个例子：</p>
<pre><code class="language-Rust">fn echo&lt;'a, 'b&gt;(content: &amp;'b str) -&gt; &amp;'a str {
    content //编译错误：引用变量本身的生命周期超过了它的借用目标
}
fn longer&lt;'a, 'b&gt;(s1: &amp;'a str, s2: &amp;'b str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len()
        { s1 }
    else
        { s2 }//编译错误：生命周期不匹配
}
</code></pre>
<p><code>echo</code> 函数输入参数生命周期标注为 <code>'b</code> , 返回值期待的是 <code>'a</code> .编译器报错信息是典型的“悬垂指针”错误。不过内容似乎并不明确。编译器指出查阅详细信息 <a href="https://doc.rust-lang.org/error-index.html#E0312">--explain E0312</a> ，这里的解释是&quot;借用内容的生命周期与期待的不一致&quot;。这个错误描述就与实际的错误情况是相符合的了。</p>
<p><code>longer</code> 函数两个参数分别具有生命周期 <code>'a</code> 和 <code>'b</code> , 返回值期待 <code>'a</code> ,当返回 <code>s2</code> 时，编译器报告生命周期不匹配。把 <code>longer</code> 函数中的生命周期 <code>'b</code> 标识为比 <code>'a</code> 长，就可以正确编译了。</p>
<pre><code class="language-Rust">fn longer&lt;'a, 'b: 'a&gt;(s1: &amp;'a str, s2: &amp;'b str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len()
        { s1 }
    else
        { s2 }//编译通过
}
</code></pre>
<p>回到我们前面的问题，<font color=#fa8919>那么输入参数中的 'a 代表什么意思 ？</font></p>
<p>我们知道编译器在函数定义上下文中所做的生命周期检查就是要确保”<strong>实际返回数据的生命周期，大于或等于返参数要求的生命周期</strong>“。当输入参数给出与返回值一样的生命周期参数 <code>'a</code> 时，实际上是人为地向编译器保证：<strong>在调用者上下文中，实际给出的函数输入参数的生命周期，不小于将来用于接收返回值的变量的生命周期。</strong></p>
<p>当有两个生命周期参数 <code>'a</code> <code>'b</code> , 而 <code>'b</code> 大于 <code>'a</code>，当然 也保证了在调用者上下文 <code>'b</code> 代表的输入参数生命周期也足够长。</p>
<p>在函数定义中，编译器并不知道将来实际调用这个函数的上下文是怎么样的。生命周期参数相当是函数上下文与调用者上下文之间关于参数生命周期的协议。</p>
<p>就像函数签名中的类型声明一样，类型声明约定了与调用者之间输入输出参数的类型，编译器编译函数时，会检查函数体返回的数据类型与声明的返回值是否一致。同样对与参数与返回值的生命周期，函数也会检查函数体中返回的变量生命周期与声明的是否一致。</p>
<p>前面说的是编译器在“<strong>函数定义上下文的生命周期检查</strong>”机制，这只是生命周期检查的一部分，还有另一部分就是“<strong>调用者上下文对生命周期的检查</strong>”机制。两者检查的规则如下：</p>
<p><strong>函数定义上下文的生命周期检查：</strong></p>
<p>函数签名中返回值的生命周期标注可以是输入标注的任何一个，只要保证由输入参数推导出来的返回的临时变量的生命周期，比函数签名中返回值标注的生命周期相等或更长。这样保证了调用者上下文中，接收返回值的变量，不会因为输入参数失效而成为悬垂指针。</p>
<p><strong>调用者上下文对生命周期的检查：</strong></p>
<p>调用者上下文中，接收函数返回借用的变量 <code>res</code> ，其生命周期不能长于返回的借用的生命周期(实际是根据输入借用参数推导出来的)。否则 <code>res</code> 会在输入参数失效后成为悬垂指针。</p>
<p>前面 <code>remove_prefix</code> 函数编译器已经校验合格，那么我们在调用者上下文中构建如下例子</p>
<pre><code class="language-Rust">let res: &amp;str;
{
    let s = String::from(&quot;reload&quot;);
    res = remove_prefix(&amp;s, &quot;re&quot;) //编译错误：s 的生命周期不够长
}
println!(&quot;{}&quot;, res);
</code></pre>
<p>这个例子中 <code>remove_prefix</code> 被调用这一行，编译器会报错 “s 的生命周期不够长”。代码中的 大括号创建了一个新的词法作用域，导致 <code>res</code> 的生命周期比大括号内部的 <code>s</code> 更长。这不符合函数签名中对生命周期的要求。函数签名要求输入参数的生命周期不短于返回值要求的生命周期。</p>
<p><strong>结构体定义中的生命周期</strong></p>
<p>结构体中有引用成员时，就会有潜在的悬垂指针问题，需要标识生命周期参数来让编译器帮助检查。</p>
<pre><code class="language-Rust">struct G&lt;'a&gt;{ m:&amp;'a str}
 
fn get_g() -&gt; () {
    let g: G;
    {
        let  s0 = &quot;Hi&quot;.to_string();
        let  s1 = s0.as_str();              //编译错误：借用值存活时间不够长
        g = G{ m: s1 };
    }
    println!(&quot;{}&quot;, g.m);
}
</code></pre>
<p>上面的例子中，结构体 <code>G</code> 包含了引用成员，不指定生命周期参数是无法编译的。函数 <code>get_g</code> 演示了在使用者上下文中如何出现生命周期不匹配的情况。</p>
<p>结构体的生命周期定义就是要保证在一个结构体实例中，其引用成员的生命周期不短于结构体实例自身的生命周期。否则如果结构体实例存活期间，其引用成员的数据先被销毁，那么访问这个引用成员时就构成了对悬垂指针的访问。</p>
<p>实际上结构体的生命周期参数可以和函数生命周期参数做类比，成员的生命周期相当函数的输入参数的生命周期，结构体整体的生命周期相当函数返回值的生命周期。这样所有之前对函数生命周期参数的分析一样可以适用。</p>
<p>如果结构体有方法成员会返回引用参数，方法同样需要填写生命周期参数。返回的引用来源可以是方法的输入引用参数，也可以是结构体的引用成员。在做生命周期分析的时候，可以把“方法的输入引用参数”和“结构体的引用成员”都看做普通函数的输入参数，这样前面对普通函数参数和返回值的生命周期分析方法可以继续套用。</p>
<p><strong>泛型的生命周期限定</strong></p>
<p>前文说过生命周期参数跟类型限定很像，比如在代码</p>
<pre><code class="language-Rust">fn longer&lt;'a&gt;(s1:&amp;'a str, s2:&amp;'a str) -&gt; &amp;'a str
 
struct G&lt;'a&gt;{ m:&amp;'a str }
</code></pre>
<p>中，<code>'a</code> 出现的位置参数类型旁边，一个对参数的静态类型做限定，一个对参数的动态时间做限定。<code>'a</code> 使用前需要先声明，声明的位置与模板参数的位置一样，在 <code>&lt;&gt;</code> 括号内，也是用来放泛型的类型参数的地方。</p>
<p>那么，<font color=#fa8919>把类型换成泛型可以吗，语义是什么？使用场景是什么？</font></p>
<p>我们看看代码例子：</p>
<pre><code class="language-Rust">use std::cmp::Ordering;

#[derive(Eq, PartialEq, PartialOrd, Ord)]
struct G&lt;'a, T:Ord&gt;{ m: &amp;'a T }
 
#[derive(Eq, PartialEq, PartialOrd, Ord)]
struct Value{ v: i32 }
 
fn longer&lt;'a, T:Ord&gt;(s1: &amp;'a T, s2: &amp;'a T) -&gt; &amp;'a T {
    if s1 &gt; s2 { s1 } else { s2 }
}
 
fn main(){
    let v0 = Value{ v:12 };
    let v1 = Value{ v:15 };
    let res_v = longer(&amp;v0, &amp;v1);
    println!(&quot;{}&quot;, res_v.v);//15
     
    let g0 = G{ m: &amp;v0 };
    let g1 = G{ m: &amp;v1 };
    let res_g = longer(&amp;g0, &amp;g1);//15
    println!(&quot;{}&quot;, res_g.m.v);
}
</code></pre>
<p>这个例子扩展了 <code>longer</code> 函数，可以对任何实现了 <code>Ord trait</code> 的类型进行操作。 <code>Ord</code> 是核心包中的一个用于实现比较操作的内置 <code>trait</code>. 这里不细说明。<code>longer</code> 函数跟前一个版本比较，只是把 <code>str</code> 类型换成了泛型参数 <code>T</code>, 并给 <code>T</code> 增加了类型限定 <code>T:Ord</code>.</p>
<p>结构体 <code>G</code> 也扩展成可以容纳泛型 <code>T</code>,但要求 <code>T</code> 实现了 <code>Ord trait</code>.</p>
<p>从代码及执行结果看，跟 把 <code>T</code> 当成普通类型一样，没有什么特别，生命周期参数依然是他原来的语义。</p>
<p>但实际上 &quot;<code>&amp;'a T</code>&quot; 还隐含另一层语义：<strong>如果 <code>T</code> 内部含有引用成员，那么其中的引用成员的生命周期要求不短于 <code>T</code> 实例的生命周期。</strong></p>
<p>老规矩，我们来构造一个反例。结构体 <code>G</code> 内部包含一个泛型的引用成员，我们将 <code>G</code> 用于 <code>longer</code> 函数，但是让 <code>G</code> 内部的引用成员生命周期短于 <code>G</code>。代码如下：</p>
<pre><code class="language-Rust">fn  main(){
    let v0 = Value{ v:12 };
    let v1_ref: &amp;Value;      // 将 v1 的引用定义在下面大括号之外，有意延长变量的生命周期范围
    let res_g: &amp;G&lt;Value&gt;;

    {
        let v1 = Value{ v:15 };
        v1_ref = &amp;v1;      //编译错误：v1的生命周期不够长。
        let res_v = longer(&amp;v0,v1_ref);
        println!(&quot;{}&quot;,res_v.v);
    }

    let g0 = G{ m:&amp;v0 };
    let g1 = G{ m:v1_ref };   // 这时候 v1_ref 已经是悬垂指针
    res_g = longer(&amp;g0, &amp;g1);
    println!(&quot;{}&quot;, res_g.m.v);
}
</code></pre>
<p>变量 <code>g1</code> 自身的生命周期是满足 <code>longer</code> 函数要求的，但是其内部的引用成员，生命周期过短。</p>
<p>这个范例是在“调用者上下文”检查时触发的，对泛型参数的生命周期限定比较难设计出在“函数定义或结构体定义上下文”触发的范例。毕竟 <code>T</code> 只是类型指代，定义时还没有具体类型。</p>
<p>实际上要把在 “<code>struct G&lt;'a,T&gt;{m:&amp;'a T}</code>中，<code>T</code> 的所有引用成员的生命周期不短于<code>'a</code> ”这个语义准确表达，应该写成：</p>
<pre><code class="language-Rust">struct G&lt;'a,T:'a&gt;{m:&amp;'a T}
</code></pre>
<p>因为 <code>T:'a</code> 才是这个语义的明确表述。但是第一种表达方式也是足够的(我用反证法证明了这一点)。所以编译器也接受第一种比较简化的表达形式。</p>
<p>总而言之，泛型参数的生命周期限定是两层含义，一层是泛型类型当做一个普通类型时一样的含义，一层是对泛型内部引用成员的生命周期约束。</p>
<p><strong>Trait 对象的生命周期</strong></p>
<p>看如下代码</p>
<pre><code class="language-Rust">trait Foo{}
struct Bar{v:i32}
struct Qux&lt;'a&gt;{m:&amp;'a  i32}
struct Baz&lt;'a,T&gt;{v:&amp;'a T}
 
impl Foo for Bar{}
impl&lt;'a&gt; Foo for Qux&lt;'a&gt;{}
impl&lt;'a,T&gt; Foo for Baz&lt;'a,T&gt;{}
</code></pre>
<p>结构体 <code>Bar</code>,<code>Qux</code>,<code>Baz</code> 都实现了 <code>trait Foo</code>, 那么 <code>&amp;Foo</code> 类型可以接受这三个结构体的任何一个的引用类型。</p>
<p>我们把 <code>&amp;Foo</code> 称为 <code>Trait</code> 对象。</p>
<p><code>Trait</code> 对象可以理解为类似其它面向对象语言中，指向接口或基类的指针或引用。其它<code>OO</code>语言指向基类的指针在运行时确定其实际类型。<code>Rust</code> 没有类继承，指向 <code>trait</code> 的指针或引用起到类似的效果，运行时被确定具体类型。所以编译期间不知道大小。</p>
<p><code>Rust</code> 的 <code>Trait</code> 不能有非静态数据成员，所以 <code>Trait</code> 本身就不会出现引用成员的生命周期小于对象自身，所以 <code>Trait</code> 对象默认的生命周期是静态生命周期。我们看下面三个函数：</p>
<pre><code class="language-Rust">fn check0() -&gt; &amp;'static Foo { // 如果不指定 'static , 编译器会报错，要求指定生命周期命参数, 并建议 'static
    const b:Bar = Bar{v:0};
    &amp;b
}
fn check1&lt;'a&gt;() -&gt; &amp;'a Foo { //如果不指定 'a , 编译器会报错
    const b:Bar = Bar{v:0};
    &amp;b
}
fn check2(foo:&amp;Foo) -&gt; &amp;Foo {//生命周期参数被省略，不要求静态生命周期
    foo
}
fn check3(foo:&amp;'static Foo) -&gt; &amp;'static Foo {
    foo
}
fn main(){
    let bar= Bar{v:0};
    check2(&amp;bar);                               //能编译通过，说明 chenk2 的输入输出参数都不是静态生命周期
    //check3(&amp;bar);                          //编译错误：bar的生命周期不够长
    const bar_c:Bar =Bar{v:0};
    check3(&amp;bar_c);                         // check3 只能接收静态参数
}
</code></pre>
<p><code>check0</code> 和 <code>check1</code> 说明将 <code>Trait</code> 对象的引用作为 函数参数返回时，跟返回其他引用类型一样，都需要指定生命周期参数。函数 <code>check2</code> 的生命周期参数只是被省略了(编译器可以推断)，但这个函数里的 <code>Trait</code> 对象并不是静态生命周期，这可以从 <code>main</code> 函数内能成功执行 <code>check2(bar)</code> 分析出来，因为 <code>bar</code> 不是静态生命周期.</p>
<p>实际上在运行时，<code>Trait</code> 对象总会动态绑定到一个实现了该 <code>Trait</code> 的具体结构体类型(如 <code>Bar</code>,<code>Qux</code>,<code>Baz</code> 等)，这个具体类型的在其上下文中有它的生命周期，可以是静态的，更多情况下是非静态生命周期 <code>'a</code> ，那么 <code>Trait</code> 对象的生命周期也是 <code>'a</code>.</p>
<table><thead><tr><th></th><th>结构体或成员生命周期</th><th>Trait 对象生命周期</th></tr></thead><tbody>
<tr><td>Foo</td><td>无</td><td>'static</td></tr>
<tr><td>Bar</td><td>'a</td><td>'a</td></tr>
<tr><td>Qux&lt;'a&gt;{m:&amp;'a str}</td><td>'a</td><td>'a</td></tr>
<tr><td>Baz&lt;'a,T&gt;{v:&amp;'a T}</td><td>'a</td><td>'a</td></tr>
</tbody></table>
<pre><code class="language-Rust">fn qux_update&lt;'a&gt;(qux: &amp;'a mut Qux&lt;'a&gt;, new_value: &amp;'a i32)-&gt;&amp;'a Foo {
    qux.v = new_value;
    qux
}

let value = 100;
let mut qux = Qux{v: &amp;value};
let new_value = 101;
let muted: &amp;dyn Foo = qux_update(&amp; mut qux, &amp;new_value);
qux_update 函数的智能指针版本如下：
 
fn qux_box&lt;'a&gt;(new_value: &amp;'a  i32) -&gt; Box&lt;Foo +'a&gt; {
    Box::new(Qux{v:new_value})
}
 
let new_value = 101;
let boxed_qux:Box&lt;dyn Foo&gt; = qux_box(&amp;new_value);
</code></pre>
<p>返回的智能指针中，<code>Box</code> 装箱的类型包含了引用成员，也需要给被装箱的数据指定生命周期，语法形式是在被装箱的类型位置增加生命周期参数，用 &quot;+&quot; 号连接。</p>
<p>这两个版本的代码其实都说明一个问题，就是 <code>Trait</code> 虽然默认是静态生命周期，但实际上，其生命周期是由具体实现这个 <code>Trait</code> 的结构体的生命周期决定，推断方式跟之前叙述的函数参数生命周期并无太大区别。</p>
<h2><a class="header" href="#7智能指针的所有权与生命周期" id="7智能指针的所有权与生命周期">7.智能指针的所有权与生命周期</a></h2>
<p>如图 6，在 <code>Rust</code> 中引用和智能指针都算是“指针”的一种形态，所以他们都可以实现 <a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">std::borrow::Borrow</a> <code>Trait</code>。一般情况下，我们对栈中的变量获取引用，栈中的变量存续时间一般比较短，当前的作用域退出时，作用域范围内的栈变量就会被回收。如果我们希望变量的生命周期能跨越当前的作用域，甚至在线程之间传递，最好是把变量绑定的数据区域创建在堆上。</p>
<p>栈上的变量其作用域在编译期间就是明确的，所以编译器能够确定栈上的变量何时会被释放，结合生命周期参数生命，编译器能找到绝大部分对栈上变量的错误引用。</p>
<p>堆上变量其的内存管理比栈变量要复杂很多。在堆上分配一块内存之后，编译器无法根据作用域来判断这块内存的存活时间，必须由使用者显式指定。<code>C</code> 语言中就是对于每一块通过 <code>malloc</code> 分配到的内存，需要显式的使用 <code>free</code> 进行释放。<code>C++</code>中是 <code>new / delete</code>。但是什么时候调用 <code>free</code> 或 <code>delete</code> 就是一个难题。尤其当代码复杂，分配内存的代码和释放内存的代码不在同一个代码文件，甚至不在同一个线程的时候，仅仅靠人工跟踪代码的逻辑关系来维护分配与释放就难免出错。</p>
<p>智能指针的核心思想是让系统自动帮我们决定回收内存的时机。其主要手段就是“<strong>将内存分配在堆上，但指向该内存的指针变量本身是在栈上，这样编译器就可以捕捉指针变量离开作用域的时机。在这时决定内存回收动作，如果该指针变量拥有内存区的所有权就释放内存，如果是一个引用计数指针就减少计数值，计数为 0 就回收内存</strong>”。</p>
<p><code>Rust</code> 的 <code>Box&lt;T&gt;</code> 为独占所有权指针，<code>Rc&lt;T&gt;</code>为引用计数指针，但其计数过程不是线程安全的，<code>Arc&lt;T&gt;</code>提供了线程安全的引用计数动作,可以跨线程使用。</p>
<p>我们看 <code>Box&lt;T&gt;</code> 的定义</p>
<pre><code class="language-Rust">pub struct Box&lt;T: ?Sized&gt;(Unique&lt;T&gt;);
pub struct Unique&lt;T: ?Sized&gt;{
    pointer: *const T,
    _marker: PhantomData&lt;T&gt;,
} 
</code></pre>
<p><code>Box</code> 本身是一个元组结构体，包装了一个 <code>Unique&lt;T&gt;</code>， <code>Unique&lt;T&gt;</code>内部有一个原生指针。</p>
<p><em>(注：Rust 最新版本的 Box<T> 实现还可以通过泛型参数指定内存分配器，让用户可以自己控制实际内存的分配。还有为什么通过 Unique<T>多层封装，这涉及智能指针实现的具体问题，这里不详述。）</em></p>
<p><code>Box</code> 没有实现 <code>Copy Trait</code>,它在所有权转移时会执行移动语意。</p>
<p>示例代码：</p>
<pre><code class="language-Rust">Struct Foo {v:i32}
fn inc(v:&amp; mut Foo) -&gt; &amp;Foo {//省略了生命周期参数
    v.v = v.v + 1;
    v
}
//返回Box指针不需要生命周期参数，因为Box指针拥有了所有权，不会成为悬垂指针
fn inc_ptr(mut foo_ptr:Box&lt;Foo&gt;) -&gt; Box&lt;Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    foo_ptr.v = foo_ptr.v + 1;
    println!(&quot;ininc_ptr：{:p}-{:p}&quot;, &amp;foo_ptr, &amp;*foo_ptr);
    foo_ptr
}
fn main() {
    let foo_ptr1 = Box::new(Foo{v:10});
    println!(&quot;foo_ptr1：{:p}-{:p}&quot;, &amp;foo_ptr1, &amp;*foo_ptr1);
    let mut foo_ptr2 = inc_ptr(foo_ptr1);
    //println!(&quot;{}&quot;,foo_ptr1.v);//编译错误，f0_ptr所有权已经丢失
    println!(&quot;foo_ptr2：{:p}-{:p}&quot;, &amp;foo_ptr2, &amp;*foo_ptr2);
     
    inc(foo_ptr2.borrow_mut());//获得指针内数据的引用，调用引用版本的inc函数
    println!(&quot;{}&quot;,foo_ptr2.v);
}
</code></pre>
<p><code>inc</code> 为引用版本，<code>inc_ptr</code> 是指针版本。改代码的输出为：</p>
<pre><code>foo_ptr1：0x8dfad0-0x93a5e0
in inc_ptr：0x8df960-0x93a5e0
foo_ptr2：0x8dfb60-0x93a5e0
12
</code></pre>
<p>可以看到 <code>foo_ptr1</code> 进入函数 <code>inc_ptr</code> 时,执行了一次所有权转移，函数返回时又执行了一次。所以三个 <code>Box&lt;Foo&gt;</code> 的变量地址都不一样，但是它们内部的数据地址都是一样的，指向同一个内存区。</p>
<p><code>Box</code> 类型自身是没有引用成员的，但是如果 <code>T</code> 包含引用成员，那么其相关的生命周期问题会是怎样的？</p>
<p>我们把 <code>Foo</code> 的成员改成引用成员试试，代码如下：</p>
<pre><code class="language-Rust">use std::borrow::BorrowMut;
struct Foo&lt;'a&gt;{v:&amp;'a mut i32}
    fn inc&lt;'a&gt;(foo:&amp;'a mut Foo&lt;'a&gt;) -&gt;&amp;'a Foo&lt;'a&gt; {//生命周期不能省略
    *foo.v=*foo.v + 1; // 解引用后执行加法操作
    foo
}
fn inc_ptr(mut foo_ptr:Box&lt;Foo&gt;) -&gt; Box&lt;Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    *foo_ptr.v = *foo_ptr.v + 1; / 解引用后执行加法操作
    println!(&quot;ininc_ptr：{:p}-{:p}&quot;, &amp;foo_ptr, &amp;*foo_ptr);
    foo_ptr
}
fn main(){
    let mut value = 10;
    let foo_ptr1 = Box::new(Foo{v:&amp; mut value});
    println!(&quot;foo_ptr1：{:p}-{:p}&quot;, &amp;foo_ptr1, &amp;*foo_ptr1);
    let mut foo_ptr2 = inc_ptr(foo_ptr1);
    //println!(&quot;{}&quot;,foo_ptr1.v);//编译错误，f0_ptr所有权已经丢失
    println!(&quot;foo_ptr2：{:p}-{:p}&quot;, &amp;foo_ptr2, &amp;*foo_ptr2);
     
    let foo_ref = inc(foo_ptr2.borrow_mut());//获得指针内数据的引用，调用引用版本的inc函数
    //println!(&quot;{}&quot;,foo_ptr2.v);//编译错误，无法获取foo_ptr2.v的不可变借用，因为已经存在可变借用
    println!(&quot;{}&quot;, foo_ref.v);
}
</code></pre>
<p>引用版本的 <code>inc</code> 函数生命周期不能再省略了。因为返回 <code>Foo</code> 的引用时，有两个生命周期值，一个是<code>Foo</code> 实例的生命周期，一个是 <code>Foo</code> 中引用成员的生命周期，编译器无法做推断，需要指定。但是智能指针版本 <code>inc_ptr</code> 函数的生命周期依然不用指定。<code>Foo</code> 的实例被智能指针包装，生命周期由 <code>Box</code> 负责管理。</p>
<p>如果 <code>Foo</code> 是一个 <code>Trait</code> ，而实现它的结构体有引用成员，那么 <code>Box&lt;Foo&gt;</code> 的生命周期会有什么情况。示例代码如下：</p>
<pre><code class="language-Rust">trait Foo{
    fn inc(&amp;mut self);
    fn value(&amp;self)-&gt;i32;
}

struct Bar&lt;'a&gt;{v:&amp;'a mut i32}

impl&lt;'a&gt; Foo for Bar&lt;'a&gt; {
    fn inc(&amp;mut self){
        *(self.v)=*(self.v)+1
    }
    fn value(&amp;self)-&gt;i32{
        *self.v
    }
}

fn inc(foo:&amp; mut dyn Foo)-&gt;&amp; dyn Foo {//生命周期参数被省略
    foo.inc();
    foo
}

fn inc_ptr(mut foo_ptr:Box&lt;dyn Foo&gt;) -&gt; Box&lt; dyn Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    foo_ptr.inc();
    foo_ptr
}

fn main() {
}
</code></pre>
<p>引用版本和智能指针版本都没生命周期参数，可以编译通过。不过 <code>main</code> 函数里是空的，也就是没有使用这些函数，只是定义编译通过了。我先试试使用引用版本：</p>
<pre><code class="language-Rust">fn main(){
    let mut value = 10;
    let mut foo1= Bar{v:&amp; mut value};
    let foo2 =inc(&amp;mut foo1);
    println!(&quot;{}&quot;, foo2.value());  // 输出 11
}
</code></pre>
<p>可以编译通过并正常输出。再试智能指针版本：</p>
<pre><code class="language-Rust">fn main(){
    let mut value = 10;
    let foo_ptr1 = Box::new(Bar{v:&amp;mut value});   //编译错误：value生命周期太短
    let mut foo_ptr2 = inc_ptr(foo_ptr1); //编译器提示：类型转换需要value为静态生命周期
}
</code></pre>
<p>编译失败。提示的错误信息是 <code>value</code> 的生命周期太短，需要为 <code>'static</code> 。因为 <code>Trait</code> 对象（ <code>Box&lt; dyn Foo&gt;</code>）默认是静态生命周期，编译器推断出返回数据的生命周期太短。去掉最后一行 <code>inc_ptr</code> 是可以正常编译的。</p>
<p>如果将 <code>inc_ptr</code> 的定义加上生命周期参数上述代码就可以编译通过。修改后的 <code>inc_ptr</code> 如下：</p>
<pre><code class="language-Rust">fn inc_ptr&lt;'a&gt;(mut foo_ptr:Box&lt;dyn Foo+'a&gt;) -&gt; Box&lt;dyn Foo+'a&gt; {
    foo_ptr.inc();
    foo_ptr
}
</code></pre>
<p>为什么指针版本不加生命周期参数会出错，而引用版没有生命周期参数却没有问题？</p>
<p>因为引用版是省略了生命周期参数，完整写法是：</p>
<pre><code class="language-Rust">fn inc&lt;'a&gt;(foo:&amp;'a mut dyn Foo)-&gt;&amp;'a dyn Foo {
    foo.inc();
    foo
}
</code></pre>
<h2><a class="header" href="#8-闭包与所有权" id="8-闭包与所有权">8. 闭包与所有权</a></h2>
<p>这里不介绍闭包的使用，只说与所有权相关的内容。闭包与普通函数相比，除了输入参数，还可以捕获上线文中的变量。闭包还支持一个 <code>move</code> 关键字，来强制转移捕获变量的所有权。</p>
<p>我们先来看 <code>move</code> 对输入参数有没有影响：</p>
<pre><code class="language-Rust">//结构 Value 没有实现Copy Trait
struct Value{x:i32}
 
//没有作为引用传递参数，所有权被转移
let mut v = Value{x:0};
let fun = |p:Value| println!(&quot;in closure:{}&quot;, p.x);
fun(v);
//println!(&quot;callafterclosure:{}&quot;,point.x);//编译错误：所有权已经丢失
 
//作为闭包的可变借用入参，闭包定义没有move,所有权没有转移
let mut v = Value{x:0};
let fun = |p:&amp;mut Value| println!(&quot;in closure:{}&quot;, p.x);
fun(&amp; mut v);
println!(&quot;call after closure:{}&quot;, v.x);
 
//可变借用作为闭包的输入参数，闭包定义增加move,所有权没有转移
let mut v = Value{x:0};
let fun = move |p:&amp; mut Value| println!(&quot;in closure:{}&quot;, p.x);
fun(&amp; mut v);
println!(&quot;call after closure:{}&quot;, v.x);
</code></pre>
<p>可以看出，变量作为输入参数传递给闭包时，所有权转移规则跟普通函数是一样的，<strong>move 关键字对闭包输入参数的引用形式不起作用，输入参数的所有权没有转移。</strong></p>
<p>对于闭包捕获的上下文变量，所有权是否转移就稍微复杂一些。</p>
<p>下表列出了 10 多个例子，每个例子跟它前后的例子都略有不同，分析这些差别，我们能得到更清晰的结论。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_9.jpg">
<p>首先要明确被捕获的变量是哪个，这很重要。比如例 8 中，<code>ref_v</code> 是 <code>v</code> 的不可变借用，闭包捕获的是 <code>ref_v</code> ，那么所有权转移的事情跟 <code>v</code> 没有关系，<code>v</code> 不会发生与闭包相关的所有权转移事件。</p>
<p>明确了被捕获的变量后，是否转移所有权受三个因素联合影响：</p>
<ol>
<li>变量被捕获的方式（值，不可变借用，可变借用）</li>
<li>闭包是否有 move 限定</li>
<li>被捕获变量的类型是否实现了 &quot;Copy&quot; Trait</li>
</ol>
<p>是用伪代码描述是否转移所有权的规则如下：</p>
<pre><code>if 捕获方式 == 值传递 {
    if 被捕获变量的类型实现了 &quot;Copy&quot;
        不转移所有权 // 例 ：9
    else
        转移所有权 // 例 ：1
    }
}
else { // 捕获方式是借用
    if 闭包没有 move 限定
        不转移所有权 // 例：2,3,6,10,12
    else { // 有 move
        if 被捕获变量的类型实现了 &quot;Copy&quot;
            不转移所有权 // 例: 8
        else
            转移所有权 // 例: 4,5,7,11,13,14
    }
}
</code></pre>
<p>先判断捕获方式，如果是值传递，相当于变量跨域了作用域，触发转移所有权的时机。<code>move</code> 是对借用捕获起作用，要求对借用捕获也触发所有权转移。是否实现 &quot;Copy&quot; 是最后一步判断。 前文提到，我们可以把 <code>Copy Trait</code> 限定的位拷贝语义当成一种转移执行的方式。<code>Copy Trait</code> 不参与转移时机的判定，只在最后转移执行的时候起作用。</p>
<ul>
<li>例 1 和(例 2、例 3) 的区别在于捕获方式不同。</li>
<li>(例 2、例 3) 和例 4 的区别在于 move 关键字。</li>
<li>例 6 和例 7 的区别 演示了 move 关键字对借用方式捕获的影响。</li>
<li>例 8 说明了捕获不可变借用变量，无论如何都不会转移，因为不可变借用实现了 Copy.</li>
<li>例 8 和例 11 的区别就在于例 11 捕获的 &quot;不可变借用&quot;没有实现 &quot;Copy&quot; Trait 。</li>
<li>例 10 和例 11 是以“不可变借用的方式”捕获了一个“可变借用变量”</li>
<li>例 12，13，14 演示了对智能指针的效果，判断逻辑也是一致的。</li>
</ul>
<p><code>C++11</code> 的闭包需要在闭包声明中显式指定是按值还是按引用捕获，<code>Rust</code> 不一样。<code>Rust</code> 闭包如何捕获上下文变量，不取决与闭包的声明，取决于闭包内部如何使用被捕获的变量。实际上编译器会尽可能以借用的方式去捕获变量（例，除非实在不行，如例 1.)</p>
<p>这里刻意没有提及闭包背后的实现机制，即 <code>Fn</code>,<code>FnMut</code>,<code>FnOnce</code> 三个 <code>Trait</code>。因为我们只用闭包语法时是看不到编译器对闭包的具体实现的。所以我们仅从闭包语法本身去判断所有权转移的规则。</p>
<h2><a class="header" href="#9多线程环境下的所有权问题" id="9多线程环境下的所有权问题">9.多线程环境下的所有权问题</a></h2>
<p>我们把前面的例 1 再改一下，上下文与闭包的实现都没有变化，但是闭包在另一个线程中执行。</p>
<pre><code class="language-Rust">let v = Value{x:1};
let child = thread::spawn(||{  // 编译器报错，要求添加 move 关键字
    let p = v;
    println!(&quot;inclosure:{}&quot;,p.x)
});
child.join();
</code></pre>
<p>这时，编译器报错，要求给闭包增加 <code>move</code> 关键字。也就是说，闭包作为线程的入口函数时，强制要求对被捕获的上下文变量执行移动语义。下面我们看看多线程环境下的所有权系统。</p>
<p>前面的讨论都不涉及变量在跨线程间的共享，一旦多个线程可以访问同一个变量时，情况又复杂了一些。这里有两个问题，一个仍然是内存安全问题，即“悬垂指针”等 5 个典型的内存安全问题，另一个是线程的执行顺序导致执行结果不可预测的问题。这里我们只关注内存安全问题。</p>
<p>首先，多个线程如何共享变量？前面的例子演示了启动新线程时，通过闭包捕获上下文中的变量来实现多个线程共享变量。这是一个典型的形式，我们以这个形式为基础来阐述多线程环境下的所有权问题。</p>
<p>我们来看例子代码：</p>
<pre><code class="language-Rust">//结构 Value 没有实现Copy Trait
struct Value{x:i32}
 
let v = Value{x:1};
let child = thread::spawn(move||{
    let p = v;
    println!(&quot;in closure:{}&quot;,p.x)
});
child.join();
//println!(&quot;{}&quot;,v.x);//编译错误：所有权已经丢失
</code></pre>
<p>这是前面例子的正确实现，变量 <code>v</code> 被传递到另一个线程(闭包内)，执行了所有权转移</p>
<pre><code class="language-Rust">//闭包捕获的是一个引用变量，无论如何也拿不到所有权。那么多线程环境下所有引用都可以这么传递吗？
let v = Value{x:0};
let ref_v = &amp;v;
let fun = move ||{
    let p = ref_v;
    println!(&quot;inclosure:{}&quot;,p.x)
};
fun();
println!(&quot;callafterclosure:{}&quot;,v.x);//编译执行成功
</code></pre>
<p>这个例子中，闭包捕获的是一个变量的引用，<code>Rust</code> 的引用都是实现了 <code>Copy Trait</code>，会被按位拷贝到闭包内的变量 <code>p.p</code> 只是不可变借用，没有获得所有权，但是变量 <code>v</code> 的不可变借用在闭包内外进行了传递。那么把它改成多线程方式会如何呢？这是多线程下的实现和编译器给出的错误提示：</p>
<pre><code class="language-Rust">let  v:Value = Value{x:1};
let ref_v = &amp;v;           // 编译错误：被借用的值 v0 生命周期不够长
let child = thread::spawn(move||{
    let p = ref_v;
    println!(&quot;in closure:{}&quot;,p.x)
});                                // 编译器提示：参数要求 v0 被借用时为 'static 生命周期
child.join();
</code></pre>
<p>编译器的核心意思就是 <code>v</code> 的生命周期不够长。当 <code>v</code> 的不可变借用被传递到闭包中，并在另一个线程中使用时，主线程继续执行， <code>v</code> 随时可能超出作用域范围被回收，那么子线程中的引用变量就变成了悬垂指针。 如果 <code>v</code> 为静态生命周期，这段代码就可以正常编译执行。即把第一行改为：</p>
<pre><code class="language-Rust">const  v:Value = Value{x:1};
</code></pre>
<p>当然只能传递静态生命周期的引用实际用途有限，多数情况下我们还是希望能把非静态的数据传递给另一个线程。可以采用 <code>Arc&lt;T&gt;</code>来包装数据。 <code>Arc&lt;T&gt;</code> 是引用计数的智能指针，指针计数的增减操作是线程安全的原子操作，保证计数的变化是线程安全的。</p>
<pre><code class="language-Rust">//线程安全的引用计数智能指针Arc可以在线程间传递
let v1 = Arc::new(Value{x:1});
let arc_v = v1.clone();
let child = thread::spawn(move||{
    let p = arc_v;
    println!(&quot;Arc&lt;Value&gt;in closure:{}&quot;,p.x)
});
child.join();
//println!(&quot;Arc&lt;Value&gt;inclosure:{}&quot;,arc_v.x);//编译错误，指针变量的所有权丢失
</code></pre>
<p>如果把上面的 <code>Arc&lt;T&gt;</code> 换成 <code>Rc&lt;T&gt;</code> ,编译器会报告错误，说&quot;<code>Rc&lt;T&gt;</code> 不能在线程间安全的传递&quot;。</p>
<p>通过上面的例子我们可以总结出来一点，因为闭包定义中的 <code>move</code> 关键字，以闭包启动新线程时，被闭包捕获的变量本身的所有权必然会发生转移。无论捕获的变量是 &quot;值变量&quot;还是引用变量或智能指针（上述例子中 <code>v</code>,<code>ref_v</code>,<code>arc_v</code> 本身的所有权被转移）。但是对于引用或指针，它们所指代的数据的所有权并不一定被转移。</p>
<p>那么对于上面的类型 <code>struct Value{x:i32}</code>, <strong>它的值可以在多个线程间传递</strong>(转移所有权)，它的<strong>多个不可变借用可以在多个线程间同时存在</strong>。同时 <code>&amp;Value</code> 和 <code>Arc&lt;Value&gt;</code> 可以在多个线程间传递（转移引用变量或指针变量自身的所有权），但是 <code>Rc&lt;T&gt;</code> 不行。</p>
<p>要知道，<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 只是 <code>Rust</code> 标准库(<code>std</code>)实现的，甚至不在核心库(<code>core</code>)里。也就是说，它们并不是 <code>Rust</code> 语言机制的一部分。那么，<font color=#fa8919>编译器是如何来判断 Arc<T> 可以安全的跨线程传递，而 Rc<T> 不行呢？</font></p>
<p><code>Rust</code> 核心库 的 <code>marker.rs</code> 文件中定义了两个标签 <code>Trait</code>:</p>
<pre><code class="language-Rust">pub unsafe auto trait Sync{}
pub unsafe auto trait Send{}
</code></pre>
<p>标签 <code>Trait</code> 的实现是空的，但编译器会分析某个类型是否实现了这个标签 <code>Trait</code>.</p>
<ul>
<li>如果一个类型 <code>T</code>实现了“<strong>Sync</strong>”，其含义是 <code>T</code> 可以安全的通过引用可以在多个线程间被共享。</li>
<li>如果一个类型 <code>T</code>实现了“<strong>Send</strong>”，其含义是 <code>T</code> 可以安全的跨线程边界被传递。</li>
</ul>
<p>那么上面的例子中的类型，<code>Value</code> ，<code>&amp;Value</code>，<code>Arc&lt;Value&gt;</code> 类型一定都实现了“<code>Send</code>”<code>Trait</code>. 我们看看如何实现的。</p>
<p><code>marker.rs</code> 文件还定义了两条规则：</p>
<pre><code class="language-Rust">unsafe impl&lt;T:Sync + ?Sized&gt; Send for &amp;T{}
unsafe impl&lt;T:Send + ?Sized&gt; Send for &amp; mut T{}
</code></pre>
<p>其含义分别是：</p>
<ul>
<li>如果类型 T 实现了“<strong>Sync</strong>”，则自动为类型 <code>&amp;T</code> 实现“<strong>Send</strong>”.</li>
<li>如果类型 T 实现了“<strong>Send</strong>”，则自动为类型 <code>&amp;mut T</code> 实现“<strong>Send</strong>”.</li>
</ul>
<p>这两条规则都可以直观的理解。比如：对第一条规则 <code>T</code> 实现了 “<strong>Sync</strong>”, 意味则可以在很多个线程中出现同一个 <code>T</code> 实例的 <code>&amp;T</code> 类型实例。如果线程 <code>A</code> 中先有 <code>&amp;T</code> 实例，线程 <code>B</code> 中怎么得到 <code>&amp;T</code> 的实例呢？必须要有在线程 <code>A</code> 中通过某种方式 <code>send</code> 过来，比如闭包的捕获上下文变量。而且 <code>&amp;T</code> 实现了 &quot;<code>Copy</code>&quot; <code>Trait</code>, 不会有所有权风险，数据是只读的不会有数据竞争风险，非常安全。逻辑上也是正确的。<font color=#fa8919>那为什么还会别标记为 unsafe ?</font> 我们先把这个问题暂时搁置，来看看为智能指针设计的另外几条规则。</p>
<pre><code class="language-Rust">impl &lt;T:?Sized&gt;!marker::Send for Rc&lt;T&gt;{}
impl &lt;T:?Sized&gt;!marker::Sync for Rc&lt;T&gt;{}
impl&lt;T:?Sized&gt;!marker::Send for Weak&lt;T&gt;{}
impl&lt;T:?Sized&gt;!marker::Sync for Weak&lt;T&gt;{}
unsafe impl&lt;T:?Sized+Sync+Send&gt;Send  for Arc&lt;T&gt;{}
unsafe impl&lt;T:?Sized+Sync+Send&gt;Sync for Arc&lt;T&gt;{}
</code></pre>
<p>这几条规则明确指定 <code>Rc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code> 不能实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”。</p>
<p>同时规定如果类型 <code>T</code> 实现了 “<strong>Sync</strong>”和 “<strong>Send</strong>”，则自动为 <code>Arc&lt;T&gt;</code> 实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”。<code>Arc&lt;T&gt;</code> 对引用计数增减是原子操作，所以它的克隆体可以在多个线程中使用(即可以为 <code>Arc&lt;T&gt;</code> 实现”<strong>Sync</strong>”和“<strong>Send</strong>”)，但为什么其前提条件是要求 <code>T</code> 也要实现&quot;<strong>Sync</strong>”和 “<strong>Send</strong>”呢。</p>
<p>我们知道，<code>Arc&lt;T&gt;</code>实现了 <code>std::borrow</code>，可以通过 <code>Arc&lt;T&gt;</code>获取 <code>&amp;T</code> 的实例，多个线程中的 <code>Arc&lt;T&gt;</code> 实例当然也可以获取到多个线程中的 <code>&amp;T</code> 实例，这就要求 <code>T</code> 必须实现“<strong>Sync</strong>”。<code>Arc&lt;T&gt;</code> 是引用计数的智能指针，任何一个线程中的 <code>Arc&lt;T&gt;</code>的克隆体都有可能成为最后一个克隆体，要负责内存的释放，必须获得被 <code>Arc&lt;T&gt;</code>指针包装的 <code>T</code> 实例的所有权，这就要求 <code>T</code> 必须能跨线程传递，必须实现 “<strong>Send</strong>”。</p>
<p><code>Rust</code> 编译器并没有为 <code>Rc&lt;T&gt;</code>或 <code>Arc&lt;T&gt;</code> 做特殊处理，甚至在语言级并不知道它们的存在，编译器本身只是根据类型是否实现了 “<strong>Sync</strong>”和 “<strong>Send</strong>”标签来进行推理。实际上可以认为编译器实现了一个检查变量跨线程传递安全性的规则引擎，编译器为基本类型直接实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”，这作为“公理”存在，然后在标准库代码中增加一些“定理”，也就是上面列举的那些规则。用户自己实现的类型可以自己指定是否实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”，多数情况下编译器会根据情况默认选择是否实现。代码编译时编译器就可以根据这些公理和规则进行推理。这就是 <code>Rust</code> 编译器支持跨线程所有权安全的秘密。</p>
<p>对于规则引擎而言，&quot;公理&quot;和&quot;定理&quot;是不言而喻无需证明的，由设计者自己声明，设计者自己保证其安全性，编译器只保证只要定理和公理没错误，它的推理也没错误。所以的&quot;公理&quot;和&quot;定理&quot;都标注为 <code>unsafe</code>,提醒声明着检查其安全性，用户也可以定义自己的&quot;定理&quot;，有自己保证安全。反而否定类规则 （实现 <code>!Send</code> 或 <code>!Sync</code>）不用标注为 <code>unsafe</code> , 因为它们直接拒绝了变量跨线程传递，没有安全问题。</p>
<p>当编译器确定 “<strong>Sync</strong>”和 “<strong>Send</strong>”适合某个类型时，会自动为其实现此。</p>
<p>比如编译器默认为以下类型实现了 <code>Sync</code> ：</p>
<ul>
<li>
<p>[u8] 和 [f64] 这样的基本类型都是 [Sync]，</p>
</li>
<li>
<p>包含它们的简单聚合类型（如元组、结构和名号）也是[Sync] 。</p>
</li>
<li>
<p>&quot;不可变&quot; 类型（如 &amp;T）</p>
</li>
<li>
<p>具有简单继承可变性的类型，如 Box <T>、Vec<T></p>
</li>
<li>
<p>大多数其他集合类型（如果泛型参数是 [Sync]，其容器就是 [Sync]。</p>
</li>
</ul>
<p>用户也可以手动使用 <code>unsafe</code> 的方式直接指定。</p>
<p>下图是与跨线程所有权相关的概念和类型的 <code>UML</code> 图。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_8.jpg">
<center>图 8与多线程相关的所有权转移</center>
<hr />
<p>编辑简介：</p>
<p>高宪凤(.nil?)，软件开发工程师，Rust 语言爱好者，喜欢有计划、有条理、有效率的工作，热爱开源文化，愿意为 Rust 中文社区的发展尽绵薄之力。</p>
<h1><a class="header" href="#嵌入式领域的rust语言" id="嵌入式领域的rust语言">嵌入式领域的Rust语言</a></h1>
<p>作者：洛佳</p>
<hr />
<p><img src="chapter_1/embedded_rust/k210.jpg" alt="k210芯片" /></p>
<p>Rust语言是二十一世纪的语言新星。Rust被人广泛承认的一点，就是因为它能运行在多样的目标上，
从桌面和服务器设备，到资源有限的嵌入式设备。</p>
<p>我们可以用适合来评价一门语言和技术。Rust非常适合开发嵌入式应用，它是一种和C相仿的、
能应用于嵌入式设备开发的编程语言。</p>
<p>操作系统都是从裸机设备开始运行的，Rust语言的这一点也意味着，它能很好地用于编写操作系统。
无论是应用层还是内核本身，Rust都是极富竞争力、值得投入时间的技术选项。</p>
<h2><a class="header" href="#裸机上的rust语言" id="裸机上的rust语言">裸机上的Rust语言</a></h2>
<p>开发裸机应用时，通常希望使用的语言速度快、可靠性强。此外们还希望语言的生态较好，
有利于提高生产效率，而且适用范围较广。Rust语言能满足以上的要求，适合裸机应用的开发。</p>
<p>运用在裸机场合时，Rust语言拥有许多优点。除了效率和安全，Rust还将传统上不用于裸机开发的编程技术引入到裸机，
让开发者有更多的选择，更灵活、高效地编写裸机应用代码。</p>
<h3><a class="header" href="#二十一世纪的裸机编程语言" id="二十一世纪的裸机编程语言">二十一世纪的裸机编程语言</a></h3>
<p>在这个互联网全面普及、性价比设备应用更广的时代，安全和可靠性成为一门语言必须考虑的因素。
Rust语言采用移动语义，拥有严格的代数类型系统以及生命周期、所有权模型；
相比传统的编程语言，这些模型能在合适的时候释放所用资源，减少漏洞的出现。
此外，通过语义检查，Rust能在编译期有效寻找内存和线程安全问题，降低开发和测试的负担。</p>
<p>Rust语言是的运行效率高、开发效率好、适用范围广。作为一门编译型语言，它直接编译输出到汇编代码，
通常公认裸机的Rust语言性能在C语言级别，拥有较高的运行效率。
Rust语言的开发效率很高，文档完善、编译器提示有帮助，能节省软件开发所需的时间。
它能应用在多个平台和指令集中，这包括裸机平台；处理核、操作系统厂家还可以提供自己的编译目标，
无需厂家自己重新开发、提供工具链。</p>
<p>Rust语言出彩的地方在于，它向嵌入式平台引入了大量新的编程技术。
这包括了闭包、过程宏等传统上用于函数式编程的技术，和多态、虚函数表等面向对象语言的技术。
新编程技术的引入，扩充了开发者的选择。即使彻底理解Rust的编程概念有一定难度，但这些易用的新技术，
让开发者只需阅读实例代码，便可快速进入开发状态。这些新技术的引入，是嵌入式平台从未有过的，
Rust能提高开发者的工作效率，降低平台间迁移的学习时间和成本。</p>
<h3><a class="header" href="#裸机上的过程宏" id="裸机上的过程宏">裸机上的过程宏</a></h3>
<p>传统用于嵌入式平台的编程，我们加快开发速度使用的宏，常常基于语法字符串的替换和修改。
Rust语言扩充了宏的概念，提出了基于语法树的“过程宏”编程方法，让宏语法更容易使用、编写更方便。</p>
<p>“过程宏”是接收Rust代码作为输入，操作这些代码，然后产生另一些代码的过程。
它和字符串的替换不同，是从语法树到语法树的替换。开发一个过程宏，可以使用简单的定义过程，
或者有工作量的属性宏定义过程。简单的定义中，我们编写代码，给出宏的输入有哪些，要翻译到哪些输出代码，
这样就完成了一个宏的定义。属性宏定义则允许完成语法树分析、代码生成甚至代码优化的过程，
就需要编写专门的“属性宏库”，借用Rust编译器的一部分，完成宏代码的转化和输出。</p>
<p>过程宏是基于语法树的分析过程，借助“树”的结构我们能理解它的一些特点。因为Rust语法树的子树也是Rust代码，
所以宏的定义内也可以完成语法分析，这就为代码编辑器的提示和补全提供了便利。
一个语法项目不可能同时属于两颗不是亲子关系的子树，因为如果属于两颗子树，将和语法树的树根产生环，
就和语法树的定义相违背，所以语法项目都是独立的，宏内代码的解析不会影响外界代码的解析。</p>
<p>这样的独立性也就是“卫生宏”思想的提出，Rust的过程宏可以理解为代码的“内部展开”，不影响代码的上下文。
正因为Rust过程宏产生完整的语法子树，它的定义不需要额外的界符，因此只需要满足Rust语法就可以了。</p>
<p>在过程宏的定义之外，Rust语言提供了大量便于嵌入式开发的标签。“align”标签定义内存对齐的方式，
“link_section”标签给定代码要链接到的段或区。这样，过程宏可以包装各种各样的标签，
Rust语言的用户可以方便地使用，而不需要深入宏了解代码的具体要求。
Rust语言定义的过程宏可以导出到包外，给其它的库使用，这有利于嵌入式Rust生态的搭建和共享。
Rust语言宏灵活的特性，让宏在更多的领域有可用之处，更好地服务嵌入式平台的开发工作。</p>
<h3><a class="header" href="#嵌入式中的模块化编程" id="嵌入式中的模块化编程">嵌入式中的模块化编程</a></h3>
<p>Rust语言拥有很好的模块化编程概念。传统平台的Rust语言中，社区总结出了“模块-包-项目”的模型。
这个模型也适用于嵌入式平台，增加协作开发的效率，更好地共享生态。</p>
<p>Rust的模块化编程分为模块、包、项目三级。模块是Rust语言可见性分划的最小单位，
语言中提供了专门的关键字，来区分不同模块的代码和可见性，是由Rust语言本身确定的。
在Rust语法中，“mod”是定义模块的关键字，“pub”是定义可见性的关键字。</p>
<p>包是Rust项目的二进制目标，这个等级是由Rust工具链给定的。每个包有版本号、作者和许可协议等元数据，
要依赖和使用的库也要登记到包中，以便共同编译。库的特性有点像传统语言的条件编译，
也是以包为单位规定的，每个包使用的库可以开启不同的特性，但库在同一个包中开启的特性是相同的。</p>
<p>“项目”这一层并非由Rust语言给定；人们开发软件时，发现一个解决方案中包含多个二进制目标是非常好的，
总结之后就出现了项目的抽象模型。项目由核心和外围包组成，或者是功能相近的一组包，
它通常由同一个团队组织和维护，可以在项目上添加扩展。项目在习惯上由核心包到功能包，以依赖的形式构成。
实践中，“项目”可以放在同一个工作空间里，以统一管理和发布编译版本。</p>
<p>Rust将模块化编程引入到嵌入式开发中，也可以方便地编写测试和性能检测代码。
模块化编程能提高Rust嵌入式开发者的工作效率，适应现代化嵌入式软件的需求。</p>
<h2><a class="header" href="#搭建rust嵌入式生态" id="搭建rust嵌入式生态">搭建Rust嵌入式生态</a></h2>
<p>生态是软件不可或缺的一部分。从编译器到软件支持，嵌入式Rust目前已经拥有良好的基础生态。
此外，操作系统内核也是嵌入式编程的重要部分，嵌入式Rust和内核开发也有较好的相容度。</p>
<p><img src="chapter_1/embedded_rust/ecosystem.png" alt="截至2020年12月的嵌入式生态架构图" /></p>
<h3><a class="header" href="#你的架构和指令集" id="你的架构和指令集">你的架构和指令集</a></h3>
<p>嵌入式Rust的应用支持分为两个部分：一个是目标处理核的支持，一个是芯片外设的支持。</p>
<p>针对目标处理核，首先我们要编译Rust到这个指令集架构。Rust语言提供丰富的编译目标，
主流的编译目标都有很好的支持；此外，如果有自主研发的指令集架构，可以为Rust添加自己的编译目标。
编译完成后，还需要编写微架构支持库和微架构运行时。微架构运行时提供最小的启动代码实现，
能搭建一个适合Rust代码运行的环境。微架构支持库简单包装汇编代码，允许应用代码操作寄存器、运行特殊的指令，
作为编译器系统的补充。这之后，Rust对这个指令集架构的代码运行支持就完成了。</p>
<p>嵌入式应用定义了各有特点的中断控制器，有些是指令集架构定义的，有些是芯片设计厂家自己定义的。
嵌入式Rust要支持这些中断控制器，需要在微架构运行时中添加处理和封装部分，或者作为通用架构的补充，
在专用架构的支持库中添加专有架构的中断运行时。架构虽然定义了标准，但基地址、中断数量等配置可能相互不同。
这些元数据配置可以放在外设访问库的中断部分，和架构支持库共同构成中断控制器的支持。</p>
<p>目标的处理核定义了调试接口和闪存烧写算法，我们需要在调试器软件中编写这些算法。
社区通用的软件“probe-rs”是很好的调试器实现，可以替代OpenOCD，作为非常好的Rust语言调试软件。
如果自己的操作系统有软件调试接口，可以添加操作系统调试器的载荷，共同完成调试软件的部分。
只要处理器厂商实现了调试接口，提供相关的文档，配套的Rust软件可以尽快完成，方便各种技术的开发者调试和使用。</p>
<h3><a class="header" href="#嵌入式生态的标准" id="嵌入式生态的标准">嵌入式生态的标准</a></h3>
<p>起初嵌入式开发者会为每个芯片都编写一次代码。随着生态的发展，大家认识到，需要提供一个基本的抽象，
大家都围绕着抽象去编写，就能剩下大量外设反复操作的时间。embedded-hal就是这样的标准，
它是Rust语言的嵌入式外设抽象，支持大量的片内和片外外设，包括传感器等，很好地扩充了嵌入式的生态。</p>
<p>embedded-hal是统一的Rust语言标准，它是针对外设功能本身的抽象，是抽象的集合，具体实现由实现库去完成。
它的扩展性很好，比如“SPI-GPIO扩展器”外设输入SPI接口抽象，输出GPIO的抽象，很多模块都是抽象到抽象的过程，
就可以方便的极联、衔接和嵌套，整合更多的项目；这就非常容易为新的芯片编写支持库。</p>
<p>市场上海量的芯片都支持embedded-hal标准。K210、GD32V和BL602系列的芯片都提供很好的embedded-hal实现库。
要编写embedded-hal标准的支持库，只需要机器生成外设库，然后编写中间层库，就能完成对此标准的原厂支持。</p>
<h3><a class="header" href="#rust与操作系统内核" id="rust与操作系统内核">Rust与操作系统内核</a></h3>
<p>操作系统也是嵌入式应用。常见的操作系统如按是否包含虚拟内存区分，有不含虚拟内存的实时系统，
和包含虚拟内存传统操作系统。基于微架构的支持库和运行时库，操作系统内核可以很方便地编写。</p>
<p>社区中提供了大量成熟的操作系统运行时。
如rCore系列操作系统是第一个基于RISC-V架构的完整Rust操作系统，尤其适合教学使用。
RTIC框架是中断驱动的异步实时系统，完全针对应用使用Rust的宏语法生成，拥有极高的效率。
Tock系统是针对微处理器的安全实时系统，已经用于手表、智能路标和加密狗等产品。</p>
<p>针对操作系统和应用程序开发，Rust是适合编写硬件驱动的语言。
如果使用有产权的代码，可以以混合链接的形式，与Rust代码联合编译为二进制使用。
系统模块、插件和动态链接库等等都能受益于Rust语言内存安全的特性，适合现在对安全敏感的开发需求。</p>
<p>物联网系统要求嵌入式的操作系统能够连上网络。Rust嵌入式社区也在探索射频连接的技术标准，
包括蓝牙、WiFi等硬件标准。smoltcp是社区提供的非常好的TCP协议栈实现，它可以代替lwip，
在嵌入式系统领域高效、安全地完成网络传输。搭配缓冲区和协议库，物联网操作系统就可以连上网了。</p>
<h2><a class="header" href="#rustsbi新型操作系统引导软件" id="rustsbi新型操作系统引导软件">RustSBI：新型操作系统引导软件</a></h2>
<p>我们在开发操作系统内核时，有的内核直接运行在裸机上，有的还依托于一个运行环境。
在RISC-V上，“SBI”就是这样的运行环境。它除了引导启动内核，还将常驻后台，提供操作系统需要的实用功能。</p>
<p>RISC-V标准中，“SBI”意味着“操作系统二进制接口”，运行在其上的操作系统会通过环境调用“ecall”指令，
陷入到二进制接口的实现中，由其调用具体硬件的实现功能。这种实现被称作“SBI实现”，社区常用的实现有开源的OpenSBI。
RustSBI是鹏城实验室“rCore代码之夏-2020”活动提出的SBI实现，它是全新的操作系统引导软件。</p>
<h3><a class="header" href="#实现与模块组成" id="实现与模块组成">实现与模块组成</a></h3>
<p>RustSBI由几个功能模块组成。硬件环境接口实现了RISC-V SBI v0.2版本的接口，能运行支持此版本的操作系统。
硬件运行时则是SBI实现运行在裸机环境的必要模块，它将由硬件启动，开始运行所有的RustSBI模块。
SBI的初始化完成后，将进入引导启动模块，这里将发挥SBI标准“引导启动”的功能，最终启动操作系统内核。
另外，兼容性模块能完成硬件到硬件间的支持，能模拟旧版硬件不存在的指令、寄存器，进一步延长操作系统的生命周期。</p>
<p>去年12月，RustSBI的0.1版本在深圳的Rust中国社区2020年年会上发布。使用目前最新的0.1.1版本，
RustSBI已经支持大量SBI标准提出的功能，支持大量自定义的扩展功能；完全使用安全的Rust语言编写，提高开发效率。
开发Rust语言的操作系统内核，可以统一编译工具链。另外，RustSBI已经被RISC-V组织收录入RISC-V SBI标准，
它的实现编号为4。</p>
<p>RustSBI是一个库，它以库的形式设计的初衷是，便于平台开发者“积木”式地引入库的模块，为自己的硬件目标开发SBI支持。
虽然RustSBI提供了QEMU、K210平台的参考实现，但应用开发者不应当将自己的目标也加入参考实现中，
而是在自己的仓库里引用RustSBI的模块，可以选择参考这些实现的内容，最终完成完全可控的开发过程。
这两个平台的使用范围较广，参考实现也会长期维护，以发现RustSBI本身可能的少量问题，并及时修补完善。</p>
<p>为什么用Rust开发RustSBI呢？我们认为，相比使用C语言，嵌入式Rust的生态圈在协调发展阶段，它容易支持新硬件，
Rust语言较强的编译约束也提高了硬件代码的安全性。</p>
<h3><a class="header" href="#硬件到硬件的兼容性" id="硬件到硬件的兼容性">硬件到硬件的兼容性</a></h3>
<p>RISC-V是快速更迭的指令集规范。我们为新版RISC-V硬件编写软件，会遇到与旧版硬件不兼容的情况。
硬件和硬件之间的兼容性，也能通过软件完成——这是RustSBI提供的功能与亮点之一。</p>
<p>RustSBI实现的硬件兼容性，是靠捕获指令异常完成的。例如，K210平台实现的是1.9.1版本的RISC-V特权级标准，
它规定了旧版的页表刷新指令；而目前最新的1.11版标准，规定的是新版的刷新指令。为新标准编写的操作系统内核，
使用新版刷新指令，会因为K210硬件无法找到新版指令，抛出非法指令异常。这个非法指令异常被RustSBI捕获，
它解析后，发现是新版的页表刷新指令，便直接在硬件上运行旧版的指令，完成指令的页表刷新功能。</p>
<p>这种硬件兼容性，目前能支持新增的指令和寄存器。一切情况下，指令、寄存器在仍然存在，但新版中修改了它们的功能和意义。
只靠RustSBI软件本身，就不足以提供兼容性支持了。如果RISC-V芯片实现提供特定的兼容性外设，
比如这个外设能拦截特定CSR寄存器的访问指令，就可以在功能修改的寄存器访问时，产生一个可供软件捕获的中断。
这样的外设设计之后，使用RustSBI软件，将能支持功能修改的指令和寄存器，将进一步提升操作系统内核的硬件兼容性。</p>
<p>兼容旧硬件，也是兼容未来新硬件的过程。未来的RISC-V标准快速发展，将与目前的硬件标准产生一定的差异；
在硬件不变的前提下，未来软件能对当前的硬件兼容，就能延长软件的生命周期。
或许，我们未来升级RISC-V上的操作系统，只需要更换硬件中的RustSBI固件，就能完美兼容最新标准的操作系统了。
升级原有系统的硬件也非常容易，替换RustSBI固件就能达到升级效果。</p>
<p>另外，硬件兼容性也意味着实现硬件上缺少的指令集。当这些指令集运行时，就会陷入到软件中，由RustSBI软件模拟这些指令，
最终返回，这个过程应用软件不会有感知。当然，这种软件模拟过程可以满足正确性，效率不如新版的硬件，
但临时运行一个新版的软件、体验新版的指令集还是足够的。当模拟指令的过程多到影响性能时，也就是硬件该升级的时候了。</p>
<h3><a class="header" href="#rustsbi与嵌入式rust生态" id="rustsbi与嵌入式rust生态">RustSBI与嵌入式Rust生态</a></h3>
<p>在RustSBI的实现中，多次使用“embedded-hal”的实现完成编写过程。“embedded-hal”是Rust嵌入式的外设规范，
它对大量厂家的外设提供了软件支持。只要厂家的硬件支持“embedded-hal”，只需要编写部分抽象接口代码，
RustSBI支持就可以快速地开发完成。</p>
<p>硬件处理核和SoC系统的开发也受益于设计好的RustSBI软件架构。“RustSBI很快速地实现了仿真环境的双核测试，”
华中科技大学的社区贡献者车春池说，“这能为处理核提供丰富的测试环境，在开发高性能RISC-V处理核中非常重要。”</p>
<p>无论硬件和软件，我们都乐于看到各个应用领域积极互动，嵌入式Rust生态的发展过程得到加快。
“embedded-hal”本是裸机外设的标准，RustSBI将这个标准运用在引导软件上，能加速裸机外设的开发和建设，
也能更快适配SBI标准到平台上。</p>
<p>借这个项目，我们很高兴能参与嵌入式领域Rust语言的建设，希望这些微小的技术更新和迭代，最终能回馈到我们美好的生活中去。</p>
<hr />
<p>作者简介：</p>
<p><strong>洛佳</strong></p>
<p>华中科技大学网络空间安全学院本科生，热爱操作系统、嵌入式开发。RustSBI项目作者，3年Rust语言开发经验，社区活跃贡献者。目前致力于向产业、教学等更多的领域推广Rust语言。</p>
<h1><a class="header" href="#用rust写操作系统--清华-rcore-os-教程介绍" id="用rust写操作系统--清华-rcore-os-教程介绍">用<code>Rust</code>写操作系统 | 清华 rCore OS 教程介绍</a></h1>
<p>编辑：张汉东</p>
<h2><a class="header" href="#rcore-os-教程简介" id="rcore-os-教程简介">rCore OS 教程简介</a></h2>
<p>众所周知，清华大学的操作系统课程是国家级精品课程。清华大学也是是国内首个使用 Rust 进行操作系统教学的高校。目前，陈渝教授和他的学生吴一凡正在编写新的操作系统教材。该教材相关的文档都是网络公开的，教程地址：<a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">https://rcore-os.github.io/rCore-Tutorial-Book-v3/</a>。</p>
<p>这本教程旨在一步一步展示如何 <strong>从零开始</strong> <strong>用 Rust 语言写一个基于 RISC-V 架构的类 Unix 内核</strong>。值得注意的是， 本项目不仅支持模拟器环境（如 Qemu/terminus 等），还支持在真实硬件平台 Kendryte K210 上运行。</p>
<p>该教程目前已经发布了近 20 万字，每一章都是一个能完整运行的内核。目前已经完成了前四章分别可以让内核能在裸机打印字符、支持系统调用和特权级切换、任务切换和虚拟存储。后面还会依次支持进程、进程间通信和数据持久化，代码已经写完，有待更新教程文档。陈渝教授和吴一凡也希望能够通过该教程吸引更多对 Rust 和 OS 感兴趣的读者，可以在教程的基础上自己从头实现一遍或者能做一些拓展，也能提供一些反馈，让教程的质量越来越高。</p>
<p>以教程目前的内容进度，正是大家从零开始学习编写操作系统的最佳时期。</p>
<h2><a class="header" href="#为什么要学习操作系统" id="为什么要学习操作系统">为什么要学习操作系统？</a></h2>
<p>一名程序员的绝大部分工作都是在操作系统上面进行的。学习操作系统，深入了解操作系统原理，是每个合格的程序员必须要经历的。</p>
<p>很多人学习 Rust 语言感到很吃力，基本上就是因为操作系统基础知识薄弱造成的。</p>
<p>通过自己实现一个操作系统，可以让你对操作系统的理解不仅仅是停留在概念上。而且用 Rust 实现操作系统，对于 Rust 爱好者来说，更有意思。</p>
<p>希望社区的朋友可以根据该教程实现自己的操作系统，如果需要交流，可以联系我（张汉东），我们可以一起建立学习小组，并且可以直接向陈渝教授和吴一凡反馈学习中的问题。</p>
<p><strong>以下内容节选自rCore OS 教程第零章</strong>。</p>
<h2><a class="header" href="#目前常见的操作系统内核都是基于c语言的为何要推荐rust语言" id="目前常见的操作系统内核都是基于c语言的为何要推荐rust语言">目前常见的操作系统内核都是基于C语言的，为何要推荐Rust语言？</a></h2>
<p>没错，C语言就是为写UNIX而诞生的。Dennis Ritchie和KenThompson没有期望设计一种新语言能帮助高效简洁地开发复杂的应用业务逻辑，只是希望用一种简洁的方式抽象出计算机的行为，便于编写控制计算机硬件的操作系统，最终的结果就是C语言。</p>
<p>C语言的指针的天使与魔鬼，且C语言缺少有效的并发支持，导致内存和并发漏洞成为当前操作系统的噩梦。</p>
<p>Rust语言具有与C一样的硬件控制能力，且大大强化了安全编程。从某种角度上看，新出现的Rust语言的核心目标是解决C的短板，取代C。所以用Rust写OS具有很好的开发和运行的体验。</p>
<p>用 Rust 写 OS 的代价仅仅是学会用 Rust 编程。</p>
<h2><a class="header" href="#目前常见的cpu是x86和arm为何要推荐risc-v" id="目前常见的cpu是x86和arm为何要推荐risc-v">目前常见的CPU是x86和ARM，为何要推荐RISC-V？</a></h2>
<p>没错，最常见的的CPU是x86和ARM，他们已广泛应用在服务器，台式机，移动终端和很多嵌入式系统中。它们需要支持非常多的软件系统和应用需求，导致它们越来越复杂。</p>
<p>x86的向过去兼容的策略确保了它的江湖地位，但导致其丢不掉很多已经比较过时的硬件设计，让操作系统疲于适配这些硬件特征。</p>
<p>x86和ARM都很成功，这主要是在商业上，其广泛使用是的其CPU硬件逻辑越来越复杂，且不够开放，不能改变，不是开源的，提高了操作系统开发者的学习难度。</p>
<p>从某种角度上看，新出现的RISC-V的核心目标是灵活适应未来的AIoT场景，保证基本功能，提供可配置的扩展功能。其开源特征使得学生都可以方便地设计一个RISC-V CPU。</p>
<p>写面向RISC-V的OS的代价仅仅是你了解RISC-V的Supevisor特权模式，知道OS在Supevisor特权模式下的控制能力。</p>
<h2><a class="header" href="#清华大学为何要写这本操作系统书" id="清华大学为何要写这本操作系统书">清华大学为何要写这本操作系统书?</a></h2>
<p>现在国内外已有一系列优秀的操作系统教材,例如 William Stallings 的《Operating Systems Internals and Design Principles》，Avi Silberschatz、Peter Baer Galvin 和 Greg Gagne 的《Operating System Concepts》，Remzi H. Arpaci-Dusseau 和 Andrea C. Arpaci-Dusseau 的《Operating Systems: Three Easy Pieces》等。然而,从我们从2000年以来的教学实践来看,某些经典教材对操作系统的概念和原理很重视，但还有如下一些问题有待改进：</p>
<p>原理与实践脱节：缺乏在操作系统的概念/原理与操作系统的设计/实现之间建立联系的桥梁，导致学生发现操作系统实现相关的实验与操作系统的概念相比，有较大的鸿沟。</p>
<p>缺少历史发展的脉络：操作系统的概念和原理是从实际操作系统设计与实现过程中，从无到有逐步演进而产生的，有其发展的历史渊源和规律。但目前的大部分教材只提及当前主流操作系统的概念和原理，有“凭空出现”的感觉，学生并不知道这些内容出现的前因后果。</p>
<p>忽视硬件细节或用复杂硬件：很多教材忽视或抽象硬件细节，是的操作系统概念难以落地。部分教材把 x86 作为的操作系统实验的硬件参考平台，缺乏对当前快速发展的RISC-V等体系结构的实验支持，使得学生在操作系统实验中可能需要花较大代价了解相对繁杂的x86硬件细节，影响操作系统实验的效果。</p>
<p>这些问题增加了学生学习和掌握操作系统的难度。我们想通过尝试解决上面三个问题，来缓解学生学习操作系统的压力，提升他们的兴趣，让他们能够在一个学期内比较好地掌握操作系统。为应对“原理与实践脱节”的问题，我们强调了实践先行，实践引领原理的理念。MIT教授 Frans Kaashoek等师生设计实现了基于UNIX v6的xv6教学操作系统用于每年的本科操作系统课的实验中，并在课程讲解中把原理和实验结合起来，在国际上得到了广泛的认可。这些都给了我们很好的启发，经过十多年的实践，对一个计算机专业的本科生而言，设计实现一个操作系统（包括CPU）有挑战但可行，前提是实际操作系统要小巧并能体现操作系统的核心思想。这样就能够让学生加深对操作系统原理和概念的理解，能让操作系统原理和概念落地。</p>
<p>为应对“缺少历史发展的脉络”的问题，我们重新设计操作系统实验和教学内容，按照操作系统的历史发展过程来建立多个相对独立的小实验，每个实验体现了操作系统的一个微缩的历史，并从中归纳总结出操作系统相关的概念与原理，并在教学中引导学生理解这些概念和原理是如何一步一步演进的。</p>
<p>为应对“忽视硬件细节或用复杂硬件”的问题，我们在硬件（x86, ARM, MIPS, RISC-V等）和编程语言（C, C++, Go, Rust等）选择方面进行了多年尝试。在2017年引入了RISC-V CPU作为操作系统实验的硬件环境，在2018年引入Rust编程语言作为开发操作系统的编程语言，使得学生以相对较小的开发和调试代价能够用Rust语言编写运行在RISC-V上的操作系统。而且方便和简化了让操作系统的概念和原理形象化，可视化的过程。学生可以吧操作系统的概念和原理直接对应到程序代码、硬件规范和操作系统的实际执行中，加强了学生对操作系统内涵的实际体验和感受。</p>
<p>所以本书的目标是以简洁的RISC-V CPU为底层硬件基础，根据上层应用从小到大的需求，按OS发展的历史脉络，逐步讲解如何设计并实现满足这些需求的“从小到大”的多个“小”操作系统。并在设计实现操作系统的过程中，逐步解析操作系统各种概念与原理的知识点，对应的做到有“理”可循和有“码”可查，最终让读者通过主动的操作系统设计与实现来深入地掌握操作系统的概念与原理。</p>
<p>在具体撰写过程中，第零章是对操作系统的一个概述，让读者对操作系统的历史、定义、特征等概念上有一个大致的了解。后面的每个章节体现了操作系统的一个微缩的历史发展过程，即从对应用由简到繁的支持的角度出发，每章会讲解如何设计一个可运行应用的操作系统，满足应用的阶段性需求。从而读者可以通过对应配套的操作系统设计实验，了解如何从一个微不足道的“小”操作系统，根据应用需求，添加或增强操作系统功能，逐步形成一个类似UNIX的相对完善的“小”操作系统。每一步都小到足以让人感觉到易于掌控，而在每一步结束时，你都有一个可以工作的“小”操作系统。另外，通过足够详尽的测试程序 ，可以随时验证读者实现的操作系统在每次更新后是否正常工作。由于实验的代码规模和实现复杂度在一个逐步递增的可控范围内，读者可以结合对应于操作系统设计实验的进一步的原理讲解，来建立操作系统概念原理和实际实现的对应关系，从而能够通过操作系统实验的实践过程来加强对理论概念的理解，通过理论概念来进一步指导操作系统实验的实现与改进。</p>
<p>在你开始阅读与实践本书讲解的内容之前，你需要决定用什么编程语言来完成操作系统实验。你可以用任何你喜欢的编程语言和你喜欢的CPU上来实现操作系统。我们推荐的编程语言是Rust，我们推荐的CPU是RISC-V。</p>
<h1><a class="header" href="#rust生态安全漏洞总结系列--part-1" id="rust生态安全漏洞总结系列--part-1"><code>Rust</code>生态安全漏洞总结系列 | Part 1</a></h1>
<p>作者：张汉东
后期编辑：张汉东</p>
<p>本系列主要是分析<a href="https://rustsec.org/advisories/"><code>RustSecurity</code> 安全数据库库</a>中记录的<code>Rust</code>生态社区中发现的安全问题，从中总结一些教训，学习<code>Rust</code>安全编程的经验。</p>
<hr />
<p>作为本系列文章的首篇文章，我节选了<a href="https://rustsec.org/advisories/"><code>RustSecurity</code> 安全数据库库</a>中 2021 年 1 月份记录的前五个安全漏洞来进行分析。</p>
<p><img src="chapter_1/./rust_security/0.png" alt="img" /></p>
<h2><a class="header" href="#01--mdbook-xss-漏洞-rustsec-2021-0001" id="01--mdbook-xss-漏洞-rustsec-2021-0001">01 | Mdbook XSS 漏洞 (RUSTSEC-2021-0001)</a></h2>
<p><img src="chapter_1/./rust_security/1.png" alt="img" /></p>
<p>正好《Rust 中文精选（RustMagazine）》也用了 mdbook，不过读者朋友不用害怕，本刊用的 mdbook 是修补了该漏洞的版本。</p>
<p>该漏洞并非 Rust 导致，而是生成的网页中 JS 函数使用错误的问题。</p>
<p>漏洞描述：</p>
<p>问题版本的 mdBook 中搜索功能（在版本<code>0.1.4</code>中引入）受到跨站点脚本漏洞的影响，该漏洞使攻击者可以通过诱使用户键入恶意搜索查询或诱使用户进入用户浏览器来执行任意<code>JavaScript</code>代码。</p>
<p>漏洞成因分析：</p>
<p>XSS的漏洞主要成因是后端接收参数时未经过滤，导致参数改变了HTML的结构。而<code>mdbook</code>中提供的<code>js</code>函数<code>encodeURIComponent</code>会转义除<code>'</code>之外的所有可能允许<code>XSS</code>的字符。 因此，还需要手动将<code>'</code>替换为其<code>url</code>编码表示形式（％27）才能解决该问题。</p>
<p><a href="https://github.com/rust-lang/mdBook/commit/648c9ae772bec83f0a5954d17b4287d5bb1d6606">修复 PR</a> 也很简单。</p>
<h2><a class="header" href="#02--暴露裸指针导致段错误-rustsec-2021-0006" id="02--暴露裸指针导致段错误-rustsec-2021-0006">02 | 暴露裸指针导致段错误 (RUSTSEC-2021-0006)</a></h2>
<p><img src="chapter_1/./rust_security/2.png" alt="img" /></p>
<p>该漏洞诞生于第三方库<a href="https://crates.io/crates/cache">cache</a>，该库虽然已经两年没有更新了，但是它里面出现的安全漏洞的警示作用还是有的。该库<a href="https://github.com/krl/cache/issues/2">问题<code>issue</code></a>中说明了具体的安全漏洞。</p>
<p>该安全漏洞的特点是，因为库接口中将裸指针（raw pointer) 公开了出来，所以该裸指针可能被用户修改为空指针，从而有段错误风险。因为这个隐患是导致 Safe Rust 出现 UB，所以是不合理的。</p>
<p>以下代码的注释分析了漏洞的产生。</p>
<pre><pre class="playground"><code class="language-rust">use cache;


/**

    `cache crate` 内部代码：

    ```rust
    pub enum Cached&lt;'a, V: 'a&gt; {
        /// Value could not be put on the cache, and is returned in a box
        /// as to be able to implement `StableDeref`
        Spilled(Box&lt;V&gt;),
        /// Value resides in cache and is read-locked.
        Cached {
            /// The readguard from a lock on the heap
            guard: RwLockReadGuard&lt;'a, ()&gt;,
            /// A pointer to a value on the heap
            // 漏洞风险
            ptr: *const ManuallyDrop&lt;V&gt;,
        },
        /// A value that was borrowed from outside the cache.
        Borrowed(&amp;'a V),
    }

    ```
**/
fn main() {
    let c = cache::Cache::new(8, 4096);
    c.insert(1, String::from(&quot;test&quot;));
    let mut e = c.get::&lt;String&gt;(&amp;1).unwrap();

    match &amp;mut e {
        cache::Cached::Cached { ptr, .. } =&gt; {
            // 将 ptr 设置为 空指针，导致段错误
            *ptr = std::ptr::null();
        },
        _ =&gt; panic!(),
    }
    // 输出：3851，段错误
    println!(&quot;Entry: {}&quot;, *e);
}

</code></pre></pre>
<p>启示：</p>
<p>所以，这里我们得到一个教训，就是不能随便在公开的 API 中暴露裸指针。值得注意的是，该库处于失去维护状态，所以这个漏洞还没有被修正。</p>
<h2><a class="header" href="#03--读取未初始化内存导致ub-rustsec-2021-0008" id="03--读取未初始化内存导致ub-rustsec-2021-0008">03 | 读取未初始化内存导致<code>UB</code> (RUSTSEC-2021-0008)</a></h2>
<p><img src="chapter_1/./rust_security/3.png" alt="img" /></p>
<p>该漏洞诞生于 <a href="https://crates.io/crates/bra">bra</a> 库。该库这个安全漏洞属于逻辑 Bug 。因为错误使用 标准库 API，从而可能让用户读取未初始化内存导致 UB。</p>
<p>披露该漏洞的<a href="https://github.com/Enet4/bra-rs/issues/1">issue</a>。目前该漏洞已经被修复。</p>
<p>以下代码注释保护了对漏洞成因对分析：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下是有安全风险的代码示例：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        let buf = unsafe {
            // safe because it's within the buffer's limits
            // and we won't be reading uninitialized memory
            // 这里虽然没有读取未初始化内存，但是会导致用户读取
            std::slice::from_raw_parts_mut(
                self.buf.as_mut_ptr().offset(b as isize),
                self.buf.capacity() - b)
        };

        match self.inner.read(buf) {
            Ok(o) =&gt; {
                unsafe {
                    // reset the size to include the written portion,
                    // safe because the extra data is initialized
                    self.buf.set_len(b + o);
                }

                Ok(&amp;self.buf[self.consumed..])
            }
            Err(e) =&gt; Err(e),
        }
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>GreedyAccessReader::fill_buf</code>方法创建了一个未初始化的缓冲区,并将其传递给用户提供的Read实现（<code>self.inner.read（buf）</code>）。这是不合理的，因为它允许<code>Safe Rust</code>代码表现出未定义的行为（从未初始化的内存读取）。</p>
<p>在标准库<code>Read</code> trait 的 <code>read</code> 方法文档中所示：</p>
<blockquote>
<p>您有责任在调用<code>read</code>之前确保<code>buf</code>已初始化。
用未初始化的<code>buf</code>（通过<code>MaybeUninit &lt;T&gt;</code>获得的那种）调用<code>read</code>是不安全的，并且可能导致未定义的行为。
https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read</p>
</blockquote>
<p>解决方法：</p>
<p>在<code>read</code>之前将新分配的<code>u8</code>缓冲区初始化为零是安全的，以防止用户提供的<code>Read</code>读取新分配的堆内存的旧内容。</p>
<p>修正代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码示例，去掉了未初始化的buf：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        self.buf.resize(self.buf.capacity(), 0);
        let buf = &amp;mut self.buf[b..];
        let o = self.inner.read(buf)?;

        // truncate to exclude non-written portion
        self.buf.truncate(b + o);

        Ok(&amp;self.buf[self.consumed..])
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>启示：</p>
<p>该漏洞给我们对启示是，要写出安全的 Rust 代码，还必须掌握每一个标准库里 API 的细节。否则，逻辑上的错误使用也会造成<code>UB</code>。</p>
<h2><a class="header" href="#04--读取未初始化内存导致ub--rustsec-2021-0012" id="04--读取未初始化内存导致ub--rustsec-2021-0012">04 | 读取未初始化内存导致<code>UB</code>  (RUSTSEC-2021-0012)</a></h2>
<p><img src="chapter_1/./rust_security/4.png" alt="img" /></p>
<p>该漏洞诞生于第三方库[cdr-rs]中，漏洞相关<a href="https://github.com/hrektts/cdr-rs/issues/10">issue</a>中。</p>
<p>该漏洞和 RUSTSEC-2021-0008 所描述漏洞风险是相似的。</p>
<p><code>cdr-rs</code> 中的 <code>Deserializer::read_vec</code>方法创建一个未初始化的缓冲区，并将其传递给用户提供的<code>Read</code>实现（self.reader.read_exact）。</p>
<p>这是不合理的，因为它允许安全的<code>Rust</code>代码表现出未定义的行为（从未初始化的内存读取）。</p>
<p>漏洞代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    unsafe { buf.set_len(len as usize) }
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p>修正：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    // 初始化为 0；
    buf.resize(len as usize, 0);
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p>启示：同上。</p>
<h2><a class="header" href="#05--panic-safety--double-free-rustsec-2021-0011" id="05--panic-safety--double-free-rustsec-2021-0011">05 | Panic Safety &amp;&amp; Double free (RUSTSEC-2021-0011)</a></h2>
<p><img src="chapter_1/./rust_security/5.png" alt="img" /></p>
<p>该漏洞诞生于<a href="https://crates.io/crates/ocl">ocl</a>库，漏洞相关<a href="https://github.com/cogciprocate/ocl/issues/194">issue</a>。该库已经处于不再维护状态，但是这个漏洞背后的成因需要引起我们重视。</p>
<p>该库中使用了<code>ptr::read</code>，并且没有考虑好<code>Panic Safety</code>的情况，所以会导致双重释放（double free)。</p>
<p>以下两段代码是漏洞展示，注意注释部分都解释：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//case 1
macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
                fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                    let mut el = EventList::with_capacity(events.len());
                    for idx in 0..events.len() {
                    // 这个 unsafe 用法在 `event.into()`调用panic的时候会导致双重释放
                        let event_opt = unsafe { ptr::read(events.get_unchecked(idx)) };
                        if let Some(event) = event_opt { el.push::&lt;Event&gt;(event.into()); }
                    }
                    // 此处 mem::forget 就是为了防止 `dobule free`。
                    // 因为 `ptr::read` 也会制造一次 drop。
                    // 所以上面如果发生了panic，那就相当于注释了 `mem::forget`，导致`dobule free`
                    mem::forget(events);
                    el
                }
        }
    )
);

// case2

impl&lt;'e, E&gt; From&lt;[E; $len]&gt; for EventList where E: Into&lt;Event&gt; {
    fn from(events: [E; $len]) -&gt; EventList {
        let mut el = EventList::with_capacity(events.len());
        for idx in 0..events.len() {
        // 同上
            let event = unsafe { ptr::read(events.get_unchecked(idx)) };
            el.push(event.into());
        }
        // Ownership has been unsafely transfered to the new event
        // list without modifying the event reference count. Not
        // forgetting the source array would cause a double drop.
        mem::forget(events);
        el
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以下是一段该漏洞都复现代码（我本人没有尝试过，但是提交issue都作者试过了），注意下面注释部分的说明：</p>
<pre><pre class="playground"><code class="language-rust">// POC:以下代码证明了上面两个case会发生dobule free 问题

use fil_ocl::{Event, EventList};
use std::convert::Into;

struct Foo(Option&lt;i32&gt;);

impl Into&lt;Event&gt; for Foo {
    fn into(self) -&gt; Event {
        /*
        根据文档，`Into &lt;T&gt;`实现不应出现 panic。但是rustc不会检查Into实现中是否会发生恐慌，
        因此用户提供的`into（）`可能会出现风险
        */
        println!(&quot;LOUSY PANIC : {}&quot;, self.0.unwrap()); // unwrap 是有 panic 风险

        Event::empty()
    }
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;I'm dropping&quot;);
    }
}

fn main() {
    let eventlist: EventList = [Foo(None)].into();
    dbg!(eventlist);
}

</code></pre></pre>
<p>以下是 Fix 漏洞的代码，使用了<code>ManuallyDrop</code>，注意注释说明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
            fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                let mut el = ManuallyDrop::new(
                    EventList::with_capacity(events.len())
                );

                for idx in 0..events.len() {
                    let event_opt = unsafe {
                        ptr::read(events.get_unchecked(idx))
                    };

                    if let Some(event) = event_opt {
                        // Use `ManuallyDrop` to guard against
                        // potential panic within `into()`.
                        // 当 into 方法发生 panic 当时候，这里 ManuallyDrop 可以保护其不会`double free`
                        let event = ManuallyDrop::into_inner(
                            ManuallyDrop::new(event)
                            .into()
                        );
                        el.push(event);
                    }
                }
                mem::forget(events);
                ManuallyDrop::into_inner(el)
            }
        }
    )
);

<span class="boring">}
</span></code></pre></pre>
<p>启示：</p>
<p>在使用 <code>std::ptr</code> 模块中接口需要注意，容易产生 UB 问题，要多多查看 API 文档。</p>
<h1><a class="header" href="#rustc-dev-guide-中文翻译启动" id="rustc-dev-guide-中文翻译启动">Rustc Dev Guide 中文翻译启动</a></h1>
<p>作者：张汉东</p>
<hr />
<p><a href="https://github.com/rust-lang/rustc-dev-guide">Rust编译器开发指南（Rustc Dev Guide）</a> 的中文翻译已经启动。因为原项目还在变动期，为了翻译方便，所以此翻译项目组织结构就不和原项目保持一致了。</p>
<ul>
<li><a href="https://rustc-dev-guide.rust-lang.org/">官方原文在线阅读</a></li>
<li><a href="https://rustcrustc.github.io/rustc-dev-guide-zh/">中文版在线阅读</a></li>
<li><a href="https://github.com/RustcRustc/rustc-dev-guide-zh">中文版翻译仓库地址</a></li>
</ul>
<h4><a class="header" href="#志愿者招募要求" id="志愿者招募要求">志愿者招募要求：</a></h4>
<ul>
<li>热爱 Rust，对 Rust 已经有一定了解</li>
<li>想深入了解 Rust 编译器</li>
<li>想为 Rust 编译器做贡献</li>
<li>业余时间充足</li>
</ul>
<h4><a class="header" href="#如何参与" id="如何参与">如何参与</a></h4>
<ol>
<li>认领感兴趣到章节</li>
<li>找到对应到 markdown 文件</li>
<li>直接发 PR</li>
<li>或者帮忙审校别人的 PR</li>
</ol>
<h3><a class="header" href="#q--a" id="q--a">Q &amp; A:</a></h3>
<ol>
<li>
<p>如何避免每个人翻译上的冲突呢，需要提前pr说翻译哪一章节吗？</p>
<p>其实没必要怕冲突，对于参与翻译的来说，翻译本身也是一次学习过程，是有收获的。了解编译器工作原理对理解 Rust 概念也有帮助的。如果同一篇有多个翻译，那我这边选翻译更好的就可以了。</p>
<p>这个项目倡导参与者自组织，但为了更加方便大家协作，还是来设置一个规则避免大家冲突。为了大家认领方便，特别创建了认领打卡的 issues，都去这里打一下卡：<a href="https://github.com/RustcRustc/rustc-dev-guide-zh/issues/1">【翻译认领】避免翻译冲突，来此打卡</a>。</p>
<p>如果你想发一个自己专属的「认领issue」也没问题，可以给该issue打上「已认领」标签。开一个独立的issue好处是可以有一个专属的地方讨论你翻译章节内容里的各种问题。</p>
</li>
<li>
<p>为什么要翻译 《Rust 编译器开发指南》  ？</p>
<p>年初的时候，我立下一个五年的 Flag ： 五年内要为 Rust 语言发 1000 个 PR。</p>
<p>然后社区里的朋友就帮我做了一个计算：五年 1000 个，那么每年 200 个，那么一天就得 0.5 个。也有朋友说，Rust 的 PR 每次 Review 周期都很长，就算你能一年提 200 个 PR，官方也不可能给你合并那么多。</p>
<p>这样的计算，确实很有道理。这个目标，确实很难完成。但其实这个 Flag 我并没有打算个人完成，而是想推动社区对 Rust 感兴趣对朋友一起完成。如果五年内，我能推动 1000 个人参与，那么每个人只提交一个 PR，那么这个 1000 个 PR 的 Flag 就轻松完成了。</p>
<p>所以，翻译 《Rust 编译器开发指南》就成了我完成这个 Flag 的第一步。希望大家踊跃参与。</p>
</li>
</ol>
<h1><a class="header" href="#图解-rust-编译器与语言设计--part-1-rust-编译过程与宏展开" id="图解-rust-编译器与语言设计--part-1-rust-编译过程与宏展开">图解 Rust 编译器与语言设计 | Part 1 ：Rust 编译过程与宏展开</a></h1>
<p>作者：张汉东</p>
<hr />
<h2><a class="header" href="#说明" id="说明">说明</a></h2>
<p>《图解 Rust 编译器与语言设计》系列文章特点：</p>
<ol>
<li>重在图解。图解的目的，是为了帮助开发者从整体结构、语义层面来掌握 Rust 编译器与语言设计。</li>
<li>边实践边总结，不一定会每月都有，但争取吧。</li>
<li>希望是众人合力编写，我只是抛砖引玉。硬骨头，一起啃。</li>
</ol>
<h2><a class="header" href="#引子" id="引子">引子</a></h2>
<p>想必读者朋友们都已经看到了 《Rust 日报》里的消息：微软、亚马逊、Facebook等巨头，都在组建自己的 Rust 编译器团队，都在战略性布局针对 Rust 语言。并且 Rust 基金会也已经进入了最后都流程，由此可以猜想，这些巨头很可能已经加入了基金会。</p>
<p>我在 RustChinaConf 2020 年大会分享《Rust 这五年》中盘点了 Rust 这五年多都发展，虽然 Rust 势头很好，但大部分贡献其实都是国外社区带来的，国内社区则是处于学习和观望的状态，等待着所谓的杀手级应用出现来引领 Rust 的“走红”。为什么国内社区不能为 Rust 多做点实质性的贡献呢？</p>
<p>因此，2020 新年到来的时候，我立下一个五年的 Flag ： 五年内要为 Rust 语言发 1000 个 PR。</p>
<p>然后社区里的朋友就帮我做了一个计算：五年 1000 个，那么每年 200 个，那么一天就得 0.5 个。也有朋友说，Rust 的 PR 每次 Review 周期都很长，就算你能一年提 200 个 PR，官方也不可能给你合并那么多。</p>
<p>这样的计算，确实很有道理。这个目标，确实很难完成。但其实这个 Flag 我并没有打算个人完成，而是想推动社区对 Rust 感兴趣对朋友一起完成。如果五年内，我能推动 1000 个人参与，那么每个人只提交一个 PR，那么这个 1000 个 PR 的 Flag 就轻松完成了。</p>
<p>所以，为了完成这个 Flag ，我把未来五年划分成三个阶段：</p>
<ol>
<li>第一阶段：2021 年。该阶段的目标是「上道」。</li>
<li>第二阶段：2022 ～ 2023 年。该阶段的目标是「进阶」。</li>
<li>第三阶段：2024 ~ 2025 年。该阶段目标是「达标」。</li>
</ol>
<p>也就是说，今年是想要「上道」的一年。那么要达成这个目标，我做了以下计划：</p>
<ol>
<li>组织社区力量来翻译官方的《Rust 编译器开发指南》。</li>
<li>组织 Rust 编译器小组，开始为 Rust 语言做点贡献，并且将在此过程中自己的学习和经验沉淀为《图解 Rust 编译器与语言设计》系列文章。</li>
</ol>
<p>通过这两份文档，希望可以帮助和影响到更多的人，来为 Rust 语言做贡献。</p>
<p>我知道，编译器作为程序员的三大浪漫之一，水很深。你也可能会说，人家搞编译器的都是 PL 出生，一般人哪有那种本事。诚然如你所想，编译器很难。但幸亏，难不等于不可能。不会，我们可以学。况且，也不是让你从零开始去实现一个 Rust 编译器。</p>
<p>为 Rust 语言做贡献，并不是 KPI 驱动，而是兴趣驱动。可能你看完了编译原理龙书虎书鲸书三大经典，也可能你实现过自己的一门语言。但其收获可能永远也比不上实际参与到 Rust 这样一个现代化语言项目中来。</p>
<p>所以，《图解 Rust 编译器与语言设计》系列文章，不仅仅会记录我自己学习 Rust 编译器的沉淀，还会记录你的沉淀，如果你愿意投稿的话。在这浮躁的世界，给自己一片净土，找回技术初心。</p>
<hr />
<h2><a class="header" href="#图解-rust-编译过程" id="图解-rust-编译过程">图解 Rust 编译过程</a></h2>
<p>对于学习，我通常习惯先从整体和外围下手，去了解一个东西的全貌和结构之后，再逐步深入细节。否则的话，很容易迷失到细节中。</p>
<p>所以，必须先来了解 Rust 编译过程。如下图：</p>
<p><img src="chapter_1/./rustc/rust-complie-process.png" alt="rust-complie-process" /></p>
<p>上图中间部分为 Rust 代码的整体编译过程，左右两边分别为过程宏和声明宏的解释过程。</p>
<p>Rust 语言是基于 LLVM 后端实现的编程语言。在编译器层面来说，Rust编译器仅仅是一个编译器前端，它负责从文本代码一步步编译到<code>LLVM</code>中间码(<code>LLVM IR</code>)，然后再交给<code>LLVM</code>来最终编译生成机器码，所以<code>LLVM</code>就是编译后端。</p>
<h3><a class="header" href="#rust-语言编译整体流程" id="rust-语言编译整体流程">Rust 语言编译整体流程</a></h3>
<ol>
<li>Rust 文本代码首先要经过「词法分析」阶段。</li>
</ol>
<p>将文本语法中的元素，识别为对 Rust 编译器有意义的「词条」，即<code>token</code>。</p>
<ol start="2">
<li>
<p>经过词法分析之后，再通过语法分析将词条流转成「抽象语法树（AST）」。</p>
</li>
<li>
<p>在得到 AST 之后，Rust 编译器会对其进行「语义分析」。</p>
</li>
</ol>
<p>一般来说，语义分析是为了检查源程序是否符合语言的定义。在 Rust 中，语义分析阶段将会持续在两个中间码层级中进行。</p>
<ol start="4">
<li>语义分析 HIR 阶段。</li>
</ol>
<p>HIR 是抽象语法树（AST）对编译器更友好的表示形式，很多 Rust 语法糖在这一阶段，已经被脱糖（desugared）处理。比如 <code>for</code> 循环在这个阶段会被转为<code>loop</code>，<code>if let</code> 被转为<code>match</code>，等等。HIR 相对于 AST 更有利于编译器的分析工作，它主要被用于 「类型检查（type check）、推断（type inference）」。</p>
<ol start="5">
<li>语义分析 MIR 阶段。</li>
</ol>
<p>MIR 是 Rust 代码的中级中间代表，基于 HIR 进一步简化构建。MIR 是在<code>RFC 1211</code>中引入的。</p>
<p>MIR 主要用于借用检查。早期在没有 MIR 的时候，借用检查是在 HIR 阶段来做的，所以主要问题就是生命周期检查的粒度太粗，只能根据词法作用域来进行判断，导致很多正常代码因为粗粒度的借用检查而无法通过编译。Rust 2018 edition 中引入的 非词法作用域生命周期（NLL）就是为来解决这个问题，让借用检查更加精细。NLL 就是因为 MIR 的引入，将借用检查下放到 MIR 而出现的一个术语，这个术语随着 Rust 的发展终将消失。</p>
<p>MIR 这一层其实担负的工作很多，除了借用检查，还有代码优化、增量编译、Unsafe 代码中 UB 检查、生成<code>LLVM IR</code>等等。关于 MIR 还需要了解它的三个关键特性：</p>
<blockquote>
<ul>
<li>它是基于控制流图（编译原理：Control Flow Graph）的。</li>
<li>它没有嵌套表达式。</li>
<li>MIR 中的所有类型都是完全明确的，不存在隐性表达。人类也可读，所以在 Rust 学习过程中，可以通过查看 MIR 来了解 Rust 代码的一些行为。</li>
</ul>
</blockquote>
<ol start="6">
<li>
<p>图中没有画出来的，还有一个从 HIR 到 MIR 的一个过渡中间代码表示 THIR（Typed HIR） 。THIR 是对 HIR 的进一步降级简化，用于更方便地构建 MIR 。在源码层级中，它属于 MIR 的一部分。</p>
</li>
<li>
<p>生成 <code>LLVM IR</code> 阶段。<code>LLVM IR</code>是<code>LLVM</code>中间语言。<code>LLVM</code>会对<code>LLVM IR</code>进行优化，再生成为机器码。</p>
</li>
</ol>
<p>后端为什么要用 <code>LLVM</code> ？不仅仅是 Rust 使用 <code>LLVM</code>，还有很多其他语言也使用它，比如 Swift 等。 <code>LLVM</code> 的优点：</p>
<blockquote>
<ul>
<li>LLVM后端支持的平台很多，我们不需要担心CPU、操作系统的问题（运行库除外）。</li>
<li>LLVM后端的优化水平较高，我们只需要将代码编译成LLVM IR，就可以由LLVM后端作相应的优化。</li>
<li>LLVM IR本身比较贴近汇编语言，同时也提供了许多ABI层面的定制化功能。</li>
</ul>
</blockquote>
<p>Rust 核心团队也会帮忙维护 <code>LLVM</code>，发现了 Bug 也会提交补丁。虽然<code>LLVM</code>有这么多优点，但它也有一些缺点，比如编译比较慢。所以，Rust 团队在去年引入了新的后端 Cranelift ，用于加速 Debug 模式的编译。Rust 编译器内部组件 <code>rustc_codegen_ssa</code> 会生成后端无关的中间表示，然后由 Cranelift 来处理。从2021年1月开始，通过<code>rustc_codegen_ssa</code> 又为所有后端提供了一个抽象接口以实现，以允许其他代码源后端（例如 Cranelift），这意味着，Rust 语言将来可以接入多个编译后端（如果有的话）。</p>
<p>以上是 Rust 整体编译流程。但 Rust 语言还包含来强大的元编程：「宏（Macro）」，宏代码是如何在编译期展开的呢？请继续往下看。</p>
<h3><a class="header" href="#rust-宏展开" id="rust-宏展开">Rust 宏展开</a></h3>
<p>Rust 本质上存在两类宏：<strong>声明宏（Declarative Macros）</strong> 与 <strong>过程宏（Procedural Macros）</strong> 。很多人可能搞不清楚它们的差异，也许看完这部分内容就懂了。</p>
<p><strong>声明宏</strong></p>
<p>回头再看看上面的图右侧部分。我们知道，Rust 在最初解析文本代码都时候会将代码进行词法分析生成词条流（TokenStream）。在这个过程中，如果遇到了宏代码（不管是声明宏还是过程宏），则会使用专门的「宏解释器（Macro Parser）」 来解析宏代码，将宏代码展开为 TokenStream，然后再合并到普通文本代码生成的 TokenSteam 中。</p>
<p>你可能会有疑问，其他语言的宏都是直接操作 AST ，为什么 Rust 的宏在 Token 层面来处理呢？</p>
<p>这是因为 Rust 语言还在高速迭代期，内部 AST 变动非常频繁，所以无法直接暴露 AST API 供开发者使用。而词法分析相对而言很稳定，所以目前 Rust 宏机制都是基于词条流来完成的。</p>
<p>那么声明宏，就是完全基于词条流（TokenStream)。声明宏的展开过程，其实就是根据指定的匹配规则（类似于正则表达式），将匹配的 Token 替换为指定的 Token 从而达到代码生成的目的。因为仅仅是 Token 的替换（这种替换依然比 C 语言里的那种宏强大），所以你无法在这个过程中进行各种类型计算。</p>
<p><strong>过程宏</strong></p>
<p>声明宏非常方便，但因为它只能做到替换，所以还是非常有局限的。所以后来 Rust 引入了过程宏。过程宏允许你在宏展开过程中进行任意计算。但我们不是说，Rust 没有暴露 AST API 吗？为什么过程宏可以做到这么强大？</p>
<p>其实，过程宏也是基于 TokenSteam API的，只不过由第三方库作者 dtolnay 设计了一套语言外的 AST ，经过这一层 AST 的操作，就实现了想要的结果。</p>
<p>没有什么问题不是可以通过加一层解决的，如果解决不了那就加两层。</p>
<p>dtolnay 在社区内被誉为最佳 API 设计天才。他创造了不少库，比如 Serde，是 Rust 生态中被应用最多的一个库。</p>
<p>话说回来。过程宏的工作机制就如上面图中左侧展示的那样。主要是利用三个库，我称之为 「过程宏三件套」：</p>
<ol>
<li>proc_macro2。该库是对 proc_macro 的封装，是由 Rust 官方提供的。</li>
<li>syn。该库是 dtolnay 实现的，基于 proc_macro2 中暴露的 TokenStream API 来生成 AST 。该库提供来方便的 AST 操作接口。</li>
<li>quote。该库配合 syn，将 AST 转回 TokenSteam，回归到普通文本代码生成的 TokenSteam 中。</li>
</ol>
<p>过程宏的整个过程，就像是水的生态循环。 蒸汽从大海（TokenSteam）中来，然后通过大雨(Syn)，降到地上(Quote)，形成涓涓细流(proc_macro2::TokenStream)最终汇入大海（TokenSteam）。</p>
<p>理解过程宏的展开原理，将有助于你学习过程宏。</p>
<h2><a class="header" href="#小结" id="小结">小结</a></h2>
<p>本篇文章主要介绍了 Rust 代码的编译过程，以及 Rust 宏代码的展开机制，学习这些内容，将有助于你深入理解 Rust 的概念。不知道这篇内容是否激发起你对 Rust 编译器对兴趣呢？编译器是一个深坑，让我们慢慢挖掘它。</p>
<p>感谢阅读。</p>
<h1><a class="header" href="#二月刊" id="二月刊">二月刊</a></h1>
<p><img src="chapter_2/../image/rust_magazine3.png" alt="logo" /></p>
<h3><a class="header" href="#发刊通告" id="发刊通告">发刊通告</a></h3>
<ul>
<li><a href="chapter_2/./announce.html">发刊通告</a></li>
</ul>
<h3><a class="header" href="#本月社区动态简报-1" id="本月社区动态简报-1">本月社区动态简报</a></h3>
<p>精选自《Rust日报》</p>
<ul>
<li><a href="chapter_2/./lang.html">Rust官方动态</a></li>
<li><a href="chapter_2/./hots.html">社区热点</a></li>
<li><a href="chapter_2/./projects.html">推荐项目</a></li>
<li><a href="chapter_2/./learns.html">学习资源</a></li>
<li><a href="chapter_2/./rust_laoke.html">Rust 唠嗑室本月汇总</a></li>
</ul>
<h3><a class="header" href="#rust-问答精选" id="rust-问答精选">Rust 问答精选</a></h3>
<ul>
<li><a href="chapter_2/./rust_zhihu.html">知乎 Rust 圆桌年话专题问答精选</a></li>
</ul>
<h3><a class="header" href="#rust-in-production-1" id="rust-in-production-1">Rust in Production</a></h3>
<ul>
<li><a href="chapter_2/./huawei_rust.html">华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景</a></li>
<li><a href="chapter_2/./rust_trace.html">PingCAP | TiKV 高性能追踪的实现解析</a></li>
<li><a href="chapter_2/./rust_error_handle.html">蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考</a></li>
<li><a href="chapter_2/./rust_error_handle_and_log.html">华为 | Rust中的错误传递和日志记录</a></li>
</ul>
<h3><a class="header" href="#学习园地-1" id="学习园地-1">学习园地</a></h3>
<ul>
<li><a href="chapter_2/./rust_study.html">新年新人新气象 | Rust 学习笔记</a></li>
<li><a href="chapter_2/./cli_gameoflife.html">「译」使用 Rust 实现命令行生命游戏</a></li>
<li><a href="chapter_2/./actor_with_tokio.html">「译」使用 Tokio 实现 Actor 系统</a></li>
<li><a href="chapter_2/./rust_1.50.html">解读 Rust 1.50 稳定版</a></li>
<li><a href="chapter_2/./rust_2021_edition.html">解读 Rust 2021 Edition RFC </a></li>
</ul>
<h3><a class="header" href="#wasm-专题" id="wasm-专题">WASM 专题</a></h3>
<ul>
<li><a href="chapter_2/./rust_wasm_frontend.html">前端入门 ｜ Rust 和 WebAssembly </a></li>
</ul>
<h3><a class="header" href="#游戏专题" id="游戏专题">游戏专题</a></h3>
<ul>
<li><a href="chapter_2/./rust_game_bevy_bomber.html">实践案例 | 使用 <code>Bevy</code> 游戏引擎制作炸弹人</a></li>
</ul>
<h3><a class="header" href="#操作系统与网络编程专题" id="操作系统与网络编程专题">操作系统与网络编程专题</a></h3>
<ul>
<li><a href="chapter_2/./io_uring_intro.html">io_uring | Linux 全新异步接口 io_uring 的 Rust 生态盘点 </a></li>
<li><a href="chapter_2/./io_uring_async_rw.html">io_uring | 用 Rust 实现基于 io_uring 的异步随机读文件</a></li>
</ul>
<h3><a class="header" href="#rust-编译器专题-1" id="rust-编译器专题-1">Rust 编译器专题</a></h3>
<ul>
<li><a href="chapter_2/./contribute_to_the_rust_part1.html">如何为 Rust 语言做贡献 | Part 1</a></li>
</ul>
<h1><a class="header" href="#二月发刊通告" id="二月发刊通告">二月发刊通告</a></h1>
<p>时光易逝，转眼二月即将过去，春暖花开的三月即将到来。过年的余味犹在，但我们不得不继续踏上征途。</p>
<p>《 RustMagazine 中文精选 》2021 年第二期发布了，后续也期待大家投稿。</p>
<h3><a class="header" href="#本刊-mdbook-模版功能改进" id="本刊-mdbook-模版功能改进">本刊 mdbook 模版功能改进</a></h3>
<p><strong>mdbook 模版功能新增：</strong></p>
<ul>
<li>增加评论功能。评论会自动同步到 RustMagazine GitHub 仓库 与文章同名的 issues 下（文章下有评论就自动创建）。</li>
<li>增加画图功能。利用 mermaid 来画图。参考：<a href="https://mermaid-js.github.io/mermaid-live-editor/">mermaid 在线使用指南</a>。</li>
</ul>
<p>画图示例：</p>
<pre class="mermaid">graph TD
    A[RustMagazine] --&gt;|每月最后一天| B(发刊)
    B --&gt; C{阅读渠道}
    C --&gt; |GitHub Page| D[GitHub]
    C --&gt;|Rustcc| E[Rust中文论坛/公众号]
    C --&gt;|Rust视界| F[Telegram]
    C --&gt;|掘金| G[技术社区]
    C --&gt;|语雀| H[在线文档]
</pre>
<p>欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！</p>
<h3><a class="header" href="#上期一月刊访问数据统计小结" id="上期一月刊访问数据统计小结">上期（一月刊）访问数据统计小结</a></h3>
<p><strong>浏览量：</strong></p>
<ul>
<li>网页浏览量 ：3,678</li>
<li>唯一身份浏览量 ：2,889</li>
</ul>
<p><strong>读者访问最多时段：</strong></p>
<ul>
<li>每天上午 8点 到 下午 6点。</li>
<li>周四 和 周五 阅读量相对更多。</li>
</ul>
<p><strong>读者分布地区排名：</strong></p>
<ul>
<li>中国</li>
<li>北美（美国/加拿大）</li>
<li>澳洲</li>
</ul>
<p><strong>一月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li>《图解 Rust 所有权》，作者：肖猛</li>
<li>《用 Rust 写操作系统 | rCore 教程介绍》，作者：清华大学</li>
<li>《RustChinaConf2020 精选 | Rust 异步开发》，作者：赖智超</li>
<li>《关于 io_uring 与 Rust 的思考》，作者：王徐旸</li>
<li>《图解 Rust 编译器 | Part 1》，作者：张汉东</li>
</ul>
<p>阅读量最低为：</p>
<ul>
<li>《Rust 生态安全漏洞总结系列 | Part 1》，作者：张汉东 </li>
<li>《Rustc Dev Guide 中文翻译启动》，作者：张汉东</li>
</ul>
<p><strong>简报关注分类依次为：</strong></p>
<ul>
<li>Rust 官方动态</li>
<li>学习资源</li>
<li>推荐项目</li>
<li>社区热点</li>
<li>Rust 唠嗑室</li>
</ul>
<p><strong>读者阅读渠道依次为：</strong></p>
<ul>
<li>直接访问</li>
<li>GitHub</li>
<li>百度</li>
<li>⾕歌</li>
<li>rustcc</li>
<li>其他</li>
</ul>
<h1><a class="header" href="#本月简报--rust官方动态" id="本月简报--rust官方动态">本月简报 | Rust官方动态</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑：张汉东</li>
</ul>
<hr />
<h2><a class="header" href="#官宣rust基金会正式成立" id="官宣rust基金会正式成立">官宣，Rust基金会正式成立！</a></h2>
<p>基金会初创白金成员包括：</p>
<p>AWS，Google, HUAWEI（华为）, Microsoft, Mozilla</p>
<p>官网地址：https://foundation.rust-lang.org/</p>
<p>相关阅读：</p>
<ul>
<li><a href="chapter_2/./huawei_rust.html">华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景</a></li>
<li><a href="https://www.zhihu.com/question/443595816">Rust 语言圆桌年话 | 关于 Rust 语言基金会成立，你有什么想说的呢？</a></li>
</ul>
<h2><a class="header" href="#rust-150-稳定版发布" id="rust-150-稳定版发布">Rust 1.50 稳定版发布</a></h2>
<p>关于 Rust 1.50 详细解读，请跳转自 <a href="chapter_2/./rust_1.50.html">解读 Rust 1.50 稳定版</a> 一文阅读。</p>
<h2><a class="header" href="#rust语言团队二月份第一次会议" id="rust语言团队二月份第一次会议">Rust语言团队二月份第一次会议</a></h2>
<p>Rust 语言团队2月3号第一次召开了规划会议，并总结了会议纪要。从今以后，语言团队计划每个月的第一个星期三举行这样的会议。</p>
<p>举行规划会议的目的：检查我们正在进行的项目的状态，计划本月剩余时间的design meeting。</p>
<p>本次会议的主要内容：</p>
<ol>
<li>async foundations: 异步基础</li>
</ol>
<p>continued progress on polish, new traits (继续改进优化新的trait)</p>
<p>making plans to stabilize async functions in traits (制定稳定Trait中async函数的规划)</p>
<p>working on a vision document that lays out a multi-year vision for how async I/O should look/feel in Rust (编写一份愿景文档规划未来几年Rust 异步IO的愿景)</p>
<ol start="2">
<li>
<p>const generics 常量泛型</p>
</li>
<li>
<p>rfc 2229 (&quot;minimal closure capture&quot;)
continued progress on the implementation, things are going well</p>
</li>
</ol>
<p>we will likely add a capture! macro to use for migration; it would force the capture of a particular local variable (and not some subpath of it)</p>
<p>链接：<a href="https://blog.rust-lang.org/inside-rust/2021/02/03/lang-team-feb-update.html">https://blog.rust-lang.org/inside-rust/2021/02/03/lang-team-feb-update.html</a></p>
<p>会议纪要：<a href="https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-02-03-Planning-Meeting.md#project-updates-and-discussion">https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-02-03-Planning-Meeting.md#project-updates-and-discussion</a></p>
<h2><a class="header" href="#关于-const-generics-mvp-你需要知道的" id="关于-const-generics-mvp-你需要知道的">关于 Const Generics MVP 你需要知道的</a></h2>
<p>自从最初的 const 泛型 RFC 被接受以来已有3年多的时间了，Rust beta 现已提供 const 泛型的第一个版本！ 它将在<code>1.51</code> 版本中提供，该版本预计将于2021年3月25日发布。Const泛型是Rust最受期待的功能之一。</p>
<p><strong>什么是常量泛型</strong></p>
<p>常量泛型功能在 <a href="chapter_2/./rust_1.50.html">解读 Rust 1.50 稳定版</a> 一文中也有介绍。</p>
<p>一个典型的示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ArrayPair&lt;T, const N: usize&gt; {
    left: [T; N],
    right: [T; N],
}

impl&lt;T: Debug, const N: usize&gt; Debug for ArrayPair&lt;T, N&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>其中，<code>[T; N]</code>就是常量泛型的应用。</p>
<p>即将在 1.51 稳定版发布的 const 泛型是一个受限制的版本，换句话说，此版本是 const 泛型的 MVP（最小可行产品）版本。因为做一个通用版本的 const 泛型十分复杂，目前还在完善中。</p>
<p><strong>MVP 版本限制如下：</strong></p>
<ol>
<li>
<p>目前唯一可以用作 const 泛型参数类型的类型是整数（即有符号和无符号整数，包括<code>isize</code>和<code>usize</code>）以及<code>char</code>和<code>bool</code>的类型。 这已经可以涵盖 const 泛型的主要用例，即对数组进行抽象。 将来会取消此限制，以允许使用更复杂的类型，例如<code>＆str</code>和 用户定义的类型。</p>
</li>
<li>
<p>const 参数中不能有复杂的泛型表达式。当前，只能通过以下形式的 const 参数实例化 const 参数：</p>
<ul>
<li>一个独立的常量参数。</li>
<li>一个字面量。</li>
<li>一个没有泛型参数的具体常量表达式（用{}括起来）。
示例：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const N: usize&gt;() {}

fn bar&lt;T, const M: usize&gt;() {
    foo::&lt;M&gt;(); // ok: `M` 是常量参数
    foo::&lt;2021&gt;(); // ok: `2021` 是字面量
    foo::&lt;{20 * 100 + 20 * 10 + 1}&gt;(); // ok: 常量表达式不包括泛型
    
    foo::&lt;{ M + 1 }&gt;(); // error: 常量表达式包括泛型参数 `M`
    foo::&lt;{ std::mem::size_of::&lt;T&gt;() }&gt;(); // error: 常量表达式包括泛型参数 `T`
    
    let _: [u8; M]; // ok: `M` 是常量参数
    let _: [u8; std::mem::size_of::&lt;T&gt;()]; // error: 常量表达式包括泛型参数 `T`
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<p><strong>标准库内部利用常量泛型的改进</strong></p>
<p>伴随常量泛型在 1.51 稳定的还有 <a href="https://doc.rust-lang.org/nightly/std/array/struct.IntoIter.html"><code>array::IntoIter</code></a> ，它允许通过值而不是通过引用来迭代数组，从而解决了一个重大缺陷。 尽管仍然存在必须解决的向后兼容性问题，但仍在继续讨论是否可以直接为数组实现<code>IntoIterator</code>的可能性。 <code>IntoIter::new</code>是一种临时解决方案，可大大简化数组的处理。</p>
<p>还有很多 API 在基于常量泛型改进，但还不会在 1.51 中稳定。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::array;
fn needs_vec(v: Vec&lt;i32&gt;) {
   // ...
}

let arr = [vec![0, 1], vec![1, 2, 3], vec![3]];
for elem in array::IntoIter::new(arr) {
   needs_vec(elem);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>未来计划</strong></p>
<ol>
<li>解决默认参数和常量泛型位置冲突的问题。</li>
</ol>
<p>Rust 目前的泛型参数必须按特定顺序排列：生命周期（lifetime），类型（type），常量（const）。 但是，这会在尝试将默认参数与const参数一起使用时造成困难。为了使编译器知道哪个泛型参数，任何默认参数都必须放在最后。 接下来将解决这个问题。</p>
<ol start="2">
<li>为自定义类型支持常量泛型</li>
</ol>
<p>从理论上讲，要使一个类型有效作为const参数的类型，我们必须能够在编译时比较该类型的值。所以在 const泛型 RFC 中引入了结构相等的概念：本质上，它包括任何带有<code>＃[derive（PartialEq，Eq）]</code>且其成员也满足结构相等的类型。</p>
<ol start="3">
<li>为复杂类型支持常量泛型</li>
</ol>
<p>Nightly Rust 提供了一个<code>feature(const_evaluatable_checked)</code>，该特性门启用了对 const 泛型的复杂表达式支持。</p>
<p>目前的困难：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 下面代码中两个表达式中的`N+1`是不同的，如果需要将它们看作相同，则需要检查的方法。这是面对复杂表达式中的一个难点。
fn foo&lt;const N: usize&gt;() -&gt; [u8; N + 1] {
   [0; N + 1]
}

// 还需要处理常量泛型操作中存在的潜在错误的方法
// 如果没有办法在此处限制M的可能值，则在计算`0-1`时（在声明时未捕获），调用`generic_function::&lt;0&gt;()`会导致错误，因此对于下游用户可能会意外失败。
fn split_first&lt;T, const N: usize&gt;(arr: [T; N]) -&gt; (T, [T; N - 1]) {
   // ...
}

fn generic_function&lt;const M: usize&gt;(arr: [i32; M]) {
   // ...
   let (head, tail) = split_first(arr);
   // ...
}

<span class="boring">}
</span></code></pre></pre>
<p>原文： <a href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta">https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta</a></p>
<h2><a class="header" href="#rust-错误处理工作组计划将error-trait迁移至-core-模块" id="rust-错误处理工作组计划将error-trait迁移至-core-模块">Rust 错误处理工作组计划将Error trait迁移至 core 模块</a></h2>
<p>如果迁移之后，在no_std模式下也可以使用Error trait了。</p>
<p>链接：<a href="https://github.com/rust-lang/rust/pull/77384#issuecomment-772835929">https://github.com/rust-lang/rust/pull/77384#issuecomment-772835929</a></p>
<h1><a class="header" href="#本月简报-社区热点" id="本月简报-社区热点">本月简报 |社区热点</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑：张汉东</li>
</ul>
<h2><a class="header" href="#curl-支持-rustls" id="curl-支持-rustls">CURL 支持 RUSTLS</a></h2>
<p>Rustls 是一个用 Rust 写的现代 TLS（安全传输协议） 库。目前已经被纳入了为 CURL 的一个 backend</p>
<p>curl 对以下这些 features 都有一些可替换的 backends ：</p>
<ul>
<li>International Domain Names</li>
<li>Name resolving</li>
<li>TLS</li>
<li>SSH</li>
<li>HTTP/3</li>
<li>HTTP content encoding</li>
<li>HTTP</li>
</ul>
<p><a href="https://daniel.haxx.se/blog/2021/02/09/curl-supports-rustls/">https://daniel.haxx.se/blog/2021/02/09/curl-supports-rustls/</a></p>
<h2><a class="header" href="#rust--全栈框架-moonzoon-计划" id="rust--全栈框架-moonzoon-计划">Rust  全栈框架 MoonZoon 计划</a></h2>
<ul>
<li><a href="https://github.com/MoonZoon/MoonZoon">仓库链接</a></li>
</ul>
<p>这是 Seed  作者新开的一个项目，目标是做一个纯 Rust 的全栈框架。</p>
<ul>
<li>NO Javascript</li>
<li>NO CSS</li>
<li>NO HTML</li>
<li>NO REST</li>
<li>NO GraphQL</li>
<li>NO SQL</li>
<li>NO Analysis Paralysis</li>
<li>NO Wheel Reinventing</li>
<li>NO Passwords*</li>
</ul>
<p>目标比较大，目前是草案阶段，感兴趣的可以关注参与。</p>
<p>个人看法：Rust 其实并不需要全栈框架。对于上面的一堆 NO XXX ，个人理解应该是指这个框架不太限定用户去使用什么，想用啥可以用啥，给予最大自由。</p>
<h2><a class="header" href="#vscode-修补了关于-rust-工作流中的一个怪异的-bug" id="vscode-修补了关于-rust-工作流中的一个怪异的-bug">VSCode 修补了关于 Rust 工作流中的一个怪异的 bug</a></h2>
<p>最新的VSCode版本中有一个 PR，以防止提示弹出窗口过度滚动。 以前你将鼠标悬停在符号上来阅读相应文档，如果继续向下滚动至底部，则滚动将继续并将从文档窗口弹出。 现在，此问题已得到解决。🎉</p>
<p><a href="https://www.reddit.com/r/rust/comments/lgccv5/ysk_vscodes_most_recent_update_fixed_a_quirk_in/">https://www.reddit.com/r/rust/comments/lgccv5/ysk_vscodes_most_recent_update_fixed_a_quirk_in/</a></p>
<h2><a class="header" href="#google资助项目以使用新的rust组件保护apache-web服务器的安全" id="google资助项目以使用新的rust组件保护apache-web服务器的安全">Google资助项目以使用新的Rust组件保护Apache Web服务器的安全</a></h2>
<p>根据ZDNet报道，由Google资助并由Internet Security Research Group领导的Apache Web服务器将设置为接收新的基于Rust的mod_ssl模块（以将Apache HTTP Web服务器项目的关键组件从容易出错的C编程语言移植到一种更安全的替代品Rust中），该模块将基于 Rustls ; 开发了Rust开源库，以 替代基于C的OpenSSL项目。</p>
<p>阅读原文: <a href="https://www.zdnet.com/article/google-funds-project-to-secure-apache-web-server-project-with-new-rust-component/">https://www.zdnet.com/article/google-funds-project-to-secure-apache-web-server-project-with-new-rust-component/</a></p>
<h2><a class="header" href="#rust-analyzer-内部体系结构文档更新" id="rust-analyzer-内部体系结构文档更新">rust-analyzer 内部体系结构文档更新！</a></h2>
<p>rust-analyzer是一个用于IDE的实验性Rust编译器前端。</p>
<p>阅读原文: <a href="https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/architecture.md">https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/architecture.md</a></p>
<h2><a class="header" href="#微软的rust课程将在下月开课" id="微软的rust课程将在下月开课">微软的Rust课程将在下月开课</a></h2>
<p>据几天前的消息微软正在组建一支Rust团队。现在，微软 Reactor 将在3月份将举办两次Rust课程，以下是课程预告。</p>
<p>课前准备：</p>
<p>不需要具有 Rust 经验，但是如果您有使用其他编程语言的经验会更佳。</p>
<p>适合人群：</p>
<p>该研讨会面向想要学习 Rust 的开发人员。不需要具有 Rust 经验，不过如果您有使用其他编程语言的经验会帮助你更快的学习 Rust 语言。</p>
<p>参与本次分享，你将收获：</p>
<p>如果您想更熟悉更多的 Rust 相关知识，包括：变量，数据类型，函数，集合类型和控制流，则应该参加此研讨会。</p>
<p>主办方：</p>
<p>微软 Reactor 上海 是微软为构建开发者社区而提供的一个社区空间。</p>
<p>原文：<a href="https://mp.weixin.qq.com/s/TS3R8MNF_t09HmYNHMMHTg">https://mp.weixin.qq.com/s/TS3R8MNF_t09HmYNHMMHTg</a></p>
<h2><a class="header" href="#coreos-的rpm-ostree用rust重写部分功能" id="coreos-的rpm-ostree用rust重写部分功能">CoreOS 的rpm-ostree用Rust重写部分功能</a></h2>
<p>rpm-ostree 是一个CoreOS上的包管理器，最近使用Rust重写部分功能。该团队说更多氧化项目（比如/etc/{passwd,group}）正在进行中。</p>
<p>链接：<a href="https://github.com/coreos/rpm-ostree/releases/tag/v2021.2">https://github.com/coreos/rpm-ostree/releases/tag/v2021.2</a></p>
<h2><a class="header" href="#rust用于web开发的2年后感悟" id="rust用于web开发的2年后感悟">《Rust用于web开发的2年后感悟》</a></h2>
<p>原文地址：<a href="https://kerkour.com/blog/rust-for-web-development-2-years-later/">https://kerkour.com/blog/rust-for-web-development-2-years-later/</a></p>
<p>大约2年前，我开始使用Rust开发Web服务（JSON API），我认为是时候可以摆脱先入为主的观念并分享我学到的知识了。</p>
<p>偏见:</p>
<ul>
<li>Rust代码很丑陋：Rust是显式的。不可否认。但是，当我编写代码时，我的IDE可以帮到我很多，而不必按下那么多键。当我阅读代码时，这种明确性真是太棒了！没有隐藏的惊喜，没有奇怪的事情。</li>
<li>内存管理令人分心：实际上呢，没有。我没有使用那么多的词法生命周期，而是使用了智能指针。是的，因此我理解了Box，Rc和Arc之间的差异，与之同时和Node.JS、Golang语言相比，我的生产率没有因此受到影响。</li>
<li>编译器很麻烦：一开始是的。但是几个月后，我能够立即理解错误，并能立刻解决这些错误。今天，我真的没有花太多时间在编译器上。相反，它成为了我最好的朋友，尤其是在重构大部分代码或升级依赖项时。</li>
<li>缓慢的编译时间:我给这个说明。在Node.JS或Golang中，一个中等大小的服务的Docker image大约需要3到10分钟来构建和部署，在Rust中大约需要30分钟。</li>
<li>生态系统还不存在：不可否认，的确是这样。缺少一些组件，例如官方的Stripe和AWS开发工具包，但是社区确实很活跃，并构建了所有这些缺少的组件。</li>
</ul>
<p>我特别值得点赞的几件事</p>
<ul>
<li>静态链接非常简单：创建小的Docker images 一件令人愉快的事情。。</li>
<li>Rust会让你成为一个更好的程序员：Rust很复杂，如果你不了解它的详细工作原理，它不会放过你。掌握它需要时间和耐心，但是一旦你这样做了，你就会学到很多你永远不会像以前那样接近编程的东西。在学习Tokio的工作原理时，我了解了Golang的运行时是如何工作的。(心智模型学习)</li>
<li>一旦它编译，通常它就可以正常工作:这是关于Rust我最喜欢的地方。当我的程序编译时，它按我的计划工作。注意：只要记住不要阻塞事件循环，编译器就会处理剩下的事情。您不再需要花时间为语言的怪癖编写测试。</li>
<li>Rust具有很高的生产力：由于Rust是多种范式，因此在编写复杂的业务逻辑时，由于其功能方面，它的确非常出色。</li>
</ul>
<p>当前我正在使用的一些crates</p>
<ul>
<li>actix-web 用于HTTP层.</li>
<li>sqlx 用于数据库PostgreSQL.</li>
<li>rusoto AWS接口服务（S3、SQS、SES）</li>
<li>tera 用于电子邮件模板</li>
<li>thiserror 用于错误类型处理</li>
<li>sentry 用于错误监控</li>
</ul>
<p>结论</p>
<p>Rust非常适合用于web开发，在此我强烈建议尝试一下。</p>
<p>取得成功是一次漫长的旅程，但完全值得，即使您不是每天都在使用它，也一定会通过学习它而成为一名更好的程序员，如果失去了，那就重新去发现编程的乐趣🤗。</p>
<p>一句话总结：Rust生而平静。凌晨3点不再有不好的惊喜，因为依赖项更新了它的API使得不再有bug。没有更多恼人的配置自动缩放或什么。而且响应时间非常短，您的用户因此会爱上您的产品。</p>
<h1><a class="header" href="#本月简报--推荐项目-1" id="本月简报--推荐项目-1">本月简报 | 推荐项目</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑：杨楚天（yct21）</li>
</ul>
<h2><a class="header" href="#rust-sqlite" id="rust-sqlite">Rust-SQLite</a></h2>
<ul>
<li><a href="https://github.com/joaoh82/rust_sqlite">仓库链接</a></li>
</ul>
<p>Rust-SQLite (SQLRite) 是一个 SQLite clone。SQLRite 有很完善的文档，代码质量非常高，而且有非常丰富的单元测试用例。</p>
<h2><a class="header" href="#tauri" id="tauri">Tauri</a></h2>
<ul>
<li><a href="https://github.com/tauri-apps/tauri">仓库链接</a></li>
<li><a href="https://tauri.studio/en/">项目主页</a></li>
</ul>
<p>Tauri 是一个桌面应用开发框架，包含了 JavaScript API，可以结合各种主流前端框架进行开发。</p>
<p><a href="https://twitter.com/victorhqc/status/1356990383792791555">有 Twitter 网友分享</a>，
他把自己的 Electron 写的应用迁移至 Rust 的 Tauri，
内存使用从 300M 降低至 6M，二进制大小从 195M 降至 7M。</p>
<h2><a class="header" href="#rustpython" id="rustpython">RustPython</a></h2>
<ul>
<li><a href="https://github.com/RustPython/RustPython">仓库链接</a> </li>
<li><a href="https://www.youtube.com/watch?v=nJDY9ASuiLc">FOSDEM 2019 上的相关演讲</a></li>
</ul>
<p>RustPython 是用 Rust 实现的 Python 3（CPython &gt;= 3.8.0） 解释器。 RustPython 可以将 Python 嵌入到 Rust 程序中；也可以将 RustPython 编译为 WebAssembly，这样开发者可以在浏览器中运行其 Python 代码。此外，RustPython 也包含一个实验性的 JIT 编译器。</p>
<h2><a class="header" href="#thirtyfour" id="thirtyfour">Thirtyfour</a></h2>
<ul>
<li><a href="https://github.com/stevepryde/thirtyfour">仓库链接</a></li>
</ul>
<p>Thirtyfour 是一个 Selenium WebDriver 客户端，可以用于自动化 UI 测试。Thirtyfour 完全支持 W2C WebDriver spec，可以搭配 tokio 或者 async-std 使用。</p>
<h2><a class="header" href="#lunatic" id="lunatic">Lunatic</a></h2>
<ul>
<li><a href="https://github.com/lunatic-solutions/lunatic">仓库链接</a></li>
<li><a href="https://lunatic.solutions/">项目主页</a></li>
</ul>
<p>Lunatic 是一个服务端的 WebAssembly 运行时，有以下特点：</p>
<ul>
<li>受到 Erlang 的启发，有一个抢占式调度的运行时, 生成占用资源极少的用户态线程。</li>
<li>借助 wasm 虚拟机，保证隔离和安全性。</li>
<li>会在未来完全兼容 WASI </li>
</ul>
<h2><a class="header" href="#postage" id="postage">Postage</a></h2>
<ul>
<li><a href="https://github.com/austinjones/postage-rs">仓库链接</a> </li>
<li><a href="https://implaustin.hashnode.dev/announcing-postage">文章链接</a></li>
</ul>
<p>Postage 是一个异步通道库，提供了丰富的通道集，并在 Sink/Stream 上有很多实用的组合子，方便了异步程序的开发。</p>
<p>作者同时也是 <a href="https://github.com/austinjones/tab-rs/">tab</a> 的作者。</p>
<h2><a class="header" href="#rustsbi" id="rustsbi">RustSBI</a></h2>
<ul>
<li><a href="https://github.com/luojia65/rustsbi">仓库链接</a></li>
</ul>
<p>RustSBI 是洛佳老师开发的一个 RISC-V SBI 实现，支持常见的硬件核心和模拟器，能够引导启动符合 RISC-V SBI 标准的操作系统，包括 Linux、rCore 等。</p>
<h2><a class="header" href="#similar" id="similar">Similar</a></h2>
<ul>
<li><a href="https://github.com/mitsuhiko/similar">仓库链接</a></li>
</ul>
<p>similar 是一个现代化的 diff 库，借鉴了 <a href="https://pijul.org/">pijul</a> 实现的耐心排序算法，并结合了 Myer 的 diff 算法。</p>
<h2><a class="header" href="#tantivy" id="tantivy">tantivy</a></h2>
<ul>
<li><a href="https://github.com/tantivy-search/tantivy">仓库链接</a></li>
</ul>
<p>tantivy 是一个全文搜索引擎库, 类似于 Apache Lucene。</p>
<h2><a class="header" href="#xh" id="xh">xh</a></h2>
<ul>
<li><a href="https://github.com/ducaale/xh">仓库链接</a></li>
</ul>
<p>xh 是一个 Httpie clone。</p>
<p><img src="https://github.com/ducaale/xh/raw/master/assets/xh-demo.gif" alt="ht" /></p>
<h2><a class="header" href="#meio" id="meio">meio</a></h2>
<ul>
<li><a href="https://github.com/rillrate/meio">仓库链接</a></li>
</ul>
<p>meio 是一个异步 actor 框架，其设计受 Erlang/OTP 启发，并可以很好地结合 rust 中的异步生态系统使用。作者正在尝试使其能 WebAssembly 兼容。</p>
<h2><a class="header" href="#message-io" id="message-io">message-io</a></h2>
<ul>
<li><a href="https://github.com/lemunozm/message-io">仓库链接</a></li>
</ul>
<p>message-io 是一个是事件驱动的消息库，可轻松快速地构建网络应用程序。message-io 可以管理和处理套接字数据流，以便向用户提供简单的事件消息 API。作为通用网络管理器，它允许你遵循一些规则来实现自己的协议，而繁琐的异步和线程管理则由 message-io 帮你管理。 </p>
<h2><a class="header" href="#cranelift" id="cranelift">Cranelift</a></h2>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/tree/main/cranelift">仓库链接</a></li>
<li><a href="https://blog.benj.me/2021/02/17/cranelift-codegen-primer/">文章链接</a></li>
</ul>
<p>Cranelift 是用 Rust 编程语言实现的代码生成器，旨在成为快速的代码生成器，其输出以合理速度运行的机器代码。
如今，它被用于包括 Wasmtime 和 Wasmer 在内的几种不同的 WebAssembly 运行时中，并且还可以作为 Rust 调试编译的替代后端。</p>
<h2><a class="header" href="#voyager" id="voyager">Voyager</a></h2>
<ul>
<li><a href="https://github.com/mattsse/voyager">仓库链接</a></li>
</ul>
<p>voyager 是一个用 Rust 实现的爬虫库。</p>
<h2><a class="header" href="#starlight" id="starlight">Starlight</a></h2>
<ul>
<li><a href="https://github.com/Starlight-JS/Starlight">仓库链接</a></li>
<li><a href="https://github.com/Starlight-JS/Starlight">reddit 链接</a></li>
</ul>
<p>Starlight 是一个 JavaScript 的运行时，其设计重点放在运行速度上，已经通过了 2k+test262 测试。Starlight 比 Boa（另一个Rust写的JS引擎）更快，其目标是和V8一样快。</p>
<h2><a class="header" href="#lettre" id="lettre">Lettre</a></h2>
<ul>
<li><a href="https://github.com/lettre/lettre">仓库链接</a></li>
</ul>
<p>Lettre 是一个可以用于发送 email 的库。</p>
<h2><a class="header" href="#optic使用实际流量来记录和测试您的api" id="optic使用实际流量来记录和测试您的api">Optic：使用实际流量来记录和测试您的API</a></h2>
<ul>
<li><a href="https://github.com/opticdev/optic">仓库链接</a></li>
</ul>
<p>说明：</p>
<ul>
<li>Optic观察开发流量并了解您的API行为</li>
<li>Optic通过将流量与当前规范相区别来检测API更改</li>
<li>Optic为每个拉取请求添加准确的API更改日志</li>
</ul>
<h2><a class="header" href="#rust-web-模板项目" id="rust-web-模板项目">Rust Web 模板项目</a></h2>
<ul>
<li><a href="https://github.com/svenstaro/rust-web-boilerplate">仓库链接</a></li>
</ul>
<p>前些日子 Rust 不适合 Web 一文引起了热议，今天就有热心群友推荐了一个 Rust Web 模板项目：</p>
<ul>
<li>使用 .env 文件管理环境变量</li>
<li>使用 diesel 来处理数据库迁移</li>
<li>配合 cargo-watch 监控开发时程序修改，方便调试</li>
<li>支持 cargo-tarpaulin 做测试覆盖率</li>
</ul>
<h2><a class="header" href="#termchat一个终端聊天软件" id="termchat一个终端聊天软件">termchat：一个终端聊天软件</a></h2>
<ul>
<li><a href="https://github.com/lemunozm/termchat">仓库链接</a></li>
</ul>
<p>最近Clubhouse因为Elon Musk突然大火，使用termchat可以在终端进行聊天。</p>
<h2><a class="header" href="#yatta-用于-windows10-的-bsp-平铺窗口管理器" id="yatta-用于-windows10-的-bsp-平铺窗口管理器">Yatta: 用于 Windows10 的 BSP 平铺窗口管理器</a></h2>
<ul>
<li><a href="https://github.com/LGUG2Z/yatta">仓库链接</a></li>
</ul>
<p>作者最近因为从之前的mac环境由于一些原因需要切换到windows环境下工作，但是没有找到之前使用mac时的桌面分割工具（窗口排放管理工具），于是自己花了几天，研究了不少其它类似的工具，捣鼓出了这个。</p>
<h2><a class="header" href="#nlprulerust-实现的-nlp-库" id="nlprulerust-实现的-nlp-库">nlprule，Rust 实现的 NLP 库</a></h2>
<ul>
<li><a href="https://github.com/bminixhofer/nlprule">仓库链接</a></li>
</ul>
<p>nlprule 使用 LanguageTool 中的资源为NLP实现了基于规则和查找的方法。</p>
<h2><a class="header" href="#firestorm-代码分析器" id="firestorm-代码分析器">firestorm： 代码分析器</a></h2>
<ul>
<li><a href="https://github.com/That3Percent/firestorm">仓库链接</a></li>
</ul>
<p>作者扎克·伯恩斯发布了这款侵入式代码分析器。“火旋风”分析器能帮助代码作者测试Rust代码的性能；它能分析项目中的时间敏感部分，输出到时间轴图、合并的火焰图或其它的表现形式。这是一款侵入式分析器，也就意味着在代码编写的过程中，用户就需要使用分析器提供的宏，帮助分析器的记录过程。项目文档指出，这款分析器能通过编译特性来启用或禁用；未被启用时，所有的记录操作都被编译为空操作，这将不会影响生产程序的运行性能。</p>
<p>我们常用的性能分析器，常常基于系统提供的“perf”指令，它就像是一个调试器，在合适的时候暂停进程，读取此时所有的线程和有关信息，从间隔的采样过程记录，从而得到运行性能输出。这种采样不需要重新添加和编译代码，但较可能漏掉时间短的函数。合理使用侵入式代码分析器，可以精细记录运行性能的细节，也能更少地影响待测程序的运行性能。</p>
<p>friestorm 分析器已经在GitHub上开源，并配有丰富的使用文档。</p>
<h2><a class="header" href="#rkyv-04共享指针和自定义序列化程序" id="rkyv-04共享指针和自定义序列化程序">rkyv 0.4：共享指针和自定义序列化程序</a></h2>
<ul>
<li><a href="https://github.com/djkoloski/rkyv">仓库链接</a></li>
</ul>
<p>大家好，大约又工作了一个月，RKYV0.4终于推出了新特性和重大变化。</p>
<p>如果你还没听说过的话，rkyv是一个针对Rust的零拷贝反序列化框架，类似于Cap'n Proto和FlatBuffers。它主要是为游戏开发而构建的，但也适用于广泛的其他应用程序。</p>
<p>文章链接，<a href="https://www.reddit.com/r/rust/comments/lniraj/rkyv_04_shared_pointers_and_custom_serializers/">https://www.reddit.com/r/rust/comments/lniraj/rkyv_04_shared_pointers_and_custom_serializers/</a></p>
<h2><a class="header" href="#rg3d-游戏引擎" id="rg3d-游戏引擎">rg3d 游戏引擎</a></h2>
<ul>
<li><a href="https://github.com/mrDIMAS/StationIapetus%E3%80%82">仓库链接</a></li>
</ul>
<p>在过去的三个月中，rg3d 和 rusty-editor取得了很多重要的功能和改进。并开始使用引擎制作了新游戏，Station lapetus，一款 Sci-Fi 3D射击游戏。</p>
<p>近3个月的进展报告: <a href="https://rg3d.rs/general/2021/02/26/progress.html">https://rg3d.rs/general/2021/02/26/progress.html</a></p>
<h2><a class="header" href="#lam-actor模式的vm" id="lam-actor模式的vm">LAM: Actor模式的VM</a></h2>
<ul>
<li><a href="https://github.com/AbstractMachinesLab/lam">仓库链接</a></li>
</ul>
<p>LAM，针对 WebAssembly和 Native 的 Actor VM。</p>
<p>访谈链接： <a href="https://notamonadtutorial.com/lam-an-actor-model-vm-for-webassembly-and-native-d7939362e1b8">https://notamonadtutorial.com/lam-an-actor-model-vm-for-webassembly-and-native-d7939362e1b8</a></p>
<p>项目链接： <a href="https://abstractmachines.dev/">https://abstractmachines.dev/</a></p>
<h1><a class="header" href="#本月简报--学习资源" id="本月简报--学习资源">本月简报 | 学习资源</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑：苏胤榕（DaviRain）</li>
</ul>
<h2><a class="header" href="#使用-rust-创建一个模拟器" id="使用-rust-创建一个模拟器">使用 Rust 创建一个模拟器</a></h2>
<p>这是 Learning to Fly: Let's create a simulation in Rust!。</p>
<p>在这一系列的文章中,作者会从头到尾带领大家使用 Rust 实现一个基本 feed-forward 的神经网络。</p>
<p><a href="https://pwy.io/en/posts/learning-to-fly-pt2/">链接</a></p>
<h2><a class="header" href="#使用rust和webassembly创建爆炸性的markdown编辑器" id="使用rust和webassembly创建爆炸性的markdown编辑器">使用Rust和WebAssembly创建爆炸性的Markdown编辑器</a></h2>
<blockquote>
<p>摘录： 让我们快速准备WebAssembly的开发环境</p>
</blockquote>
<p>Rust通常cargo使用命令构建，但是WebAssembly有一个叫做wasm-pack的工具，它可以很方便地完成很多事情，所以让我们安装它。</p>
<p><a href="https://zenn.dev/beijaflor/articles/da789ea779c005">链接</a></p>
<h2><a class="header" href="#improving-texture-atlas-allocation-in-webrender" id="improving-texture-atlas-allocation-in-webrender">Improving texture atlas allocation in WebRender</a></h2>
<p>作者花费大量篇幅解读了如何改进WebRender中Texture atlas分配的问题。</p>
<p><a href="https://nical.github.io/posts/etagere.html">链接</a></p>
<h2><a class="header" href="#新书black-hat-rust" id="新书black-hat-rust">新书：《Black Hat Rust》</a></h2>
<p>《Black Hat Rust》是一本基于Rust编程语言深入研究攻击性、安全性的书。最终出版预计2021年7月，书篇预估320页。如果你是一名安全的从业者，应该会对此书非常感兴趣。</p>
<p><a href="https://academy.kerkour.com/black-hat-rust">链接</a></p>
<h2><a class="header" href="#emacs-配置-rust-开发环境" id="emacs-配置-rust-开发环境">Emacs 配置 Rust 开发环境</a></h2>
<p>喜欢使用 Emacs 的小伙伴如果想开发 Rust，可以参考这篇文章进行详细的设置。</p>
<p><a href="https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/">链接</a></p>
<h2><a class="header" href="#rust-知识精炼" id="rust-知识精炼">Rust 知识精炼</a></h2>
<p>该文是作者将自己的所学的 Rust 知识整理到这里，感兴趣的同学的可以看一下。</p>
<p><a href="https://www.greyblake.com/blog/2021-02-07-rust-knowledge-refinement/">链接</a></p>
<h2><a class="header" href="#exercismio一个在线编程训练的平台" id="exercismio一个在线编程训练的平台">exercism[.]io：一个在线编程训练的平台</a></h2>
<p>exercism[.]io 是一个在线编程训练平台支持Rust语言。</p>
<p><a href="https://exercism.io">链接</a></p>
<h2><a class="header" href="#视频1password-开发者炉边谈话介绍-rust-宏" id="视频1password-开发者炉边谈话介绍-rust-宏">【视频】1Password 开发者炉边谈话：介绍 Rust 宏</a></h2>
<p><a href="https://youtu.be/Lh262L63asA">视频链接</a></p>
<h2><a class="header" href="#比较-rust-async-与-linux-线程上下文切换时间" id="比较-rust-async-与-linux-线程上下文切换时间">比较 Rust async 与 Linux 线程上下文切换时间</a></h2>
<p>作者写了一些代码，试图比较 Linux 线程上下文切换所需时间和Rust async任务调度切换所需时间及其各自在使用时的内存使用总量，并且还做出了总结。</p>
<p><a href="https://github.com/jimblandy/context-switch">Github</a></p>
<h2><a class="header" href="#使用-tokio-直接构建-actors" id="使用-tokio-直接构建-actors">使用 Tokio 直接构建 Actors</a></h2>
<p>本文使用Tokio直接构建 Actors，而不是使用任何现有的actor库。</p>
<p>感兴趣的同学可以阅读一下。</p>
<p><a href="https://ryhl.io/blog/actors-with-tokio/">链接</a></p>
<p>Rust 从零到生产: 可维护的测试套件的骨架和原则</p>
<h2><a class="header" href="#这是-rust-从零到生产-系列的第七章-part-1" id="这是-rust-从零到生产-系列的第七章-part-1">这是 &lt;&lt;Rust 从零到生产&gt;&gt; 系列的第七章 part 1.</a></h2>
<p>该章节主要侧重于测试，整个书基本上都是使用 test-driven的方式来编写新的功能。当代码变的庞大之后，一个良好的测试框架可以更好的支撑更复杂的特性和日渐增多的测试用例。</p>
<p><a href="https://www.lpalmieri.com/posts/skeleton-and-principles-for-a-maintainable-test-suite/">链接</a></p>
<h2><a class="header" href="#for-the-love-of-macros" id="for-the-love-of-macros">For the Love of Macros</a></h2>
<p>宏是一种超越 more power的存在，他赋予了我们超越源代码的抽象能力，但是，同时，你也会放弃表层语法。例如，在一个拥有强大的宏的语言中，重命名基本上是不太可能 100% 工作的。</p>
<p>本文尽力探索Rust中宏的使用方式， 目的是为了找到一种不放弃源代码推断的解决方案。</p>
<p><a href="https://matklad.github.io/2021/02/14/for-the-love-of-macros.html">链接</a></p>
<h2><a class="header" href="#使用rust从零重写一个sqlite" id="使用rust从零重写一个sqlite">使用Rust从零重写一个SQLite</a></h2>
<p>作者计划使用Rust重新复制一个SQLite数据库，目前正在进行中。</p>
<p>SQLite有很完善的文档，代码质量非常高，而且有非常丰富的单元测试用例，终于有人尝试使用Rust重写一个SQLite了，感兴趣的朋友可以一起参与！</p>
<p><a href="https://github.com/joaoh82/rust_sqlite">Github</a></p>
<p><a href="https://medium.com/the-polyglot-programmer/what-would-sqlite-look-like-if-written-in-rust-part-1-4a84196c217d">链接</a></p>
<h2><a class="header" href="#微软的员工发布的windows用户rust视频" id="微软的员工发布的windows用户rust视频">微软的员工发布的Windows用户Rust视频</a></h2>
<p>主要介绍怎样在Windows平台使用windows-rs这个crate构建Rust程序。</p>
<p><a href="https://kennykerr.ca/2021/02/18/rust-for-windows-getting-started/">链接</a></p>
<h2><a class="header" href="#如何使用-webassembly-构建一个-telnet-聊天服务器" id="如何使用-webassembly-构建一个-telnet-聊天服务器">如何使用 webassembly 构建一个 telnet 聊天服务器</a></h2>
<p>相信有大批的人喜欢 terminals这种审美， 作者也是其中之一。</p>
<p>作者使用 webassembly + Rust 构建了一个 telnet 聊天服务器。 你可以使用下面的命令来尝试一下。</p>
<pre><code># US
&gt; telnet lunatic.chat
# EU
&gt; telnet eu.lunatic.chat
</code></pre>
<p><a href="https://lunatic.solutions/blog/lunatic-chat/">链接</a></p>
<h2><a class="header" href="#easyrust-现在有视频了" id="easyrust-现在有视频了">EasyRust 现在有视频了</a></h2>
<p>EasyRust 是一个非常好的 Rust 入门教程，现在，他不仅有文档,还有视频了。</p>
<p>下面是第一期视频,未来至少还有 70 期。想学习的小伙伴可以跟着视频了解一下。</p>
<p><a href="https://dhghomon.github.io/easy_rust/Chapter_0.html">EasyRust地址</a></p>
<p><a href="https://www.youtube.com/watch?v=-lYeJeQ11OI&amp;list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">油管视频</a></p>
<h2><a class="header" href="#经典-rust-面试题六道" id="经典-rust-面试题六道">经典 Rust 面试题六道</a></h2>
<p>在电报群由 @wayslog 提出的六道面试题目，wayslog 老师称之为“经典六道”：</p>
<ol>
<li>
<p>RwLock<T> 对想要在多线程下正确使用，T的约束是？</p>
</li>
<li>
<p>如下代码：</p>
<pre><code>trait A{ fn foo(&amp;self) -&gt; Self; }
Box&lt;Vec&lt;dyn A&gt;&gt;;
</code></pre>
<p>是否可以通过编译？为什么？ </p>
</li>
<li>
<p>Clone与 Copy 的区别是什么？ </p>
</li>
<li>
<p>deref 的被调用过程？ </p>
</li>
<li>
<p>Rust里如何实现在函数入口和出口自动打印一行日志？ </p>
</li>
<li>
<p>Box&lt;dyn (Fn() + Send +'static)&gt; 是什么意思?</p>
</li>
</ol>
<p>@wayslog 提供的答案：</p>
<ol>
<li>The type parameter T represents the data that this lock protects. It is required that T satisfies Send to be shared across threads and Sync to allow concurrent access through readers。</li>
<li>不可以，参考object safe 三条规则。</li>
<li>Copy是marker trait，告诉编译器需要move的时候copy。Clone表示拷贝语义，有函数体。不正确的实现Clone可能会导致Copy出BUG。</li>
<li>Deref 是一个trait，由于rust在调用的时候会自动加入正确数量的 * 表示解引用。则，即使你不加入*也能调用到Deref。</li>
<li>调用处宏调用、声明时用宏声明包裹、proc_macro包裹函数、邪道一点用compiler plugin、llvm插桩等形式进行。（Go:我用snippet也行）</li>
<li>一个可以被Send到其他线程里的没有参数和返回值的callable对象，即 Closure，同时是 ownershiped，带有static的生命周期，也就说明没有对上下文的引用。</li>
</ol>
<p>读者们又会几道呢~</p>
<p><a href="https://rustcc.cn/article?id=0b0afa3e-db03-428e-9fc5-b06347997d41">讨论链接</a></p>
<h2><a class="header" href="#rust-for-web-development" id="rust-for-web-development">Rust for web development</a></h2>
<p>本篇blog作者是今年七月要出的rust新书Black Hat Rust的作者，在两年前作者就已经开始尝试用Rust去进行web开发，这篇blog谈的是他开发的一些感受，一些经验，同时提到了他开发中用到了哪些crate。</p>
<p><a href="https://kerkour.com/blog/rust-for-web-development-2-years-later/">链接</a></p>
<h2><a class="header" href="#笨方法学习rust所有权机制" id="笨方法学习rust所有权机制">笨方法学习Rust所有权机制</a></h2>
<p>为了真正了解Rust，我们需要了解其关键的区别于其它语言的特性: 所有权。本篇blog用了笨方法的方式来讲解Rust的所有权。</p>
<p><a href="https://chrismorgan.info/blog/rust-ownership-the-hard-way/">链接</a></p>
<h2><a class="header" href="#好文推荐rust和lora" id="好文推荐rust和lora">好文推荐：《Rust和LoRa》</a></h2>
<p>Drogue IoT 是一个试图将可重用和高效的组件引入嵌入式Rust的团队，本文讲述了“如何在Rust中开始使用LoRa“。</p>
<p>ps: LoRa是一种低功率远程无线协议</p>
<p>阅读原文: <a href="https://blog.drogue.io/rust-and-lora/">https://blog.drogue.io/rust-and-lora/</a></p>
<p>Repo: <a href="https://github.com/drogue-iot/drogue-device">https://github.com/drogue-iot/drogue-device</a></p>
<h2><a class="header" href="#rust-循环优化" id="rust-循环优化">Rust 循环优化</a></h2>
<p><img src="https://rustcc-1252416178.cos.ap-nanjing.myqcloud.com/rust_loop_opt.jpeg" alt="1" />
<img src="https://rustcc-1252416178.cos.ap-nanjing.myqcloud.com/rust_loop_opt_2.jpeg" alt="2" />
<img src="https://rustcc-1252416178.cos.ap-nanjing.myqcloud.com/rust_loop_opt_2.jpeg" alt="3" /></p>
<h2><a class="header" href="#cranelift-代码生成入门" id="cranelift-代码生成入门">Cranelift 代码生成入门</a></h2>
<p>Cranelift 是用 Rust 编程语言编写的代码生成器，旨在成为快速的代码生成器，其输出以合理速度运行的机器代码。如今，它被用于包括 Wasmtime 和 Wasmer 在内的几种不同的 WebAssembly 运行时中，并且还可以作为 Rust 调试编译的替代后端。</p>
<p>更多见博客原文：<a href="https://blog.benj.me/2021/02/17/cranelift-codegen-primer/">https://blog.benj.me/2021/02/17/cranelift-codegen-primer/</a></p>
<p>Cranelift 仓库地址：<a href="https://github.com/bytecodealliance/wasmtime/tree/main/cranelift#cranelift-code-generator">https://github.com/bytecodealliance/wasmtime/tree/main/cranelift#cranelift-code-generator</a></p>
<h2><a class="header" href="#rtic-book" id="rtic-book">Rtic book</a></h2>
<p><a href="https://github.com/rtic-rs/cortex-m-rtic">RTIC 框架</a> 是中断驱动的异步实时系统，完全针对应用使用Rust的宏语法生成，拥有极高的效率。</p>
<p>RTIC Book ：<a href="https://rtic.rs/0.5/book/en/by-example.html">https://rtic.rs/0.5/book/en/by-example.html</a></p>
<h2><a class="header" href="#国外-rust-咨询公司-ferrous-system-的嵌入式课程资料" id="国外-rust-咨询公司-ferrous-system-的嵌入式课程资料">国外 Rust 咨询公司 Ferrous System 的嵌入式课程资料</a></h2>
<p>链接：<a href="https://embedded-trainings.ferrous-systems.com/preparations.html">https://embedded-trainings.ferrous-systems.com/preparations.html</a></p>
<h1><a class="header" href="#本月简报--rust-唠嗑室本月汇总-1" id="本月简报--rust-唠嗑室本月汇总-1">本月简报 | Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
<li>后期编辑：高宪凤</li>
</ul>
<hr />
<h2><a class="header" href="#rust-唠嗑室第-18-期---剖析-rust-的引用" id="rust-唠嗑室第-18-期---剖析-rust-的引用">《Rust 唠嗑室》第 18 期 - 剖析 Rust 的引用</a></h2>
<p><strong>时间</strong>: 2021/02/02 20:30-21:30</p>
<p><strong>主讲人</strong>：舒乐之（Andy）</p>
<p>一网网络工程师，2018 年开始写 Rust，参与 ImmuxDB 不可变数据库和 ImmuxCompute 计算引擎的设计开发；曾用 C 开发比特币节点 tinybtc；曾任 Matters Lab 首席工程师，Web 前后端都写过。</p>
<p><strong>内容</strong>：</p>
<p>这次的主要内容，是从零开始，解释 Rust 中「引用」的概念，以及一批与引用相关的概念：地址、指针、借用、切片、智能指针、胖指针、裸指针、所有权、生命周期、作用域等。</p>
<p>还会谈到一些关于 Rust 引用的问题，比如：</p>
<ul>
<li>生命周期与作用域的关系是什么？</li>
<li>为什么 str 不会单独出现，总是以要靠引用（比如&amp;str）使用？</li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a> 有一个 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_boxed_slice">into_boxed_slice()</a>方法 —— boxed slice 是什么，与 Vec 有什么区别？</li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a>、<a href="https://doc.rust-lang.org/core/cell/struct.Cell.html">Cell</a>、<a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html">UnsafeCell</a> 的区别是什么？什么时候用什么？</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV15N411o7e4">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<ul>
<li>
<p>官方文档</p>
<ul>
<li>https://doc.rust-lang.org/stable/reference/types/pointer.html</li>
<li>https://doc.rust-lang.org/stable/reference/types/function-pointer.html</li>
<li>https://doc.rust-lang.org/nomicon/ownership.html</li>
<li>https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md</li>
<li>http://rust-lang.github.io/rfcs/1558-closure-to-fn-coercion.html</li>
<li>https://prev.rust-lang.org/en-US/faq.html#ownership</li>
<li>https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</li>
</ul>
</li>
<li>
<p>博客</p>
<ul>
<li>http://smallcultfollowing.com/babysteps/blog/2014/05/13/focusing-on-ownership/</li>
<li>https://ricardomartins.cc/2016/06/25/interior-mutability-thread-safety</li>
<li>https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</li>
<li>https://internals.rust-lang.org/t/function-pointers-are-inconsistent-with-other-language-features/12439</li>
</ul>
</li>
</ul>
<hr />
<h2><a class="header" href="#rust-牛年春晚" id="rust-牛年春晚">Rust 牛年春晚</a></h2>
<p><strong>时间</strong>：2021/02/14 16:00 - 24:00</p>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p14-点场-rust150-最新改动讲解" id="p14-点场-rust150-最新改动讲解">P1【4 点场】 Rust1.50 最新改动讲解</a></h3>
<p><strong>嘉宾</strong>：张汉东</p>
<p>张汉东老师以一段 <code>Rust</code> 宏代码开启欢乐的 Rust 牛年春晚。随后汉东老师着重讲解了这次 <a href="https://blog.rust-lang.org/2021/02/11/Rust-1.50.0.html">Rust1.50 版本</a>更新的主要内容。这次更新主要包括： <code>语言级特性</code>、<code>编译器</code>， <code>标准库</code>、 <code>稳定的 API</code>、<code>Cargo 相关</code>、<code>其他</code>、<code>兼容性提示</code>几个方面。</p>
<!-- - 语言级特性方面
  - 常量泛型`[CONST; N]`进一步得到完善
  - 将共用体(union)中`ManualDrop`类型字段的分配视为安全
- 编译器方面
  - 添加对`armv5te-unknown-linux-uclibcgnueabi`目标的内置支持
  - 在ARM Mac上添加对Arm64 Catalyst的支持
  - 修复 FreeBSD 上的链接问题
- 标准库方面
  - 为` proc_macro::Punct `增加 `PartialEq`
  - Unix 平台优化：Option<File> 大小等价于 File
- 兼容性变更
  - 过期 compare_and_swap 方法
  - 放弃对所有 cloudabi target 的支持 -->
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=1">查看回放</a></p>
<p><strong>扩展资料</strong></p>
<ol>
<li>暖场代码</li>
</ol>
<pre><code class="language-Rust">macro_rules! m {
    ($($s:stmt)*) =&gt; {
        $(
            { stringify!($s); 1 }
        )&lt;&lt;*
    };
}

fn main() {
    print!(
        &quot;{}{}{}&quot;,
        m! { return || true },
        m! { (return) || true },
        m! { {return} || true },
    );
}
</code></pre>
<ol start="2">
<li><a href="https://mp.weixin.qq.com/s/s7MCqwJWk_Kh77tvLRCKwA">Rust 1.50 稳定版发布解读</a></li>
</ol>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p25-点场-delay-timer-分享" id="p25-点场-delay-timer-分享">P2【5 点场】 Delay-Timer 分享</a></h3>
<p><strong>嘉宾</strong>：炮炮</p>
<p><a href="https://github.com/BinChengZhao/delay-timer">Delay-Timer</a> 是一个类似于管理周期性任务的库，目前支持同步、异步任务进行周期化交付，支持一些任务在调度过程中动态添加和动态提交任务的操作。炮炮老师分享了开发过程中的心路历程。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=2">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<ol>
<li>暖场代码</li>
</ol>
<pre><code class="language-Rust">fn main() {
    let a = 4;
    println!(&quot;{},{}&quot;, --a, --a);
}
</code></pre>
<ol start="2">
<li><a href="https://github.com/BinChengZhao/delay-timer">Delay-Timer</a></li>
</ol>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p35-点场libra-代码分析讲解" id="p35-点场libra-代码分析讲解">P3【5 点场】Libra 代码分析讲解</a></h3>
<p><strong>嘉宾</strong>：Shara</p>
<p><a href="https://developers.diem.com/docs/welcome-to-diem/">Libra</a> Facebook 开发的一个 Rust 区块链项目，它的使命是为全球数十亿人建立一个简单的全球货币和金融基础设施。Share 老师分享了分析 Libra 代码的思路。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=3">查看回放</a></p>
<p><strong>扩展资料</strong>：
<a href="https://developers.diem.com/docs/welcome-to-diem/">Libra</a></p>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p46-点场rust-开发嵌入式烂苹果" id="p46-点场rust-开发嵌入式烂苹果">P4【6 点场】Rust 开发嵌入式烂苹果</a></h3>
<p><strong>嘉宾</strong>：王 Mono</p>
<p>王老师现场撸代码，使用 Rust 一步一步完成开发嵌入式烂苹果。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=4">查看回放</a></p>
<p><strong>扩展资料</strong></p>
<ol>
<li>暖场代码</li>
</ol>
<pre><code class="language-Rust">trait Trait {
    fn f(self);
}

impl&lt;T&gt; Trait for fn(T) {
    fn f(self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;T&gt; Trait for fn(&amp;T) {
    fn f(self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let a: fn(_) = |_: u8| {};
    let b: fn(_) = |_: &amp;u8| {};
    let c: fn(&amp;_) = |_: &amp;u8| {};
    a.f();
    b.f();
    c.f();
}
</code></pre>
<ol start="2">
<li><a href="https://longan.sipeed.com/zh/">Longan 文档</a></li>
</ol>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p58-点场来自-go-社区大佬的视角" id="p58-点场来自-go-社区大佬的视角">P5【8 点场】来自 go 社区大佬的视角</a></h3>
<p><strong>嘉宾</strong>：云喝酒</p>
<p>Go 和 Rust 作为两门新生语言，Go 的开发者人数大约是 Rust 的64倍。几位来自 Go 社区大佬以不同的视角一起聊聊。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=5">查看回放</a></p>
<p><strong>扩展资料</strong></p>
<ol>
<li>Cloubhouse</li>
</ol>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p69-点场程序员的吉他课" id="p69-点场程序员的吉他课">P6【9 点场】程序员的吉他课</a></h3>
<p><strong>嘉宾</strong>：MiskoLee</p>
<p>MiskoLee 老师现场教授弹吉他，妥妥的程序员吉他速成班。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=6">查看回放</a></p>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p79-点场snＭp-项目介绍" id="p79-点场snＭp-项目介绍">P7【9 点场】SNＭP 项目介绍</a></h3>
<p><strong>嘉宾</strong>：Robin</p>
<p>SNMP 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。 SNMP 使网络管理员能够管理网络效能，发现并解决网络问题以及规划网络增长。通过 SNMP 接收随机消息（及事件报告）网络管理系统获知网络出现问题。Robin 老师分享 SNMP 在自己工作中实际应用。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=7">查看回放</a></p>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p810-点场maya-rs-分享" id="p810-点场maya-rs-分享">P8【10 点场】Maya-rs 分享</a></h3>
<p><strong>嘉宾</strong>：JungWoo</p>
<p>在 Maya 中运用 Rust 实现噪声效果的案例。原理：使用 Rust 调用 Python API，然后再将结果给到 Python API。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=8">查看回放</a></p>
<p><strong>扩展资料</strong></p>
<ol>
<li><a href="https://github.com/Choi-Jungwoo/maya_poly_noise_rs">Maya PolyNoise</a></li>
<li><a href="http://help.autodesk.com/view/MAYAUL/2019/ENU/">Maya帮助</a></li>
</ol>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p910-点场关于数据库研究和开发的一些话" id="p910-点场关于数据库研究和开发的一些话">P9【10 点场】关于数据库研究和开发的一些话</a></h3>
<p><strong>嘉宾</strong>：金明剑</p>
<p>金明剑老师结合自己实际经验聊了聊对 Rust 的理解，既有深度又有广度。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=9">查看回放</a></p>
<center><font color=#f56c6c>----------> Rust 牛年春晚 <----------</font></center>
<h3><a class="header" href="#p1011-点场wasm-与-rust-及-vitejs-rs-分享" id="p1011-点场wasm-与-rust-及-vitejs-rs-分享">P10【11 点场】wasm 与 rust 及 vitejs-rs 分享</a></h3>
<p><strong>嘉宾</strong>：夏歌&amp;lencx</p>
<p>夏歌老师根据自己整理的 WebAssembly 生态图，对其整体状况进行简单介绍。</p>
<p>Lencx 老师现场演示，通过一个标准的 <a href="https://vitejs.dev/">Vite</a> 脚手架开始项目，集成进 Rust，最后打包生成 Wasm 项目。</p>
<p><a href="https://www.bilibili.com/video/BV1pi4y1T78V?p=10">查看回放</a></p>
<p><strong>扩展资料</strong></p>
<ol>
<li>https://github.com/second-state/tencent-tensorflow-scf</li>
<li>https://mtc.nofwl.com/tech/post/wasm-start.html#rust</li>
<li>https://vitejs.dev/</li>
</ol>
<h1><a class="header" href="#知乎-rust-圆桌年话专题问答精选" id="知乎-rust-圆桌年话专题问答精选">知乎 Rust 圆桌年话专题问答精选</a></h1>
<p>编辑：张汉东</p>
<p>在牛年春节期间，我在知乎发起 <a href="https://www.zhihu.com/question/443595816">Rust 语言圆桌年话 | 关于 Rust 语言基金会成立，你有什么想说的呢？
</a></p>
<hr />
<p><strong><a href="https://www.zhihu.com/question/443595816">关于 Rust 语言基金会成立，你有什么想说的呢？</a></strong></p>
<p><strong>@韩朴宇：</strong></p>
<pre><code>链接：https://www.zhihu.com/question/443595816/answer/1734191236
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>华为在创始成员中既惊讶又感到正常，因为并没有听说华为在rust项目上的投资（其他4个成员公司存在大量的Rust项目组成员），但是华为也有Rust写的产品，比如StratoVirt。StratoVirt 是华为的企业级Linux操作系统EulerOS的开源版openEuler旗下的一个项目，是一个基于Linux KVM的虚拟机StratoVirt兼容QEMU的QMP API,同时支持x86和鲲鹏arm处理器，并且使用virtio半虚拟化设备接口。除了华为的StratoVirt, 还有一些Rust编写的虚拟机。最早的应该是Google的crosvm （cros是ChromeOS的缩写），这个虚拟机管理器是为了在ChromeOS上运行一个单独的Linux虚拟机而设计的（即Crostini 计划）。</p>
<p>ChromeOS是一个类似于Android的系统，其系统分区是只读的，使用A/B分区的方式无缝升级，并且使用单独的用户数据分区。但是不同于Android高度定制化的用户空间，ChromeOS的用户空间就是用Gentoo Linux的包管理器Portage编译出来的，因此ChromeOS是一个标准的GNU/Linux系统。但是Google认为直接在该系统上运行任意的Linux程序会损害ChromeOS的安全性，因此在ChromeOS上运行一个轻量级虚拟机来运行一个命令行版的ChromeOS, 该系统可以运行LXC容器，默认的容器是Debian。Google认为这样套娃下来，既可以运行普通的Linux程序，又不会产生安全性问题。crosvm的特色是实现了一个基于virtio的Wayland总线，可以将虚拟机的Wayland/Xwayland程序的窗口直接穿过虚拟机的界限绘制到主系统的Wayland合成器上。使用最广的应该是AWS的 firecracker-microvm/firecracker ，AWS已经将其用于生成环境。此外还有Intel的 cloud-hypervisor/cloud-hypervisor，不仅支持x64, 而且像前3者一样也支持ARM64,而且还支持Windows 10。Rust在KVM上的生态离不开rust-vmm项目，该项目提供了对KVM api的绑定，该项目带起了整个Rust虚拟机的生态。</p>
<p><strong>@iyacontrol：</strong></p>
<pre><code>链接：https://www.zhihu.com/question/443595816/answer/1723079060
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>首先恭喜Rust有了好爸爸，而且不止一个。而且可以预见不久的未来，IBM、阿里云、腾讯云等大厂也会加入进来。有了这么多的好爸爸的加持，小伙伴们可以放心大胆地用Rust了，不用再担心Rust被砍掉了。通过基金会的成员来看，除了亲爸爸Mozilla，其他member大多都和云有关系。可以得出两点：Rust 的安全性和不差的性能，适合用来写一些偏底层的软件，比如各种运行时。而且也得到了大家一致的认可。Rust 将在云原生领域大放异彩了。目前来看，很有可能和Golang相互配合，Rust负责底层部分，Go负责中间部分，共同服务上层各种语言的应用。另外，感谢Mozilla的不为五斗米折腰，没有让Rust走了Java的路。如果Rust卖给类似于甲骨文的公司，那么Rust的前景就不好说了。</p>
<p><strong>@最帅的物理课代表：</strong></p>
<pre><code>链接：https://www.zhihu.com/question/443595816/answer/1734618924
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>虽然我是老华为黑粉了，但是其实很开心能看到华为在创始人名单之列。rust语言是很有前途的语言，这几乎是业界共识。华为有自研的容器项目，采用rust语言编写，这是一个很有意义的作品，比hm系列高到不知道哪里去。我们能通过这些看到华为的决心和勇气。同时这也很能带动国内的其他互联网企业，一起为rust投入更多精力，也给全球的rust社区添砖加瓦。我国的互联网发展和欧美一些国家一直都有较大的差距。但是众所周知，我们的传统艺能就是弯道超车。</p>
<p>还有很多回答，可以去知乎查看。</p>
<hr />
<p><strong><a href="https://www.zhihu.com/question/438833112">您对 2021 年的 Rust 语言有哪些期待？</a></strong></p>
<p><strong>@韩朴宇:</strong></p>
<pre><code>链接：https://www.zhihu.com/question/438833112/answer/1673155747
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>我在<code>rustbuild（即src/bootstrap）</code>上提过几个pr，因此说几个和<code>rustc</code>相关的（或者说和语言无关的工程问题）。</p>
<ol>
<li>
<p><code>cranelift</code>以及<code>rustc_codegen_cranelift</code>可以大大加速debug build，test，proc_macro和build.rs的速度，结合<code>jit</code>模式，可以实现以接近cargo check的速度同时检查语法错误，借用检查错误和逻辑错误。目前cg_clif已经进入rust仓库，在SYSV abi，Windows ABI，原子操作，内联汇编，SIMD上还有一些问题。cg_clif是由一位开发者bjorn3单枪匹马写出来的，很厉害。另外新的asm！内联汇编宏不再使用llvm_asm的语法，就是因为有朝一日rustc会集成上全功能的rust编写的后端。由Inline Assembly project group开发</p>
</li>
<li>
<p><code>std aware cargo</code>也就是 <code>cargo -Z build-std</code>，这个功能在优化二进制大小上很有用，在操作系统开发上是必需品。由std Aware Cargo working group负责。</p>
</li>
<li>
<p><code>core::error::Error</code>, <code>core::io::Error</code>和<code>backtrace</code>支持这是<code>Error handling project group</code>的工作重点，目前已有demo可用。有了这个wasm，嵌入式和操作系统开发也可以用常用的错误处理库了。</p>
</li>
<li>
<p><code>chalk</code> 。trait 系统的改进全靠这个，包括<code>GAT</code>由<code>traits working group</code>负责为什么我的期待都有working group，因为这就是rust项目的治理方式，没有working group的东西就肯定是没戏的，至少一年内是如此。比如取一个稳定的abi，作为rust abi和c++ abi的子集和C abi的超集，已经吵了好几年了，估计今年也是没戏。</p>
</li>
</ol>
<p><strong>@Nugine：</strong></p>
<pre><code>链接：https://www.zhihu.com/question/438833112/answer/1672070201
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p><code>min const generics</code> 将于 1.51 稳定，大约3月底，可以解锁一些较为常规的设计方法。</p>
<p>GAT 仍然是我最期待的有生之年的特性，它与 async trait, monad 之类的东西相关，能派生出很多魔法设计。</p>
<p><code>async-std 1.8</code>，<code>tokio 1.0</code>，希望更多常用的库不再犹豫，赶紧1.0。</p>
<p>希望 tracing 加快速度到 0.2，异步上下文追踪就指望它了。</p>
<p>生态中很多常见领域都已经有了至少一两个占主导地位的库，但还需要打磨。希望做到商业级、工业级可用。</p>
<p>希望 2021 Rust 多出一些杀手级产品，最好是国产的。</p>
<p><strong>@dontpanic:</strong></p>
<pre><code>链接：https://www.zhihu.com/question/438833112/answer/1673710125
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>我比较没出息，我只想要糖…… 最想要的几个：</p>
<ol>
<li><code>arbitrary_self_types</code>(p.s 这个例子并不是必须使用arbitrary self types，使用 associate function可以有同样的效果，参见评论区）真的好用，已经离不开了。</li>
</ol>
<p>目前能用做 Self 类型的，只有 <code>self/&amp;self/&amp;mut self/Box&lt;Self&gt;/Rc&lt;Self&gt; </code>等几个类型。 Arbitrary self types 允许使用任意 Deref 到 Self 的类型用作 self。有什么用呢？比如，我想扩展下面的 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Base:trait Derived {
    fn foobar(&amp;self);
}

struct Base&lt;T: Derived&gt; {
    ext: T,
}

impl&lt;T: Derived&gt; Base&lt;T&gt; {
    fn foo(&amp;self) {
        self.ext.foobar();
    }

    fn bar(&amp;self) {
        println!(&quot;bar!&quot;);
    }
}

struct DerivedImpl {
    base: Weak&lt;RefCell&lt;Base&lt;DerivedImpl&gt;&gt;&gt;,
}

impl Derived for DerivedImpl {
    fn foobar(&amp;self) {
        self.base.upgrade().unwrap().borrow().bar();
        println!(&quot;foobar!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样的实现就会强制 base 必须以使用 Rc 的方式使用，并且要小心多次 BorrowMut（很容易发生，要么就需要 Derived 提供 interior mutability）。或者也可以在 trait Derived 的函数参数里面把 base 传进去，但是有点 verbose。当然也可以说这种设计不够 rust idiomatic...不过有了 Arbitrary self types 之后，世界就清爽了。</p>
<p>首先实现一下<code>deref/deref_mut</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Derived + 'static&gt; Deref for Base&lt;T&gt; {
    type Target = T;

    #[inline(always)]
    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.ext
    }
}

impl&lt;T: Derived + 'static&gt; DerefMut for Base&lt;T&gt; {
    #[inline(always)]
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        &amp;mut self.ext
    }
}
然后 Derived 可以直接：trait Derived : 'static + Sized {
    fn foobar(self: &amp;mut Base&lt;Self&gt;);
}

struct DerivedImpl {
}

impl Derived for DerivedImpl {
    fn foobar(self: &amp;mut Base&lt;Self&gt;) {
        self.bar();  // !!!!!
        println!(&quot;foobar!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>多了 'static + Sized，但也可以接受。</p>
<ol start="2">
<li>
<p><a href="https://github.com/rust-lang/rust/issues/53667">let_chains_2</a>，啥也不说了，羡慕 Swift。</p>
</li>
<li>
<p>标准库里面有很多 unstable 的函数，经常会一用上来发现还是 unstable 需要开 feature。自己的项目随便开开倒是无所谓，但生产环境必定要谨慎的多。希望能够尽快 stable，比如 drain_filter。</p>
</li>
</ol>
<p>longfangsong:</p>
<pre><code>链接：https://www.zhihu.com/question/438833112/answer/1674659637
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。    
</code></pre>
<p>其他答主说的已经很好了，尤其是语言设计上的（GAT什么的大家都久等了），我再补充几点：</p>
<p>语言设计：</p>
<ol>
<li>看Rust Internals的时候看到的一个感觉有点意思的idea：更细粒度的unsafe。</li>
<li>看到前面有人说的enumerate variant as type，我想要的一个和这个比较像的一个糖是 Typescript 那样的 (untagged) union type，目前我习惯是用enum_dispatch crate来部分模拟这个特性。</li>
</ol>
<p>工具方面的：</p>
<ol>
<li>IDE支持，CLion 现在index不了编译时生成的代码（即使开了RA也一样）。vsc可以但是RA有时会莫名其妙地hang住。</li>
<li>能不能修修<code>cargo</code> 的 <code>[patch]</code> 只认repo的url而不管rev的问题，即<code>cargo#7497</code></li>
<li>求编译能再快一点……编译产物能再多复用一点……</li>
</ol>
<p>社区建设方面：</p>
<ol>
<li>现在感觉很多还没有入门rust的人都被它“传言中”的难度吓到了，实际上rust也就是一门普通的语言，可能所有权检查、强制性的线程安全这些特性确实是别的语言没有的，但掌握这些特性其实也不比掌握指针之类的概念困难，还有其实很多看着很长很可怕的写法（<code>Option&lt;Rc&lt;RefCell&gt;&gt;&gt;</code>）虽然第一眼看上去劝退实际上却更合理更可读（分离了是否可空、是否多个所有者、是否可变三个关注点，相比其他某些语言一个指针走天下其实更容易分析）。其实宣传的时候可以更多的去给新人一种rust并不难的印象，可以更好地壮大社区。</li>
<li>有没有入口可以给rust foundation捐钱啊（x</li>
</ol>
<p>还有很多回答，可以去知乎查看。</p>
<hr />
<p>还有很多精彩的问题等待你的探索和回答：</p>
<ul>
<li><a href="https://www.zhihu.com/question/31644802">Rust相较于Haskell除了效率还有何优势？</a></li>
<li><a href="https://www.zhihu.com/question/30407715">如何看待 Rust 的应用前景？</a></li>
<li><a href="https://www.zhihu.com/question/442315024">写 wasm 项目选 C++ 还是 Rust？</a></li>
<li><a href="https://www.zhihu.com/question/400001723">学Rust之前，是不是应该先学C++？</a></li>
<li><a href="https://www.zhihu.com/question/424290703">学习Rust, 可以绕开C语言吗?</a></li>
<li><a href="https://www.zhihu.com/question/344733952">在中国有多少开发者使用Rust编程语言？</a></li>
<li><a href="https://www.zhihu.com/question/308540043">只学过 C 语言适合学 Rust 吗？</a></li>
<li><a href="https://www.zhihu.com/question/30511494">GitHub 上有哪些值得关注的 Rust 项目？</a></li>
<li><a href="https://www.zhihu.com/question/31038569">如何开始学习 Rust 语言?</a></li>
<li><a href="https://www.zhihu.com/question/34665842">学习Rust适合写什么练手项目？</a></li>
<li><a href="https://www.zhihu.com/question/352420716">Rust程序员都做什么项目？</a></li>
<li><a href="https://www.zhihu.com/question/441960256">本科毕业论文想写点 Rust 语言相关的内容，什么样的题目比较好？</a></li>
<li><a href="https://www.zhihu.com/question/30408031">我应该放弃 C++，学习 Rust 吗？</a></li>
</ul>
<h1><a class="header" href="#华为--可信编程----华为引领rust语言开发的实践和愿景" id="华为--可信编程----华为引领rust语言开发的实践和愿景">华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景</a></h1>
<p>作者：（俞一峻、Amanieu d'Antras、Nghi D. Q. Bui） / 后期编辑：张汉东</p>
<hr />
<h2><a class="header" href="#本文结构" id="本文结构">本文结构</a></h2>
<ul>
<li>可信编程 -- 华为引领 Rust 语言开发的实践和愿景
<ul>
<li>Rust带来的创新</li>
<li>Rust在华为的初步推进</li>
<li>华为对 Rust 社区的贡献</li>
<li>配置华为的端到端 Rust 工具链
<ul>
<li>tokei</li>
<li>cargo-geiger</li>
</ul>
</li>
<li>通过深度代码学习研究 Rust</li>
<li>结论</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#rust带来的创新" id="rust带来的创新">Rust带来的创新</a></h2>
<p>StackOverflow 的调查表明, 自 2015 年以来，Rust 一直是开发者最爱的编程语言。</p>
<p><img src="chapter_2/./huawei_rust/1-RustConChina2020-yu-v42.png" alt="img" /></p>
<p>学术界对于Rust也越来越重视，在编程语言和软件工程顶会上发表的关于Rust的论文正逐年增加。</p>
<p><img src="chapter_2/./huawei_rust/2-RustConChina2020-yu-v43.png" alt="img" /></p>
<p>不仅如此，《自然》杂志2020年尾的文章《Why Scientists are Turning to Rust》中也强调：科学家极为推崇Rust。</p>
<p><img src="chapter_2/./huawei_rust/3-RustConChina2020-yu-v41.png" alt="img" /></p>
<h2><a class="header" href="#rust在华为的初步推进" id="rust在华为的初步推进">Rust在华为的初步推进</a></h2>
<p>华为的目标是引领通信系统软件向安全可信演进，其中 Rust 语言正在发挥很大的作用。</p>
<p>例如，我们希望通过部分 C/C++ 代码的迁移，在保证高性能的同时，拥有更高的安全性。在此过程中， 我们为开发者提供一套自动化工具支持：基于开源的 C2Rust 转译工具， 首先从 C 代码生成 Rust 代码, 然后通过源到源变换工具自动重构。</p>
<p>在华为内部我们还基于 Actor 的并发编程模式开发了 Rust 库，方便程序员充分利用 Rust的语言特性, 例如<code>async/await</code>等。</p>
<p>以华为代表的通信系统软件的开发以 C/C++ 代码为主, 这些 Rust 库将使 C/C++ 到 Rust 的迁移更加顺畅。 作为业界领先公司和 Rust基金会 的创始成员，华为致力于 Rust 在通信软件行业，并将持续为 Rust 社区做出贡献。</p>
<h2><a class="header" href="#华为对rust社区的贡献" id="华为对rust社区的贡献">华为对Rust社区的贡献</a></h2>
<p>我们为 Rust 社区贡献了许多重要的功能特性。例如，我们最近为 Rust 编译器提交了一系列代码，使得 Rust 编译目标可以支持<code>ARM AArch64 32</code>位大端变体<a href="https://developer.arm.com/documentation/dai0490/latest/">ILP32</a>芯片组, 用于我们的通信产品中。 这些改进使得我们和友商可以在这些常用网络硬件架构上执行Rust 原生程序。这些代码已经通过我们的 Rust 专家<code>Amanieu d'Antras</code> 提交给了 <a href="https://reviews.llvm.org/rG21bfd068b32ece1c6fbc912208e7cd1782a8c3fc">LLVM 编译器</a>, <a href="https://github.com/rust-lang/libc/pull/2039">libc 库</a>, 以及 <a href="https://github.com/rust-lang/rust/pull/81455">Rust 编译器</a>等开源社区。</p>
<p>这些对 Rust 编译器的更改引入了新的端到端交叉编译目标，针对定制硬件构建 Rust 产品变得更容易,只需要简单的命令，比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo build --target aarch64_be-unknown-linux-gnu
cargo build --target aarch64-unknown-linux-gnu_ilp32
cargo build --target aarch64_be-unknown-linux-gnu_ilp32
<span class="boring">}
</span></code></pre></pre>
<p>华为在中国 Rust 社区方面也走在前列，战略支持 12月26日至27日 在 深圳 举办了<a href="https://2020conf.rustcc.cn/">第一届 Rust China Conf 大会</a>，并推行多项 社区活动，包括为中国的开发者提供 Rust教程 和 Rust编码规范。</p>
<h2><a class="header" href="#配置华为的端到端rust工具链" id="配置华为的端到端rust工具链">配置华为的端到端Rust工具链</a></h2>
<p>Rust社区中有几种端到端的工具，我们已经开始从开发人员和工具的交互中获取信息。</p>
<p>这里有一些例子:</p>
<p><strong>tokei</strong></p>
<p>由于可信编程项目通常涉及多个编程语言，我们采用了tokei作为多语言代码复杂性度量工具，识别多达200种编程语言。例如，开源的 Fuchhia 项目涉及了多种编程语言，下面的统计信息显示有多少行不同语种的代码：</p>
<p><img src="chapter_2/./huawei_rust/4-RustConChina2020-yu-v49.png" alt="img" /></p>
<p>C、C++、Rust 代码在 Fuchhia 项目的占比，可以绘制成如下演进图：</p>
<p><img src="chapter_2/./huawei_rust/5-RustConChina2020-yu-v410.png" alt="img" /></p>
<p>为了在大型项目中满足处理多种编程语言的场景需求，我们提交代码到tokei支持识别编程语言的批处理。</p>
<p><strong>cargo-geiger</strong></p>
<p>为了提高安全性，我们经常想知道有多少代码已经被 Rust 编译器检查过。幸运的是，通过统计&quot;Unsafe&quot;项目，如<code>fn</code>、<code>expr</code>，<code>struct</code>、<code>impl</code>、<code>trait</code>及其在各相关库实现中的出现次数， <a href="https://github.com/rust-secure-code/cargo-geiger">cargo-geiger</a>几乎做到了这点。</p>
<p><img src="chapter_2/./huawei_rust/6-RustConChina2020-yu-v411.png" alt="img" /></p>
<p>不过，统计数字中并没有反映安全性，所以没办法展现Rust项目总体上取得了多少进展的比例。因此，我们 提交了<a href="https://github.com/rust-secure-code/cargo-geiger/pull/167">代码</a>，在改进的 cargo-geiger 计数器报告中提供 Rust 项目的安全检查比率。这个代码采纳后，我们的产品团队现在每天定期都在使用这个工具，一份典型的报告能够更容易理解哪些代码库还没被 Rust 编译器完全检查到。</p>
<p><img src="chapter_2/./huawei_rust/7-RustConChina2020-yu-v412.png" alt="img" /></p>
<h2><a class="header" href="#通过深度代码学习研究-rust" id="通过深度代码学习研究-rust">通过深度代码学习研究 Rust</a></h2>
<p>随着 Rust 开源社区代码的发展和革新，初学者需要学习掌握Rust最佳的实践，其包括但不限于 Rust 语言本身。把统计机器学习的方法应用到源代码数据上，也称为<a href="https://arxiv.org/abs/1709.06182">大代码</a>，正被全世界的软件工程研究团队关注：类似于 图像处理和自然语言处理中的机器学习问题，这些问题都需要通过深度神经网络(deep neural networks DNN)提取大量的特征，Big Code 可能同样需要去训练DNN来反映程序的统计特性，所以也称为&quot;深度代码学习&quot;。</p>
<p>在这方面，华为与<a href="https://mcs.open.ac.uk/yy66">英国开放大学</a>和<a href="http://www.mysmu.edu/faculty/lxjiang/">新加坡管理大学</a>进行技术合作，在现在最先进的“跨语言”深度代码学习基础上进行优化研究。</p>
<p>例如，最初的深度代码学习方法应用于北京大学编程课程收集到的104个算法类的5.2万个C/C++程序。对此数据集，树基卷积神经网络(TBCNN)算法分类准确率达到94%(<a href="https://github.com/bdqnghi/tbcnn.tensorflow">AAAI'16</a>)。最近的 SOTA 在语句级使用抽象语法树 (<a href="https://github.com/zhangj111/astnn">ICSE '19</a>)准确率达到98%。近期我们同英国开放大学和新加坡管理大学在树基胶囊网络的合作研究进展推动了SOTA进一步提高，达到98.4%的准确率(<a href="https://arxiv.org/abs/2009.09777">AAAI'21</a>)。</p>
<p>早些时候我们已经使用跨语言的数据集表明，对一种编程语言的深度代码学习模型也适用于另一种编程语言。例如，从GitHub 爬取的数据集 Rosetta Code，从 Java 到 C 语言，可以获得86%的算法分类准确度 (<a href="https://github.com/bdqnghi/bi-tbcnn">SANER'19</a>)，在Java到C#的跨语言API映射 问题也能发挥重要作用(ESEC/FSE'19)。这些统计语言模型在软件工程中可以应用于很多方面，比如代码分类、代码搜索、代码推荐、代码摘要、方法名称预测、代码克隆检测等等(<a href="https://github.com/bdqnghi/infercode">ICSE'21</a>)。</p>
<p>为了进一步研究分析 Rust 项目，我们向 Rust 解析器项目<code>tree-sitter</code>和 XML序列化 <code>quick-xml</code>等项目提交了代码，通过 Rust 程序的抽象语法树来训练深度代码学习模型。研究的初步结果很有希望，算法检测任务在 Rust代码上的精度高达85.5%。随着工具链的改进，这个比例还有望进一步提升。</p>
<p>在 IDE 上的原型是在<code>Visual Studio Code IDE</code>上，我们开发扩展插件，使得程序员可以得到合适的算法推荐和可解释性的帮助。</p>
<p><img src="chapter_2/./huawei_rust/8-RustConChina2020-yu-v414.png" alt="img" /></p>
<h2><a class="header" href="#结论-1" id="结论-1">结论</a></h2>
<p>综上所述，华为可信开源软件工程实验室正在开展的 Rust 工作为程序员提供智能化端到端 IDE 工具链，以期最大限度地提高代码的安全性和性能。走向可信编程远景的旅程刚刚开始，我们希望与 Rust社区 和 Rust基金会深度合作，引领电信软件产业的可信革新。</p>
<hr />
<p>作者简介：</p>
<p>俞一峻：
可信编程首席专家/华为可信软件工程开源实验室/华为爱尔兰研究所</p>
<p>Amanieu d'Antras:
可信编程首席专家/华为可信软件工程开源实验室/华为爱尔兰研究所</p>
<p>Nghi D. Q. Bui:
可信编程首席专家/华为可信软件工程开源实验室/华为爱尔兰研究所</p>
<h1><a class="header" href="#pingcap--tikv-高性能追踪的实现解析" id="pingcap--tikv-高性能追踪的实现解析">PingCAP | TiKV 高性能追踪的实现解析</a></h1>
<p>作者：钟镇炽 / 后期编辑：张汉东</p>
<hr />
<h2><a class="header" href="#前言" id="前言">前言</a></h2>
<p>本文为  PingCAP Observability 团队研发工程师钟镇炽在 Rust China Conf 2020 大会上所做演讲 《高性能 Rust tracing 库设计》的更详细文本，介绍了对性能要求非常苛刻的分布式 KV 数据库 TiKV 如何以不到 5% 的性能影响实现所有请求的耗时追踪 。另可点击 https://www.bilibili.com/video/BV1Yy4y1e7zR?p=22 查看演讲视频。</p>
<h2><a class="header" href="#背景" id="背景">背景</a></h2>
<p>系统的可观测性 (Observability) 通常由三个维度组成：日志 (Logging)、指标 (Metrics) 和追踪 (Tracing)，它们之间的关系如下：</p>
<p><img src="chapter_2/./rust_trace/1.png" alt="1" /></p>
<ul>
<li>日志：离散的错误信息和状态信息。</li>
<li>指标：记录和呈现可聚合的数据。</li>
<li>追踪：单个请求的一系列事件。</li>
</ul>
<p>TiKV 实现了完备的日志和指标系统，但缺失了追踪，导致在诊断 TiKV 和 TiDB 问题时会遇到以下困难：</p>
<ul>
<li><strong>观测数据之间的没有关联</strong>：只有熟悉请求链路上每个操作对应什么监控指标的同学才能完整追溯和诊断问题。</li>
<li><strong>请求抖动难以追溯</strong>：TiKV 节点往往同时处理不同模式的业务，零星请求的性能抖动无法体现在 AVG / P99 / MAX 等监控指标中，从而无法诊断抖动原因。</li>
</ul>
<p><strong>追踪可以有效解决上述场景中遇到的问题</strong>。以下详细介绍 TiKV 中高性能追踪的实现。追踪功能在 TiKV 中尚为实验性特性，需要特定代码分支开启，感兴趣的同学可以关注 GitHub issue <a href="https://github.com/tikv/tikv/pull/8981">Introduce tracing framework (#8981)</a>。</p>
<h3><a class="header" href="#基本概念" id="基本概念">基本概念</a></h3>
<p>追踪（Trace）呈现系统中的一个请求的执行路径。例如追踪一个 SQL 语句从 TiDB 到 TiKV 的执行全过程后可以得到下图：</p>
<p><img src="chapter_2/./rust_trace/2.png" alt="2" /></p>
<p>从图中可以直观看到 SQL 语句<code>“INSERT INTO</code>t<code>VALUES (1), (2), (3);” </code>有趣的信息：</p>
<ul>
<li>TiDB 处理这个请求时依次进行了 compile、plan、execute 三个步骤</li>
<li>TiDB 在 execute 阶段调用了 TiKV 的 Prewrite RPC 和 Commit RPC</li>
<li>请求共耗时 5ms</li>
</ul>
<p>图中每个方框代表一个事件，称之为 Span。每个 Span 包含：</p>
<ul>
<li>事件名称</li>
<li>事件起始时间戳和结束时间戳</li>
</ul>
<p>Span 之间有层级，可以构成父子关系或先后关系，如下图所示：</p>
<p><img src="chapter_2/./rust_trace/3.png" alt="3" /></p>
<h2><a class="header" href="#实现-1" id="实现-1">实现</a></h2>
<blockquote>
<p>本文所有性能测试结果，若特别说明测试环境，均在以下平台完成：</p>
<p>CPU: Intel Core i7-8700
Linux distros: Ubuntu 20.04
Linux kernel: 5.4
Memory: 32G
Disk: NVMe SSD</p>
</blockquote>
<p>TiKV 使用 Rust 编写。Rust 生态中有几个现成的追踪库，分别是 <a href="https://github.com/tokio-rs/tracing">tokio-tracing</a>, <a href="https://github.com/sile/rustracing">rustracing</a> 和 <a href="https://github.com/open-telemetry/opentelemetry-rust">open-telemetry</a>，它们都兼容 <a href="https://opentracing.io/specification/">OpenTracing 规范</a>，但<strong>性能不够理想</strong>，引入后会降低 TiKV 50% 以上性能。<strong>TiKV 目前的实现能将性能的影响控制在 5% 以内</strong>。这主要来自于<strong>单个 Span 追踪收集仅耗时 <code>20ns</code></strong>：</p>
<p><img src="chapter_2/./rust_trace/4.png" alt="4" /></p>
<p>以下具体介绍 TiKV 如何在 <code>20ns</code> 内完成单个 Span 追踪和收集。</p>
<h3><a class="header" href="#计时" id="计时">计时</a></h3>
<p>计时在追踪中是高频操作，每个 Span 都需要取两次时间戳，分别代表事件的起始和结束时刻，因此计时的性能会很大程度上影响追踪的性能。</p>
<p>追踪库采用的计时方式通常需要能满足以下要求：</p>
<ul>
<li>获取的时间戳单调递增</li>
<li>高性能</li>
<li>高精度</li>
</ul>
<h4><a class="header" href="#stdinstant" id="stdinstant">std::Instant</a></h4>
<p>Rust 原生提供以下两种计时方式：</p>
<ul>
<li><code>std::SystemTime::now()</code></li>
<li><code>std::Instant::now()</code></li>
</ul>
<p>其中第一种方式获取的是当前系统时间，它可能受用户手动调整、NTP 服务修正等原因的影响，获取到的时间戳并不提供单调递增的保证，因此不能采用。</p>
<p>大多数 Rust 社区的追踪库采取了第二种方式，可以取得单调递增的、纳秒精度的时间戳。但它的性能不够理想，取两次时间需要 <code>50ns</code>，这是社区追踪库性能较低的原因之一。</p>
<h4><a class="header" href="#coarse-time" id="coarse-time">Coarse Time</a></h4>
<p>若仅从高性能的角度出发来寻找计时方案，可使用 Coarse Time，<strong>它牺牲了一定的精度换取高性能</strong>。在 Linux 环境下，以 <code>CLOCK_MONOTONIC_COARSE</code> 作为时间源参数，通过 <code>clock_gettime</code> 系统调用可获取 Coarse Time。Rust 社区也提供了库 <a href="https://docs.rs/coarsetime/0.1.18/coarsetime/">coarsetime</a> 获取 Coarse Time：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>coarsetime::Instant::now()
<span class="boring">}
</span></code></pre></pre>
<p>Coarse Time 性能很高，在测试环境下完成两次调用仅需要 <code>10ns</code>。它的精度取决于 Linux 的 jiffies 配置，默认精度为 <code>4ms</code>。</p>
<p>低精度的计时对于短耗时请求的追踪会产生让人困惑的结果。如下图所示，从观测的角度来看已经损失了相当一部分的细节信息：</p>
<p><img src="chapter_2/./rust_trace/5.png" alt="5" /></p>
<p>当然<strong>在多数情况下，Coarse Time 仍是快速计时的首选</strong>。一方面是它在 Linux 系统下开箱即用，获取方便。另一方面，<code>4ms</code> 精度对大部分应用来说是可以接受的。</p>
<p>尽管如此，作为追踪功能的开发者，我们不希望限制用户的场景，例如对于 KvGet 请求，<code>4ms</code> 在要求高的场景中已足够作为异常的抖动需要追溯了，因此<strong>有必要支持微秒乃至纳秒级别精度的追踪</strong>。同时，性能作为核心出发点，也不能被牺牲掉。幸运的是，这个问题是有解的，它便是接下来要介绍的 TSC。</p>
<h4><a class="header" href="#tsc" id="tsc">TSC</a></h4>
<p>TiKV 采用 Time Stamp Counter (TSC) 寄存器进行高精度高性能计时。TSC 寄存器在现代 x86 架构的 CPU 中已经存在很久了，最早可以追溯到 2003 年推出的奔腾处理器。它记录了 CPU 供电重设后到当前时刻所经过的 CPU 时钟周期数。在 CPU 时钟周期速率相同的条件下，经过测量和换算即可用于高精度计时。</p>
<p><strong>TSC 可以同时满足单调递增、高精度和高性能的需求</strong>。在我们的测试环境中取两次 TSC 仅需 <code>15ns</code>。在实际情况中，随着处理器的不断发展，TSC 寄存器积累了相当多历史遗留问题会对其正确性造成影响，需要修正。</p>
<p><strong>TSC 速率</strong></p>
<p>TSC 递增速率由 CPU 频率决定。<strong>现代化 CPU 可能会动态调节频率节省能耗，导致 TSC 递增速率不稳定</strong>：</p>
<p><img src="chapter_2/./rust_trace/6.png" alt="6" /></p>
<p>另外，<strong>一些 CPU 在休眠状态时不会递增 TSC</strong>：</p>
<p><img src="chapter_2/./rust_trace/7.png" alt="7" /></p>
<p><strong>比较现代的 x86 架构 CPU 提供了特性确保 TSC 递增速率的稳定性</strong>。在 Linux 下可以通过 <code>/proc/cpuinfo</code> 中的 CPU flag 来检查 TSC 速率是否稳定：</p>
<ul>
<li>constant_tsc: TSC 将以固定的额定标称频率而非瞬时频率递增</li>
<li>nonstop_tsc: TSC 在 CPU 休眠状态下仍持续递增</li>
</ul>
<p>以上 TSC 速率的稳定性保证<strong>仅对单个 CPU 核心有效</strong>，在多核情况下还需处理 TSC 同步问题。</p>
<p><strong>TSC 多核同步</strong></p>
<p>x86 架构 CPU <strong>没有提供 TSC 寄存器在所有核心上的一致性保证</strong>，这会导致计时存在问题。下图展示了某台 2020 年生产的搭载了当时最新 x64 CPU 的笔记本上 TSC 测量情况。可以看到，16 个核心中有一个核心 CPU 0 的 TSC 值存在偏差。</p>
<p><img src="chapter_2/./rust_trace/8.png" alt="8" /></p>
<p>在追踪中，完整的计时操作会读取两次时间戳，分别代表事件的始末。由于操作系统的线程调度，这两个时间戳的读取可能发生在不同的核心上。若我们简单地以 TSC 值差值进行计时，会<strong>在多核 TSC 不同步的情况下造成耗时计算的偏差</strong>。</p>
<p>举个例子：</p>
<ol>
<li>t1 时刻，线程在 Core 1 上运行，读取了较大的 tsc1</li>
<li>操作系统将线程从 Core 1 调度至 Core 2</li>
<li>t2 时刻，线程在 Core 2 上运行，读取了较小的 tsc2</li>
</ol>
<p><img src="chapter_2/./rust_trace/9.png" alt="9" /></p>
<p>此时计算的 TSC 差值甚至成为了负数，无法换算为耗时。</p>
<p>为了解决这个问题，<strong>TiKV 会同步各个核心的原始 TSC 值，计算出 TSC 值在各个核心的偏移量</strong>，使用同步过后的 TSC 值用于计算耗时。具体算法为在各个核心上任取两次 TSC 和物理时间，以物理时间作为 x 轴、核心上的 TSC 作为 y 轴计算截距，差值即为各个核心的 TSC 偏移，如下图所示：</p>
<p><img src="chapter_2/./rust_trace/10.png" alt="10" /></p>
<p>在计算初始 TSC 偏移时，<strong>需要确保取两次 TSC 的过程全都同一核心上执行</strong>。在 Linux 中可以通过系统调用 <code>sched_setaffinity</code> 设置线程的亲核性，将线程固定到某个核心上运行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn set_affinity(cpuid: usize) -&gt; Result&lt;(), Error&gt; {
   use libc::{cpu_set_t, sched_setaffinity, CPU_SET};
   use std::mem::{size_of, zeroed};
 
   let mut set = unsafe { zeroed::&lt;cpu_set_t&gt;() };
   unsafe { CPU_SET(cpuid, &amp;mut set) };
 
   // Set the current thread's core affinity.
   if unsafe {
       sched_setaffinity(
           0, // Defaults to current thread
           size_of::&lt;cpu_set_t&gt;(),
           &amp;set as *const _,
       )
   } != 0
   {
       Err(std::io::Error::last_os_error().into())
   } else {
       Ok(())
   }
}

<span class="boring">}
</span></code></pre></pre>
<p>有了各个核心的 TSC 偏移值后，在计时阶段只需获取当前执行线程所在的 CPU 及 TSC 值，即可计算出同步后的 TSC 值。需要注意的是，当前执行所在的 CPU 及当前的 TSC 值需要在一条指令中同时获取，避免其中插入操作系统的线程调度导致计算错误。这<strong>可以通过 RDTSCP 指令实现</strong>。它可以帮助我们原子性地获取原始 TSC 值和 CPU ID。</p>
<p>Rust 代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn tsc_with_cpuid() -&gt; (u64, usize) {
   #[cfg(target_arch = &quot;x86&quot;)]
   use core::arch::x86::__rdtscp;
   #[cfg(target_arch = &quot;x86_64&quot;)]
   use core::arch::x86_64::__rdtscp;
 
   let mut aux = std::mem::MaybeUninit::&lt;u32&gt;::uninit();
   let tsc = unsafe { __rdtscp(aux.as_mut_ptr()) };
   let aux = unsafe { aux.assume_init() };
 
   // IA32_TSC_AUX are encoded by Linux kernel as follow format:
   //
   // 31       12 11      0
   // [ node id ][ cpu id ]
   (tsc, (aux &amp; 0xfff) as usize)
}


<span class="boring">}
</span></code></pre></pre>
<p>上文描述的高精度计时的逻辑已经提取成一个独立的 Rust 社区库 <a href="https://github.com/zhongzc/minstant.git">minstant</a>，可供相似需求的其他项目直接使用。</p>
<h3><a class="header" href="#span-收集" id="span-收集">Span 收集</a></h3>
<p>Span 可能在各个线程上产生，最终要收集起来汇聚成一个追踪，因此需要跨线程的 Span 收集机制。<strong>Span 的收集也是追踪库的一个常见性能瓶颈点</strong>。</p>
<p>一般有以下方式进行线程安全的 Span 收集：</p>
<ul>
<li><code>Arc&lt;Mutex&lt;Vec&lt;Span&gt;&gt;&gt;</code></li>
<li><code>std::sync::mpsc::Receiver&lt;Span&gt;</code></li>
<li><code>crossbeam::channel::Receiver&lt;Span&gt;</code></li>
</ul>
<p>这几种常见的收集方式中 crossbeam channel 是最优的，发送和收集一次 Span 的耗时约为 40ns。为了在提升性能，TiKV 采用了与上述不同的方式收集 Span：同一线程上 Span 仅<strong>在线程本地无竞争地收集</strong>、最终汇集各个线程上已经<strong>收集好的一批 Span 到全局收集器</strong>。</p>
<h4><a class="header" href="#local-span" id="local-span">Local Span</a></h4>
<p>TiKV 为每个线程维护一个线程本地结构 LocalSpanLine，负责 LocalSpan 的产生和存储。再由另外一个线程本地结构 LocalCollector，负责驱动 LocalSpanLine 和收集 LocalSpan。这三者之间的关系和各自的职责如下图。</p>
<p><img src="chapter_2/./rust_trace/11.png" alt="11" /></p>
<p>由于 LocalSpan、LocalSpanLine 和 LocalCollector 均是线程本地的，它们之间的交互均<strong>不需要线程间的同步和互斥，也不会破坏内存缓存，因此性能极高</strong>。LocalSpan 的收集是简单的 <code>Vec::push</code> 操作，平均耗费仅为 <code>4ns</code>。</p>
<p>另外，在构造 Span 依赖关系时，利用线程本地的特性可以很方便地实现<strong>隐式上下文</strong>的机制，<strong>用户无需修改函数签名来手动传递追踪上下文</strong>，大大降低了对现有代码的侵入性。</p>
<p>下面我们来深入了解关于 LocalSpan 产生和收集的实现细节。</p>
<p>首先，LocalSpanLine 维护了一个容器 SpanQueue，用于装载正在进行的或者已经完成的 LocalSpan。“正在进行”意味着 LocalSpan 所指示的事件开始时间已知，而结束时间未知。这些 LocalSpan 均存储在 SpanQueue 内部的 Vec 结构。</p>
<p>除此之外，上文提到我们利用隐式上下文来构造 LocalSpan 之间的父子依赖关系，这个过程实际上依赖于 SpanQueue 维护的一个变量 <code>next_parent_id</code>。</p>
<p>接下来我们将通过一些例子对整个过程进行更为详细的展开。</p>
<p>假设这样一个 foo 事件，于 <code>09:00</code> 产生，持续至 <code>09:03</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>09:00  foo +
09:01      |
09:02      |
09:03      +
<span class="boring">}
</span></code></pre></pre>
<p>初始状态下，SpanQueue 为空，<code>next_parent_id</code> 记为 root。那么在 foo 发生的时刻，即 09:00，SpanQueue 会去完成以下几个步骤：</p>
<ul>
<li>新增一条记录，填写事件名称 foo，起始时间 09:00，留空结束时间</li>
<li>将 <code>next_parent_id</code> 的值赋给 foo 的 parent</li>
<li>将 <code>next_parent_id</code> 更新为 foo</li>
<li>向外部返回 <code>index</code> 的值 0，用以接收事件结束的通知，进而完成后续结束时间的回填</li>
</ul>
<p><img src="chapter_2/./rust_trace/12.png" alt="12" /></p>
<p>在 foo 结束的时刻，即 <code>09:03</code>，用户提交 <code>index</code>，向 SpanQueue 通知 foo 事件结束，于是 SpanQueue 开始回填工作：</p>
<ul>
<li>通过 <code>index</code> 索引到 foo 事件所在记录</li>
<li>将结束时间回填为 <code>09:03</code></li>
<li>将 <code>next_parent_id</code> 更新为该记录的 <code>parent</code></li>
</ul>
<p><img src="chapter_2/./rust_trace/13.png" alt="13" /></p>
<p>以上的例子描述了单个事件的记录过程，很简单也很有效。而实际上多个事件的记录也仅仅只是上述过程的重复。比如下面的过程，foo 事件包含了两个子事件：bar 和 baz。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>09:00  foo +
09:01      | bar +
09:02      |     |
09:03      |     +
09:04      |
09:05      | baz +
09:06      |     |
09:07      |     +
09:08      +


<span class="boring">}
</span></code></pre></pre>
<p>正如上文所述，SpanQueue 除了记录各个事件的起始和结束时间，还需要记录各个事件之间的父子依赖关系。这个例子中，foo 发生时 SpanQueue 的存储内容和上文没有区别。而在 bar 发生时，SpanQueue 设置 bar 的 parent 为当前的 <code>next_parent_id</code> 值，即 foo，同时将 <code>next_parent_id</code> 更新为 bar：</p>
<p><img src="chapter_2/./rust_trace/14.png" alt="14" /></p>
<p>在 bar 结束时，会按照上面提到的回填步骤，更新 bar 记录的结束时间以及 <code>next_parent_id</code> 变量：</p>
<p><img src="chapter_2/./rust_trace/15.png" alt="15" /></p>
<p>重复以上步骤，最终 SpanQueue 以一种高效的方式，完整记录了这三个事件的信息：</p>
<p><img src="chapter_2/./rust_trace/16.png" alt="16" />
<img src="chapter_2/./rust_trace/17.png" alt="17" /></p>
<p>将这些记录串连起来，最终形成如下的 Trace 树状结构：</p>
<p><img src="chapter_2/./rust_trace/18.png" alt="18" /></p>
<h4><a class="header" href="#normal-span" id="normal-span">Normal Span</a></h4>
<p>虽然 LocalSpan 的记录比较高效，但是由于其本身基于线程本地的实现方式，使得灵活性不足。比如在异步场景下，一些 Span 的产生和结束发生在不同的线程，线程本地的实现就不再能发挥作用。</p>
<p>针对上述问题，TiKV 保留了前文最开始所描述的线程安全的 Span 记录方式，即采用 crossbeam channel 每次进行单个 Span 的收集，这样的 Span 下文称之为 NormalSpan。</p>
<p>从实现的角度看，NormalSpan 的信息不会记录在线程本地的容器当中，而是由相应的变量自行维护，以便于跨线程的移动。同时，NormalSpan 之间的父子关系不再由线程本地隐式构建，而需由用户手动指定。</p>
<p>但是，NormalSpan 和 LocalSpan 并非完全隔离，TiKV 通过以下的交互方式将这两者联系起来：从 LocalCollector 收集而来的一组 LocalSpan，可以挂载在 NormalSpan 上作为子树，如下图所示。同时，挂载的数量不受限制，通过允许进行多对多的挂载方式，TiKV 在一定程度上支持了对 batch 场景的追踪，这是社区中大部分追踪库没有覆盖到的。</p>
<p><img src="chapter_2/./rust_trace/19.png" alt="19" /></p>
<p>上述实现方式形成了 Span 收集的快慢两条路径。它们共同合作，完成对某个请求的执行路径信息的记录：</p>
<ul>
<li>LocalSpan 不可跨越线程但记录高效，通过批量收集 LocalSpan 然后挂载至普通 Span 的方式，让追踪的开销变得非常低。</li>
<li>普通 Span 的记录相对较慢，不过它可以跨线程传递，使用起来比较灵活。</li>
</ul>
<h2><a class="header" href="#使用方法" id="使用方法">使用方法</a></h2>
<p><strong>TiKV 中的高性能追踪的逻辑已提取成一个独立的库</strong> <a href="https://github.com/tikv/minitrace-rust">minitrace-rust</a>，可直接在各种项目中使用，步骤如下：</p>
<ul>
<li>请求到达时，创建对应根 Span；</li>
<li>请求执行路径上，使用 minitrace-rust 提供的接口记录事件的发生；</li>
<li>请求完成时，收集执行路径上产生的所有 Span。</li>
</ul>
<h3><a class="header" href="#根-span-的创建和收集" id="根-span-的创建和收集">根 Span 的创建和收集</a></h3>
<p>一般在一个请求开始的时候可以创建根 Span。在 minitrace-rust 中用法如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for req in listener.incoming() {
   let (root_span, collector) = Span::root(&quot;http request&quot;);
   let guard = root_span.enter();
   my_request_handler(req);
}
<span class="boring">}
</span></code></pre></pre>
<p>Span 基于 Guard 实现了自动在作用域结束后结束 Span，而无需手工标记 Span 的终止。除了返回根 Span 外，<code>Span::root(event)</code>  还返回了一个 <code>Collector</code>。 <code>Collector</code> 与根 Span 一一对应。在请求完成时，可调用 <code>Collector</code> 的 <code>collect</code> 方法，从而完成对执行路径上产生的所有 Span 的收集。如下所示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (root_span, collector) = Span::root(&quot;http request&quot;);
let guard = root_span.enter();
 
handle_http_request(req);
 
drop((guard, root_span));
let spans = collector.collect();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#事件记录" id="事件记录">事件记录</a></h3>
<p>比较推荐使用 minitrace-rust 提供的 <code>trace</code> 和 <code>trace_async</code> 宏进行函数级别的事件记录。通过上述方式为单个函数记录的执行信息如下：</p>
<ol>
<li>调用的发生时刻</li>
<li>调用的返回时刻</li>
<li>直接（或间接）调用者的引用</li>
<li>直接（或间接）调用的子函数的引用</li>
</ol>
<p>例如，追踪两个同步函数 <code>foo</code> 和 <code>bar</code>，通过添加 <code>trace(event)</code> 作为这两个函数的 attribute，即可记录函数的执行信息。如下所示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[trace(&quot;foo&quot;)]
fn foo() -&gt; u32 {
   bar();
   42
}
 
#[trace(&quot;bar&quot;)]
fn bar() { }
<span class="boring">}
</span></code></pre></pre>
<p>最终记录下来的信息，包括这两个函数各自的起始和完成时刻，以及函数调用关系：<code>foo</code> 调用了 <code>bar</code>。</p>
<p><img src="chapter_2/./rust_trace/20.png" alt="20" /></p>
<p>对于异步函数的记录，步骤略有不同。首先须将 <code>trace</code> 替换成 <code>trace_async</code>，如下所示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[trace_async(&quot;foo async&quot;)]
async fn foo_aysnc() -&gt; u32 {
   bar_async().await;
   42
}
 
#[trace_async(&quot;bar async&quot;)]
async fn bar_async() {
   yield_now().await;
}

<span class="boring">}
</span></code></pre></pre>
<p>另外还需要关键的一步：将 Task 用 minitrace-rust 提供的 Future 适配器 <code>in_span</code> 进行包装，从而将该 Future 与某个 Span 绑定起来。</p>
<p>Task，在 Rust 异步语境中，特指被 spawn 至某个 executor 的 Future，也称根 Future。例如以下的 <code>foo_async</code> 就是一个 Task：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>executor::spawn(
   foo_async()
);
<span class="boring">}
</span></code></pre></pre>
<p>假设要追踪 <code>foo_async</code> 这样一个 Task，并且与一个由 <code>Span::from_local_parent(event)</code> 创建的 Span 进行绑定，那么，相关的应用代码将如下所示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>executor::spawn(
   foo_async().in_span(Span::from_local_parent(&quot;Task: foo_async&quot;))
);
<span class="boring">}
</span></code></pre></pre>
<p>下图为该 Task 追踪的结果：</p>
<p><img src="chapter_2/./rust_trace/21.png" alt="21" /></p>
<h2><a class="header" href="#结语" id="结语">结语</a></h2>
<p>TiKV 作为底层 KV 数据库，对其增加观测性功能天然有着与普通业务程序完全不一样的性能要求，非常具有挑战性。除了追踪以外，TiKV 及其上层 SQL 数据库 TiDB 也还有其他富有挑战性的观测性需求。PingCAP 的 Observability 团队专注于这类观测难题的解决与功能实现，感兴趣的同学可投递简历到 <a href="mailto:hire@pingcap.com">hire@pingcap.com</a> 加入我们，或加入 Slack channel <a href="https://slack.tidb.io/invite?team=tidb-community&amp;channel=sig-diagnosis&amp;ref=tracing">#sig-diagnosis</a> 参与技术讨论。</p>
<h1><a class="header" href="#蚂蚁集团-ceresdb-团队--关于-rust-错误处理的思考" id="蚂蚁集团-ceresdb-团队--关于-rust-错误处理的思考">蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考</a></h1>
<p>作者：evenyag / 后期编辑：张汉东</p>
<hr />
<p>错误处理并非一件容易的事情，尽管在使用 Rust 时，有编译器不厌其烦地督促我们，基本不存在漏掉错误不处理的情况了，但这并不意味着错误处理这件事情变简单了。这里也记录一下我使用 Rust 一段时间后，对于错误处理的一些思考，包含大量主观看法，欢迎读者拍砖。</p>
<h2><a class="header" href="#不可恢复错误和可恢复错误" id="不可恢复错误和可恢复错误">不可恢复错误和可恢复错误</a></h2>
<p>使用 Rust 的人都知道， Rust 错误处理的手段主要分为两种，对于不可恢复的错误（unrecoverable error），可以通过 panic 来直接中断程序的执行，而对于可恢复的错误（recoverable error），一般会返回 Result 。至于什么时候使用 panic ，什么时候使用 Result ，官方提供了一些指导意见，很多文章对这块都有讨论，相信不少人在这上面是能达成共识的，因此本文在这块也不做过多展开。</p>
<p>错误处理中最麻烦的，还是处理可恢复的错误。</p>
<h2><a class="header" href="#error-类型" id="error-类型">Error 类型</a></h2>
<p>在进行错误处理，首先，你得把自己 Error 类型给定义了。我认为，对于一个新项目来说，定义好自己的 Error 类型甚至是属于最先要做的几件事情之一。即便一开始不做，等到你写到了第一个 Result 时，你也不得不考虑了。定义 Error 类型是一个可简单，可复杂的事情，毕竟在 <code>Result&lt;T, E&gt;</code> 里，<code>E</code> 其实可以塞任何东西。如果你胆子够大，甚至可以直接把 String 作为 Error 来使用，还能带上一定的错误信息。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_string_err() -&gt; Result&lt;(), String&gt; {
    Err(format!(&quot;Oh, string is not {}&quot;, 1))
}

fn string_err_example() -&gt; Result&lt;(), String&gt; {
    make_string_err()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>String 甚至可以转为来使用 <code>Box&lt;dyn Error&gt;</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn string_box_err() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    Err(format!(&quot;Oops, {}&quot;, 1))?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>不过这种错误处理方式过于简单粗暴，而错误一旦转为了 String ，就丧失了大部分可编程性，上层想要针对某些类型的错误做针对性的处理就会变得非常困难 —— 唯一的手段估计就只剩下字符串匹配了。</p>
<p>更多的时候，我们可能会想要把错误定义为一个 Enum 或者 Struct ，并实现 Error 等相关的 trait 。这是个体力活，如果你还需要处理 std 或者第三方库抛出来的 Error ，还需要手工实现一大堆 <code>From</code> 来为自己的 Error 实现相应的转换规则。这样下去，还没等 Error 类型定义完，写代码的热情就已经冷却了。</p>
<p>这些工作太枯燥了，就应该交给工具库去做！而当你去找 Rust 相关的错误处理库（严格来说，可能称为错误管理或者错误定义库更合适）时，就会发现， Rust 的错误处理库也太多了，而且以后可能会更多，这对于有选择困难症的来说简直是灾难。后面我也会从早期到近期挑选出一些比较有代表性的错误处理库，谈下我对他们的理解和在错误处理上的一些看法。当然，由于不是每个库我都使用过，所以也难免理解存在偏颇，欢迎大家指正</p>
<h2><a class="header" href="#quick-error" id="quick-error">quick-error</a></h2>
<p>在我刚接触 Rust 时，市面上的错误处理库还没有现在多，或者说我对 Rust 错误处理还不如现在了解，挑选库的过程反而比较简单。由于当时 tikv 已经挺有名气了，于是我直接打开 tikv 的项目，发现它在使用 quick-error ，就决定跟着它用了。当时我的需求也很简单，就是希望有个工具库帮我把定义错误的这些 boilerplate code 给包掉，而 quick-error 也正如其名，能够比较麻利地帮我把 Error 类型定义出来。而 Rust 最早的错误处理库基本上也就只帮你干这样的事情，因此其实更像是错误定义库（如今 quick-error 也不仅仅只能帮你定义错误了，不过也是后话了）。</p>
<p>例如下面就是个使用 quick-error 的例子，定义了一个 Error 类型，并且自动实现了 <code>From&lt;io::Error&gt;</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quick_error! {
    #[derive(Debug)]
    pub enum MyError {
        Io(err: io::Error) {
            from()
            display(&quot;I/O error: {}&quot;, err)
            source(err)
        }
        Other(descr: &amp;'static str) {
            display(&quot;Error {}&quot;, descr)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#丢失上下文" id="丢失上下文">丢失上下文</a></h2>
<p>然而，仅仅只是把 Error 定义出来只不过是刚刚踏入了错误处理的门，甚至可以说定义 Error 也只是错误处理那一系列 boilerplate code 的一小部分而已。单纯见到错误就往上抛并不难，而且 Rust 还提供了 <code>?</code> 运算符来让你可以更爽地抛出错误，但与之相对的，直接上抛错误，就意味着丢弃了大部分错误的上下文，也会给时候定位问题带来不便。</p>
<p>例如有类似下面的代码，使用了刚刚在上面定义的 Error 类型，而 eat()/drink()/work()/sleep() 中任意一个都有可能抛出 <code>io::Error</code> 的函数。那么当 daily() 出错时，你拿到的最终信息可能只是个 &quot;I/O error: failed to fill whole buffer&quot; ，而到底是哪里出的错，为什么出错了呢？不知道，因为错误来源丢失了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn daily() -&gt; Result&lt;(), MyError&gt; {
    eat()?;
    drink()?;
    work()?;
    sleep()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>丢失错误源头这种问题在 Rust 里还是很容易发生的，也是 Rust 错误处理里较恼人的一件事。当然，很大的原因还是在于错误提供没有 backtrace （现在也尚未 stable）。为了避免出现类似的问题，遇到错误时就需要注意保存一些调用信息以及错误的现场，概况下来，就是两样东西</p>
<ul>
<li>调用栈，或者说 backtrace</li>
<li>错误的上下文，如关键入参</li>
</ul>
<p>严格来说， backtrace 也属于上下文的一部分，这里分开提更多是考虑到两者在实现层面是有所区分的。有 backtrace 自然方便，但 backtrace 也并不能解决所有问题：</p>
<ul>
<li>光靠 backtrace 其实只能回答哪里出了错的问题，而回答不了为什么出错的</li>
<li>一些预期内时常会抛错误的代码路径也不宜获取 backtrace</li>
</ul>
<p>反过来，通过在日志里打印或者在 Error 类型中追加上下文信息，其实是能反过来推断出调用链路的，使得排查问题不强依赖 backtrace。我在 Rust 里进行的错误处理时做得最多的事情就是，考虑这个地方适不适合打印错误日志：</p>
<ul>
<li>如果适合，打下错误日志和相关信息，继续抛错误</li>
<li>不适合，考虑错误直接抛上去了后续是否方便定位问题
<ul>
<li>如果不方便，还会把 error 和上下文信息 format 下得到新的 error message ，然后产生个新的错误抛出去</li>
</ul>
</li>
</ul>
<p>这种方式虽说能解决问题，不过并不认为是一种最佳实践，更称不上优雅，光是打印日志和补充错误信息，就得写不少代码，更不提日志和错误信息里有不少内容可能还是相互重复的。</p>
<h2><a class="header" href="#error-chain-和-failure" id="error-chain-和-failure">error-chain 和 failure</a></h2>
<p>有没有办法更方便地将错误的上下文信息放到 Error 里面呢？早期的 error-chain 库在这方面做了不少尝试，其中 <code>chaining errors</code> 模式有点类似 golang 中的 <code>errors.Wrap()</code> ，允许用户通过 <code>chain_err()</code> 将错误或者可转换为错误的类型（如 String）不断地串联起来。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;()&gt; = do_something().chain_err(|| &quot;something went wrong&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>除此之外，这个库还提供了 <code>ensure!</code> ， <code>bail!</code> 等工具宏以及 backtrace 功能，这些我认为对后来错误处理库的发展都是由一定启发作用的。不过 error-chain 文档里那一大坨宏定义，各种概念以及说明，对于刚接触 Rust 的人还是比较劝退的。</p>
<p>到了 failure 库， <code>chain_err()</code> 的模式改为了通过 <code>context()</code> 来携带错误的上下文信息。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use failure::{Error, ResultExt};

fn root() -&gt; Result&lt;(), Error&gt; {
    a().context(&quot;a failed&quot;)?;
    b().context(&quot;b failed&quot;)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>如今错误处理库也基本沿用了 <code>context()</code> 这一 api 命名，甚至 <code>context()</code> 已经成为了 Rust 风格错误处理的一部分。</p>
<p>尽管我也考虑过使用这两个库替换掉自己项目里在用的 quick-error ，不过，一旦项目变庞大后，这种替换错误处理库以及错误处理风格的工作就多少有点工作量抵不上收益了。另一方面， error-chain 和 failure 作为出现得比较早的错误处理库，更多起到探索和过渡的作用，他们当初需要解决的问题在 std 的 Error trait 的演进下，很多也都不复存在了（起码在 nightly 上是这样），因此他们的演进也基本走到尽头了。包括 failure 的开发后来也逐渐停滞，现在已经是处于 deprecated 的状态了，项目维护者也都推荐用一些更新的错误处理库。</p>
<h2><a class="header" href="#thiserror--anyhow" id="thiserror--anyhow">thiserror + anyhow</a></h2>
<p>对于一些新的错误处理库，目前社区里较为主流的建议可能是组合使用 thiserror 和 anyhow 这两个库。其中 thiserror 可以看作是定义 Error 的一个工具，它只帮你生成一些定义 Error 的代码，别的什么都不做，相当纯粹。</p>
<p>而 anyhow 则为你定义好了一个 Error 类型，基本可以看作是一个 <code>Box&lt;dyn Error&gt;</code> ，同时还提供了一些如 <code>context</code> 等扩展功能，用起来更加无脑。</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    ...
    it.detach().context(&quot;Failed to detach the important thing&quot;)?;

    let content = std::fs::read(path)
        .with_context(|| format!(&quot;Failed to read instrs from {}&quot;, path))?;
    ...
}
</code></pre></pre>
<p>除此之外， anyhow 的 Error 只占用一个指针大小的栈空间，相应的 Result 的栈空间占用也会变小，在一些<a href="https://zhuanlan.zhihu.com/p/191655266">场景</a>下也比较有用。</p>
<p>这两个库的作者 dtolnay 建议，如果你是在开发库，则用 thiserror ，而如果是开发应用则使用 anyhow 。这在实践时遇到的一个问题就是所谓库和应用的边界有时候并没有那么清晰：对一个多模块的应用来说，本质上也可以看作是由若干个库构成的，而这些模块或者&quot;库&quot;之间，也可能是有层级关系的。对于这些模块，使用 anyhow 就存在以下问题</p>
<ul>
<li>需要使用 anyhow 专门提供的 Error 类型，可能直接将 <code>anyhow::Error</code> 暴露到库的 api 上</li>
<li>调用方拿到的不是明确的错误类型</li>
<li>无法对 <code>anyhow::Error</code> 做 pattern match</li>
<li>更近一步，应用也不保证不会有处理具体错误的需求</li>
</ul>
<p>本质上， <code>anyhow::Error</code> 库提供的 Error 类型，更类似一种 Report 类型，适合汇报错误，而不适合处理具体的错误。如果使用 thiserror ，就失去了便利的 <code>context</code> 功能，用起来相对没那么方便，而作者看上去也不打算支持这一点。总的看下来， thiserror + anyhow 的组合方案还是存在一定局限性，似乎用起来并没有那么顺手。</p>
<h2><a class="header" href="#snafu" id="snafu">snafu</a></h2>
<p>而 snafu 的方案，则让我看到 context 也是可以和具体的 Error 类型比较优雅地结合起来。不妨看下 snafu 官方的例子</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use snafu::{ResultExt, Snafu};
use std::{fs, io, path::PathBuf};

#[derive(Debug, Snafu)]
enum Error {
    #[snafu(display(&quot;Unable to read configuration from {}: {}&quot;, path.display(), source))]
    ReadConfiguration { source: io::Error, path: PathBuf },

    #[snafu(display(&quot;Unable to write result to {}: {}&quot;, path.display(), source))]
    WriteResult { source: io::Error, path: PathBuf },
}

type Result&lt;T, E = Error&gt; = std::result::Result&lt;T, E&gt;;

fn process_data() -&gt; Result&lt;()&gt; {
    let path = &quot;config.toml&quot;;
    let configuration = fs::read_to_string(path).context(ReadConfiguration { path })?;
    let path = unpack_config(&amp;configuration);
    fs::write(&amp;path, b&quot;My complex calculation&quot;).context(WriteResult { path })?;
    Ok(())
}

fn unpack_config(data: &amp;str) -&gt; &amp;str {
    &quot;/some/path/that/does/not/exist&quot;
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的例子就体现出 snafu 的一些特点：</p>
<ul>
<li>基于 context selector 的 context 方案
<ul>
<li>同样是 <code>io::Error</code> ， snafu 可以通过不同的 context 返回不同的 enum variant ，同时还能带上一些错误相关信息</li>
<li>比起为 Error 直接实现 <code>From&lt;io::Error&gt;</code> 要更有意义，毕竟我们更希望拿到的错误告诉我是 read configuration 出错了，还是 write result 出错了，以及出错的文件 path 是哪个</li>
<li>本质上是把 context 的类型也提前定义了</li>
</ul>
</li>
<li>产生的 Error 就是我们自己定义的 Error，无需依赖 snafu 提供的 Error 类型</li>
<li>这里其实还有一个隐含的好处，就是这个 Error 是可以做 pattern match 的</li>
</ul>
<p>关于 snafu 和错误处理， influxdb_iox 其实总结了一份他们错误处理的 style guide ，我觉得很有参考价值，里面也提到了 snafu 的一些<a href="https://docs.rs/snafu/0.6.10/snafu/guide/philosophy/index.html">设计哲学</a></p>
<ul>
<li>同样的底层错误可以根据上下文不同而转换为不同的领域特定错误，例如同样是 io 错误，根据上层业务语义的不同能够转换为不同的业务错误</li>
<li>在库和应用的场景下都同样好用</li>
<li>模块级别的 Error 类型，每个模块都应该定义一个，甚至多个自己专用的错误类型</li>
</ul>
<p>而这些设计哲学，我认为也是错误处理里比较好的实践。其中，关于 Error 类型应该做到模块级别还是做到 crate 级别（全局），可能会有较多争议，也值得发散开来聊聊。</p>
<h2><a class="header" href="#模块级-error-类型与全局-error-类型" id="模块级-error-类型与全局-error-类型">模块级 Error 类型与全局 Error 类型</a></h2>
<p>先摆观点，我认为 Error 类型尽量做到模块级别是更好的，甚至部分函数有专门的 Error 类型也不过分，但是也要摆一个事实，那就是我自己的代码里这一点做得也还不够好。</p>
<p>所以，这里还是要提一下全局 Error 类型的一些好处，起码包括</p>
<ul>
<li>方便做一套全局的错误码，而且类型参数不合法就是比较常见的错误</li>
<li>不需要花太多精力定义 Error 类型，很多 enum variant 可以共用，<code>Result&lt;T, Error&gt;</code> 也只需要定义一份，，这也是全局 Error 类型最大的优势</li>
</ul>
<p>但是，全局 Error 类型也存在相应的缺陷</p>
<ul>
<li>所有用到了 Error 类型的模块，其实通过 Error 类型间接和其他模块耦合了，除非你的 Error 类型只想用 <code>anyhow::Error</code> 这样的类型</li>
<li>即使来源 Error 相同，上下文也不同，定义到一个 enum variant 里面不见得合适</li>
<li>更容易出现 Error 抛着抛着不知道哪来的情况</li>
</ul>
<p>而模块级的 Error 类型则看上去也更符合一个模块化的 crate 应有的设计</p>
<ul>
<li>不存在共用 Error 类型导致的间接耦合</li>
<li>更加内聚，每个模块可以专心处理自己的错误， match 错误的范围也大大减少</li>
<li>即使不依赖 backtrace ，错误本身也能明确反映出了层次关系和链路</li>
</ul>
<p>当然，模块级的 Error 类型也并非没有缺点，例如</p>
<ul>
<li>定义 Error 的工作会变多，做全局的错误码会麻烦些，可能需要在上层做一次转换</li>
<li>模块层次过深的话，或者一些模块的 Error 字段较多，由于 Rust enum 的特点，越上层的 Error 类型就会越大（std::mem::size_of::<Error>()），像 snafu 同样也会有这样的问题</li>
</ul>
<h2><a class="header" href="#总结-1" id="总结-1">总结</a></h2>
<p>错误处理可能不存在最佳方案一说，更多还是要结合实际场景。即便是谈到错误处理库，我要是大喊一声 snafu 是 Rust 最好的错误处理库，相信社区里肯定也会有一堆人跳出来反对我。而实际上 snafu 也存在自身的缺点，例如 Error 定义的工作量相对大（需要定义各种 context）， Error 类型体积可能会比较大等。</p>
<p>总的来说，错误处理一直是一件麻烦的事。我觉得能做到错误的现场可追溯，就已经算错误处理做得不错了的。经过几年的发展， Rust 的错误处理库初步发展出了 context 和 backtrace 两种记录错误上下文的手段，同时也更加强大和易用了，但我认为目前他们尚未发展到终态，也尚未出现一个库独大的局面。如果说现在我新起个项目或者模块，需要选择一个错误处理库的话，我可能会先尝试下 snafu 。</p>
<h2><a class="header" href="#关于我们" id="关于我们">关于我们</a></h2>
<p>我们是蚂蚁智能监控技术中台的时序存储团队，我们正在使用 Rust 构建高性能、低成本并具备实时分析能力的新一代时序数据库，欢迎加入或者推荐，联系人 jiachun.fjc@antgroup.com</p>
<h2><a class="header" href="#参考" id="参考">参考</a></h2>
<ul>
<li>https://blog.yoshuawuyts.com/error-handling-survey/</li>
<li>https://www.ncameron.org/blog/migrating-a-crate-from-futures-0-1-to-0-3/</li>
<li>https://zhuanlan.zhihu.com/p/225808164</li>
<li>https://nick.groenen.me/posts/rust-error-handling/</li>
<li>https://doc.rust-lang.org/book/ch09-00-error-handling.html</li>
<li>https://github.com/tikv/rfcs/pull/38#discussion_r370581410</li>
<li>https://github.com/shepmaster/snafu/issues/209</li>
<li>https://github.com/rust-lang/project-error-handling/issues/24</li>
<li>https://github.com/rust-lang/rust/issues/53487</li>
<li>https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md</li>
<li>https://zhuanlan.zhihu.com/p/191655266</li>
<li>https://docs.rs/snafu/0.6.10/snafu/guide/philosophy/index.html</li>
<li>https://doc.rust-lang.org/src/std/error.rs.html#48-153</li>
<li>https://github.com/facebook/rocksdb/blob/00519187a6e495f0be0bbc666cacd9da467a6c1e/include/rocksdb/status.h#L34</li>
<li>https://github.com/tailhook/quick-error/issues/22</li>
<li>https://github.com/dtolnay/anyhow</li>
<li>https://github.com/dtolnay/thiserror</li>
<li>https://github.com/tailhook/quick-error</li>
<li>https://github.com/rust-lang-nursery/failure</li>
<li>https://github.com/rust-lang-nursery/error-chain</li>
</ul>
<h1><a class="header" href="#rust中的错误传递和日志记录" id="rust中的错误传递和日志记录">Rust中的错误传递和日志记录</a></h1>
<p>作者：楼智豪 / 后期编辑：张汉东</p>
<hr />
<h2><a class="header" href="#简介以及背景" id="简介以及背景">简介以及背景</a></h2>
<p>在Rust代码的编写过程中，开发者也需要关注错误处理和日志记录的过程，程序能够及时反馈信息，保证程序的正常运行。
本文分两部分，第一部分讲述如何进行错误传递和处理，第二部分讲述应该如何记录日志。</p>
<h2><a class="header" href="#错误处理" id="错误处理">错误处理</a></h2>
<p>以前在使用C进行错误处理时，通常采用的是函数传递错误码的方式，而对于Rust而言这种方式显得有些古老。</p>
<p>首先，Rust当中的错误处理基于两个特性，Result和Error。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Result&lt;T, E&gt; {
    /// Contains the success value
    Ok(T),
    /// Contains the error value
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Result是Rust提供的一个枚举类，它里面应当包含，程序成功运行时返回的值T，或者是程序运行失败时返回的错误类型E。如果一个函数，它的返回值是一个Result，那么就表明，它有可能失败并返回一个错误类型，需要我们来处理这个Result。</p>
<p>Rust在标准库中提供了一个trait，<code>sdt::error::Error</code>，目前错误处理都是基于这个trait来进行，一个结构体/枚举如果实现了这个trait，那么我们认为，它就是一个错误类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//为自定义的结构体实现Error的trait，该trait要求同时实现Display和Debug
//Error tarit包含多个方法，但通常情况下impl的时候除了source方法其他无需重写
pub trait Error: Debug + Display {
    //如果该错误类型中包含了底层的错误Err，那么source方法应该返回Some(err),如果没有返回None。不重写则默认为None
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;;
    //type_id()：该方法被隐藏
    fn type_id(&amp;self, _: private::Internal) -&gt; TypeId;
    //backtrace()：返回发生此错误的堆栈追溯，目前为unstable，默认禁用，且占用大量内存，性能很差
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt;;
    //description()：已废弃，改使用Display
    fn description(&amp;self) -&gt; &amp;str;
    //cause()：已废弃，改使用source()
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>错误传递的背景在于，在开发过程中，可能各个模块自身都定义了一个错误类型，那么当这些模块需要一起使用时，不同错误类型的结构体应该如何转换和处理，如何传递。</p>
<h3><a class="header" href="#方式一自定义错误类型" id="方式一自定义错误类型">方式一：自定义错误类型</a></h3>
<ul>
<li>自定义错误类型，并且通过From trait进行转换</li>
<li>用 <code>?</code>来传递错误，自动执行类型转换</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Error for MyError {

}

/// MyError属于当前自定义的枚举，其中包含了多种错误类型
/// MyError也包含了从下层传递而来的错误类型，统一归纳
#[derive(Debug)]
pub enum MyError {
    BadSchema(String, String, String),
    IO(io::Error),
    Read,
    Receive,
    Send,
}

//实现Display
impl fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            MyError::BadSchema(s1, s2, s3) =&gt; {
                write!(f, &quot;BadSchema Error:{}, {}, {}&quot;, s1, s2, s3)
            }
            MyError::IO(e) =&gt; {
                write!(f, &quot;IO Error: {}&quot;, e)
            }
            MyError::Read =&gt; {
                write!(f, &quot;Read Error&quot;)
            }
            MyError::Receive =&gt; {
                write!(f, &quot;Receive Error&quot;)
            }
            MyError::Send =&gt; {
                write!(f, &quot;Send Error&quot;)
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在定义MyError时，其中包括了多种错误类型，有当前模块产生的错误（比如Read, Receive, Send），也有从下层模块传递上来的错误，比如IO(io::Error)，针对从下层传递而来的这种错误，我们需要将它归纳到自己的MyError中，统一传递给上层。为了实现这个目的，我们就需要实现From 方法，当我们为一个错误类型的转换实现了From方法，就可以使用<code>?</code>来进行自动转换。如下所示</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;io::Error&gt; for MyError {
    fn from(err: io::Error) -&gt; MyError {
        MyError::IO(err)
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//这两个示例是相同的
fn test_error() -&gt; Result&lt;i32, MyError&gt; {
    let s = std::fs::read_to_string(&quot;test123.txt&quot;)?;
    Ok(s)
}

fn test_error2() -&gt; Result&lt;String, MyError&gt; {
    let s = match std::fs::read_to_string(&quot;test123.txt&quot;) {
        Ok(s)=&gt;{
            s
        }
        Err(e)=&gt;{
            return Err(MyError::from(e));
        }
    };
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>注意在示例一当中<code>?</code>的作用，它等效于示例二中的match，意思是</p>
<ul>
<li>
<p>该函数的返回值是一个<code>Result&lt;T,Error&gt;</code>，需要进行处理。</p>
</li>
<li>
<p>如果该函数运行正确，那么返回T，上述的示例中返回String</p>
</li>
<li>
<p>如果该函数运行失败，返回了一个错误类型Error，这里返回了io::Error， 并且因为我们实现了From方法，io::Error被自动转换成了MyError::IO(io::Error)，然后程序在此处直接return，不再继续往下走。</p>
<p>注意From的类型转换是通过<code>?</code>来隐式调用的，如果不使用<code>?</code>而是直接return一个错误，它是不会自动进行类型转换的。</p>
</li>
</ul>
<h3><a class="header" href="#方式二--使用trait-object传递错误" id="方式二--使用trait-object传递错误">方式二 ： 使用trait Object传递错误</a></h3>
<ul>
<li>
<p>不定义自己的类型，而直接使用 <code>Box&lt;dyn Error&gt;</code> 来统一错误类型。</p>
</li>
<li>
<p>用 <code>?</code>来传递错误，自动把Error转换成 <code>Box&lt;dyn Error&gt;</code> </p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_error() -&gt; Result&lt;i32, Box&lt;dyn Error&gt;&gt; {
    let s = std::fs::read_to_string(&quot;test123.txt&quot;)?;
    let n = s.trim().parse::&lt;i32&gt;()?;
    Ok(n)
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面这个示例中，可以看到，我们返回了一个Box<dyn Error>，他是一个trait Object，意思是泛指一个具有Error trait的结构体/枚举类型。我们之所以可以这么写，其实是因为Rust本身为Box<dyn Error>实现了From方法，所以可以实现自动转换。</p>
<p>上述代码中，第一行和第二行分别返回了io:Error和ParseIntError，都可以被转换成Box<dyn Error>。这种方式的好处在于开发者不用再一个个地去定义错误类型，编写From方法，坏处在于丢失了具体的错误类型的信息，如果要对于不同的错误类型进行不同处理，就会遇到麻烦。</p>
<p>虽然Rust提供的downcast方法可以将Box<dyn Error>重新还原成具体的结构体，但是<code>e.downcast::&lt;MyError&gt;();</code>这种形式的调用也还是需要预先知道结构体类型，所以使用起来还是有困难。</p>
<h3><a class="header" href="#对比" id="对比">对比</a></h3>
<table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody>
<tr><td>自定义错误类型</td><td>可以统一错误类型，方便上层用户对不同的错误类型采取不同的措施</td><td>需要进行各式的类型转换，较为繁琐</td></tr>
<tr><td>Box&lt;dyn Error&gt;</td><td>Error可以直接透传，不需要在乎具体的类型</td><td>丢失了结构体类型信息，但是也可以通过downcast把trait object转换回具体的结构体</td></tr>
</tbody></table>
<p>结论：综合以上两种方式的优缺点以及各方给出的意见，得出结论如下</p>
<ul>
<li>如果是编写一个库，那么最好采取方式一，因为我们需要给上层用户传递具体的错误类型，来方便他们进行处理。</li>
<li>如果是编写一个完整的应用程序，所有错误都在自身内部进行处理了，不需要传递给其他人，那么可以考虑采取方式二</li>
</ul>
<h3><a class="header" href="#其他第三方库" id="其他第三方库">其他：第三方库</a></h3>
<h3><a class="header" href="#anyhow-专门为错误处理设计的第三方库" id="anyhow-专门为错误处理设计的第三方库">anyhow ：专门为错误处理设计的第三方库</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;

fn get_cluster_info() -&gt; Result&lt;ClusterMap&gt; {
    //从std::io::Error转换成了anyhow::Error
    let config = std::fs::read_to_string(&quot;cluster.json&quot;)?;
    let map: ClusterMap = serde_json::from_str(&amp;config)?;
    Ok(map)
}

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match root_cause.downcast_ref::&lt;DataStoreError&gt;() {
    //从anyhow::Error转换成自定义的DataStoreError
    Some(DataStoreError::Censored) =&gt; Ok(),
    None =&gt; Err(error),
}
<span class="boring">}
</span></code></pre></pre>
<p>anyhow这个库可以把用户自定义的，所有实现了<code>std::Error trait</code>的结构体，统一转换成它定义的<code>anyhow::Error</code>。这样用户在传递错误的过程中就使用的是统一的一个结构体，不用自定义各种各样的错误。</p>
<p>论用法，其实anyhow和第二种trait Object方法是类似的，但是有几点不同</p>
<ul>
<li><code>anyhow::Error</code> 的错误是<code>Send</code>, <code>Sync</code> 和 <code>'static</code>的</li>
<li><code>anyhow::Error</code> 保证<code>backtrace</code>方法可用，即便你的底层Error没有提供<code>backtrace</code></li>
<li><code>anyhow::Error</code>是一个机器字长，而<code>Box&lt;dyn Error&gt;</code>是两个机器字长</li>
</ul>
<h3><a class="header" href="#thiserror-提供便捷的派生宏的第三方库" id="thiserror-提供便捷的派生宏的第三方库">thiserror ：提供便捷的派生宏的第三方库</a></h3>
<p>前面有提到，一个自定义的MyError结构体，需要实现很多内容，Error trait，Display，Debug以及各种From函数，手动编写可能较为麻烦，而thiserror这个库则提供了过程宏来简化这个过程</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum DataStoreError {
    #[error(&quot;data store disconnected&quot;)]
    Disconnect(#[from] io::Error),
    #[error(&quot;the data for key `{0}` is not available&quot;)]
    Redaction(String),
    #[error(&quot;invalid header (expected {expected:?}, found {found:?})&quot;)]
    InvalidHeader {
        expected: String,
        found: String,
    },
    #[error(&quot;unknown data store error&quot;)]
    Unknown,
    #[error(&quot;Utf data store error&quot;)]
    Utf{
        #[from]
        source: Utf8Error,
        backtrace: Backtrace
    },
    #[error(transparent)]
    Other(#[from] anyhow::Error)
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>在我们自定义的结构体前加上<code>#[derive(Error)]</code>，就可以自动impl Error</p>
</li>
<li>
<p><code>#[error(&quot;invalid header (expected {expected:?}, found {found:?})&quot;)]</code>这条语句代表如何实现Display，后面的字符串就代表Display会输出的字符，同时支持格式化参数，比如这条语句里的expected就是代表结构体里面的元素。如果是元组则可以通过<code>.0</code>或者<code>.1</code>的方式来表示元素</p>
</li>
<li>
<p><code>#[from]</code>表示会自动实现From方法，将对应的子错误进行转换</p>
<ul>
<li><code>#[from]</code>有两种写法，第一种就是<code>Disconnect(#[from] io::Error)</code>这样，自动将<code>io::Error</code>转换成<code>DataStoreError::Disconnect</code>，简单的结构体嵌套</li>
<li>第二种写法是<code>Utf { #[from] source: Utf8Error, backtrace: Backtrace }</code>这种，这种格式有且只能有两个字段，<code>source</code>和<code>backtrace</code>，不能有其他字段。它会自动将<code>Utf8Error</code>转换成<code>DtaStoreError::Utf</code>，并且自动捕获原错误中的<code>backtrace</code>方法</li>
</ul>
</li>
<li>
<p><code>#[source]</code>表示将这个结构体字段的值作为<code>source</code>方法的返回值，如果字段本身的名称就是<code>source</code>的话就不用加<code>#[source]</code>而会自动应用。而<code>backtrace</code>方法则会自动寻找结构体里类型为<code>std::backtrace::Backtrace</code>的字段来作为返回值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug)]
pub struct MyError {
    msg: String,
    #[source]  // optional if field name is `source`
    source: anyhow::Error,
    backtrace: Backtrace,  // automatically detected
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><code>#[error(transparent)]</code>表示将源错误的<code>source</code>方法和<code>Display</code>方法不加修改直接应用到<code>DataStoreError::Other</code></p>
</li>
</ul>
<h2><a class="header" href="#日志记录" id="日志记录">日志记录</a></h2>
<h3><a class="header" href="#a-hrefhttpscratesiocratesloglog库a" id="a-hrefhttpscratesiocratesloglog库a"><a href="https://crates.io/crates/log">log库</a></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error!(target: &quot;yak_events&quot;, &quot;Commencing yak shaving for {:?}&quot;, yak);
// target默认为当前crate的名称
warn!( &quot;hello world&quot;);
info!( &quot;hello world&quot;);
debug!( &quot;hello world&quot;);
trace!( &quot;hello world&quot;);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>记录当前crate的名字、文件名路径、行号、文本信息</li>
</ul>
<p><strong>日志门面库</strong></p>
<p>通过定义统一的接口，使用统一的日志记录方式，可以在多个日志框架中灵活切换，可以让开发者不必关心底层的日志系统。如果你是Rust库的开发者，自然不期望自己的框架绑定某个具体日志库，而是只使用log门面日志库，由使用者自行决定日志库。</p>
<pre class="mermaid">graph TD
	应用程序--&gt;log
	log--&gt;具体的日志系统
	具体的日志系统--&gt;env_logger
	具体的日志系统--&gt;pretty_env_logger
	具体的日志系统--&gt;log4rs
	具体的日志系统--&gt;slog-stdlog
	具体的日志系统--&gt;...
</pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SimpleLogger {};

impl log::Log for SimpleLogger {};

log::set_logger(SimpleLogger);
<span class="boring">}
</span></code></pre></pre>
<p>使用方式：调用set_logger方法绑定底层的日志系统，然后用户只需调用error!、log!这几个宏，其余的如何写入日志的问题则交给系统自己去做。</p>
<h3><a class="header" href="#开源库如何记录日志" id="开源库如何记录日志">开源库如何记录日志</a></h3>
<p>下面列出了一些开源库使用了什么日志工具，以及它们是如何记录日志的。</p>
<p>可以得到结论，绝大部分开源库都在使用log这个日志门面库，而且日志记录的方式，通常是直接写入字符串信息，以及调用Error的Display方法进行写入。</p>
<ul>
<li>
<p><a href="https://github.com/ivanceras/diwata">ivanceras / diwata</a> —用于PostgreSQL的数据库管理工具 ： 使用log库</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>debug!(&quot;ERROR: {} ({})&quot;, msg, status);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a href="https://community.chef.io/products/chef-habitat/">habitat</a>—由<a href="https://www.chef.io/">Chef</a>创建的用于构建，部署和管理应用程序的工具：使用log库</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  match server::run(args) {
      Err(err) =&gt; {
          error!(&quot;Launcher exiting with 1 due to err: {}&quot;, err);
          process::exit(1);
      }
      Ok(code) =&gt; {
          let level = if code == 0 { Level::Info } else { Level::Error };
          log!(level, &quot;Launcher exiting with code {}&quot;, code);
          process::exit(code);
      }
  } 
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a href="https://github.com/changlan/kytan">kytan</a> —高性能对等VPN ：使用log库</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>warn!(&quot;Invalid message {:?} from {}&quot;, msg, addr);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a href="https://github.com/servo/servo">Servo</a> —原型Web浏览器引擎 :  使用log库和gstreamer库</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>gst_element_error!(src, CoreError::Failed, [&quot;Failed to get memory&quot;]);
// 引用C动态库，采取错误码方式传递u32
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a href="https://github.com/wez/wezterm">wezterm</a> — GPU加速的跨平台终端仿真器和多路复用器 ：使用log库</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>log::error!(&quot;not an ioerror in stream_decode: {:?}&quot;, err);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a href="https://github.com/nicohman/eidolon">nicohman / eidolon</a> —适用于linux和macosx的无Steam和drm的游戏注册表和启动器：使用log库</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error!(&quot;Could not remove game. Error: {}&quot;, res.err().unwrap());
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a href="https://github.com/tokio-rs/mio">Mio</a> - Mio是一个用于Rust的，快速的底层I/O库：使用log库</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Err(err) = syscall!(close(self.kq)) {
            error!(&quot;error closing kqueue: {}&quot;, err);
        }
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a href="https://github.com/alacritty/alacritty">Alacritty</a> —跨平台，GPU增强的终端仿真器：使用log库 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Err(err) = run(window_event_loop, config, options) {
        error!(&quot;Alacritty encountered an unrecoverable error:\n\n\t{}\n&quot;, err);
        std::process::exit(1);
    }
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>最后，关于Error的Display方法具体应当输出什么内容，这里可以参考<code>std::io::Error</code>的内容（这里的<code>io::Error</code>并不是一个trait，而是一个实现了<code>std::error::Error</code>的trait的具体类型，是一个结构体）</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ErrorKind {
  pub(crate) fn as_str(&amp;self) -&gt; &amp;'static str {
      match *self {
          ErrorKind::NotFound =&gt; &quot;entity not found&quot;,
          ErrorKind::PermissionDenied =&gt; &quot;permission denied&quot;,
          ErrorKind::ConnectionRefused =&gt; &quot;connection refused&quot;,
          ErrorKind::ConnectionReset =&gt; &quot;connection reset&quot;,
          ErrorKind::ConnectionAborted =&gt; &quot;connection aborted&quot;,
          ErrorKind::NotConnected =&gt; &quot;not connected&quot;,
          ErrorKind::AddrInUse =&gt; &quot;address in use&quot;,
          ErrorKind::AddrNotAvailable =&gt; &quot;address not available&quot;,
          ErrorKind::BrokenPipe =&gt; &quot;broken pipe&quot;,
          ErrorKind::AlreadyExists =&gt; &quot;entity already exists&quot;,
          ErrorKind::WouldBlock =&gt; &quot;operation would block&quot;,
          ErrorKind::InvalidInput =&gt; &quot;invalid input parameter&quot;,
          ErrorKind::InvalidData =&gt; &quot;invalid data&quot;,
          ErrorKind::TimedOut =&gt; &quot;timed out&quot;,
          ErrorKind::WriteZero =&gt; &quot;write zero&quot;,
          ErrorKind::Interrupted =&gt; &quot;operation interrupted&quot;,
          ErrorKind::Other =&gt; &quot;other os error&quot;,
          ErrorKind::UnexpectedEof =&gt; &quot;unexpected end of file&quot;,
      }
  }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3><a class="header" href="#slog库结构化日志" id="slog库结构化日志">slog库：结构化日志</a></h3>
<p>这里还要提到一个库，slog，意为structured log，结构化日志。前面提到的日志都是非结构化日志，直接记录一段话，没有具体的格式。如果程序的日志数量比较小，那么非结构化日志是可以满足要求的，如果日志的数量很大，那么非结构化的日志就会带来诸多问题，就比如，格式多种多样，难以进行查询和解析。</p>
<p>何为结构化日志，就是具有明确具体结构的日志记录形式，最主要的是具有key-value的键值对的形式，典型的是使用json来记录日志，一个json条目就是一条日记，每个字段就是一个键值对。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>debug!(log, &quot;Here is message&quot;; key1 =&gt; value1, key2 =&gt; value2);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-json">//传统的非结构化日志
DEBUG 2018-02-05 02:00:45.541 [file:src/main.rs][line:43] CPU OVerload in location 100,ThreadId is 123456,MemoryUsage is 0,ThreadId is 234567,MemoryUsage is 0

//结构化日志
{
    &quot;Timestamp&quot;: &quot;2018-02-05 02:00:45.541&quot;,
    &quot;Severity&quot;: &quot;Debug&quot;,
    &quot;File&quot;: &quot;src/main.rs&quot;,
    &quot;Line&quot;: &quot;43&quot;,
    &quot;Message&quot;: &quot;Memory overflow&quot;,
    &quot;Info&quot;: {
        &quot;ThreadId&quot;: &quot;123456&quot;,
        &quot;MemoryUsage&quot;: &quot;0&quot;,
        &quot;ThreadId&quot;: &quot;234567&quot;,
        &quot;MemoryUsage&quot;: &quot;0&quot;,
    }
}
</code></pre>
<p>日志是维测能力的一个重要方面，也是调试的重要工具。 传统上非结构化的字符串，很难进行后续的二次分析，日志的相关处理也很麻烦。目前结构化日志日趋流行，使用结构化日志，使日志文件具有机器可读性和更高级的功能，以易于解析的结构化格式编写日志文件。这意味着日志分析工具可以轻松地获取结构化日志数据，这也使处理和查询日志更容易，并且分析日志更快，针对特定的条目进行过滤和跟踪分析。</p>
<p>非结构化的日志查询，往往就是搜索关键字，速度慢，准确性差，容易查询出其他不相关的内容，效率低下。而目前的许多json分析工具，支持使用sql语言对条目进行查询；<a href="https://cloud.google.com/logging/docs/view/logs-viewer-interface">Google Cloud</a>的提供的结构化日志的服务还内置了日志解析工具，提供图形化界面解析日志，定义了日志查询语言来进行查询。</p>
<p>最后，结构化日志可以帮助降低日志的存储成本，因为大多数存储系统上，结构化的键值数据比非结构化的字符串有更高的压缩率。</p>
<hr />
<p>作者介绍：</p>
<p>楼智豪 </p>
<p>任职于华为技术有限公司嵌入式软件能力中心，本文章仅代表作者个人观点，不代表公司意见。</p>
<h1><a class="header" href="#新年新人新气象--rust-学习笔记" id="新年新人新气象--rust-学习笔记">新年新人新气象 | Rust 学习笔记</a></h1>
<p>作者：李大狗（李骜华）/ 后期编辑： 张汉东</p>
<hr />
<blockquote>
<p><strong>本系列所有源码：</strong></p>
<p>https://github.com/leeduckgo/Rust-Study</p>
</blockquote>
<h2><a class="header" href="#新年新目标" id="新年新目标">新年新目标</a></h2>
<p>打算在 2021 年学习一门新的编程语言，Rust 是一个很好的标的，一方面它及其具备实用性；另一个方面它也能让我们在更高的层面上理解计算机。</p>
<p>本系列将是我从Rust小学生开始的Rust学习过程全记录。</p>
<p>话不多说，我们开整。</p>
<p>由于是一门新的语言（相对 Java），所以传统的到网上去找一本好的入门教材的方法失效了。</p>
<p>那我们就来康康 Rust 能做什么有趣的事情，有什么有趣的Repo。</p>
<p>Substrate（Polkadot公链）、Libra（Facebook链）、WeDPR（FISCO BCOS 隐私保护组件）都是用 Rust 写的，不过评估一下，这些 Repo 的难度太高了，不适合用来作为语言入门。</p>
<p>后来发现 Rust 在 WebAssembly 方面目前进展很不错：</p>
<blockquote>
<p>WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。</p>
<h2><a class="header" href="#简而言之" id="简而言之">简而言之</a></h2>
<p>对于网络平台而言，WebAssembly具有巨大的意义——它提供了一条途径，以使得以各种语言编写的代码都可以以接近原生的速度在Web中运行。在这种情况下，以前无法以此方式运行的客户端软件都将可以运行在Web中。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzml3h1uij30w00mi41a.jpg" alt="image-20210212094819556" /></p>
<p>所以，Rust 的学习路线就这么定下来了，从wasm开始！</p>
<h2><a class="header" href="#检索实例" id="检索实例">检索实例</a></h2>
<p>既然确定了目标，那么可以开始检索相应的实例。这个实例有两个条件：</p>
<ul>
<li>光有文章是不行的，必须配套相应的的源码</li>
<li>这个源码必须足够简洁，适合用来入门</li>
</ul>
<p>经过一番检索，最后找到了这个：</p>
<blockquote>
<p>项目代码：</p>
<p>https://github.com/RodionChachura/rust-js-snake-game/</p>
<p>运行地址：</p>
<p>https://rodionchachura.github.io/rust-js-snake-game/</p>
<p>教程地址：</p>
<p>https://geekrodion.com/blog/rustsnake</p>
</blockquote>
<p>git clone 下来，运行了试试，的确可以。</p>
<p>但感觉不是我想要的，因为前端代码的内容太多了。</p>
<p>然后打开官方教程：</p>
<blockquote>
<p>https://developer.mozilla.org/zh-CN/docs/WebAssembly/Rust_to_wasm</p>
</blockquote>
<p>看到：</p>
<blockquote>
<p>Rust 和 WebAssembly 有两大主要用例：</p>
<ul>
<li>构建完整应用 —— 整个 Web 应用都基于 Rust 开发！</li>
<li>构建应用的组成部分 —— 在现存的 JavaScript 前端中使用 Rust。</li>
</ul>
<p>目前，Rust 团队正专注于第二种用例，因此我们也将着重介绍它。对于第一种用例，可以参阅 <code>yew</code> 这类项目。</p>
</blockquote>
<p>Yep，感觉我需要的是<code>yew</code>！</p>
<h2><a class="header" href="#yew-的探索之旅" id="yew-的探索之旅">Yew 的探索之旅</a></h2>
<p>首先找到 <code>yew</code>的官网：</p>
<blockquote>
<p><strong>Yew</strong> is a modern Rust framework for creating multi-threaded front-end web apps with WebAssembly.</p>
<p>https://github.com/yewstack/yew</p>
</blockquote>
<p>找到它官方的例子：</p>
<blockquote>
<p>https://yew.rs/docs/zh-CN/getting-started/build-a-sample-app</p>
</blockquote>
<p>结果，运行报错……</p>
<pre><code>cargo-web is not compatible with web-sys.
</code></pre>
<p>遇到问题，第一时间，当然是到官方Repo里去检索啦，然后就搜到这么一条 Issue：</p>
<blockquote>
<p>https://github.com/yewstack/yew/issues/1081</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzml07drdj30x60u0tf8.jpg" alt="image-20210212102606760" /></p>
<p>建议使用 trunk，妥~</p>
<h2><a class="header" href="#trunk-的探索之旅" id="trunk-的探索之旅">Trunk 的探索之旅</a></h2>
<p>跳转到 Trunk Repo：</p>
<blockquote>
<p>https://github.com/thedodd/trunk</p>
</blockquote>
<p>发现里面有examples，于是直接 clone 下来运行：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzmkyp56nj315m020mxd.jpg" alt="image-20210212103935572" /></p>
<p>执行没问题，很好！</p>
<p>但是只有一个简单的实例，没法基于这个进行学习，怎么办？</p>
<p>我们回到 yew 的 Repo 里面，看下有没啥实例。</p>
<blockquote>
<p>https://github.com/yewstack/yew/tree/master/examples</p>
</blockquote>
<p>Examples 很多，也都能跑通，赞：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzmky3r5lj31160u0k06.jpg" alt="image-20210212104228167" /></p>
<h2><a class="header" href="#魔改出-base64-encoder" id="魔改出-base64-encoder">魔改出 Base64 Encoder！</a></h2>
<p>在入门一个新的计算机技术的时候，千万不要一开始就从0到1！因为从0到1的难度对新手来说太高。最开始应该先去魔改一个已有的项目。</p>
<p>我选择的是todomvc，原始是长这样：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzml3vu1zj310q0hydhg.jpg" alt="image-20210212104717518" /></p>
<p>目的是把它修改成一个 Base64-Encoder：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzmkz5c6mj30yi0bc75c.jpg" alt="image-20210212104823485" /></p>
<p>Ok，那我们来看看原始代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>......
    fn view(&amp;self) -&gt; Html {
        let hidden_class = if self.state.entries.is_empty() {
            &quot;hidden&quot;
        } else {
            &quot;&quot;
        };
        html! {
            &lt;div class=&quot;todomvc-wrapper&quot;&gt;
                &lt;section class=&quot;todoapp&quot;&gt;
                    &lt;header class=&quot;header&quot;&gt;
                        &lt;h1&gt;{ &quot;todos&quot; }&lt;/h1&gt;
                        { self.view_input() }
                    &lt;/header&gt;
                    &lt;section class=classes!(&quot;main&quot;, hidden_class)&gt;
                        &lt;input
                            type=&quot;checkbox&quot;
                            class=&quot;toggle-all&quot;
                            id=&quot;toggle-all&quot;
                            checked=self.state.is_all_completed()
                            onclick=self.link.callback(|_| Msg::ToggleAll)
                        /&gt;
                        &lt;label for=&quot;toggle-all&quot; /&gt;
                        &lt;ul class=&quot;todo-list&quot;&gt;
                            { for self.state.entries.iter().filter(|e| self.state.filter.fits(e)).enumerate().map(|e| self.view_entry(e)) }
                        &lt;/ul&gt;
                    &lt;/section&gt;
                    &lt;footer class=classes!(&quot;footer&quot;, hidden_class)&gt;
                        &lt;span class=&quot;todo-count&quot;&gt;
                            &lt;strong&gt;{ self.state.total() }&lt;/strong&gt;
                            { &quot; item(s) left&quot; }
                        &lt;/span&gt;
                        &lt;ul class=&quot;filters&quot;&gt;
                            { for Filter::iter().map(|flt| self.view_filter(flt)) }
                        &lt;/ul&gt;
                        &lt;button class=&quot;clear-completed&quot; onclick=self.link.callback(|_| Msg::ClearCompleted)&gt;
                            { format!(&quot;Clear completed ({})&quot;, self.state.total_completed()) }
                        &lt;/button&gt;
                    &lt;/footer&gt;
                &lt;/section&gt;
                &lt;footer class=&quot;info&quot;&gt;
                    &lt;p&gt;{ &quot;Double-click to edit a todo&quot; }&lt;/p&gt;
                    &lt;p&gt;{ &quot;Written by &quot; }&lt;a href=&quot;https://github.com/DenisKolodin/&quot; target=&quot;_blank&quot;&gt;{ &quot;Denis Kolodin&quot; }&lt;/a&gt;&lt;/p&gt;
                    &lt;p&gt;{ &quot;Part of &quot; }&lt;a href=&quot;http://todomvc.com/&quot; target=&quot;_blank&quot;&gt;{ &quot;TodoMVC&quot; }&lt;/a&gt;&lt;/p&gt;
                &lt;/footer&gt;
            &lt;/div&gt;
        }
    }
}
......
<span class="boring">}
</span></code></pre></pre>
<p>挺好，这个就是前端部分了，我们把它删减一下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn view(&amp;self) -&gt; Html {
        let hidden_class = if self.state.entries.is_empty() {
            &quot;hidden&quot;
        } else {
            &quot;&quot;
        };
        html! {
            &lt;div class=&quot;todomvc-wrapper&quot;&gt;
                &lt;h1&gt;{ &quot;encode/decode&quot; }&lt;/h1&gt;
                { self.view_input() }
                &lt;section class=classes!(&quot;main&quot;, hidden_class)&gt;
                    &lt;ul class=&quot;todo-list&quot;&gt;
                        { for self.state.entries.iter().filter(|e| self.state.filter.fits(e)).enumerate().map(|e| self.view_entry(e)) }
                    &lt;/ul&gt;
                &lt;/section&gt;
            &lt;/div&gt;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到，输入的逻辑在<code>view_input()</code>这个地方，于是我们找到那个函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view_input(&amp;self) -&gt; Html {
        html! {
            // You can use standard Rust comments. One line:
            // &lt;li&gt;&lt;/li&gt;
            &lt;input
                class=&quot;new-todo&quot;
          			// 改掉replaceholder
                placeholder=&quot;What needs to be encode/decode?&quot;
                value=&amp;self.state.value
                oninput=self.link.callback(|e: InputData| Msg::Update(e.value))
                onkeypress=self.link.batch_callback(|e: KeyboardEvent| {
                    if e.key() == &quot;Enter&quot; { Some(Msg::Add) } else { None }
                })
            /&gt;
            /* Or multiline:
            &lt;ul&gt;
                &lt;li&gt;&lt;/li&gt;
            &lt;/ul&gt;
            */
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>再找到<code>Msg::Add</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
        match msg {
            Msg::Add =&gt; {
                //info!(&quot;add things&quot;);
                let description = self.state.value.trim();
                let description_handled = format!(&quot;{}: {}&quot;, description, encode(description.to_string()));

                if !description.is_empty() {
                    let entry = Entry {
                        description: description_handled,
                        completed: false,
                        editing: false,
                    };
                    //info!(&quot;{}&quot;, entry.description);
                    self.state.entries.push(entry);
                }
                self.state.value = &quot;&quot;.to_string();
            }
......
<span class="boring">}
</span></code></pre></pre>
<p>这个时候，我想先调试一下，因此需要把一些数据打印出来。</p>
<p>这个时候，首先想到的是<code>print</code>大法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Input: {}&quot;, val);
<span class="boring">}
</span></code></pre></pre>
<p>但是，在<code>trunk serve</code>命令中，<code>println!</code>这个函数失效了！</p>
<p>在<code>trunk</code>和<code>yew</code>的 Repo 中进行检索，均未找到解决方案。</p>
<p>但是随即发现<code>yew</code>有 Discord Chatroom，于是乎进去搜索聊天记录。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzml4by57j311q0qmgpg.jpg" alt="image-20210212105847278" /></p>
<p>Yummy，这里提到只要使用wasm-logger即可。</p>
<blockquote>
<p>https://crates.io/crates/wasm-logger</p>
</blockquote>
<p>在项目里添加<code>wasm-logger</code>：</p>
<pre><pre class="playground"><code class="language-rust">......
// in the first of main.rs
#[macro_use] extern crate log;
......
fn main() {
		// init wasm logger!
    wasm_logger::init(wasm_logger::Config::default());
    yew::start_app::&lt;Model&gt;();
}
</code></pre></pre>
<p>调用试试看：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
        match msg {
            Msg::Add =&gt; {
                info!(&quot;add things&quot;);
......
<span class="boring">}
</span></code></pre></pre>
<p>妥了！</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzml2kyvrj31ga0oo0vx.jpg" alt="image-20210212110203302" /></p>
<p>接下来找到Rust Base64 的库，调用之（修改的地方用new标出了）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>......
use base64::{encode, decode};
......
fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
        match msg {
            Msg::Add =&gt; {
                // new
                info!(&quot;add things&quot;);
                let description = self.state.value.trim();
                // new
                let description_handled = format!(&quot;{}: {}&quot;, description, encode(description.to_string()));

                if !description.is_empty() {
                    let entry = Entry {
                      	// new
                        description: description_handled,
                        completed: false,
                        editing: false,
                    };
                  	// new
                    info!(&quot;{}&quot;, entry.description);
                    self.state.entries.push(entry);
                }
                self.state.value = &quot;&quot;.to_string();
            }
<span class="boring">}
</span></code></pre></pre>
<p>运行之。</p>
<p>Okay，Base64-Encoder就做好了！</p>
<p>效果：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnzml2w1ejj30k009z758.jpg" alt="encoder" /></p>
<p><code>Cargo.toml</code>最后长这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;encoder&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Denis Kolodin &lt;deniskolodin@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
strum = &quot;0.20&quot;
strum_macros = &quot;0.20&quot;
serde = &quot;1&quot;
serde_derive = &quot;1&quot;
yew = { path = &quot;./packages/yew&quot; }
yew-services = { path = &quot;./packages/yew-services&quot; }

log = &quot;0.4.6&quot;
wasm-logger = &quot;0.2.0&quot;
base64 = &quot;0.13.0&quot;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#生成-eth-公私钥与地址" id="生成-eth-公私钥与地址">生成 ETH 公私钥与地址</a></h1>
<blockquote>
<p><strong>本系列所有源码：</strong></p>
<p>https://github.com/leeduckgo/Rust-Study</p>
</blockquote>
<p>本篇是 Rust 学习笔记的第二篇。在第一篇里，我们魔改出了一个 Encoder，现在我们继续延续我们的魔改之路，挑战一个难度+1的Repo：</p>
<blockquote>
<p>Rust library for generating cryptocurrency wallets</p>
<p>https://github.com/AleoHQ/wagyu</p>
</blockquote>
<p>魔改目标 0x1：</p>
<blockquote>
<p><strong>抽取 Repo 中以太坊私钥、公钥、地址生成的部分，打印到控制台中。</strong></p>
</blockquote>
<p>但在魔改之前，笔者首先要对上一篇文章稍作补充，总结一下上篇文章中所涉及的知识点。</p>
<h2><a class="header" href="#上篇文章中所涉及的知识点" id="上篇文章中所涉及的知识点">上篇文章中所涉及的知识点</a></h2>
<ul>
<li>变量的赋值</li>
<li>format!函数（连接字符串）</li>
<li>库的添加与使用，以wasm-logger为例</li>
<li>trunk 与 yew 结合，让Rust程序 wasm 化，使其在浏览器中可访问</li>
</ul>
<h2><a class="header" href="#跑一遍-wagyu" id="跑一遍-wagyu">跑一遍 wagyu</a></h2>
<p>首先要验证这个库符合我们的需求，所以按照 Repo 中的 Readme，采用源码的方式跑一遍。</p>
<pre><code class="language-bash"># Download the source code
git clone https://github.com/AleoHQ/wagyu
cd wagyu

# Build in release mode
$ cargo build --release
./target/release/wagyu
</code></pre>
<p>成功：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnpi5cklf3j313y0fi79f.jpg" alt="image-20210213091719643" /></p>
<p>在这个过程里，我们学习到了 cargo 的更多用法：</p>
<pre><code class="language-bash">$ cargo run # 直接执行
$ cargo build # build 出 debug 版本，可执行文件在 ./target/debug 目录下
$ cargo build --release # build 出 正式版本（release version)，可执行文件在 ./target/release 下
</code></pre>
<h2><a class="header" href="#研究-wagyu-代码" id="研究-wagyu-代码">研究 wagyu 代码</a></h2>
<p>首先喵一眼目录结构：</p>
<pre><code>.
├── AUTHORS
├── Cargo.lock
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
├── README.md
├── bitcoin
├── ethereum
├── model
├── monero
├── target
├── zcash
└── wagyu
      ├── cli
      │   ├── bitcoin.rs
      │   ├── ethereum.rs
      │   ├── mod.rs
      │   ├── monero.rs
      │   ├── parameters
      │   └── zcash.rs
      ├── lib.rs
      └── main.rs

</code></pre>
<p>我们可以看到，主入口是<code>wagyu</code>。</p>
<p>在<code>wagyu</code>的<code>main.rs</code>中，会对<code>cli</code>目录下的子模块进行调用，进而对和<code>cli</code>平级的子模块进行调用。</p>
<p>其代码如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), CLIError&gt; {
    let arguments = App::new(&quot;wagyu&quot;)
        .version(&quot;v0.6.3&quot;)
        .about(&quot;Generate a wallet for Bitcoin, Ethereum, Monero, and Zcash&quot;)
        .author(&quot;Aleo &lt;hello@aleo.org&gt;&quot;)
        .settings(&amp;[
            AppSettings::ColoredHelp,
            AppSettings::DisableHelpSubcommand,
            AppSettings::DisableVersion,
            AppSettings::SubcommandRequiredElseHelp,
        ])
        .subcommands(vec![
            BitcoinCLI::new(),
            EthereumCLI::new(),
            MoneroCLI::new(),
            ZcashCLI::new(),
        ])
        .set_term_width(0)
        .get_matches();

    match arguments.subcommand() {
        (&quot;bitcoin&quot;, Some(arguments)) =&gt; BitcoinCLI::print(BitcoinCLI::parse(arguments)?),
        (&quot;ethereum&quot;, Some(arguments)) =&gt; EthereumCLI::print(EthereumCLI::parse(arguments)?),
        (&quot;monero&quot;, Some(arguments)) =&gt; MoneroCLI::print(MoneroCLI::parse(arguments)?),
        (&quot;zcash&quot;, Some(arguments)) =&gt; ZcashCLI::print(ZcashCLI::parse(arguments)?),
        _ =&gt; unreachable!(),
    }
}
</code></pre></pre>
<p>我们再进入<code>wagyu &gt; cli &gt; ethereum.rs</code>目录下，发现里面有个简单的函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn new&lt;R: Rng&gt;(rng: &amp;mut R) -&gt; Result&lt;Self, CLIError&gt; {
        let private_key = EthereumPrivateKey::new(rng)?;
        let public_key = private_key.to_public_key();
        let address = public_key.to_address(&amp;EthereumFormat::Standard)?;
        Ok(Self {
            private_key: Some(private_key.to_string()),
            public_key: Some(public_key.to_string()),
            address: Some(address.to_string()),
            ..Default::default()
        })
    }
<span class="boring">}
</span></code></pre></pre>
<p>很好，就拿这个改造了！</p>
<h2><a class="header" href="#复制必要文件到新项目" id="复制必要文件到新项目">复制必要文件到新项目</a></h2>
<ol>
<li>新建项目</li>
</ol>
<pre><code class="language-bash">$ cargo new hello-crypto-rust
</code></pre>
<p>或者直接把上一个项目复制一份。</p>
<ol start="2">
<li>把<code>wagyu</code>的<code>Cargo.toml</code>中的必要内容复制过来</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
log = &quot;0.4&quot;
pretty_env_logger = &quot;0.3&quot;

wagyu-ethereum = { path = &quot;./ethereum&quot;, version = &quot;0.6.3&quot; }
wagyu-model = { path = &quot;./model&quot;, version = &quot;0.6.3&quot; }

arrayvec = { version = &quot;0.5.1&quot; }
base58 = { version = &quot;0.1&quot; }
clap = { version = &quot;~2.33.1&quot; }
colored = { version = &quot;1.9&quot; }
digest = { version = &quot;0.9.0&quot; }
either = { version = &quot;1.5.3&quot; }
failure = { version = &quot;0.1.8&quot; }
hex = { version = &quot;0.4.2&quot; }
lazy_static = { version = &quot;1.4.0&quot; }
rand = { version = &quot;0.7&quot; }
rand_core = { version = &quot;0.5.1&quot; }
safemem = { version = &quot;0.3.3&quot; }
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = { version = &quot;1.0&quot; }
tiny-keccak = { version = &quot;1.4&quot; }

[profile.release]
opt-level = 3
lto = &quot;thin&quot;
incremental = true

[profile.bench]
opt-level = 3
debug = false
rpath = false
lto = &quot;thin&quot;
incremental = true
debug-assertions = false

[profile.dev]
opt-level = 0

[profile.test]
opt-level = 3
incremental = true
debug-assertions = true
debug = true
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>把<code>ethereum</code>与<code>model</code>两个文件夹复制到<code>hello-crypto-rust</code>目录下</li>
</ol>
<p>此时的文件目录是这个样子的：</p>
<pre><code class="language-bash">.
├── Cargo.lock
├── Cargo.toml
├── ethereum
├── model
├── src
└── target
</code></pre>
<h2><a class="header" href="#补充代码" id="补充代码">补充代码</a></h2>
<ol>
<li>补充<code>lib.rs</code>文件</li>
</ol>
<p>在<code>src</code>目录下新建<code>lib.rs</code>文件，内容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern crate wagyu_ethereum as ethereum;
pub extern crate wagyu_model as model;
extern crate pretty_env_logger;
<span class="boring">}
</span></code></pre></pre>
<p>作用是加载外部 crate，更详细的说明可见：</p>
<blockquote>
<p>https://wiki.jikexueyuan.com/project/rust-primer/module/module.html</p>
</blockquote>
<ol start="2">
<li>编写<code>main.rs</code>文件。</li>
</ol>
<p>首先引用必要的外部模块：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::{rngs::StdRng};
use rand_core::SeedableRng;
use hello_crypto_rust::ethereum::{EthereumPrivateKey, EthereumFormat};
use hello_crypto_rust::model::{PrivateKey, PrivateKeyError, AddressError, PublicKeyError, PublicKey};

#[macro_use] extern crate log;
<span class="boring">}
</span></code></pre></pre>
<p>然后我们编写主函数：</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    pretty_env_logger::init();  // 初始化 pretty_env_logger 模块
    new(); //调用new函数
}
</code></pre></pre>
<p>写<code>new()</code>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Result&lt;EthereumPrivateKey, CreateError&gt; {
    let rng = &amp;mut StdRng::from_entropy();
    let private_key = EthereumPrivateKey::new(rng)?;
    info!(&quot;priv: {}&quot;, private_key.to_string());
    let public_key = private_key.to_public_key();
    info!(&quot;pub: {}&quot;, public_key.to_string());
    let address = public_key.to_address(&amp;EthereumFormat::Standard)?;
    info!(&quot;addr: {}&quot;, address.to_string());
    Ok(private_key)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们这里使用了相对于<code>println!</code>更高级的输出方式，通过log输出。</p>
<p>这里有个关键的语法糖——<code>?</code>，用于错误处理。</p>
<blockquote>
<p>把 result 用 match 连接起来会显得很难看；幸运的是，<code>?</code> 运算符可以把这种逻辑变得 干净漂亮。<code>?</code> 运算符用在返回值为 <code>Result</code> 的表达式后面，它等同于这样一个匹配 表达式：其中 <code>Err(err)</code> 分支展开成提前返回的 <code>return Err(err)</code>，而 <code>Ok(ok)</code> 分支展开成 <code>ok</code> 表达式。</p>
<p>—— https://rustwiki.org/zh-CN/rust-by-example/std/result/question_mark.html</p>
</blockquote>
<p>两个等价的函数，一个使用了<code>?</code>，一个没有：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn not_use_question_mark() {
    let a = 10;                                                   // 把这里改成 9 就会报错.
    let half = halves_if_even(a);
    let half = match half {
        Ok(item) =&gt; item,
        Err(e) =&gt; panic!(e),
    };
    assert_eq!(half, 5);
}


fn use_question_mark&lt;'a &gt;() -&gt; Result&lt;i32, &amp;'a str&gt; {              // 这里必须要返回Result
    let a = 10;
    let half = halves_if_even(a)?;                     // 因为?要求其所在的函数必须要返回Result
    assert_eq!(half, 5);
    Ok(half)                                                                   
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们定义一下枚举类型<code>CreateError</code>，里面会囊括<code>AddressError</code>、<code>PrivateKeyError</code>与<code>PublicKeyError</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CreateError {
    AddressError(AddressError),
    PrivateKeyError(PrivateKeyError),
    PublicKeyError(PublicKeyError)
}

impl From&lt;AddressError&gt; for CreateError {
    fn from(error: AddressError) -&gt; Self {
        CreateError::AddressError(error)
    }
}

impl From&lt;PrivateKeyError&gt; for CreateError {
    fn from(error: PrivateKeyError) -&gt; Self {
        CreateError::PrivateKeyError(error)
    }
}

impl From&lt;PublicKeyError&gt; for CreateError {
    fn from(error: PublicKeyError) -&gt; Self {
        CreateError::PublicKeyError(error)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#try-it" id="try-it">Try It！</a></h2>
<p>实现成功：</p>
<p><img src="https://img.learnblockchain.cn/2021/02/22_/320988596.jpg" alt="image-20210213095659766" /></p>
<h2><a class="header" href="#本篇所涉及的知识点" id="本篇所涉及的知识点">本篇所涉及的知识点</a></h2>
<ul>
<li>cargo 的更多用法</li>
<li><code>lib.rs</code>的用法</li>
<li>函数与函数返回值</li>
<li><code>pretty_env_logger</code>的用法</li>
<li>枚举类型，以<code>CreateError</code>为例</li>
</ul>
<hr />
<p>作者简介：</p>
<p>李大狗（李骜华），上海对外经贸大学区块链技术与应用研究中心副主任、柏链教育 CTO、FISCO BCOS（微众银行区块链框架）区块链认证讲师、5 年区块链工程师、北京大学硕士。
研究领域包括：区块链系统、共识机制、智能合约、区块链应用、数字身份等。</p>
<h1><a class="header" href="#译使用-rust-实现命令行生命游戏" id="译使用-rust-实现命令行生命游戏">「译」使用 Rust 实现命令行生命游戏</a></h1>
<p>译者：m1zzx2 </p>
<hr />
<p>原文：</p>
<ul>
<li><a href="https://dev.to/jbarszczewski/rust-cli-game-of-life-tutorial-part-1-57pp">https://dev.to/jbarszczewski/rust-cli-game-of-life-tutorial-part-1-57pp</a></li>
<li><a href="https://dev.to/jbarszczewski/rust-cli-game-of-life-tutorial-part-2-16j3">https://dev.to/jbarszczewski/rust-cli-game-of-life-tutorial-part-2-16j3</a></li>
</ul>
<h2><a class="header" href="#介绍-1" id="介绍-1">介绍</a></h2>
<p>你好！如果你看到了这篇文章，说明你对Rust感兴趣，并且想学习或者了解它。我早在2020年6月就编写了我的第一个Rust教程<a href="https://dev.to/jbarszczewski/rust-actix-cosmosdb-mongodb-tutorial-api-17i5">Rust + Actix + CosmosDB (MongoDB) tutorial api</a>。这次，我将尝试介绍Rust的CLI。为了让这次的介绍更有趣，使用了<a href="https://rustwasm.github.io/docs/book/game-of-life/rules.html">Official Rust WebAssembly</a>教程来实现“生命游戏”，来增强用户的交互逻辑。</p>
<p>虽然这是个新手教程，但是我仍然强烈建议你通过了官方的新手教程后再来做这个。
<a href="https://github.com/rust-lang/rustlings">rustlings tutorial</a></p>
<p>可以在我的<a href="https://github.com/jbarszczewski/cli-game-of-life">github仓库</a>中找到“最终”代码</p>
<h2><a class="header" href="#创造universe" id="创造universe">创造Universe</a></h2>
<p>开始吧！
在创建一些新的项目像 new cli-game-of-life (或者 cargo init 如果你已经在一个正确的目录里面)之后。 使用你喜欢的编辑器打开它，目前要忽略main.rs。我们先要创建一个逻辑模块，所以继续创建一个src/game.rs文件。和前面说的一样，我将使用和wasm官方教程一样的逻辑来讲解，如果你之前做过它，你就会对它非常熟悉。让我们在游戏Universe里面来定义一个游戏单元格的枚举。</p>
<pre><code>#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
</code></pre>
<p>derive 声明会告诉编译器提供(Copy, Clone, Debug, Eq, PartialEq)的基本实现，所以我们可以给单元分配枚举值并且比较他们。</p>
<p><strong>注意</strong>: 我们也可以用bool值来实现一样的功能，不过使用enum可以具有更好的可读性，两者占用的内存是相等的。</p>
<p>我们的游戏Universe定义如下:</p>
<pre><code>pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
</code></pre>
<p>好了现在我们开始实现游戏的函数了。让我们从一个方便的构造函数开始，这个构造函数将会设置Universe的大小，并初始化Cells的初始值。set_cells函数将会接受一个cells坐标，并把对应坐标的Cell设置成Alive状态。</p>
<pre><code>impl Universe {
    pub fn new(width: u32, height: u32) -&gt; Universe {
        Universe {
            width: width,
            height: height,
            cells: vec![Cell::Dead; (width * height) as usize],
        }
    }

    pub fn set_cells(&amp;mut self, cells: &amp;[(u32, u32)]) {
        for (row, col) in cells.iter().cloned() {
            let idx = self.get_index(row, col);
            self.cells[idx] = Cell::Alive;
        }
    }

    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }
}
</code></pre>
<p>get_index 函数是一个辅助函数，它会把Universed的坐标翻译成cells数组对应的下标。</p>
<p>接下来，我们会实现Display特性，方便打印当前游戏的状态。</p>
<pre><code>use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, &quot;{}&quot;, symbol)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
</code></pre>
<p>Perfect! Now we have something to run. Head over to your main.rs and replace all with the following content:
非常完美!现在我们需需要定义一个启动函数: 挑转到main.rs 用下面的内容替换main.rs的内容：</p>
<pre><code>mod game;

fn main() {
    let mut game = game::Universe::new(5, 5);
    game.set_cells(&amp;[(2, 1), (2, 2), (2, 3)]);
    print!(&quot;{}&quot;, game);
}
</code></pre>
<p>运行 cargo run之后 ,代码顺利的跑起来了，但是它实际上没有做什么，因此我们需要新增一个tick函数:</p>
<pre><code>pub fn tick(&amp;mut self) {
    let mut next = self.cells.clone();
    for row in 0..self.height {
        for col in 0..self.width {
            let idx = self.get_index(row, col);
            let cell = self.cells[idx];
            let live_neighbours = self.live_neighbour_count(row, col);
            next[idx] = match (cell, live_neighbours) {
                (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                (Cell::Dead, 3) =&gt; Cell::Alive,
                (otherwise, _) =&gt; otherwise,
            };
        }
    }
    self.cells = next;
}

fn live_neighbour_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbour_row = (row + delta_row) % self.height;
            let neighbour_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbour_row, neighbour_col);
            count += self.cells[idx] as u8;
        }
    }

    count
}
</code></pre>
<p>该代码直接来自WASM锈皮书，它将Conway的《生命游戏》规则应用到我们的宇宙中，同时还要注意边缘包裹，以使我们的宇宙看起来像是循环的（请参见风味3）。
在使用刻度之前，我们需要准备终端以显示动画游戏Universe。 让我们现在就跳进去！</p>
<p>P.S. -您可以在我的GitHub上找到本章的源代码</p>
<p>这段代码来自wasm rust book ，它把ConWay的 Conway's Game Of Life 的规则应用到我们的universe中，它也会注意边界条件，让我们的universe看起来是循环运动的。<a href="https://rustwasm.github.io/docs/book/game-of-life/implementing.html">看第三章</a></p>
<p>在我们使用tick函数之前，我们需要准备用终端去展示Universe 的界面，让我们来进入这个操作吧!</p>
<p>P.S -你们可以在<a href="https://github.com/jbarszczewski/cli-game-of-life/tree/42c60e1c10073dd65819af7d1a6d7b049d1a449d">这里</a>找到本章的源代码</p>
<h2><a class="header" href="#绘制游戏universe" id="绘制游戏universe">绘制游戏Universe</a></h2>
<p>为了让终端输入输出，我们将会使用<a href="https://crates.io/crates/crossterm">Crossterm crate</a>包，因此我们需要把它添加进我们的Cargo.toml文件里面:</p>
<pre><code>[dependencies]
crossterm = &quot;0.19.0&quot;
</code></pre>
<p>这个工具箱里面有很多方便的函数来操作终端，并且它是跨平台的，我们不需要担心任何平台的区别。大多数crossterm指令是容易理解的，因为他们被分进了不同的模块，就像cursor:Hide 就是和它的字面意思的一样，隐藏光标。</p>
<pre><code>use crossterm::{
    cursor::{Hide, MoveTo, Show},
    event::{poll, read, Event},
    execute,
    style::{Color, Print, ResetColor, SetForegroundColor},
    terminal::{Clear, ClearType, EnterAlternateScreen, LeaveAlternateScreen},
    Result,
};
use std::io::stdout;
use std::time::Duration;
</code></pre>
<p>接下老，我们的main函数需要被填充成这个样子:</p>
<pre><code>fn main() -&gt; Result&lt;()&gt; {
    let mut game = game::Universe::new(5, 5);
    game.set_cells(&amp;[(2, 1), (2, 2), (2, 3)]);
    execute!(
        stdout(),
        EnterAlternateScreen,
        SetForegroundColor(Color::Magenta),
        Hide
    )?;

    loop {
        if poll(Duration::from_millis(500))? {
            match read()? {
                Event::Key(_) =&gt; break,
                _ =&gt; {}
            }
        } else {
            execute!(
                stdout(),
                Clear(ClearType::All),
                MoveTo(0, 0),
                Print(&amp;game),
                Print(&quot;Press enter to exit...&quot;)
            )?;
            game.tick();
        }
    }
    execute!(stdout(), ResetColor, Show, LeaveAlternateScreen)?;
    Ok(())
}
</code></pre>
<p>好的让我们拆解一下在做的事情:</p>
<ol>
<li>main函数现在返回了Result类型。这能让用户随时退出。</li>
<li>我们在execute!宏里面设置临时终端，它的第一个参数是std::io::Writer(这个case里面的输入)类，后面的参数是一些命令。</li>
<li>在这个循环里面，我们用poll去读取用户的输入，这样不会阻塞execution去绘画终端。当用户输入回车按钮时，这个循环就会退出，如果用户在500ms内没有输入，我们将会根据tick计算的状态重新绘画Universe。</li>
<li>循环结束以后，我们就会离开这个临时终端。
现在我们可以跑脚本cargo run 了。
你将会看到水平线和垂直线相互交替出现，但是输入enter，游戏没有停止。我们需要修改代码来实现这个功能。</li>
</ol>
<h2><a class="header" href="#和universe交互" id="和universe交互">和Universe交互</a></h2>
<p>我们只能处理回车的原因是，默认的输入是在按下回车后处理的。通常，你的输入都准备好之后，在按下会车触发，这才有意义。但是在我们的需求里面，我们希望和一个键交互。这意味着我们需要启用<a href="https://docs.rs/crossterm/0.19.0/crossterm/terminal/#raw-mode">raw mode</a>. 新的代码会被改成这样:</p>
<pre><code>
// add required imports:
use terminal::{disable_raw_mode, enable_raw_mode};

// add this line at the very begining of the main() function:
enable_raw_mode()?;

// replace code block when poll returns true, the match statement, with following:

if let Event::Key(KeyEvent { code, .. }) = read()? {
    match code {
        KeyCode::Esc =&gt; {
            break;
        }
        _ =&gt; {}
    }
}

// finaly disable raw mode at the end of the function before returning Ok(()):
disable_raw_mode()?;
</code></pre>
<p>添加循环退出功能是很重要的，因为raw mode模式下，会禁用ctrl+c退出的方式。
现在你可以运行这个代码了，但是你会发现输出的格式都是乱的，这是因为raw mode不会处理换行符。现在我们需要将光标显示在正确的位置。这意味着我们不能用Display 特征来显示了。取而代之的，我们会遍历Universe，把每一行分别打印出来，向Universe中添加新方法：</p>
<pre><code>pub fn row_as_string(&amp;self, row: u32) -&gt; Option&lt;String&gt; {
    if row &lt; self.height {
        let mut row_string = String::new();
        let start = self.get_index(row, 0);
        let end = self.get_index(row, self.width);
        let line = &amp;self.cells[start..end];
        for &amp;cell in line {
            let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
            row_string.push(symbol);
        }
        Some(row_string)
    } else {
        None
    }
}
</code></pre>
<p>如果该行和Universe大小一致，我们返回整行作为一个字符串，否则，返回None.
在我们的main.rs中，从crossterm队列中添加新的导入，请排队！宏类似于执行，但需要手动刷新。如果要有条件地构建输出，这将非常方便。让我们看看它如何进行。首先在main（）函数的开头初始化一个新变量：</p>
<pre><code>let mut stdout = stdout();
</code></pre>
<p>现在，可以把stdout()替换为我们的新名称，我们需要用以下代码替换整个循环:</p>
<pre><code>loop {
    if poll(Duration::from_millis(500))? {
        if let Event::Key(KeyEvent { code, .. }) = read()? {
            match code {
                KeyCode::Esc =&gt; {
                    break;
                }
                _ =&gt; {}
            }
        }
    } else {
        queue!(stdout, Clear(ClearType::All))?;
        let mut i = 0;
        while let Some(line) = game.row_as_string(i) {
            queue!(stdout, MoveTo(0, i as u16), Print(line))?;
            i += 1;
        }

        queue!(
            stdout,
            MoveTo(0, (i + 1) as u16),
            Print(&quot;Press Esc to exit...&quot;)
        )?;
        stdout.flush()?;
        game.tick();
    }
}
</code></pre>
<p>按键处理逻辑不会改变,所有的更改都在else里面：</p>
<ol>
<li>
<p>我们把execute!替换成 queue! 宏。</p>
</li>
<li>
<p>遍历Universe的每一行，queue! 会直接打印结果，你会看到返回Option <T>有多方便！我们不需要任何额外的处理，这个代码看起来会很干净。</p>
</li>
<li>
<p>在所有文本都准备好之后，我们调用 flush() 刷新到输出。</p>
</li>
</ol>
<h2><a class="header" href="#接受参数" id="接受参数">接受参数</a></h2>
<p>使用std :: env :: args函数可以非常简单的接受参数.但是我想展示一些依赖外部包 <a href="https://crates.io/crates/clap">clap</a>的方法。有三种配置clap的方式:</p>
<ul>
<li>'Builder Pattern'</li>
<li>yaml配置</li>
<li>宏
'Builder Pattern'是我最喜欢的一种方式，它可以动态扩展输入的参数，并提供一些检查。对于像这样的简单项目，将配置放在main.rs中是完全可以的，随着项目复杂度的增长，可能湖考虑把配置放在单独的文件里面，可以有更好的可读性。首先Cargo.toml添加依赖：</li>
</ul>
<pre><code>clap = &quot;2.33.3&quot;
</code></pre>
<p>接下来更新我们的main.rs文件:</p>
<pre><code>use clap::{crate_version, App, Arg};

//below code goes at the beginning of main() function:
  let matches = App::new(&quot;CLI Game Of Life&quot;)
        .version(crate_version!())
        .author(&quot;jbarszczewski&quot;)
        .about(&quot;Simple implementation of Conway's Game Of Life in Rust.&quot;)
        .after_help(&quot;Have fun!&quot;)
        .arg(
            Arg::with_name(&quot;INPUT&quot;)
                .help(&quot;Sets the input file to configure initial state of game&quot;)
                .short(&quot;i&quot;)
                .long(&quot;input&quot;)
                .takes_value(true),
        )
        .arg(
            Arg::with_name(&quot;DELAY&quot;)
                .help(&quot;Sets the delay between game ticks. Value is in miliseconds&quot;)
                .short(&quot;d&quot;)
                .long(&quot;delay&quot;)
                .takes_value(true)
                .default_value(&quot;500&quot;),
        )
        .get_matches();
</code></pre>
<p>clap包会创建两个子命令(除非你覆盖了它们):</p>
<ul>
<li>help (-h or --help)</li>
<li>version (-V --version) That's why we provide basic info about the app. You may notice crate_version! macro, this will grab the version number from your Cargo.toml file so you don't need to manually update it. Then we add two arguments, INPUT and DELAY, with some description how to use it. Build your app with cargo build (you will find binary in /target/debug directory) and run like this ./cli-game-of-life -h which will print out help page:</li>
</ul>
<pre><code>
CLI Game of Life 0.2.0
jbarszczewski
Simple implementation of Conway's Game of Life in Rust.

USAGE:
    cli-game-of-life [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -d, --delay &lt;DELAY&gt;    Sets the delay between game ticks. Value is in miliseconds [default: 500]
    -i, --input &lt;INPUT&gt;    Sets the input file to configure initial state of game

Have fun!
</code></pre>
<p>现在，可以写代码获取你输入的值:</p>
<pre><code>if let Some(input) = matches.value_of(&quot;INPUT&quot;) {
    println!(&quot;A config file was passed: {}&quot;, input);
}
</code></pre>
<p>value_of() 将会返回  Option<T> 因此你可以输入的数据是否存在而采取相应的行动，我们把DELAY设置成了默认值，也就是说无论有没有解析到输入，我们都会可以采取行动.现在我们不会使用value_of(), 在这个项目里面，我们会使用flag接受参数。默认情况下，所有的clap参数都是flag，这也就是为什么我们在描述INPUT和DELAY的时候，需要添加take_values()方法。因为flag并不会有值，当我们使用它们，像在这种场景:</p>
<pre><code>if matches.is_present(&quot;TEST&quot;) {
    println!(&quot;TEST!&quot;);
}
</code></pre>
<p>这里有太多的可能的配置，所以我只建议你用到配置的时候才去看<a href="https://docs.rs/clap/2.33.3/clap/struct.Arg.html">文档</a>。</p>
<p>好的，我们通过配置，已经能让我们的应用接受参数了，但是他们不会做任何处理，接下来将会做一些处理。</p>
<h2><a class="header" href="#控制速度" id="控制速度">控制速度</a></h2>
<p>让我们使用DELAY参数，现在我们的游戏hard-code了500ms作为刷新下一个状态的频率，动态地改变它是很简单的，首先，我们需要去读并且解析(Duration::from_millis() accept u64)我们输入的参数:</p>
<pre><code>let delay:u64 = matches.value_of(&quot;DELAY&quot;).unwrap().parse().unwrap();
</code></pre>
<p>我们的第一个unwrap(返回空，将会抛出panic)，来检查输入是否为空，第二个unwrap(如果返回Err，将会抛出panic)来检查输入是不是一个合法的int, panic时候，我们希望程序退出。如果你想定制第二个错误，你需要写下面的逻辑:</p>
<pre><code>let delay: u64 = match matches.value_of(&quot;DELAY&quot;).unwrap().parse() {
    Ok(val) =&gt; val,
    Err(e) =&gt; {
        println!(&quot;Error parsing DELAY argument: {}&quot;, e);
        500
    }
};
</code></pre>
<p>然后我们可以吧poll 函数里面的500换成delay变量。如果你想测试脚本是否正确运行，你需要执行这样的脚本: ./cli-game-of-life -d 200(记住这个值是毫秒)
这里有个小问题。由于处理的方式，我们需要在delay ms后，才展示屏幕上面的内容，如果delay5秒，那么程序开始的5秒不会有任何输出。我们可以用&quot;drawing&quot;修复它，
代码:</p>
<pre><code>loop {
    queue!(stdout, Clear(ClearType::All))?;
    let mut i = 0;
    while let Some(line) = game.row_as_string(i) {
        queue!(stdout, MoveTo(0, i as u16), Print(line))?;
        i += 1;
    }

    queue!(
        stdout,
        MoveTo(0, (i + 1) as u16),
        Print(&quot;Press Esc to exit...&quot;)
    )?;
    stdout.flush()?;
    if poll(Duration::from_millis(delay))? {
        if let Event::Key(KeyEvent { code, .. }) = read()? {
            match code {
                KeyCode::Esc =&gt; {
                    break;
                }
                _ =&gt; {}
            }
        }
    }

    game.tick();
}
</code></pre>
<h2><a class="header" href="#定义universe" id="定义universe">定义Universe</a></h2>
<p>现在是使用INPUT参数的时候了，这个参数制定了universe的配置路径，文件将会是下面这种格式:</p>
<pre><code>5
5
00000
00100
00010
01110
00000
</code></pre>
<p>第一行代表Universe的行数，第二行代表Universe的列数，接下来就是描述Universe每个格子的详情,0代表死,1代表或者。现在这里有两个地方你可以放置配置文件:</p>
<ol>
<li>项目的根目录，一些文件像是Cargo.toml就在这个里面，并且你能通过脚本cargo run -- -i INPUT跑你的应用。使用cargo运行之后的内容，都可以作为参数传递给你的项目。</li>
<li>./target/debug. 这意味着您需要在每次更改后重新构建，然后执行/debug/cli-game-of-life -i starship。
在本次教程里面，建议使用第一种方式，因为它更方便。上面的配置在“Game of Life”中称为starship pattern，因此我们将文件命名为一样的，然后继续下一步
我们将会读取这个文件，首先需要导入一个新的依赖:</li>
</ol>
<pre><code>use std::fs::File;
use std::io::{BufRead, BufReader};
</code></pre>
<p>下面是解析文件的函数，返回game::Universe:: </p>
<pre><code>fn create_game_from_file(path: &amp;str) -&gt; game::Universe {
    let file = File::open(path).unwrap();
    let mut reader = BufReader::new(file);
    let mut line = String::new();
    let mut rows_number = 0;
    if let Ok(success) = reader.read_line(&amp;mut line) {
        if success &gt; 0 {
            rows_number = line.trim().parse().unwrap();
            line.clear();
        } else {
            panic!(&quot;Rows number not detected!&quot;);
        }
    };
    let mut cols_number = 0;
    if let Ok(success) = reader.read_line(&amp;mut line) {
        if success &gt; 0 {
            cols_number = line.trim().parse().unwrap();
            line.clear();
        } else {
            panic!(&quot;Columns number not detected!&quot;);
        }
    };
    let mut game_universe = game::Universe::new(cols_number, rows_number);
    let mut row = 0;
    let mut live_cells = Vec::&lt;(u32, u32)&gt;::new();
    loop {
        match reader.read_line(&amp;mut line) {
            Ok(0) =&gt; break,
            Ok(_) =&gt; {
                let mut col = 0;
                for char in line.chars() {
                    match char {
                        '1' =&gt; live_cells.push((row, col)),
                        _ =&gt; {}
                    }
                    col += 1;
                }
            }
            _ =&gt; break,
        }

        line.clear();
        row += 1;
    }
    game_universe.set_cells(&amp;live_cells);
    game_universe
}
</code></pre>
<p>这看起来很长而且有一定重构的空间，但是比较容易理解:</p>
<ol>
<li>打开文件，写入BufReader。</li>
<li>创建变量line读取每一行。</li>
<li>尝试去解析行数和列数。</li>
<li>创建新的 Universe。</li>
<li>遍历剩余行，解析cell，写入vector。</li>
<li>调用game_universe.set_cell方法，把vector的值写入对象，然后返回。</li>
</ol>
<p>我们需要做的最后一件事情就是让我们的新的函数得到使用，在main函数里面删除初始化游戏的逻辑，并且把我们新的代码放在解析DELAY变量后面:</p>
<pre><code>let mut game = match matches.value_of(&quot;INPUT&quot;) {
    Some(path) =&gt; create_game_from_file(path),
    None =&gt; {
        let mut default_game = game::Universe::new(5, 5);
        default_game.set_cells(&amp;[(2, 1), (2, 2), (2, 3)]);
        default_game
    }
};
</code></pre>
<p>这个逻辑很简单：我们尝试读取INPUT参数，如果一个通过了，我们接下来调用create_game_from_file方法，如果没通过，我们然后默认的universe。</p>
<p>现在我们可以调用cargo run -- -i starship并且享受美景!你可以使用更大的场地，类似15*15， 并且由于我们不校验参数，所以不需要在每行最后输入0。</p>
<h2><a class="header" href="#总结-2" id="总结-2">总结</a></h2>
<p>希望您喜欢本教程，多谢您的阅读！</p>
<hr />
<p>译者介绍：</p>
<p>m1zzx2 ，Rust 初学者，知乎工程师。</p>
<h1><a class="header" href="#译使用-tokio-实现-actor-系统" id="译使用-tokio-实现-actor-系统">「译」使用 Tokio 实现 Actor 系统</a></h1>
<p>译者：Matrixtang</p>
<p>原文：<a href="https://ryhl.io/blog/actors-with-tokio/">https://ryhl.io/blog/actors-with-tokio/</a></p>
<hr />
<p>本文将不使用任何 Actors 库(例如 Actix ) 而直接使用Tokio实现 Actors 系统。事实上这甚至是更容易的，但是还是有一些细节需要注意：</p>
<ol>
<li><code>tokio::spawn</code> 的调用位置。</li>
<li>使用带有<code>run</code>方法的结构体还是裸函数。</li>
<li>Actor 的 Handle 函数。</li>
<li>背压( Backpressure ) 和 有界信道。</li>
<li>优雅的关闭。</li>
</ol>
<p>本文概述的技术适用于任何执行器，但为简单起见，我们仅讨论Tokio。与Tokio教程中的 <a href="https://tokio.rs/tokio/tutorial/spawning">spawning</a> 和<a href="https://tokio.rs/tokio/tutorial/channels">channel chapters</a>章节有一些重叠， 当然啦，我建议也阅读这些章节。</p>
<p>​	在讨论如何编写 Actor 之前，我们需要知道 Actor 是什么。Actor 背后的基本思想是产生一个独立的任务，该任务独立于程序的其他部分执行某些工作。 通常，这些参与者通过使用消息传递信道与程序的其余部分进行通信。 由于每个 Actor 独立运行，因此使用它们设计的程序自然是并行的。 Actor 的一个常见用法是为 Actor 分配你要共享的某些资源的专有所有权，然后让其他任务通过与 Actor 通信来间接访问彼此的资源。 例如，如果要实现聊天服务器，则可以为每个连接生成一个任务，并在其他任务之间路由一个聊天消息的主任务。 十分有用，因为主任务可以避免必须处理网络IO，而连接任务可以专门处理网络IO。 </p>
<h2><a class="header" href="#实现-2" id="实现-2">实现</a></h2>
<p>​	Actor 分为两部分：任务和handle。 该任务是独立生成的Tokio任务，实际上执行 Actor 的职责，而 handle 是一种允许你与该任务进行通信的结构。</p>
<p>​	让我们考虑一个简单的 Actor 。 Actor 在内部存储一个计数器，该计数器用于获取某种唯一ID。 Actor 的基本结构如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::{oneshot, mpsc};

struct MyActor {
    receiver: mpsc::Receiver&lt;ActorMessage&gt;,
    next_id: u32,
}
enum ActorMessage {
    GetUniqueId {
        respond_to: oneshot::Sender&lt;u32&gt;,
    },
}

impl MyActor {
    fn new(receiver: mpsc::Receiver&lt;ActorMessage&gt;) -&gt; Self {
        MyActor {
            receiver,
            next_id: 0,
        }
    }
    fn handle_message(&amp;mut self, msg: ActorMessage) {
        match msg {
            ActorMessage::GetUniqueId { respond_to } =&gt; {
                self.next_id += 1;

                // The `let _ =` ignores any errors when sending.
                // `let _ =` 忽略了发送的任何 error
                // This can happen if the `select!` macro is used
                // to cancel waiting for the response.
                // 当 `select!` 宏被用到时将会停止接受响应
                let _ = respond_to.send(self.next_id);
            },
        }
    }
}

async fn run_my_actor(mut actor: MyActor) {
    while let Some(msg) = actor.receiver.recv().await {
        actor.handle_message(msg);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们有了 Actor 本身，我们还需要一个与 actor 配套的handle 。 handle  是其他代码段可以用来与 actor 对话的对象，也是让 Actor 存活的原因。 </p>
<p>以下是 handle 的实现： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct MyActorHandle {
    sender: mpsc::Sender&lt;ActorMessage&gt;,
}

impl MyActorHandle {
    pub fn new() -&gt; Self {
        let (sender, receiver) = mpsc::channel(8);
        let actor = MyActor::new(receiver);
        tokio::spawn(run_my_actor(actor));
        // 译者提醒： 注意 tokio::spawn 的位置
        Self { sender }
    }

    pub async fn get_unique_id(&amp;self) -&gt; u32 {
        let (send, recv) = oneshot::channel();
        let msg = ActorMessage::GetUniqueId {
            respond_to: send,
        };

        // Ignore send errors. If this send fails, so does the
        // recv.await below. There's no reason to check for the
        // same failure twice.
        // 忽略发送 error 。如果它发送失败， 将会执行下方的 recv.await
        // 检测同样的错误两次是没有道理的。
        let _ = self.sender.send(msg).await;
        recv.await.expect(&quot;Actor task has been killed&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1e60fb476843fb130db9034e8ead210c">full example</a></p>
<p>让我们仔细看一下本示例中的不同部分。</p>
<p><strong><code>ActorMessage.</code></strong> <code>ActorMessage</code> 枚举定义了我们可以发送给 Actor 的消息类型。 通过使用这个枚举，我们可以拥有许多不同的消息类型，并且每种消息类型都可以具有自己的参数集。我们通过<a href="https://docs.rs/tokio/1/tokio/sync/oneshot/index.html"><code>oneshot</code></a>信道向 sender 返回值 , 而这种信道只允许发送一条消息。</p>
<p>在上面的示例中，我们在 actor 结构的 <code>handle_message</code> 方法中的枚举上进行了匹配，但这不是构造此方法的唯一办法。 也可以在 <code>run_my_actor</code> 函数的枚举中进行匹配。 然后，此匹配项中的每个分支都可以在 actor 对象上调用各种方法，例如  <code>get_unique_id</code> 。 </p>
<p><strong>发送消息时出错</strong> 在处理信道时，并非所有错误都是致命( fatal )的。 因此，该示例有时使用 <code>let _ =</code> 来忽略错误。 通常，如果 receiver 被丢弃，那在信道上的 <code>send</code> 操作将失败。 在我们的示例中，此操作的第一个实例是 actor 中我们响应已发送的消息的那行 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = respond_to.send(self.next_id);)
<span class="boring">}
</span></code></pre></pre>
<p>这将发生在接收方不再需要操作的结果的情形下，例如 发送消息的任务可能已被杀死。</p>
<p><strong>关闭Actor</strong>  我们可以通过查看接收消息是否失败来决定何时关闭 Actor 。 在我们的示例中，这发生在以下 while 循环中： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(msg) = actor.receiver.recv().await {
    actor.handle_message(msg);
}
<span class="boring">}
</span></code></pre></pre>
<p>当所有发送到<code>receiver</code> 的 <code>sender</code> 都被丢弃时，我们就知道将不会再收到其他信息了，因此可以关闭 Actor 。 当这种情况发生时，调用<code>.recv（）</code>将返回 <code>None</code> ，并且由于它与模式<code>Some（msg）</code>不匹配，while 循环将退出并且函数会返回。 </p>
<h2><a class="header" href="#结构体的-run-方法" id="结构体的-run-方法">结构体的 run 方法</a></h2>
<p>​	我上面给出的示例使用的顶层函数并未在任何结构上定义，因为我们将其作为 Tokio 任务产生 ，但是许多人发现直接在 MyActor 结构体中定义 <code>run</code>方法并且启动更加自然。 也不是不行，但是我举这个使用顶层函数的示例的原因是，使用这种方法就可以避免很多由生命周期而产生的问题了。 为了说清楚这种问题，我准备了一个例子，说明不熟悉该模式的人经常会想到什么。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyActor {
    fn run(&amp;mut self) {
        tokio::spawn(async move {
            while let Some(msg) = self.receiver.recv().await {
                self.handle_message(msg);
            }
        });
    }

    pub async fn get_unique_id(&amp;self) -&gt; u32 {
        let (send, recv) = oneshot::channel();
        let msg = ActorMessage::GetUniqueId {
            respond_to: send,
        };

        // Ignore send errors. If this send fails, so does the
        // recv.await below. There's no reason to check for the
        // same failure twice.
        let _ = self.sender.send(msg).await;
        recv.await.expect(&quot;Actor task has been killed&quot;)
    }
}

... and no separate MyActorHandle
<span class="boring">}
</span></code></pre></pre>
<p>这个示例存在两个问题：</p>
<ol>
<li><code>tokio::spawn</code>在  <code>run</code> 方法中被调用。</li>
<li>Actor 和 handle 其实是一个结构体。</li>
</ol>
<p>导致问题的第一个原因是，因为<code>tokio :: spawn</code>函数要求参数为 <code>'static'</code>。那就意味着新任务必须拥有完整的所有权，这就导致了该方法借用了<code>self</code>，所以它无法将 <code>self</code> 的所有权交给新任务。</p>
<p>第二个问题是，因为Rust强制实施了单一所有权原则。 如果将 actor 和 handle 都合并为同一个结构体，则（至少从编译器的角度来看）将使每个handle 都可以访问 actor 的任务所拥有的全部字段。 例如， <code>next_id</code> 应仅由 actor 任务拥有，而且不应该让任何 handle 直接访问。 </p>
<p>也就是说，有一个通过解决以上两个问题，变得可行的版本。代码如下： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyActor {
    async fn run(&amp;mut self) {
        while let Some(msg) = self.receiver.recv().await {
            self.handle_message(msg);
        }
    }
}

impl MyActorHandle {
    pub fn new() -&gt; Self {
        let (sender, receiver) = mpsc::channel(8);
        let actor = MyActor::new(receiver);
        tokio::spawn(async move { actor.run().await });

        Self { sender }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>该函数与顶层函数相同。 请<strong>注意</strong>，严格来讲，可以编写<code>tokio :: spawn</code>在<code>run</code>内的那种 ， 但是我并不推荐。</p>
<h2><a class="header" href="#actor-的-其他变体" id="actor-的-其他变体">actor 的 其他变体</a></h2>
<p>​	我在本文中的示例使用了参与者使用消息的请求-响应模型(request-response)，但是这不是必须的。 在本节中，我将给你一些使用其他方式的例子，给你一些启发。</p>
<h3><a class="header" href="#不对消息回应" id="不对消息回应">不对消息回应</a></h3>
<p>​	在之前的示例中我们介绍了一种使用<code>oneshot</code>信道发送对消息响应的方式，但是并不总是需要响应。在这些情况下，仅在消息枚举中不包含 <code>oneshot</code> 信道是没有问题的。当信道中有空间时，这甚至可以让你在处理完消息之前就返回。 但是仍应确保使用有界信道，以保证在该信道中等待的消息数不会无限增长。在某些情况下，这意味着仍然需要由一个异步函数来处理<code>发送</code>操作，用于处理等待信道需要更多空间的情况。 但是，还有一种替代方法可以使<code>send</code>操作成为异步的。即使用 <code>try_send</code> 方法，并通过简单地杀死 Actor 来处理发送失败的情况。这在 Aoctor 管理 <code>TcpStream</code> 时，用于转发发送到连接中的任何消息的情况下是很有用的。这种情况下，如果无法继续向 <code>TcpStream</code> 写入 ，则可直接关闭连接。 </p>
<h3><a class="header" href="#多个handle共享一个-actor" id="多个handle共享一个-actor">多个handle共享一个 Actor</a></h3>
<p>​	如果需要从不同的地方向 actor 发送消息，则可以使用多个 handle 来强制某些消息只能从某些地方发送。 当使用这种方法时，你仍然可以在内部重复使用相同的 <code>mpsc</code> 通道，并使用其中包含所有可能的消息类型的枚举。 如果你<strong>不得不</strong>想要为此使用单独的信道，则  actor 可以使用 <a href="https://docs.rs/tokio/1/tokio/macro.select.html"><code>tokio::select!</code></a> 来一次性冲多个信道中接受信息。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    tokio::select! {
        Some(msg) = chan1.recv() =&gt; {
            // handle msg
        },
        Some(msg) = chan2.recv() =&gt; {
            // handle msg
        },
        else =&gt; break,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是在信道关闭时的处理方式，因为在这种情况下，它们的 <code>recv</code> 方法会立即返回 <code>None</code> 。 幸运的是，<code>tokio :: select！</code> 宏允许您通过提供 <code>Some（msg）</code> 来处理这种情况。 如果仅关闭一个信道，则该分支将被禁用，另外一个信道依旧是可用的。 当两者都关闭时，else分支运行并使用<code>break</code>退出循环。 </p>
<h3><a class="header" href="#actors-间发送信息" id="actors-间发送信息">Actors 间发送信息</a></h3>
<p>​	让 Actor 将消息发送给其他 Actor 也是可行的。 为此，只需为一个 Actor 提供其他 Actor 的 handle 即可。 当Actor 形成了循环时，需要上点心，因为为了保持彼此的 handle 存活，防止 Actor 被关闭最后一个 <code>sender</code> 不会被丢弃。 为了处理这种情况，您可以让一个 actor 具有两个带有独立的<code>mpsc</code>通道的 handle ，<code>tokio :: select！</code>会被用在下面这个示例里 ： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    tokio::select! {
        opt_msg = chan1.recv() =&gt; {
            let msg = match opt_msg {
                Some(msg) =&gt; msg,
                None =&gt; break,
            };
            // handle msg
        },
        Some(msg) = chan2.recv() =&gt; {
            // handle msg
        },
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>如果 <code>chan1</code> 关闭，即使<code>chan2</code>仍然打开，上述循环也将退出。 如果<code> chan2</code>  是 Actor 循环的一部分，则这会中断该循环并让 Actor 关闭。 </p>
<p>只需要简单的在循环里调用  <a href="https://docs.rs/tokio/1/tokio/task/struct.JoinHandle.html#method.abort"><code>abort</code></a> 就可以了。</p>
<h3><a class="header" href="#多个-actors-共享一个-handle" id="多个-actors-共享一个-handle">多个 Actors 共享一个 handle</a></h3>
<p>​	就像每个 Actor 可以共享多个 handle 一样，每个 handle 也可以共享多个  Actors 。 最常见的示例是在处理诸如 <code>TcpStream</code>之类的连接时，通常会产生两个任务：一个用于读，一个用于写。 使用此模式时，需要将读和写入任务变得尽可能简单——它们的唯一工作就是执行IO。 读任务会将接收到的所有消息发送给其他任务，通常是另一个 Actor ，而写任务会将接收到的所有消息转发给连接。 这种模式非常有用，因为它把与执行IO相关的复杂性隔离开来，这意味着其他程序部分可以假装将某些内容立即写入连接，尽管实际的写入其实是在 Actor 处理消息后进行的。</p>
<h2><a class="header" href="#当心循环" id="当心循环">当心循环</a></h2>
<p>​	我已经在<code>Actors 间发送信息</code> 标题下讨论了一些关于循环的问题，在此我讨论了如何关闭循环的Actors。但是，如何关闭并不是循环可能导致的唯一问题，因为这种循环还会产生死锁，循环中的每个 Actor 都在等待下一个 Actor 接收消息，但是下一个 Actor 直到它的下一个Actor接收到消息才会接收到该消息，依此类推。 为避免这种死锁，必须确保循环的信道容量都不受限。这样做的原因是有界信道上的 <code>send</code> 方法不会立即返回，而具有立即返回<code>send</code> 方法的信道是不记入这种循环，因为这种<code>send</code>方法是不会产生死锁的。 当心，这意味着<code>oneshot</code> 信道也不会产生死锁，因为它们也有 立即返回的 <code>send</code>  方法。还要当心，如果使用的是 <code>try_send</code> 而不是<code>send</code>来发送消息，那么这也不是死锁循环的一部分。 </p>
<p>感谢 <a href="https://matklad.github.io/">matklad</a>指出循环和死锁的问题。 </p>
<hr />
<p>译者简介：</p>
<p>Matrixtang，Rust/cpp 程序员，对编译相关领域感兴趣，不会 pwn 的安全爱好者。</p>
<h1><a class="header" href="#解读-rust-150-稳定版" id="解读-rust-150-稳定版">解读 Rust 1.50 稳定版</a></h1>
<p>作者：张汉东 / 后期编辑： 张汉东</p>
<hr />
<p>2021 年 2 月 11 号，<a href="https://blog.rust-lang.org/2021/02/11/Rust-1.50.0.html">Rust 1.50 稳定版发布</a>。1.50 版更新包括：</p>
<ul>
<li>语言级特性</li>
<li>编译器</li>
<li>标准库</li>
<li>稳定的 API </li>
<li>Cargo 相关</li>
<li>其他</li>
<li>兼容性提示</li>
</ul>
<p>以下挑一些重点讲解。</p>
<h1><a class="header" href="#语言级特性" id="语言级特性">语言级特性</a></h1>
<h3><a class="header" href="#a-hrefhttpsrust-langgithubiorfcs2000-const-genericshtml常量泛型-const-na-进一步得到完善" id="a-hrefhttpsrust-langgithubiorfcs2000-const-genericshtml常量泛型-const-na-进一步得到完善"><a href="https://rust-lang.github.io/rfcs/2000-const-generics.html">常量泛型 <code>[CONST; N]</code></a> 进一步得到完善：</a></h3>
<ul>
<li>常量泛型数组实现了 <code>ops::Index</code> 和 <code>ops::IndexMut</code>。</li>
<li>值重复的常量数组<code>[x; N]</code>现在支持 常量值作为 x ，无论 x 是否实现 <code>Copy</code>。</li>
</ul>
<p>Rust 有一种内置数组类型<code>[T; LEN]</code>，但是这个 <code>LEN</code>一直无法支持泛型，所以这类数组就沦为了二等公民。比如 <code>[0,0,0]</code>和<code>[0,0,0,0]</code>不是同一个类型。所谓一等公民应该是不管数组长度如何，至少可以用同一个类型表示。为了提升这个数组类型，就引入了常量泛型的支持。<code>[CONST; N]</code> 是从 1.38 版本开始筹划，在 Rust 1.38~1.46 版本内，引入了一个<code>std::array::LengthAtMost32</code>来限制默认<code>[T; LEN]</code>的长度不能超过 32 。到 Rust 1.47 版本，首次在内部引入了 <code>[CONST; N]</code> 的支持。</p>
<p>直到 <code>Rust 1.50 </code>版本，进一步对<code>[CONST; N]</code> 功能进行了完善。</p>
<p>对常量泛型数组实现了 <code>ops::Index</code> 和 <code>ops::IndexMut</code>：</p>
<pre><pre class="playground"><code class="language-rust">fn second&lt;C&gt;(container: &amp;C) -&gt; &amp;C::Output
where
    C: std::ops::Index&lt;usize&gt; + ?Sized,
{
    &amp;container[1]
}

fn main() {
    let array: [i32; 3] = [1, 2, 3];
    assert_eq!(second(&amp;array[..]), &amp;2); // 之前必须转成切片才可以
    assert_eq!(second(&amp;array), &amp;2); // 现在直接传引用就可以了
}
</code></pre></pre>
<p>值重复的常量数组<code>[x; N]</code>现在支持 常量值作为 x ：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 这行代码是不允许的，因为`Option&lt;Vec&lt;i32&gt;&gt;` 没有实现 `Copy`。
    let array: [Option&lt;Vec&lt;i32&gt;&gt;; 10] = [None; 10];

  	// 但是，现在改成 `const` 定义就可以了
    const NONE: Option&lt;Vec&lt;i32&gt;&gt; = None;
    const EMPTY: Option&lt;Vec&lt;i32&gt;&gt; = Some(Vec::new());

    // 虽然没有实现`Copy`，但是现在可以重复`const`的值了。
    let nones = [NONE; 10];
    let empties = [EMPTY; 10];
}
</code></pre></pre>
<p>这样写起来可能比较麻烦，但是在随后 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2920-inline-const.md">RFC 2920: inline const </a>功能稳定后，就可以写成下面这种形式了：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 这行代码是不允许的，因为`Option&lt;Vec&lt;i32&gt;&gt;` 没有实现 `Copy`。
    let array: [Option&lt;Vec&lt;i32&gt;&gt;; 10] = [None; 10];

    // 虽然没有实现`Copy`，但是现在可以重复`const`的值了。
    let nones : [Option&lt;Vec&lt;i32&gt;&gt;; 10] = [const {None}; 10];
    let empties : [Option&lt;Vec&lt;i32&gt;&gt;; 10]  = [const {Some(Vec::new())}; 10];
}
</code></pre></pre>
<p>其实可以 Rust 本可以做到下面这种形式：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 这行代码是不允许的，因为`Option&lt;Vec&lt;i32&gt;&gt;` 没有实现 `Copy`。
    let array: [Option&lt;Vec&lt;i32&gt;&gt;; 10] = [None; 10];

    // 虽然没有实现`Copy`，但是现在可以重复`const`的值了。
    let nones : [Option&lt;Vec&lt;i32&gt;&gt;; 10] = [None; 10];
    let empties : [Option&lt;Vec&lt;i32&gt;&gt;; 10]  = [Some(Vec::new()); 10];
}
</code></pre></pre>
<p>上面<code>None</code>和<code>Some(Vec::new())</code>可以自动被编译器提升为常量，但这样可能为用户带来困扰，对于一些不能被自动提升为常量的类型，还需要用户去学习一大堆<a href="https://github.com/rust-lang/const-eval/blob/master/promotion.md#promotability">常量提升规则</a>，并且使用 <code>const fn</code>等功能来定义常量。倒不如显示地加一个 const 块表达式来直接标注更好。</p>
<p>另外，关于<code>#![feature(min_const_generics)]</code><a href="https://github.com/rust-lang/rust/pull/79135">将在 Rust 1.51 中稳定</a>，预计 <code>2021-03-25</code>。</p>
<h3><a class="header" href="#将共用体union中a-hrefhttpsdocrust-langorgstablestdmemstructmanuallydrophtmlsearchmanualdropa类型字段的分配视为安全" id="将共用体union中a-hrefhttpsdocrust-langorgstablestdmemstructmanuallydrophtmlsearchmanualdropa类型字段的分配视为安全">将共用体(<code>union</code>)中<a href="https://doc.rust-lang.org/stable/std/mem/struct.ManuallyDrop.html?search="><code>ManualDrop</code></a>类型字段的分配视为安全</a></h3>
<pre><pre class="playground"><code class="language-rust">// Rust 1.49 新增特性，允许 union 中使用 ManuallyDrop
use core::mem::ManuallyDrop;

union MyUnion {
    f1: u32,
    f2: ManuallyDrop&lt;String&gt;,
}

fn main() {
    let mut u = MyUnion { f1: 1 };

    // These do not require `unsafe`.
    u.f1 = 2;
    u.f2 = ManuallyDrop::new(String::from(&quot;example&quot;));
}

</code></pre></pre>
<p>在<code>Union</code> 类型 中 <code>Copy</code>或<code>ManuallyDrop</code>的字段不会调用析构函数，所以不必加 <code>unsafe</code>块。</p>
<p>进一步，当 Drop 一个 Union 类型的时候，需要手工去实现 Drop。因为 共用体 本身的特性，它不会知道该 drop 哪个字段才是安全的，所以才需要字段都是 <code>Copy</code> 或 <code>ManuallyDrop</code>的。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(untagged_unions)]
use std::mem::ManuallyDrop;
use std::cell::RefCell;

union U1 {
    a: u8
}

union U2 {
    a: ManuallyDrop&lt;String&gt;
}

union U3&lt;T&gt; {
    a: ManuallyDrop&lt;T&gt;
}

union U4&lt;T: Copy&gt; {
    a: T
}

// 对于 ManuallyDrop 之外的 非 Copy 类型，目前还是 unstable，需要 `#![feature(untagged_unions)]` 特性门支持。
union URef {
    p: &amp;'static mut i32,
}

// RefCell 没有实现 Drop ，但是它是非 Copy 的
union URefCell { // field that does not drop but is not `Copy`, either
    a: (RefCell&lt;i32&gt;, i32),
}

fn generic_noncopy&lt;T: Default&gt;() {
    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };
    u3.a = ManuallyDrop::new(T::default()); // OK (assignment does not drop)
    
}

fn generic_copy&lt;T: Copy + Default&gt;() {
    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };
    u3.a = ManuallyDrop::new(T::default()); // OK
    
    let mut u4 = U4 { a: T::default() };
    u4.a = T::default(); // OK
}

fn main() {
    let mut u1 = U1 { a: 10 }; // OK
    
    u1.a = 11; // OK

    let mut u2 = U2 { a: ManuallyDrop::new(String::from(&quot;old&quot;)) }; // OK
    u2.a = ManuallyDrop::new(String::from(&quot;new&quot;)); // OK (assignment does not drop)

    let mut u3 = U3 { a: ManuallyDrop::new(0) }; // OK
    u3.a = ManuallyDrop::new(1); // OK

    let mut u3 = U3 { a: ManuallyDrop::new(String::from(&quot;old&quot;)) }; // OK
    u3.a = ManuallyDrop::new(String::from(&quot;new&quot;)); // OK (assignment does not drop)
    
}
</code></pre></pre>
<h1><a class="header" href="#编译器" id="编译器">编译器</a></h1>
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/78142">添加对<code>armv5te-unknown-linux-uclibcgnueabi</code>目标的内置支持</a>。 基于ARMv5TE指令集的，你可以认为是ARM处理器，但实际上已经有原来intel的很多技术在里面进行了修改。</li>
<li><a href="https://github.com/rust-lang/rust/pull/77484">在ARM Mac上添加对Arm64 Catalyst的支持</a>。苹果很快将发布基于ARM64的Mac，macOS应用将使用在ARM上运行的Darwin ABI。 该PR增加了对ARM Macs上Catalyst应用程序的支持：为darwin ABI编译的iOS应用程序。</li>
<li><a href="https://github.com/rust-lang/rust/pull/79484">修复 FreeBSD 上的链接问题</a>。在FreeBSD上，有时会出现一个问题，即使基本系统中包含<code>lld</code>，由于 Rust 未找到链接程序，链接 Rust 程序也会失败。 这似乎主要影响裸机/交叉编译，例如<code>wasm</code>构建和<code>arm / riscv</code>裸机工作（例如，尝试编译时）。 在<code>Linux</code>和其他操作系统上，启用了用于构建 Rust 的完整工具，因此没有链接问题。 如果使用这些选项正确构建了 Rust，则此PR应该可以在FreeBSD上启用完整的功能。</li>
</ul>
<p>除了这三个，还有其他 target 支持，查看<a href="https://forge.rust-lang.org/release/platform-support.html">Platform Support 页面</a>。</p>
<h1><a class="header" href="#标准库" id="标准库">标准库</a></h1>
<h3><a class="header" href="#a-hrefhttpsgithubcomrust-langrustpull78636为proc_macropunct增加-partialeqchar-a" id="a-hrefhttpsgithubcomrust-langrustpull78636为proc_macropunct增加-partialeqchar-a"><a href="https://github.com/rust-lang/rust/pull/78636">为<code>proc_macro::Punct</code>增加 <code>PartialEq&lt;char&gt; </code></a></a></h3>
<p>用于在宏中判断特殊标点符号更加方便。比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
else if let TokenTree::Punct(ref tt) = tree {
  if tt.as_char() == '$' {
    after_dollar = true;
    return None;
  }
  // ...
 if p.as_char() == '&gt;' { 
  // ...
if tt.as_char() == '=' { 
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#unix-平台优化optionfile-大小等价于-file" id="unix-平台优化optionfile-大小等价于-file">Unix 平台优化：<code>Option&lt;File&gt;</code> 大小等价于 <code>File</code></a></h3>
<p>在Unix平台上，Rust 的文件仅由系统的整数文件描述符组成，并且它永远不会为<code>-1</code>！ 返回文件描述符的系统调用使用<code>-1</code>表示发生了错误（检查errno），因此<code>-1</code>不可能是真实的文件描述符。 从<code>Rust 1.50</code>开始，此niche（特定生态场景）被添加到类型的定义中，因此它也可以用于布局优化。 因此，<code>Option &lt;File&gt;</code>现在将具有与<code>File</code>本身相同的大小！</p>
<h1><a class="header" href="#兼容性变更" id="兼容性变更">兼容性变更</a></h1>
<h3><a class="header" href="#a-hrefhttpsgithubcomrust-langrustpull79261过期-compare_and_swap-方法a" id="a-hrefhttpsgithubcomrust-langrustpull79261过期-compare_and_swap-方法a"><a href="https://github.com/rust-lang/rust/pull/79261">过期 compare_and_swap 方法</a></a></h3>
<p>推荐使用 <code>compare_exchange</code> 和 <code>compare_exchange_weak</code>。过期这个cas方法一方面是为了和<code> cpp</code> 的  <code>compare_exchange_strong</code> 和  <code>compare_exchange_weak</code> 对应，另一方面也是为了避免使用这个cas在 arm 架构下产生不必要的指令，因为有 cas 的时候，很多人可能会直接使用 cas，从而在 ARM 下产生不必要的指令。</p>
<blockquote>
<p>ARM 架构实现LL/SC对(load-linked/store-conditional) ，可以基于它们实现 cas。Load-linked（LL） 运算仅仅返回指针地址的当前变量值，如果指针地址中的内存数据在读取之后没有变化，那么 Store-conditional（SC）操作将会成功，它将LL读取 指针地址的存储新的值，否则，SC将执行失败。</p>
</blockquote>
<blockquote>
<p>通过LL/SC对实现的CAS并不是一个原子性操作，但是它确实执行了原子性的CAS，目标内存单元内容要么不变，要么发生原子性变化。由于通过LL/SC对实现的CAS并不是一个原子性操作，于是，该CAS在执行过程中，可能会被中断。因此<code>C++11</code>标准中添入两个<code>compare_exchange</code>原语: <code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>。即使当前的变量值等于预期值，这个弱的版本也可能失败，比如返回false。可见任何weak CAS都能破坏CAS语义，并返回false，而它本应返回true。而Strong CAS会严格遵循CAS语义。</p>
</blockquote>
<blockquote>
<p>何种情形下使用Weak CAS，何种情形下使用Strong CAS呢？通常执行以下原则：</p>
</blockquote>
<blockquote>
<p>倘若CAS在循环中（这是一种基本的CAS应用模式），循环中<strong>不存在</strong>成千上万的运算（循环体是轻量级和简单的），使用<code>compare_exchange_weak</code>。否则，采用强类型的<code>compare_exchange_strong</code>。</p>
</blockquote>
<p>因此，Rust 标准库过期 cas 方法，就是为了让开发者可以根据场景来判断使用 强还是弱的 cas 语义。而 标准库里的cas方法则只是对 <code>compare_exchange</code> 的包装，而 Rust 中 <code>compare_exchange</code> 对应 强CAS 语义，所以容易被滥用。</p>
<h3><a class="header" href="#a-hrefhttpsgithubcomrust-langrustpull78439放弃对所有-cloudabi-target-的支持a" id="a-hrefhttpsgithubcomrust-langrustpull78439放弃对所有-cloudabi-target-的支持a"><a href="https://github.com/rust-lang/rust/pull/78439">放弃对所有 cloudabi target 的支持</a></a></h3>
<p>包括：</p>
<ul>
<li>aarch64-unknown-cloudabi</li>
<li>armv7-unknown-cloudabi</li>
<li>i686-unknown-cloudabi</li>
<li>x86_64-unknown-cloudabi</li>
</ul>
<p>因为 <a href="https://github.com/NuxiNL/cloudabi#note-this-project-is-unmaintained">CloudABI 不再被维护了</a>，可以考虑 WASI 了，WASI 的一些概念就是受到 CloudABI 的启发，现在算是 CloudABI 的接班人了。</p>
<h1><a class="header" href="#解读-rust-2021-edition-rfc" id="解读-rust-2021-edition-rfc">解读 Rust 2021 Edition RFC</a></h1>
<p>作者/编辑：张汉东</p>
<hr />
<p>目前 Rust 2021 Edition 正在讨论中，<a href="https://github.com/rust-lang/rfcs/pull/3085">RFC 3085</a> 目前已经取代了 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2052-epochs.md">RFC 2052</a> 成为新的 RFC。</p>
<p><code>Edition</code> 在RFC 2052中提出，Rust在2018年发布了第一个 Edition版本。这项工作在许多方面都是成功的，但也带来了一些困难的教训。 RFC 3085 为 2021 Edition 提出了不同的模型。 需要注意的是，目前该 RFC 还未合并。</p>
<h3><a class="header" href="#2021-edition-模型讨论的关键点包括" id="2021-edition-模型讨论的关键点包括">「2021 Edition 模型」讨论的关键点包括：</a></h3>
<ul>
<li><code>Edition</code> 用于将语言引入更改，否则可能会破坏现有代码，例如引入新关键字。</li>
<li><code>Edition</code> 永远不允许分裂生态系统。 我们只允许不同版本的 crate 进行互操作的更改。</li>
<li><code>Edition</code> 以其出现的年份命名（例如，Rust 2015，Rust 2018，Rust 2021）。</li>
<li>发布新 <code>Edition</code> 时，我们还会发布工具以自动执行 crate 的迁移。 可能需要进行一些手动操作，但是这种情况很少见。</li>
<li>Nightly 工具链提供对即将发布的 <code>Edition</code> 的“预览”访问权限，以便我们可以随时进行针对将来 <code>Edition</code> 的工作。</li>
<li>我们维护一个《<code>Edition</code> 迁移指南》，其中提供了有关如何迁移到下一 <code>Edition</code> 的指南。</li>
<li>只要有可能，都应使新功能适用于所有 <code>Edition</code> 。</li>
</ul>
<p>该RFC旨在确立 <code>Edition</code> 的高级用途，并描述RFC对最终用户的感觉。 它有意避免进行详细的策略讨论，这些讨论将由相应的子团队（编译器，lang，开发工具等）来解决。</p>
<h3><a class="header" href="#目标与设计原则" id="目标与设计原则">目标与设计原则</a></h3>
<p>顺序代表优先级</p>
<ol>
<li><code>Edition</code>不能分裂生态系统。</li>
</ol>
<p>最重要的一条规则是：一个<code>Edition</code>中的 crate 可以与其他<code>Edition</code>中编译的 crate 无缝地互操作。不管<code>Edition</code>如何，所有 Rust 代码最终都会在编译器中编译为相同的内部 IR。</p>
<ol start="2">
<li><code>Edition</code> 迁移应该很方便且尽最大可能自动化完成。</li>
</ol>
<p>在发布新<code>Edition</code>的同时也会发布一些工具帮助自动升级<code>Edition</code>。并且维护《<code>Edition</code>迁移指南》以便手动迁移之需。</p>
<ol start="3">
<li>
<p>由用户来控制何时使用新的<code>Edition</code></p>
</li>
<li>
<p><code>Edition</code> 注定是要被使用的。目标是看到所有Rust用户都采用新<code>Edition</code>。</p>
</li>
<li>
<p>Rust 应该感觉像是一种语言，而非被 <code>Edition</code> 分割为多种“方言”。</p>
</li>
</ol>
<p><code>Edition</code>向 Rust 引入了向后不兼容的更改，从而又增加了 Rust 开始感觉像具有多种方言的语言的风险。 我们想要避免人们进入 Rust 项目的经历，并对给定的代码含义或可以使用的功能种类感到不确定。 这就是为什么我们更喜欢基于年份的版本（例如Rust 2018，Rust 2021），这些版本将许多更改组合在一起，而不是细粒度的选择加入; 可以简洁地描述基于年份的版本，并确保当您进入代码库时，相对容易地确定可以使用哪些功能。</p>
<h3><a class="header" href="#一些背景" id="一些背景">一些背景</a></h3>
<p>Rust 2018版在 RFC 2052中被描述为一个“集结点”，不仅引入了一些迁移，而且还是许多其他更改（例如更新本书，实现连贯的新API集等）的目标。这在很多方面都很有帮助，但在其他方面却是有害的。 例如，在是否有必要升级到新<code>Edition</code>以使用其功能方面存在一定的困惑（尚不清楚该困惑是否具有除困惑之外的其他负面影响）。 这也是组织本身将所有内容整合在一起的压力。 它与「火车模型」相反，后者旨在确保我们具有“低压力”发布。</p>
<p>相反，2021版故意是“低调”事件，其重点仅在于介绍已进行了一段时间的一些迁移，惯用法lint和其他工作。 我们没有将其与其他无关的更改进行协调。 这并不是说我们永远不应该再发布“集结点”。 但是，目前，我们在工作中并没有一整套协调一致的变化，我们需要将这些变化汇总在一起。</p>
<p>但是，由于此更改，Rust 2018的一项好处可能会丢失。 有一定比例的潜在Rust用户可能对Rust感兴趣，但兴趣不足以跟进每个<code>Edition</code>并跟踪发生了什么变化。 对于这些用户，一篇博客文章列出了Rust 2018以来发生的所有令人振奋的事情，足以说服他们尝试一下Rust。 我们可以通过发布回顾过去几年的回顾来解决这个问题。 但是，我们不必将此回顾与<code>Edition</code>联系在一起，因此，此RFC中未对此进行描述。</p>
<h3><a class="header" href="#小结-1" id="小结-1">小结</a></h3>
<p>通过以上内容，我想你应该对目前官方的 Rust 2021 Edition 工作内容有所了解。目前该 RFC 还在持续且激烈的讨论中，更多内容可以移步<a href="https://github.com/rust-lang/rfcs/pull/3085">该 RFC 的 PR</a>中参看。</p>
<p>在官方的 <a href="https://doc.rust-lang.org/edition-guide/rust-next/index.html">Edition Guide</a> 文档中，已经增加了 <a href="https://doc.rust-lang.org/edition-guide/rust-next/index.html#the-next-edition">Next Edition</a> 可能发布的功能集合，感兴趣可以自行关注。</p>
<h1><a class="header" href="#前端入门--rust-和-webassembly" id="前端入门--rust-和-webassembly">前端入门 ｜ Rust 和 WebAssembly</a></h1>
<p>作者: 陈鑫(lencx) / 后期编辑：张汉东</p>
<hr />
<h2><a class="header" href="#wasm是什么" id="wasm是什么">Wasm是什么?</a></h2>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/WebAssembly">MDN官方文档</a>是这样给出定义</p>
</blockquote>
<p><code>WebAssembly</code>(为了书写方便，简称<code>Wasm</code>)是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。</p>
<p>对于网络平台而言，WebAssembly具有巨大的意义——它提供了一条途径，以使得以各种语言编写的代码都可以以接近原生的速度在Web中运行。在这种情况下，以前无法以此方式运行的客户端软件都将可以运行在Web中。</p>
<p>WebAssembly被设计为可以和JavaScript一起协同工作——通过使用WebAssembly的JavaScript API，你可以把WebAssembly模块加载到一个JavaScript应用中并且在两者之间共享功能。这允许你在同一个应用中利用WebAssembly的性能和威力以及JavaScript的表达力和灵活性，即使你可能并不知道如何编写WebAssembly代码。</p>
<hr />
<h2><a class="header" href="#环境安装及简介" id="环境安装及简介">环境安装及简介</a></h2>
<h3><a class="header" href="#1-a-hrefhttpswwwrust-langorgzh-cnlearnget-startedrusta" id="1-a-hrefhttpswwwrust-langorgzh-cnlearnget-startedrusta">1. <a href="https://www.rust-lang.org/zh-CN/learn/get-started">Rust</a></a></h3>
<blockquote>
<p>一门赋予每个人<br />
构建可靠且高效软件能力的语言。</p>
</blockquote>
<p>安装</p>
<pre><code class="language-bash"># macOS
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 其他安装方式
# https://forge.rust-lang.org/infra/other-installation-methods.html
</code></pre>
<p>常用命令</p>
<pre><code class="language-bash"># 版本更新
rustup update

# 查看版本
cargo --version

# 构建项目
cargo build

# 运行项目
cargo run

# 测试项目
cargo test

# 为项目构建文档
cargo doc

# 将库发布到 crates.io
cargo publish
</code></pre>
<pre><code class="language-bash"># nightly rust
rustup toolchain install nightly

rustup toolchain list

rustup override set nightly
</code></pre>
<h3><a class="header" href="#2-a-hrefhttpsnodejsorgendownloadnodejsa" id="2-a-hrefhttpsnodejsorgendownloadnodejsa">2. <a href="https://nodejs.org/en/download">Node.js</a></a></h3>
<blockquote>
<p>Node.js是基于Chrome的V8 JavaScript引擎构建的JavaScript运行时</p>
</blockquote>
<h3><a class="header" href="#3-a-hrefhttpsgithubcomrustwasmwasm-packwasm-packa" id="3-a-hrefhttpsgithubcomrustwasmwasm-packwasm-packa">3. <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a></a></h3>
<blockquote>
<p>用于构建和使用您希望与JavaScript，浏览器或Node.js互操作的Rust生成的WebAssembly。</p>
</blockquote>
<p>安装</p>
<pre><code class="language-bash"># macOS
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# 其他安装方式
# https://rustwasm.github.io/wasm-pack/installer
</code></pre>
<p>常用命令</p>
<pre><code class="language-bash"># 创建
# https://rustwasm.github.io/docs/wasm-pack/commands/new.html
wasm-pack new &lt;name&gt; --template &lt;template&gt; --mode &lt;normal|noinstall|force&gt;

# 构建
# https://rustwasm.github.io/docs/wasm-pack/commands/build.html
wasm-pack build
  [--out-dir &lt;out&gt;]
  [--out-name &lt;name&gt;]
  [--&lt;dev|profiling|release&gt;]
  [--target &lt;bundler|nodejs|web|no-modules&gt;]
  [--scope &lt;scope&gt;]
  [mode &lt;normal|no-install&gt;]

# 测试
# https://rustwasm.github.io/docs/wasm-pack/commands/test.html
wasm-pack test

# 发包
# https://rustwasm.github.io/docs/wasm-pack/commands/pack-and-publish.html
# npm pack
wasm-pack pack
# npm publish
wasm-pack publish
</code></pre>
<h3><a class="header" href="#4-a-hrefhttpsvitejsdevvitea" id="4-a-hrefhttpsvitejsdevvitea">4. <a href="https://vitejs.dev">Vite</a></a></h3>
<blockquote>
<p>下一代前端工具</p>
</blockquote>
<p><strong><a href="https://github.com/lencx/vite-plugin-rsw">vite-plugin-rsw</a>：vite插件，简称<code>Rsw</code> - 集成<code>wasm-pack</code>的CLI</strong></p>
<ul>
<li>支持rust包文件热更新，监听<code>src</code>目录和<code>Cargo.toml</code>文件变更，自动构建</li>
<li>vite启动优化，如果之前构建过，再次启动<code>npm run dev</code>，则会跳过<code>wasm-pack</code>构建</li>
</ul>
<pre><code class="language-bash"># 在vite项目中安装
npm i -D vite-plugin-rsw
# or
yarn add -D vite-plugin-rsw
</code></pre>
<h3><a class="header" href="#5-a-hrefhttpsgithubcomlencxcreate-xc-appcreate-xc-appa" id="5-a-hrefhttpsgithubcomlencxcreate-xc-appcreate-xc-appa">5. <a href="https://github.com/lencx/create-xc-app">create-xc-app</a></a></h3>
<blockquote>
<p>脚手架 - ⚡️在几秒钟内创建一个项目！维护了多种项目模板。</p>
</blockquote>
<pre><code class="language-bash"># 根据命令行提示，输入项目名称，选择模板初始化项目
# template: `wasm-react` or `wasm-vue`
npm init xc-app
</code></pre>
<p><img src="chapter_2/./wasm_fronted/rust_wasm_frontend-xc-app.png" alt="xc-app" /></p>
<h2><a class="header" href="#快速开始" id="快速开始">快速开始</a></h2>
<ul>
<li>在原有<code>vite</code>项目中使用，只需安装配置<code>vite-plugin-rsw</code>插件即可。</li>
<li>新项目可以使用<code>vite</code>提供的<code>@vitejs/app</code>初始化项目，然后安装配置<code>vite-plugin-rsw</code>。</li>
<li>或者使用脚手架<code>create-xc-app</code>初始化项目，模板包含<code>wasm-react</code>和<code>wasm-vue</code>，会定期更新维护相关版本依赖。</li>
</ul>
<h3><a class="header" href="#项目结构" id="项目结构">项目结构</a></h3>
<pre><code class="language-bash"># 推荐目录结构
[my-wasm-app] # 项目根路径
|- [wasm-hey] # npm包`wasm-hey`
|    |- [pkg] # 生成wasm包的目录
|    |    |- wasm-hey_bg.wasm # wasm文件
|    |    |- wasm-hey.js # 包入口文件
|    |    |- wasm-hey_bg.wasm.d.ts # ts声明文件
|    |    |- wasm-hey.d.ts # ts声明文件
|    |    |- package.json
|    |    `- ...
|    |- [src] # rust源代码
|    | # 了解更多: https://doc.rust-lang.org/cargo/reference/cargo-targets.html
|    |- [target] # 项目依赖，类似于npm的`node_modules`
|    | # 了解更多: https://doc.rust-lang.org/cargo/reference/manifest.html
|    |- Cargo.toml # rust包管理清单
|    `- ...
|- [@rsw] # npm 组织包
|     |- [hey] # @rsw/hey, 目录结构同`wasm-hey`
|     `- ...
|- [node_modules] # 前端的项目包依赖
|- [src] # 前端源代码(可以是vue, react, 或其他)
| # 了解更多: https://nodejs.dev/learn/the-package-json-guide
|- package.json # `npm`或`yarn`包管理清单
| # 了解更多: https://vitejs.dev/config
|- vite.config.ts # vite配置文件
| # 了解更多: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html
|- tsconfig.json # typescript配置文件
` ...
</code></pre>
<p>乍一看，可能会觉得目录有点复杂，其实它就是一个标准的基于<code>vite</code>前端项目，然后，在根路径下去添加我们需要构建的wasm包(一个rust crate会对应生成一个wasm包，可单独发布到npm上)</p>
<h3><a class="header" href="#创建wasm包" id="创建wasm包">创建Wasm包</a></h3>
<pre><code class="language-bash"># 两种方式创建

# 1.
# 如果报错，可查看：https://github.com/rustwasm/wasm-pack/issues/907
wasm-pack new &lt;name&gt;

# 2.
# name可以是npm组织
# 例：cargo new --lib @rsw/hello
# 需要手动配置Cargo.toml
cargo new --lib &lt;name&gt;
</code></pre>
<p><img src="chapter_2/./wasm_fronted/rust_wasm_frontend-wasm-pack-new.png" alt="wasm-pack new" />
<img src="chapter_2/./wasm_fronted/rust_wasm_frontend-caro-new.png" alt="cargo new" /></p>
<h3><a class="header" href="#项目配置" id="项目配置">项目配置</a></h3>
<blockquote>
<p>以react项目为例</p>
</blockquote>
<p><strong>Step1: 配置Vite插件</strong> - <code>vite.config.ts</code></p>
<pre><code class="language-js">import reactRefresh from '@vitejs/plugin-react-refresh';
import { defineConfig } from 'vite';
import ViteRsw from 'vite-plugin-rsw';

export default defineConfig({
  plugins: [
    reactRefresh(),
    // 查看更多：https://github.com/lencx/vite-plugin-rsw
    ViteRsw({
      // 支持开发(dev)和生产模式(release)
      // 生产模式会对wasm文件的体积进行优化
      mode: &quot;release&quot;,
      // 如果包在`unLinks`和`crates`都配置过
      // 会执行，先卸载(npm unlink)，再安装(npm link)
      // 例如下面会执行
      // `npm unlink wasm-hey rsw-test`
      unLinks: ['wasm-hey', 'rsw-test'],
      // 项目根路径下的rust项目
      // `@`开头的为npm组织
      // 例如下面会执行:
      // `npm link wasm-hey @rsw/hey`
      // 因为执行顺序原因，虽然上面的unLinks会把`wasm-hey`卸载
      // 但是这里会重新进行安装
      crates: [&quot;wasm-hey&quot;, &quot;@rsw/hey&quot;],
    }),
  ],
})
</code></pre>
<p><strong>Step2: 配置Rust项目清单</strong> - <code>wasm-hey/Cargo.toml</code></p>
<pre><code class="language-toml"># ...

# https://github.com/rustwasm/wasm-pack/issues/886
# https://developers.google.com/web/updates/2019/02/hotpath-with-wasm
[package.metadata.wasm-pack.profile.release]
wasm-opt = false

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[profile.release]
opt-level = &quot;s&quot;

[dependencies]
wasm-bindgen = &quot;0.2.70&quot;
</code></pre>
<p><strong>Step3: 添加Rust代码</strong> - <code>wasm-hey/src/lib.rs</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

// Import the `window.alert` function from the Web.
#[wasm_bindgen]
extern &quot;C&quot; {
    fn alert(s: &amp;str);
}

// Export a `greet` function from Rust to JavaScript, that alerts a hello message.
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Step4: React项目中调用Wasm方法</strong> - <code>src/App.tsx</code></p>
<pre><code class="language-jsx">import React, { useEffect } from 'react';
import init, { greet } from 'wasm-hey';

import logo from './logo.svg';
import './App.css';

function App() {
  useEffect(() =&gt; {
    // wasm初始化，在调用`wasm-hey`包方法时
    // 必须先保证已经进行过初始化，否则会报错
    // 如果存在多个wasm包，则必须对每一个wasm包进行初始化
    init();
  }, [])

  const handleHey = () =&gt; {
    // 调用greet方法
    greet('wasm');
  }

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;header className=&quot;App-header&quot;&gt;
        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;
        &lt;p&gt;Hello WebAssembly!&lt;/p&gt;
        &lt;p&gt;Vite + Rust + React&lt;/p&gt;
        &lt;p&gt;
          &lt;button onClick={handleHey}&gt;hi wasm&lt;/button&gt;
        &lt;/p&gt;
        &lt;p&gt;Edit &lt;code&gt;App.tsx&lt;/code&gt; and save to test HMR updates.&lt;/p&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  )
}

export default App
</code></pre>
<h2><a class="header" href="#常见问题汇总" id="常见问题汇总">常见问题汇总</a></h2>
<h3><a class="header" href="#rsw插件" id="rsw插件">Rsw插件</a></h3>
<ul>
<li>插件内部是通过<code>npm link</code>的形式实现的wasm包安装，在一些极端场景下会出现，找不到依赖的安装包，导入的包不存在等错误，可以根据提示路径删除其link的文件，重新启动<code>npm run dev</code>可以解决。</li>
<li><code>npm link</code>命令会把包<code>link</code>到全局环境，如果在多个项目使用相同wasm包名，可能会导致报错，解决办法，在全局npm的<code>node_modules</code>中删除该包即可。推荐不同项目使用不同wasm包名避免此类异常。</li>
<li>插件是处于Vite开发模式下运行构建，所以至少执行过一次<code>npm run dev</code>，生成<code>wasm</code>包之后，再执行<code>npm run build</code>，否则也会报错，到不到<code>.wasm</code>文件之类的。</li>
<li>插件API可以配置需要卸载的包(仅限于之前通过插件配置<code>crates</code>中rust项目)</li>
</ul>
<h3><a class="header" href="#前端" id="前端">前端</a></h3>
<pre><code class="language-js">// init是wasm实例的初始化方法
// 在调用其他方法之前，必须先调用一次init方法，否则会报错
// init会请求`.wasm`文件并且返回一个`Promise`
import init, { greet } from 'wasm-test';

// -----------------------------------------

// 调用init方法，有两种方式

// 1.
// 在react，vue3中可以将其抽离为`hook`组件,
// 在进入生命周期时调用
init();

// 在调用过init方法之后，可以单独调用greet方法
greet('wasm');

// 2.
// 在初始化之后直接调用方法
init()
  .then(wasm =&gt; wasm.greet('wasm'));
</code></pre>
<hr />
<h2><a class="header" href="#相关链接" id="相关链接">相关链接</a></h2>
<ul>
<li><a href="https://github.com/lencx/learn-wasm">Wasm学习项目: lencx/learn-wasm</a></li>
<li><a href="https://github.com/lencx/vite-plugin-rsw">Vite插件Rsw - lencx/vite-plugin-rsw</a></li>
<li><a href="https://github.com/lencx/create-xc-app">项目脚手架 - lencx/create-xc-app</a></li>
<li><a href="https://mtc.nofwl.com/awesome/wasm.html">WebAssembly相关资源清单</a></li>
</ul>
<hr />
<ul>
<li><a href="https://webassembly.org">WebAssembly官网</a></li>
<li><a href="https://www.rust-lang.org">Rust官网 - 一门赋予每个人 构建可靠且高效软件能力的语言</a></li>
<li><a href="https://nodejs.org">Nodejs官网 - 基于Chrome的V8 JavaScript引擎构建的JavaScript运行时</a></li>
<li><a href="https://vitejs.dev">Vite官网 - 下一代前端工具</a></li>
<li><a href="https://rustwasm.github.io/wasm-pack">wasm-pack - Rust =&gt; WebAssembly</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm">rust-to-wasm</a></li>
<li><a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a></li>
</ul>
<hr />
<p>作者简介：</p>
<p>陈鑫(lencx)</p>
<p>{折腾 ⇌ 迷茫 ⇌ 思考]ing，在路上...</p>
<ul>
<li>公众号：浮之静</li>
<li>Blog: https://mtc.nofwl.com</li>
<li>GitHub: https://github.com/lencx</li>
</ul>
<h1><a class="header" href="#实践案例--使用-bevy-游戏引擎制作炸弹人" id="实践案例--使用-bevy-游戏引擎制作炸弹人">实践案例 | 使用 Bevy 游戏引擎制作炸弹人</a></h1>
<p>作者：Cupnfish / 后期编辑：张汉东</p>
<hr />
<h3><a class="header" href="#目录-1" id="目录-1">目录</a></h3>
<ul>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B--%E4%BD%BF%E7%94%A8-bevy-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%88%B6%E4%BD%9C%E7%82%B8%E5%BC%B9%E4%BA%BA">实践案例 | 使用 Bevy 游戏引擎制作炸弹人</a>
<ul>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B">引擎简介</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E5%BC%80%E5%8F%91%E5%8A%A8%E6%9C%BA">开发动机</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#rust-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%8E%A8%E4%BB%8B">Rust 开发环境推介</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6">编译速度</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#query-filter">Query filter</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#queryset">QuerySet</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#event">Event</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#timer">Timer</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#system%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8"><code>system</code>的链接与代码复用</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81">如何实现游戏的不同状态</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#rapier%E7%AE%80%E7%9F%AD%E7%AC%94%E8%AE%B0">Rapier简短笔记</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E9%80%9A%E8%BF%87rapier%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%A2%B0%E6%92%9E%E8%BF%87%E6%BB%A4">通过Rapier来实现碰撞过滤</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81">多平台支持</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E6%97%A5%E5%BF%97">日志</a></li>
<li><a href="chapter_2/rust_game_bevy_bomber.html#%E7%A2%8E%E7%A2%8E%E5%BF%B5">碎碎念</a></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#引擎简介" id="引擎简介">引擎简介</a></h3>
<p>Bevy 是一款由Rust语言构建且简单明了的数据驱动的游戏引擎,永远开源免费! </p>
<p>它的设计目标如下:</p>
<ul>
<li>功能:提供完整的2D和3D功能集</li>
<li>简单:对于新手来说很容易上手，但是对于高级用户来说非常灵活</li>
<li>以数据为中心:使用实体组件系统范式的面向数据的体系结构</li>
<li>模块化:只使用你需要的。替换掉你不喜欢的东西</li>
<li>快速:应用逻辑应该快速运行，并且在可能的情况下并行运行</li>
<li>高效:变更应该能够快速编译…等待不是有趣的</li>
</ul>
<p><a href="https://bevyengine.org/">官网了解更多</a>: https://bevyengine.org/</p>
<h3><a class="header" href="#前言-1" id="前言-1">前言</a></h3>
<p><a href="https://github.com/rgripper/rusty-bomber">Rusty BomberMan</a>是著名的BomberMan小游戏的bevy复刻版。虽然说是复刻，但实际上和原本游戏长得完全不一样，原因是原版游戏的美术资源没搞到，所以另找了一些美术资源，十分感谢<a href="https://opengameart.org/">opengameart.org</a>上<a href="https://github.com/rgripper/rusty-bomber#assets-and-attribution">这些</a>美术资源。</p>
<blockquote>
<p>Changed: 1. 修正了之前刚体类型使用场景 2. 添加了目录，方便直接跳转想要阅读的内容。 3. 末尾加上了本人联系方式。 4. 原<code>Rapier</code>部分拆分成两个部分，更方便查阅。 5. 修正部分语句不通顺的地方。</p>
</blockquote>
<h3><a class="header" href="#开发动机" id="开发动机">开发动机</a></h3>
<p>开发这个游戏的起因是当时我正在逛reddit，正好看到了<a href="https://github.com/rgripper">@rgripper</a>发帖想找人一起写bevy项目，抱着学习、实践的心态，我和他联系之后一拍即合，随即开始了这个项目。</p>
<h3><a class="header" href="#rust-开发环境推介" id="rust-开发环境推介">Rust 开发环境推介</a></h3>
<p>开发中使用最新版rust（建议nightly版本，bevy官网的快速开发迭代有推介用这个）。</p>
<p>开发环境推介 <code>vscode</code> + <a href="https://github.com/rust-analyzer/rust-analyzer"><code>rust-analyzer</code></a>（建议安装最新发布版，尽量别用nightly版本，我喜欢自己下载源码编译。） + <a href="https://www.tabnine.com/"><code>Tabline</code></a>（可选），或者<code>Clion</code> + <a href="https://www.jetbrains.com/rust/"><code>IntelliJ Rust</code></a>。
前者可能需要自己折腾，后者开箱即用，不过<code>Clion</code>不是免费的。</p>
<h3><a class="header" href="#编译速度" id="编译速度">编译速度</a></h3>
<p>bevy的官网中有提到其编译速度很快，其中0.4版本发布的时候，由于添加了动态链接的feature，增量编译的编译速度确实快了几倍，但是需要进行一系列的配置。</p>
<p>rust本身的编译速度实在不能说快，但在使用bevy进行开发迭代过程中，配置好快速编译的开发环境后，增量编译的速度令人十分满意。</p>
<p>我笔记本的配置是：</p>
<ul>
<li>处理器	Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz   2.81 GHz</li>
<li>机带 RAM	16.0 GB (15.9 GB 可用)</li>
</ul>
<p>在开启动态链接的feature进行编译的情况下，每次增量编译的时间大概2.5秒左右，加入其它大型依赖之后，比如<code>bevy_rapier</code>，增量编译的速度会变长，但是仍然在可接受范围内，约3.5秒。在这次开发过程中，项目编译速度我很满意，开发体验十分良好。</p>
<p>那么如何搭建一个快速编译的开发环境呢？</p>
<p>官网里有详细的介绍了如何搭建一个快速开发环境：https://bevyengine.org/learn/book/getting-started/setup/ （在最后的<code>Enable Fast Compiles (Optional)</code>部分）</p>
<p>在搭建环境的过程中,可能会出现一些奇怪的问题，比如这个：</p>
<pre><code>error: process didn't exit successfully: `target\debug\bevy_salamanders.exe` (exit code: 0xc0000139, STATUS_ENTRYPOINT_NOT_FOUND)
</code></pre>
<p>解决方法是把该游戏项目下的<code>.cargo/config.toml</code>文件中这行改了：</p>
<pre><code class="language-toml">#before: 
[target.x86_64-pc-windows-msvc]
linker = &quot;rust-lld.exe&quot;
rustflags = [&quot;-Zshare-generics=y&quot;]
#after:
[target.x86_64-pc-windows-msvc]
linker = &quot;rust-lld.exe&quot;
rustflags = [&quot;-Zshare-generics=off&quot;]
</code></pre>
<p>改了之后如果还有类似的奇怪错误，可以试着把<code>.cargo</code>这个文件夹直接删除，只使用动态链接就行，动态链接对编译速度提升是远远大于切换linker的。还有其它奇怪的没法解决的错误的话，那可以去提issue了。</p>
<p>除此之外，每次运行的时候带一个<code>--features bevy/dynamic</code>也很麻烦，我喜欢在<code>cargo.toml</code>内部添加两个bevy，平时开发的时候注释掉另一个，直到要发布最终版本的时候才替换成另一个，大概像这样：</p>
<pre><code class="language-toml">bevy = { version=&quot;0.4&quot;, features = [&quot;dynamic&quot;] }
# bevy = &quot;0.4&quot; 
</code></pre>
<p>下面的这个平时注释掉，只有当要发布最终版的时候，才把上面的注释掉，切换成下面的这个。平时开发过程中基本是直接<code>cargo run</code>就可以了。</p>
<h3><a class="header" href="#query-filter" id="query-filter">Query filter</a></h3>
<p>Bevy内部提供了不少查询过滤器，0.4版本更新之后也更好用，易读性得到了提高。</p>
<p>大致用法如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn movement_system(
    query:Query&lt;(要查询的组件),(查询的过滤器)&gt;，
    mut example_query:Query&lt;&amp;mut Transform,With&lt;Player&gt;&gt;
){
    for item in query.iter(){
        // 对查询内容进行操作
    }
    for mut transform in example_query.iter_mut() {
        // 就和迭代器一样使用
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>常见的过滤器有<code>With&lt;T&gt;</code>,<code>Without&lt;T&gt;</code>,<code>Added&lt;T&gt;</code>,<code>Changed&lt;T&gt;</code>,<code>Mutated&lt;T&gt;</code>，<code>Or&lt;T&gt;</code>，其中<code>Mutated</code>是<code>Added</code>和<code>Changed</code>的集合，也就是说新添加的和改变了的都可以用<code>Mutated</code>来查到，而<code>Added</code>只查询新添加的组件，<code>Changed</code>只查询已经存在的组件中更改过的组件，这里面<code>Or</code>又比较特殊，使用其它几个过滤器基本都是减小查询范围，而使用<code>Or</code>却可以扩大过滤的范围，比如查询玩家和生物的位置与速度，就可以这样定义查询：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Query&lt;(&amp;Transform,&amp;Speed),Or&lt;(With&lt;Player&gt;,With&lt;Creature&gt;)&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>查询多于一个组件的时候需要用括号括起来，将多个组件作为一个元组进行参数传递,同样多个过滤器也以元组的形式传参。当然使用到Or，通常会和Option一起使用，比如既想查询玩家和生物的位置和速度，还想专门查询玩家专属的组件，玩家的力量，就可以这样写查询器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Query&lt;(&amp;Transform,&amp;Speed,Option&lt;&amp;PlayerPower&gt;),Or&lt;(With&lt;Player&gt;,With&lt;Creature&gt;)&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<p>这样查询出来的结果带有<code>PlayerPower</code>的肯定是玩家，使用惯用的rust方式处理option就可以了。</p>
<h3><a class="header" href="#queryset" id="queryset">QuerySet</a></h3>
<p>当一个<code>system</code>中的查询相互冲突时，编译后运行会触发一个<code>panic</code>：<code>xxx has conflicting queries</code>。这个时候就需要<code>QuerySet</code>来帮助我们了。</p>
<blockquote>
<p>关于心智负担，我个人观点是写这部分代码时，完全不用带着审视的目光去查看所有的查询，只有在发生这种<code>panic</code>的时候，再去审视相关代码，将冲突的部分替换成<code>QuerySet</code>就可以了，正好对应rust中诸如所有权、生命期等情况。</p>
</blockquote>
<blockquote>
<p>Note：关于哪些情况属于查询冲突，其实很好判断，在同一系统，多次可能查到同一结果的查询中，存在对组件的可变引用查询，那这个查询就是冲突的。</p>
</blockquote>
<p>比如以下两个查询：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn position(
    mut q0: Query&lt;(&amp;Transform, &amp;mut Point)&gt;,
    q1: Query&lt;&amp;Transform, Or&lt;(With&lt;Point&gt;, With&lt;Head&gt;)&gt;&gt;,
){
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>同时查询了<code>Transform</code>和<code>Point</code>,并且，<code>q1</code>很有可能查到<code>q0</code>的结果，但是因为重复查询的组件<code>Transform</code>没有可变引用，所以这两个查询放在一个系统内，并不会发生冲突。</p>
<p>而以下两个查询：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn position(
    mut q0: Query&lt;(&amp;mut Transform, &amp;Point)&gt;,
    q1: Query&lt;&amp;Transform, Or&lt;(With&lt;Point&gt;, With&lt;Head&gt;)&gt;&gt;,
){
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>因为重复查询的组件<code>Transform</code>是有可变引用的，所以会发生冲突。</p>
<p>发生查询冲突之后，就是<code>QuerySet</code>大展身手的地方了。</p>
<p>考虑以下两个组件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Head;

pub struct Point {
    pub pre: Entity,
}
<span class="boring">}
</span></code></pre></pre>
<p>假设我们需要写一个系统，让每一个点的位置根据前一个实体的位置而改变，可以有以下系统：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn position(
    mut q0: Query&lt;(&amp;mut Transform, &amp;Point)&gt;,
    q1: Query&lt;&amp;Transform, Or&lt;(With&lt;Point&gt;, With&lt;Head&gt;)&gt;&gt;,
) {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>我们甚至没有给这个系统实现任何功能，直接添加到<code>App</code>中运行的话，就会直接触发查询冲突。</p>
<p>而使用<code>QuerySet</code>的话，也十分简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn position(
    points_query: QuerySet&lt;(
        Query&lt;(&amp;mut Transform, &amp;Point)&gt;,
        Query&lt;&amp;Transform, Or&lt;(With&lt;Point&gt;, With&lt;Head&gt;)&gt;&gt;,
    )&gt;,
) {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>在没有实现任何内容的情况下添加到<code>App</code>中运行，能够正常运行。使用起来也十分方便，只需要将之前的查询以元组的形式当作泛型传到<code>QuerSet</code>中即可。</p>
<p>那实现具体的内容呢？
如果不使用<code>QuerySet</code>我们实现的内容看起来应该是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn position(
    q0: Query&lt;(&amp;mut Transform, &amp;Point)&gt;,
    q1: Query&lt;&amp;Transform, Or&lt;(With&lt;Point&gt;, With&lt;Head&gt;)&gt;&gt;,
) {
    for (mut transform, point) in q0.iter_mut() } {
        if let Ok(pre_transform) = q1.get(point.pre)  {
            *transform = Transform::from_translation(
                pre_transform.translation - Vec3::new(1.0, 1.0, 0.0)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>那么使用<code>QuerySet</code>之后，我们的内容应该是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn position(
    mut points_query: QuerySet&lt;(
        Query&lt;(&amp;mut Transform, &amp;Point)&gt;,
        Query&lt;&amp;Transform, Or&lt;(With&lt;Point&gt;, With&lt;Head&gt;)&gt;&gt;,
    )&gt;,
) {
    for (mut transform, point) in points_query.q0_mut().iter_mut() {
        if let Ok(pre_transform) = points_query.q1().get(point.pre) {
            *transform = Transform::from_translation(
                pre_transform.translation - Vec3::new(1.0, 1.0, 0.0) * 30.0,
            )
        } else {
            warn!(&quot;not find right transform!&quot;);
        }
    }  
}
<span class="boring">}
</span></code></pre></pre>
<p>我们还没有运行我们的代码，<code>rust-analyzer</code>就已经给我们报错了，我们在<code>q0_mut()</code>这里将<code>points_query</code>的<code>&amp;mut</code>引用传了进去，按照借用规则，后续不能再把<code>points_query</code>的指针借用出去了，所以在这里我们就需要使用<code>unsafe</code>了。</p>
<p>添加<code>unsafe</code>之后我们的代码变成这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn position(
    mut points_query: QuerySet&lt;(
        Query&lt;(&amp;mut Transform, &amp;Point)&gt;,
        Query&lt;&amp;Transform, Or&lt;(With&lt;Point&gt;, With&lt;Head&gt;)&gt;&gt;,
    )&gt;,
) {
    // Safety: 一般调用unsafe时，情况复杂的需要写下相关注释
    for (mut transform, point) in unsafe { points_query.q0().iter_unsafe() } {
        if let Ok(pre_transform) = points_query.q1().get(point.pre)  {
            *transform = Transform::from_translation(
                pre_transform.translation - Vec3::new(1.0, 1.0, 0.0) * 30.0,
            )
        } else {
            warn!(&quot;not find right transform!&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>bevy几乎所有的<code>unsafe</code>都贴心的写出了<code>Safety</code>，使用这部分api时的内存安全由使用者来保证，而使用者只需要判断自己的调用情况是否符合<code>Safety</code>的要求，就能判断这个调用是否满足内存安全。比如该处的<code>Safety</code>要求就是这样的：</p>
<blockquote>
<p>This allows aliased mutability. You must make sure this call does not result in multiple mutable references to the same component</p>
</blockquote>
<p>我们已经能够明确，我们的两次查询，不会造成查询结果中，存在同一个组件的多个包含可变引用的引用，所以在这里调用该<code>unsafe</code>函数是<code>Safety</code>的！</p>
<p>当你把借用的问题处理好之后，再次运行我们的<code>App</code>，就一切如你所愿了。</p>
<p>谈谈<code>QuerySet</code>的体验，因为<code>rust-analyzer</code>对过程宏生成的Api支持不是很友好，对类似由宏生成的Api的代码补全体验可以说是很糟糕。而且出于减少总编译时间的考虑，这部分的过程宏只预备了五个参数的位置，也就说说除了<code>q0</code>到<code>q4</code>多出<code>q4</code>的部分，这个过程宏是没有预先生成相关函数的。当然我相信在实际应用的过程中，很少有出现这么极端的查询情况。总得来说掌握这个Api的使用并不难，而且在生产过程中也很实用。</p>
<h3><a class="header" href="#event" id="event">Event</a></h3>
<p>0.4版本的bevy的<code>event</code>有个十分不好用的地方，看以下示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn game_events_handle(
    game_events: Res&lt;Events&lt;GameEvents&gt;&gt;,
    mut events_reader: Local&lt;EventReader&lt;GameEvents&gt;&gt;,
) -&gt; Result&lt;()&gt; {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>可能只看函数参数并不能感受到哪里不好用，可是如果你注意到这是一个事件处理系统，传递进来的参数居然同时需要<code>Events</code>和<code>EventReader</code>，并且使用的时候是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for event in events_reader.iter(&amp;game_events) {
        match event {
            ...
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>没错，<code>EventReader</code>不是一个真正的迭代器，在调用<code>iter()</code>的时候需要传递一个该事件的引用，这在使用的过程中感受到多余。</p>
<p>好在<code>EventReader</code>在即将要发布的0.5版本当中已经得到了改善，在这个<a href="https://github.com/bevyengine/bevy/pull/1244">PR</a>合并之后，<code>EventReader</code>的调用已经变成了这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn game_events_handle(
    // 不再需要多余的Events作为EventReader参数
    // game_events: Res&lt;Events&lt;GameEvents&gt;&gt;,
    // mut events_reader: Local&lt;EventReader&lt;GameEvents&gt;&gt;,
    // 不再需要指定Local，EventReader在Bevy中已经变成了更高级别的API
    mut events_reader: EventReader&lt;GameEvents&gt;,
) -&gt; Result&lt;()&gt; {
    // 变得更像真实的迭代器
    for event in events_reader.iter() {
        match event {
            ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>需要注意的是，不仅仅是<code>EventReader</code>变成了更高级别的API（即成为真正的系统参数），<code>Events</code>也同样不再需要在其外部套一个<code>ResMut</code>了，写系统时直接写<code>Events&lt;T&gt;</code>作为参数。</p>
<blockquote>
<p>可以这样改动的原因：之前的<code>Events</code>是作为<code>Resource</code>使用的，也就是说存在<code>Res</code>、<code>ResMut</code>两种状态。其中<code>Res&lt;Events&lt;T&gt;&gt;</code>只有给旧版的<code>EventReader</code>当作参数的存在意义，但是新版的<code>EventReader</code>已经不再需要这个参数，<code>Res</code>版本的<code>Events</code>失去了其存在意义，因此相对于<code>ResMut&lt;Events&lt;T&gt;&gt;</code>，索性改成了<code>Events&lt;T&gt;</code>，减少了用户API层面的复杂性。</p>
</blockquote>
<h3><a class="header" href="#timer" id="timer">Timer</a></h3>
<p>bevy现版本的<code>Timer</code>是个值得争议的地方，先来看看具体用法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定义一个动画计时器组件：
pub struct Animation(pub Timer);
// 作为Player实体的组件添加到Player中：
#[derive(Bundle)]// 使用Bundel派生宏可以将多个组件打包到一块，bevy官方指南也推介这样做，性能上似乎也比直接使用with更好
pub struct PlayerBundle {
    player: Player,
    animation: Animation,
    ...//省略了其它组件
}
// 初始化PlayerBundle
impl Default for PlayerBundle {
    fn default() -&gt; Self {
        Self {
            player: Player,
            animation: Animation(Timer::from_seconds(0.3, true)),
            ...//省略了其它组件
        }
    }
}
// Timer 在实例化的时候需要提供两个参数，一个是计时器计时的时间，另一个是该计时器是否重复计时。
// 查询计时器进行相关修改：
fn player_animation(
    time: Res&lt;Time&gt;,// 使用计时器时必须用到时间去tick计时器
    mut query: Query&lt;(&amp;mut Animation,&amp;Player)&gt;,
) {
    for (mut animation,player) in query.iter_mut(){
        animation.0.tick(time.delta_seconds());
        // animation.0是因为我们将Timer包裹在了Animation下
        if animation.0.just_finished() {
            ...// 相关操作
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以上基本就是计时器在使用时的流程，现在来回答几个问题。</p>
<ul>
<li>为什么要使用一个结构体去包裹已有的计时器？</li>
</ul>
<blockquote>
<p>大家应该注意到我们没有直接将计时器作为组件附加到<code>Player</code>上，而是通过一个结构体去包裹计时器之后再附加到<code>Player</code>上，这样做的其中一个原因是我们的<code>Player</code>实体可能需要不止一个计时器，所以我们需要给每个计时器不同的标识。</p>
</blockquote>
<ul>
<li>为什么在调用计时器的<code>finished()</code>等相关计时API之前需要先调用<code>tick(time.delta_seconds())</code>?</li>
</ul>
<blockquote>
<p>bevy的计时器本身相当于一个保存有当前时间量的结构体，本身没有时间流动的概念，只有tick的时候告诉它已经过去了多少时间，它才会把过去了多少时间加到它本身保存的状态上。</p>
</blockquote>
<p><code>Timer</code>比较有争议的地方就是使用计时器时不能十分容易的给它添加标识，需要在计时器外部套一个结构体，目前有些<a href="https://github.com/bevyengine/bevy/pull/1151">PR</a>提出了给<code>Timer</code>增加一个泛型的位置的想法，我个人不是很喜欢这种实现，理由很多，比如<code>@cart</code>大大的理由就是bvey内部有不少不需要特殊标识的计时器，如果添加泛型之后需要这样写：<code>Timer&lt;()&gt;</code>，相对于之前的<code>Timer</code>来说，实在是太丑了。</p>
<p>出了标识的问题，还有目前的计时器使用的<code>f32</code>类型，应该替换成时间更常用的<code>Duration</code>，刚刚提到的PR在这个方面就已经完成了。</p>
<h3><a class="header" href="#system的链接与代码复用" id="system的链接与代码复用"><code>system</code>的链接与代码复用</a></h3>
<p>之前<code>Events</code>部分有个系统例子和其它常规例子不一样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn game_events_handle(
    mut events_reader: EventReader&lt;GameEvents&gt;,
) -&gt; Result&lt;()&gt; {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>它拥有一个<code>Result</code>返回值，如果直接将这个系统添加到<code>App</code>中，会被<code>rust-analyzer</code>直接报错，因为bevy不支持带有返回值的系统。</p>
<p>那如何让带有返回值的系统添加到<code>App</code>中去呢？当然是处理掉它的返回值，bevy给我们提供了一个<code>fn chain(self, system: SystemB)</code>函数，调用的时候大概像下面这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .add_system(game_events_handle.system().chain(error_handler.system()))
<span class="boring">}
</span></code></pre></pre>
<p>它可以‘无限续杯’，只要你愿意，你可以无限<code>chain</code>下去。</p>
<p>那如何写一个可以<code>chain</code>的系统呢？考虑以下系统</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn head_translation(query: Query&lt;&amp;Transform, With&lt;Head&gt;&gt;) -&gt; Option&lt;Vec3&gt; {
    query.iter().map(|transform| transform.translation).next()
}
<span class="boring">}
</span></code></pre></pre>
<p>该系统返回一个<code>Option&lt;Vec3&gt;</code>，因此能够处理该返回值的系统应该要带有一个<code>In&lt;Option&lt;Vec3&gt;&gt;</code>的参数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn head_translation_handle(come_in: In&lt;Option&lt;Vec3&gt;&gt;) -&gt; Option&lt;Vec3&gt; {
    if let In(Some(vec)) = come_in {
        Some(vec + Vec3::new(1.0, 1.0, 0.0) * 30.0)
    } else {
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>出于教学目的，这里没有直接处理本不需要再返回出去的<code>Option&lt;Vec3&gt;</code>，而是为了验证多次链接是否有用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn body_point_translation_handle(
    come_in: In&lt;Option&lt;Vec3&gt;&gt;,
    mut query: Query&lt;&amp;mut Transform, With&lt;BodyPoint&gt;&gt;,
) {
    if let In(Some(vec)) = come_in {
        for mut transform in query.iter_mut() {
            transform.translation = vec;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>没错，在每次链接的时候，你可以添加新的参数，这种设计大大增加代码的灵活性，同时也提高了代码复用率。</p>
<p>这是bevy中我很喜欢的一个功能，既实用又灵活。虽然在本次项目中用到的地方不多，基本都用来做错误处理了，但是我相信在一个大型项目中，这种功能够充分发挥出它的优势，大概就是bevy中各处都彰显着类似这样设计的人体工程学，因此大家才为之感到兴奋。</p>
<p>当然上面的代码可能有些地方让有强迫症的人感到不适，比如传出来的结果为啥是<code>Option</code>的，这样如果这个系统返回<code>None</code>的时候仍然一直在游戏中运行会不会很占资源？确实是会有这方面的考虑，所以现在已经有<a href="https://github.com/bevyengine/bevy/pull/1393">PR</a>提出了异步系统的概念，如果真的实现出来的话，应该来大大减缓这种情况，编写出来的代码估计也会好看一些。</p>
<h3><a class="header" href="#如何实现游戏的不同状态" id="如何实现游戏的不同状态">如何实现游戏的不同状态</a></h3>
<p>我们的项目中实现了一个完整的游戏流程，包括开始游戏的菜单界面，游戏内部的暂停，玩家被炸弹炸死或者被生物触碰时的失败，以及玩家找到下一关的入口之后的胜利。如果有体验过我们的游戏，会发现关卡基本没有设计，仅仅只是实现了游戏中各种道具的效果，包括第一关与第二关的区别也仅仅是多了几只怪。作为游戏而言，我是对这部分的实现是很不满意的，但是作为体验、学习bevy而言，我觉得收获良多。我甚至还保留了一个随机的关卡实现接口，只不过没有真的去实现，roguelike的相关算法此前我都没有什么经验，只希望下一个项目能够在这方面得到提升。</p>
<p>回到正题，为了实现这样一个完整的游戏流程，我参考了<a href="https://github.com/Bobox214/Kataster">Kataster</a>的相关代码，将游戏整体流程放在了<code>AppState</code>这个枚举体内：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AppState {
    StartMenu,
    Game,
    Temporary,
}
<span class="boring">}
</span></code></pre></pre>
<p>看上去我们的游戏有<code>StartMenu</code>、<code>Game</code>、<code>Temporary</code>三个状态，实际上只需要考虑前两个状态就好了，<code>Temporaty</code>这个状态只是为了方便修复游戏中的一个小bug而已。</p>
<p>通常构建一个游戏的状态需要以下四个步骤：</p>
<p>1.将我们的游戏状态以资源的方式添加到游戏中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>app.add_resource(State::new(AppState::StartMenu))
// 添加游戏状态资源时，需要特意指明初始化的状态，比如这里就指明了创建好的状态加载到游戏开始菜单的状态下
<span class="boring">}
</span></code></pre></pre>
<p>2.初始化StateStage</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 接上第一步的部分
    .add_stage_after(// 此处也很灵活，可以按照自己的喜好来
        stage::UPDATE,// target，你可以把你的状态放到你想放的任何已有状态下
        APP_STATE_STAGE,// name，名字也很灵活，可以自己取，这里是const APP_STATE_STAGE: &amp;str = &quot;app_state&quot;;
        StateStage::&lt;AppState&gt;::default(),// 这里就挺固定了，需要将你的游戏状态枚举作为StateStage的一个泛型，以便初始化。
    )
<span class="boring">}
</span></code></pre></pre>
<p>3.处理stage</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 紧接上一步
    .stage(APP_STATE_STAGE, |stage: &amp;mut StateStage&lt;AppState&gt;| {
        // 通过这个闭包，可以给我们游戏的不同状态添加系统
        stage
            // start menu
            // on_state_enter用来设置进入该State时调用的系统，通常用来加载资源。
            .on_state_enter(AppState::StartMenu, start_menu.system())
            // on_state_update用来设置该State下游戏更新时调用的系统。
            .on_state_update(AppState::StartMenu, button_system.system())
            // on_state_exit用来设置退出该State时调用的系统，通常用来清楚屏幕，更新相关游戏数据之类的。
            .on_state_exit(AppState::StartMenu, exit_ui_despawn.system())
            // in game
            .on_state_enter(AppState::Game, setup_map.system()))
            // 类似于on_state_update，不过可以同时设置多个。
            .update_stage(AppState::Game, |stage: &amp;mut SystemStage| {
                stage
                // 以下的方法都不是SystemStage自带的，而是在我们游戏项目的各个模块下通过自定义trait给SystemStage实现的，只是为了方便管理各个模块。
                // 这部分设计是有缺陷的，一般来说physics系统中的其中一部分是需要提前加载的，不然会造成现版本中出现查询错误的小bug
                    .physics_systems()
                    .player_systems()
                    .bomb_systems()
                    .buff_systems()
                    .creature_systems()
                    .portal_systems()
            })
            .on_state_exit(AppState::Game, exit_game_despawn.system())
            .on_state_enter(AppState::Temporary, jump_game.system())
    });
<span class="boring">}
</span></code></pre></pre>
<p>4.处理游戏状态跳转</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 另外构建一个处理游戏状态的跳转的系统
pub fn jump_state(
    mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;,
    input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut app_exit_events: ResMut&lt;Events&lt;AppExit&gt;&gt;,
) -&gt; Result&lt;()&gt; {
    // 使用模式匹配能够很清晰的将我们游戏状态跳转进行处理
    match app_state.current() {
        AppState::StartMenu =&gt; {
            if input.just_pressed(KeyCode::Return) {
                // set_next这个方法就是从当前状态跳转到指定状态
                app_state.set_next(AppState::Game)?;
                // game_state是原来处理游戏状态下的各种状态的，比如暂停、胜利、失败等，和app_state大同小异，因此此处都省略了，如果感兴趣可以直接看这部分源码，放到了src/events下
                // game_state.set_next(GameState::Game)?;
            }
            if input.just_pressed(KeyCode::Escape) {
                // 这个事件是bevy内置的事件，用来退出应用
                app_exit_events.send(AppExit);
            }
        }
        AppState::Game =&gt; {
            if input.just_pressed(KeyCode::Back) {
                app_state.set_next(AppState::StartMenu)?;
                // game_state.set_next(GameState::Invalid)?;
                map.init();
            }
        }
        AppState::Temporary =&gt; {}
    }
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>通过以上四个步骤，就能够为你的游戏添加上不同的状态，现在我们来谈一下第三步，其实这部分很有可能在之后的版本中被<a href="https://github.com/bevyengine/bevy/pull/1144">新的调度器</a>取代，但那还是久远之后的事，到那时需要新的blog去探讨。</p>
<h3><a class="header" href="#rapier简短笔记" id="rapier简短笔记">Rapier简短笔记</a></h3>
<p><code>rapier</code>作为物理引擎，它的内容十分丰富，本项目所涉及的内容，仅仅是其中的一小部分，本文也只是从中挑出了一些有意义的进行记录。如果想要深入学习<code>rapier</code>，我的建议是先看<a href="https://rapier.rs/docs/user_guides/rust/getting_started">官方文档</a>，然后再去<a href="https://discord.gg/VuvMUaxh">discord</a>的<code>bevy_rapier</code>群组去交流学习。</p>
<p>rapier的常用组件有两个，一个是刚体（RigidBody），一个是碰撞体（Collider）。bevy中的每一个实体，只能有一个刚体，而碰撞体可以有多个，比如角色的头、胳膊、腿，这些部分都可以使用单独一个碰撞体来表示。</p>
<p>创建刚体的方法很简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 创建一个运动学刚体，不受外部力影响，但是能单向影响动态刚体，需要通过专门设置其位置，常用于移动平台，如电梯
RigidBodyBuilder::new_kinematic()
.translation(translation_x, translation_y)
// 创建一个静态刚体，不受任何外部力的影响，常用于墙体等静态物体
RigidBodyBuilder::new_static()
.translation(translation_x, translation_y)        
// 创建一个动态刚体，受外部力的影响，常用于玩家控制的角色、游戏中的怪物等
RigidBodyBuilder::new_dynamic()        
.translation(translation_x, translation_y)        
.lock_rotations()// （可选）让刚体锁定旋转    
.lock_translations()// （可选）让刚体锁定位置
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>创建刚体时需要明确指定其位置，因为<code>bevy_rapier</code>内部有一个系统专门用于转换刚体的位置和实体的<code>Transform</code>，相当于我们不再需要去管理实体中的<code>Transform</code>，只需要通过刚体来管理该实体的速度、位置、旋转、受力等就可以。</p>
</blockquote>
<p>创建碰撞体的方法也很简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 碰撞体实际上就是定义参与碰撞计算的形状，rapier有多种选择，因为我们的游戏项目中只用到两种，所以只谈这两类
// 矩形，设置的时候需要提供它的半高和半宽
ColliderBuilder::cuboid(hx, hy)
// 圆形，设置的时候需要提供半径
ColliderBuilder::ball(radius)
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>note：矩形碰撞体构建需要提供的参数是半高和半宽，而不是整高和整宽。</p>
</blockquote>
<p>对于单一碰撞体的直接讲刚体和碰撞体作为组件插入到已有实体即可：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn for_player_add_collision_detection(
    commands: &amp;mut Commands,
    query: Query&lt;
        (Entity, &amp;Transform),
        (
            With&lt;Player&gt;,
            Without&lt;RigidBodyBuilder&gt;,
            Without&lt;ColliderBuilder&gt;,
            Without&lt;RigidBodyHandleComponent&gt;,
            Without&lt;ColliderHandleComponent&gt;,
        ),
    &gt;,
) {
    for (entity, transform) in query.iter() {
        let translation = transform.translation;
        commands.insert(
            entity,
            (
                create_dyn_rigid_body(translation.x, translation.y),
                create_player_collider(entity),
            ),
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>如果只是单个碰撞体和刚体的组合，则用这种方法插入即可，但如果是多个碰撞体和单个刚体的组合，则稍微有所不同，详情可以看<a href="https://github.com/dimforge/bevy_rapier/blob/master/bevy_rapier2d/examples/multiple_colliders2.rs">这里</a>。</p>
</blockquote>
<p>我们的游戏当中使用的是动态加载，也就是在所有地图资源加载之后，再给没有加上刚体和碰撞体的实体插入相应的刚体和碰撞体。</p>
<p>比如上面给出的例子，可能大家会对查询的过滤器感到奇怪。因为我们是给没有刚体构建器和碰撞体构建器的实体插入刚体和碰撞体，所以再过滤器中有<code> Without&lt;RigidBodyBuilder&gt;</code>和<code>Without&lt;ColliderBuilder&gt;</code>并不让人奇怪。让人奇怪的地方是后两条过滤器<code>Without&lt;RigidBodyHandleComponent&gt;</code>和<code>Without&lt;ColliderHandleComponent&gt;</code>，这两条实际上是因为<code>bevy_rapier</code>内部有一个负责转换构建器（<code>Builder</code>）到句柄组件（<code>HandleComponent</code>）的系统，当我们给实体插入构建器之后，该系统就会通过一些内部的方法将其转换为句柄组件。所以为了防止我们查询到的结果当中存在已经插入过句柄组件的实体，所以需要再加入这条过滤。</p>
<p>仅仅添加这些并不足以让物理引擎在我们的游戏里面运行起来，主要原因是现在的<code>bevy_rapier</code>仍然是作为一个外部crate引入到我们的游戏项目中，在将来如果集成到了<code>bevy</code>主体的物理引擎中，则不再需要以下操作。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在app中添加物理引擎插件
    app
    ...// 初始化其它资源和添加其它插件
        .add_plugin(RapierPhysicsPlugin)
<span class="boring">}
</span></code></pre></pre>
<p>这样简单设置之后，我们的游戏中就成功的启用了物理引擎。</p>
<h3><a class="header" href="#通过rapier来实现碰撞过滤" id="通过rapier来实现碰撞过滤">通过Rapier来实现碰撞过滤</a></h3>
<p>还有一件事需要特别记录一下，在我们的游戏中，生物是可以互相碰撞的，那么如何实现这种效果呢？只需要在创建碰撞器的时候指明解算组或者碰撞组即可。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ColliderBuilder::cuboid(HALF_TILE_WIDTH, HALF_TILE_WIDTH)
        // 用户数据，可以插入一些自定义的数据，但是只能以u128格式插入，通常用来插入实体，有了实体之后可以通过查询来获取该实体的其它组件
        .user_data(entity.to_bits() as u128)
        // 解算组，可以通过设定一个交互组（InteractionGroups）来让该碰撞器在该组规则下进行力的解算
        .solver_groups(InteractionGroups::new(WAY_GROUPS, NONE_GROUPS))
        // 碰撞组，同样设定交互组之后，让该碰撞器在该组规则下进行碰撞解算
        .collision_groups(InteractionGroups::new(WAY_GROUPS, NONE_GROUPS))
<span class="boring">}
</span></code></pre></pre>
<p>在更进一步谈论解算组和碰撞组的区别之前，我们需要了解交互组的构建规则，交互组<code>new</code>的时候需要提供两个参数，第一个参数是设定该碰撞体属于哪一组，需要的参数类型是一个<code>u16</code>，第二个参数是设定该碰撞体和哪些组的碰撞体会产生交互，参数同样是一个<code>u16</code>。</p>
<p>对于第二个参数，设定和单个碰撞体交互倒是挺好理解，但如果设定和多个碰撞体交互又该怎么设置呢？这正是参数的类型设定为<code>u16</code>的妙处，举个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CREATURE_GROUPS: u16 = 0b0010;
const PLAYER_GROUPS: u16 = 0b0001;
const WALL_GROUPS: u16 = 0b0100;
const WAY_GROUPS: u16 = 0b1000;
const NONE_GROUPS: u16 = 0b0000;
<span class="boring">}
</span></code></pre></pre>
<p>以上常量皆是我们这次游戏中用到的交互组变量，而<code>0b0011</code>表示的就是生物组和玩家组两个组，而这个数就是用<code>CREATURE_GROUPS</code>和<code>PLAYER_GROUPS</code>通过<code>&amp;</code>运算出来的。</p>
<p>至于解算组和碰撞组的区别，解算组解算的就是受力状况，与之交互的组都会参与到受力解算中。而碰撞组是管理碰撞事件的，碰撞事件可以通过<code>Res&lt;EventQueue&gt;</code>进行接收处理。</p>
<p>还有<code>user_data</code>也是一个比较常用的，通常是在碰撞体插入的时候将该实体传入到碰撞体构建器当中，通过这个数据，可以使用以下命令获得实体：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = Entity::from_bits(user_data as u64);
<span class="boring">}
</span></code></pre></pre>
<p>那<code>user_data</code>又从哪里来呢？从碰撞事件中我们会获得一个索引，该索引可以通过<code>Res&lt;ColliderSet&gt;</code>的get方法获取器<code>user_data</code>，这方面比较繁琐，也是我认为目前<code>bevy_rapier</code>当中最不好用的部分。</p>
<p>除此之外，如果你就此运行你的游戏，你会发现你的角色也好，画面中的其它动态刚体，除了你设定的之外，还会收到一个重力，这完全不符合你俯视2d游戏的初衷，所以我们需要将该重力给修改为零。</p>
<p>当前版本是通过添加这样一个系统来修改物理引擎的重力的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup(
    mut configuration: ResMut&lt;RapierConfiguration&gt;,
) {
    configuration.gravity = Vector::y() * 0.0;
}
<span class="boring">}
</span></code></pre></pre>
<p>将这个系统添加到<code>startup_system()</code>只需要在每次游戏启动之前运行一次就行。</p>
<h3><a class="header" href="#多平台支持" id="多平台支持">多平台支持</a></h3>
<p>我们的游戏这次除了支持正常的桌面端平台以外，还做了<code>wasm</code>的支持，其中因为<code>bevy</code>的声音在<code>wasm</code>没有得到支持继而没有实现声音以外，总算是没什么遗憾。做完游戏之后发给小伙伴们玩了一下，都在问我有没有手机版本的。<code>bevy</code>的支持计划里面是有移动端的，而且就从桌面端迁移到移动端上要做出的改变来说是很少的，再说我们尚未支持的移动端之前，来看看我们是如何支持<code>wasm</code>版本的。</p>
<p><code>bevy</code>的渲染后端用的是<code>wgpu</code>，虽然原生的<code>wgpu</code>渲染后端已经支持编译到<code>wasm</code>了，但是由于某些原因居然没有给<code>bevy</code>实装上，我们能够参考的已有的<code>bevy</code>的<code>wasm</code>版本项目基本上都是基于<code>bevy_webgl2</code>这个crate。</p>
<p>添加<code>wasm</code>支持也十分方便，除了需要添加常规的html之类的文件，还需要做如下改动：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 添加webgl2的插件，添加这个插件之前需要关闭bevy的wgpu的feature
    #[cfg(target_arch = &quot;wasm32&quot;)]
    app.add_plugins(bevy_webgl2::DefaultPlugins);
    #[cfg(not(target_arch = &quot;wasm32&quot;))]
    app.add_plugins(DefaultPlugins);
<span class="boring">}
</span></code></pre></pre>
<p>关闭wgpu的feature：</p>
<pre><code class="language-toml">[features]
# 这部分是native和wasm都会用到的bevy的feature
default = [
  &quot;bevy/bevy_gltf&quot;,
  &quot;bevy/bevy_winit&quot;,
  &quot;bevy/bevy_gilrs&quot;,
  &quot;bevy/render&quot;,
  &quot;bevy/png&quot;,
]
# 这部分是native会用到的wgpu的feature
native = [
  &quot;bevy/bevy_wgpu&quot;,
  &quot;bevy/dynamic&quot;# （可选，开发的时候提高增量编译速度，编译真的十分快！）
]
# 这部分是wasm支持会用到的webgl2的feature
web = [
  &quot;bevy_webgl2&quot;
]
</code></pre>
<p>基本上这样就设置好了，其余的设置是跟html有关的，需要稍微丢丢的wasm开发的知识。关于编译的时候用到的<code>cargo make</code>等工具链如何使用，同样是在那一丢丢的wams开发的知识里面学习。关于如何部署到github的page服务上，这个我是完全不会的，我们游戏的这部分部署是有我的搭档<code>@rgripper</code>完成的。</p>
<p>对于移动端的支持，以安卓为例，如果不考虑触屏啊，按钮之类的，官方其实给了示例的，在桌面端的基础上迁移起来也十分方便。除了基本的安卓开发环境的搭配（这部分可以详情看<a href="https://github.com/BrainiumLLC/cargo-mobile"><code>cargo mobile</code></a>的READEME里面讲的十分详情），只需要做出下面这种改动，即可支持移动端，甚至如果以后修复了wgpu对wasm端的支持，应该同样也只是需要下面这种修改，即可对多端支持：</p>
<pre><pre class="playground"><code class="language-rust">// 对，就是添加这个过程宏之后，编译的时候使用对应平台的编译指令即可打包到相应平台
#[bevy_main]
fn main() {
    App::build()
        .insert_resource(Msaa { samples: 2 })
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup.system())
        .run();
}
</code></pre></pre>
<h3><a class="header" href="#日志" id="日志">日志</a></h3>
<p>bevy内建了日志系统，使用起来也十分方便，同时也能和rust生态中的其它日志crate配合在一起使用，对于后续测试和收集数据有很重要的作用。</p>
<p>这次项目中我们并没有深入使用日志功能，也没有和外部的日志crate深度结合使用，只是当作<code>println!</code>调试的时候用，所以这部分就不再探讨。</p>
<h3><a class="header" href="#碎碎念" id="碎碎念">碎碎念</a></h3>
<p>这是本文的最后一个部分，也是谈谈开发下来的一些感受，上面基本是干货居多，感受这种东西并不是每个人的愿意看，所以也不愿意放在前面叨扰大家。总得来说做完整个项目总结之后，发现自己之前走了不少弯路，甚至有些地方都用错了（比如前几个版本中的切换游戏状态，受参考的源代码影响也用了一堆if-else，当时自己看的时候也是一头雾水的，改成match之后清晰明了），在这个项目之前，rust对于我来说只是刷题、刷教程趁手的工具，虽然学到了不少的知识，但总觉得缺乏自己的实践。但这样一趟走下来，实践经验确实增长不少，最重要的是还交到了<code>@rgripper</code>这样的好朋友，果然github是个大型在线交友平台，哈哈哈。</p>
<p>使用<code>bevy</code>的开发体验在我这里被区分为两个部分，但总得来说是十分有趣的。</p>
<p>而这个分界点就是在游戏里加入<a href="https://rapier.rs/">rapier</a>前后，加入之前和加入之后是两种完全不同的开发体验。</p>
<p>其中最主要原因还是因为自己之前没有使用过物理引擎，有不少生涩的词汇在开发中需要接触和学习，加上<code>bevy_rapier</code>当中不少接口放到<code>bevy</code>实际开发中体验并不良好，所以造成了使用<code>rapier</code>之后开发速率下降、开发心情糟糕等情况。</p>
<p>当然对于最终我们的游戏中使用了<code>rapeir</code>这件事，我觉得是很值得的，在这样一个小游戏中使用物理引擎这件事并不值得。但如果是为了学习这个物理引擎，那就是值得的，而且也确实涨了不少知识（在这部分真的十分感谢<code>rapier</code>的作者<a href="https://github.com/sebcrozet">@Sébastien Crozet</a>，在他的discord群组里，基本上大家问的问题都得到了解决，也很感谢群组里帮助我们提出思路的各个网友）。</p>
<p>谈一下本次开发中的遗憾，游戏没有加入音频算一个遗憾，这部分的工作早先是由我的搭档去完成的，但是因为bevy的<a href="https://github.com/bevyengine/bevy/issues/88#issuecomment-753546363">一些原因</a>，导致音频部分对wasm支持很差，所以我们放弃了。地图没有细致的去设计以及没有随机地图的支持这算两个遗憾。小怪的ai因为我们连个人此前都没写过游戏，因此对这方面不熟悉，导致有时候小怪会傻傻站着，和卡了bug一样，这也算一个。在游戏基本写完的时候<a href="https://github.com/joshuajbouw/bevy_tilemap"><code>bevy_tilemap</code></a>发布了，并且还有一个游戏动图，我们没能在一个网格游戏当中用到这种crate，也算是一个遗憾。游戏的资产加载没有专门做成一个状态，导致在网络差的情况下，网页版的游戏很有可能出现这个<a href="https://github.com/rgripper/rusty-bomber/issues/16">issue</a>所说的游戏主体出现了但是游戏资产没有加载进来的诡异情况，这也算是一个遗憾。</p>
<hr />
<p>作者介绍：</p>
<blockquote>
<p>Cupnfish，目前青岛某大学大四在校生一名。大二的时候因为自己主力语言是 python 和 C#（后面上课还学了Java，虽然很早之前就学过C，但不是很喜欢，刚接触指针的时候可懵逼了），所以很想学一门底层语言，当时看知乎不少关于Rust的讨论，对Rust产生了一些兴趣，恰好18年初张汉东老师的<code>Rust编程之道</code>正好上架，下单之后随即入坑Rust。2020年初疫情期间GAMES101课程在B站有录播，通过闫令琪老师的课程算是入门计算机图形学，同时期学了Wgpu，很想以后工作能从事 Rust 游戏开发，不过目前看来社区还得发展两三年。知乎上有不少人对Rust图形化编程方面呈悲观态势，起初只有Amethyst的时候我确实也很同意他们的观点，但是bevy给了rust社区中很多人希望，bevy不仅仅是想用Rust来做游戏引擎，同时也在鼓励使用Rust来编写游戏，这是区别于Amethyst等游戏引擎的，同时我想说，就目前bevy的ECS部分的Api来看，bevy做到了！这是梦想中的Rust，你几乎很少会用到生命期之类的Rust中一切繁琐的东西，bevy带给你的Rust开发体验是前所未有的，当然现在它仍然还很弱小，需要大家的呵护、照顾，它有很大的潜力，但同时也需要社区进行各方面的支持。</p>
</blockquote>
<p>你可以通过以下方式联系到我，无论是进行技术讨论，还是项目合作，都可以直接和我联系：</p>
<ul>
<li>邮箱：pointu@foxmail.com</li>
<li>QQ：760280519</li>
</ul>
<h1><a class="header" href="#linux-全新异步接口-io_uring-的-rust-生态盘点" id="linux-全新异步接口-io_uring-的-rust-生态盘点">Linux 全新异步接口 io_uring 的 Rust 生态盘点</a></h1>
<p>作者：施继成@DatenLord / 后期编辑：张汉东</p>
<hr />
<p>io_uring 无可置疑是近两年内核圈最火的话题之一，作为风头正劲的 Linux 异步 I/O 接口，其野心更大，不仅仅想将 Linux 的 I/O 操作全面异步化，还希望将所有<a href="https://lwn.net/Articles/810414/">Linux系统调用异步化</a>。</p>
<p>Rust 作为一门系统级编程语言，兼具安全和高性能的特点，大家也一定是想使用Rust语言 “尝鲜” io_uring。然而遗憾的是 io_uring 作者 Jens Axboe 仅仅维护一个<a href="https://github.com/axboe/liburing">C语言的库</a>。用户想要用Rust调用，一方面还需要自己进行一些封装，另一方面 C 语言的接口还是太底层，想在 Rust 的异步框架中使用仍有许多工作要做。</p>
<p>好消息是已经有一些 Rust 语言封装的 io_uring 库出现在 github 上，今天让我们来挑选一些使用人数较多（通过star数目来判断）的库进行分析，看看是否可以给大家使用 io_uring 带来便利。</p>
<h1><a class="header" href="#a-hrefhttpsgithubcomtokio-rsio-uringtokio-io-uringa" id="a-hrefhttpsgithubcomtokio-rsio-uringtokio-io-uringa"><a href="https://github.com/tokio-rs/io-uring">Tokio io-uring</a></a></h1>
<p>Tokio 是 github 上 Star 数目最多的异步框架，那么他们团队封装的io_uring lib如何呢？通过阅读代码不难发现，该 io_uring 库完全撇弃了 C 语言的 liburing 库，自己在 io_uring 系统调用上从零开始封装了一层，实现了submission queue，completion queue 和 submitter。</p>
<p>上述的三层抽象比 C 语言的封装稍微高层一些，但仍然需用户将 request 放到submission queue上，将 response 从 completion queue 上取下，和同步读写方式区别巨大，且和 Rust 现有的异步 I/O 框架的设计相去甚远。以下是一个简单的样例代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ring = IoUring::new(256)?;
let (submitter, mut sq, mut cq) = ring.split();

let mut accept = AcceptCount::new(listener.as_raw_fd(), token_alloc.insert(Token::Accept), 3);

// put request on the submission queue
accept.push_to(&amp;mut sq);

// submit the request
match submitter.submit_and_wait(1) {
    Ok(_) =&gt; (),
    Err(ref err) if err.raw_os_error() == Some(libc::EBUSY) =&gt; (),
    Err(err) =&gt; return Err(err.into()),
}

// get complete events from the completion queue
for cqe in &amp;mut cq {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>该 io_uring 库的优缺点分列如下：</p>
<p>优点：</p>
<ol>
<li>纯 Rust 封装，安全性更好。</li>
<li>比 C 语言库封装高层，使用起来接口更加简单。</li>
</ol>
<p>缺点：</p>
<ol>
<li>维护成本更高，需要根据kernel的更新手动追加新 feature，包括新数据结构。</li>
<li>封装还不够彻底，暴露了底层实现的两个队列，用户使用难度较高。</li>
</ol>
<h1><a class="header" href="#a-hrefhttpsgithubcomspacejamriospacejam-rioa" id="a-hrefhttpsgithubcomspacejamriospacejam-rioa"><a href="https://github.com/spacejam/rio">Spacejam rio</a></a></h1>
<p>该 io_uring 库在 github 上的 star 数目在写稿时已经达到了 590 个，该库的作者还创建了 <a href="https://github.com/spacejam/sled">sled</a> 嵌入式数据库。由于 sled 数据库也使用了这个 io_uring 库，所以我们有理由相信， rio 是一个经过实际项目验证的库，其更友好的用户接口更是降低了用户的使用难度。</p>
<p>通过下面的简单示例，大家可以很容易感受到接口的易用性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Read file example
let ring = rio::new().expect(&quot;create uring&quot;);
let file = std::fs::open(&quot;file&quot;).expect(&quot;openat&quot;);
let data: &amp;mut [u8] = &amp;mut [0; 66];
let completion = ring.read_at(&amp;file, &amp;mut data, at);

// if using threads
completion.wait()?;

// if using async
completion.await?
<span class="boring">}
</span></code></pre></pre>
<p>rio 同时提供了针对 thread 和 async 两种编程模型的接口，在提供便利性的同时大大降低了使用者的约束，可以自由选择喜欢的编程模型。</p>
<p>然而这个库是 unsoundness 的，即有可能被错误或者恶意使用。并且根据作者在 <a href="https://github.com/spacejam/rio/issues/25">issue</a> 里面的回复，作者并不会对此进行修复。这将使得基于该库构建的软件都不安全。</p>
<p>该 io_uring 库的优缺点分列如下：</p>
<p>优点：</p>
<ol>
<li>接口丰富且使用简单。</li>
<li>有实际使用的项目验证。</li>
</ol>
<p>缺点：</p>
<ol>
<li>Unsoundness，安全性不佳。</li>
</ol>
<h1><a class="header" href="#a-hrefhttpsgithubcomringbahnringbahnringbahna" id="a-hrefhttpsgithubcomringbahnringbahnringbahna"><a href="https://github.com/ringbahn/ringbahn">ringbahn</a></a></h1>
<p>ringbahn 的作者是 withoutboats, Rust 语言的核心开发者之一。该库由三个抽象层组成，第一层为 C 语言 libfuse 的 Rust 封装, 名称为 <a href="https://github.com/ringbahn/uring-sys">uring-sys</a>；第二层为 Submission Queue 和 Completion Queue 等数据结构的封装，名称为 <a href="https://github.com/ringbahn/iou">iou</a>；最后一层则封装了Rust 异步编程的接口。</p>
<p>不难看出，ringbahn 从设计上考虑了更多，从接口易用性到安全性都更加优秀。以下为拷贝文件的示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Copy File from props.txt to test.txt
futures::executor::block_on(async move {
    let mut input:  File = File::open(&quot;props.txt&quot;).await.unwrap();
    let mut output: File = File::create(&quot;test.txt&quot;).await.unwrap();
    let mut buf = vec![0; 1024];
    let len = input.read(&amp;mut buf).await.unwrap();
    output.write(&amp;mut buf[0..len]).await.unwrap();
    output.flush().await.unwrap();
});

<span class="boring">}
</span></code></pre></pre>
<p>该库也并非完美无缺，它也具有下列缺陷：</p>
<ol>
<li>并发不友好，在 Submission Queue 上有一把大锁，每个提交任务的线程都会被串行化。</li>
<li>读写操作会导致内存在用户态被拷贝，对于大数据量的操作而言，多余的内存拷贝会带来明显的性能下降。之所以要进行内存拷贝，是为了保证传给内核的memory buffer不会被用户态异步修改，保证安全性。</li>
</ol>
<p>作者也在 Readme 文件中说明了最上层的 ringbahn 封装只是一次尝试，并不适合在正式生产上使用。</p>
<h1><a class="header" href="#a-hrefhttpsgithubcomdatenlordring-iotreedevdatenlord-ring-ioa" id="a-hrefhttpsgithubcomdatenlordring-iotreedevdatenlord-ring-ioa"><a href="https://github.com/datenlord/ring-io/tree/dev">DatenLord ring-io</a></a></h1>
<p>基于上述讨论，我们团队 Datenlord 也实现了自己的 io_uring Rust lib， 名称是 ring-io。现阶段的实现吸取了 Tokio io-uring 和 iou 的经验，同样实现了Submission Queue 和 Completion Queue 的抽象。具体的实现细节请参见王徐旸同学写的<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_1/io_uring_and_rust.html">文章</a>。</p>
<p>现阶段的实现也具有下列问题：</p>
<ol>
<li>暴露了一些unsafe接口，提醒用户某些操作需要注意，和内核的错误交互会带来无法预知的结果。</li>
<li>抽象层偏低，使用起来不方便。</li>
</ol>
<p>接下去，我们会针对一些特定的 buffer 类型实现异步 I/O 接口，方便用户的使用，且暴露 safe 的接口。在实现的过程中，我们也会将高效考虑在内，避免不必要的内存拷贝。<strong>和ringbahn 的方法不同，我们保证内存安全的方式为 Rust 提供的内存所有权转移，即用户在发送 I/O 请求之后就不在拥有 buffer 的所有权，直到 request 返回所有权才被归还</strong>。具体的实现细节我们会在下一篇文章中进行讨论，这里先给出设计的架构图：</p>
<p><img src="chapter_2/./io_uring_intro/io_uring_arch.jpeg" alt="io uring architecture" /></p>
<ul>
<li>SQ submitter 负责将用户 Task 发送来的 I/O 请求通过 io_uring 发送到 kernel。</li>
<li>CQ collector 负责将 kernel 完成任务的返回结果返回给用户。</li>
<li>User Task 会 block 在各自的 channel 上，直到 I/O 任务完成，User Task 才会被重新调度。</li>
</ul>
<h1><a class="header" href="#总结-3" id="总结-3">总结</a></h1>
<p>虽然 io_uring 非常火爆，国内外也有很多团队进行了 Rust 封装，但是仍然没有一个完美的方案，同时解决了安全性、高性能和易用性的问题。</p>
<p>大家可以根据自己的情况选择一个符合需求的库，当然更希望大家积极贡献社区，提出自己的想法，创建出更好用、更安全和更快的 io_uring 库。</p>
<h2><a class="header" href="#datenlord" id="datenlord">DatenLord</a></h2>
<p><a href="https://github.com/datenlord/datenlord">DatenLord</a>  是用 Rust 实现的新一代开源分布式存储，面向云原生场景提供高性能存储解决方案。</p>
<p>一方面，在当今的硬件架构下，CPU 和 GPU 的计算的速度远远超过 IO 的速度，即便现在 NVMe SSD 的 IO 速度已经比从前机械硬盘的速度有了百倍的提升，网络的速度也有至少百倍提升，但还是常常碰到IO跟不上计算速度的问题，导致计算等待数据，降低了计算的性能。</p>
<p>另一方面，操作系统的 IO 模型已经很久没有发生大的变化，仍然是以内核为主体来执行IO任务，这样的方式带来不少额外的开销，诸如数据拷贝、系统调用引起的阻塞以及进程上下文切换等等。</p>
<p>为了提高 IO 性能，DatenLord 采用绕过内核 (bypass Kernel) 的方式，主要在用户态实现 IO 功能，避免内核执行 IO 任务带来的额外开销，从而实现高性能分布式存储。</p>
<h1><a class="header" href="#io_uring--用-rust-实现基于-io_uring-的异步随机读文件" id="io_uring--用-rust-实现基于-io_uring-的异步随机读文件">io_uring | 用 Rust 实现基于 io_uring 的异步随机读文件</a></h1>
<p>作者：迟先生（skyzh）/ 后期编辑：张汉东</p>
<hr />
<p>本文介绍了 <code>io_uring</code> 的基本使用方法，然后介绍了本人写的异步读文件库的实现方法，最后做了一个 benchmark，和 mmap 对比性能。</p>
<h2><a class="header" href="#tldr" id="tldr">TL;DR</a></h2>
<p>一句话总结：在 <a href="https://github.com/skyzh/uring-positioned-io">skyzh/uring-positioned-io</a> 中，我包装了 Tokio 提供的底层 <code>io_uring</code> 接口，在 Rust 中实现了基于<code>io_uring</code> 的异步随机读文件。你可以这么用它：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.read(fid, offset, &amp;mut buf).await?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#io_uring-简介" id="io_uring-简介">io_uring 简介</a></h2>
<p><code>io_uring</code> 是一个由 Linux 内核的提供的异步 I/O 接口。它于 2019 年 5 月在 Linux 5.1 中面世，现在已经在各种项目中被使用。
比如：</p>
<ul>
<li><a href="https://github.com/facebook/rocksdb/pull/5881">RocksDB 的 MultiRead</a> 目前就是通过 <code>io_uring</code> 做并发读文件。</li>
<li>Tokio 为 <code>io_uring</code> <a href="https://github.com/tokio-rs/io-uring">包装了一层 API</a>。在 Tokio 1.0 发布之际，开发者表示今后会通过 io_uring 提供真正的异步文件操作
(见 <a href="https://tokio.rs/blog/2020-12-tokio-1-0">Announcing Tokio 1.0</a>)。
目前 Tokio 的异步文件操作通过开另外的 I/O 线程调用同步 API 实现。</li>
<li>QEMU 5.0 已经使用 <code>io_uring</code> (见 <a href="https://wiki.qemu.org/ChangeLog/5.0">ChangeLog</a>)。</li>
</ul>
<p>目前关于 <code>io_uring</code> 的测试，大多是和 Linux AIO 对比 Direct I/O 的性能 <a href="https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/">(1)</a> <a href="https://developers.mattermost.com/blog/hands-on-iouring-go/">(2)</a> <a href="https://zhuanlan.zhihu.com/p/62682475">(3)</a>。
<code>io_uring</code> 通常能达到两倍于 AIO 的性能。</p>
<h2><a class="header" href="#随机读文件的场景" id="随机读文件的场景">随机读文件的场景</a></h2>
<p>在数据库系统中，我们常常需要多线程读取文件任意位置的内容 <code>(&lt;fid&gt;, &lt;offset&gt;, &lt;size&gt;)</code>。
经常使用的 <code>read / write</code> API 无法完成这种功能（因为要先 seek，需要独占文件句柄）。
下面的方法可以实现文件随机读。</p>
<ul>
<li>通过 <code>mmap</code> 直接把文件映射到内存中。读文件变成了直接读内存，可以在多个线程中并发读。</li>
<li><code>pread</code> 可以从某一位置 <code>offset</code> 开始读取 <code>count</code> 个字节，同样支持多线程并发读。</li>
</ul>
<p>不过，这两种方案都会把当前线程阻塞住。比如 <code>mmap</code> 后读某块内存产生 page fault，当前线程就会阻塞；<code>pread</code> 本身就是一个阻塞的 API。
异步 API (比如 Linux AIO / <code>io_uring</code>) 可以减少上下文切换，从而在某些场景下提升吞吐量。</p>
<h2><a class="header" href="#io_uring-的基本用法" id="io_uring-的基本用法">io_uring 的基本用法</a></h2>
<p><code>io_uring</code> 相关的 syscall 可以在 <a href="https://kernel.dk/io_uring.pdf">这里</a> 找到。<a href="https://github.com/axboe/liburing">liburing</a> 提供了更易用的 API。
Tokio 的 <a href="https://github.com/tokio-rs/io-uring">io_uring crate</a> 在此基础之上，提供了 Rust 语言的 <code>io_uring</code> API。下面以它为例，
介绍 <code>io_uring</code> 的使用方法。</p>
<p>要使用 <code>io_uring</code>，需要先创建一个 ring。在这里我们使用了 <code>tokio-rs/io-uring</code> 提供的 <code>concurrent</code> API，
支持多线程使用同一个 ring。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use io_uring::IoUring;
let ring = IoUring::new(256)?;
let ring = ring.concurrent();
<span class="boring">}
</span></code></pre></pre>
<p>每一个 ring 都对应一个提交队列和一个完成队列，这里设置队列最多容纳 256 个元素。</p>
<p>通过 <code>io_uring</code> 进行 I/O 操作的过程分为三步：往提交队列添加任务，向内核提交任务 [注1]，
从完成队列中取回任务。这里以读文件为例介绍整个过程。</p>
<p>通过 <code>opcode::Read</code> 可以构造一个读文件任务，通过 <code>ring.submission().push(entry)</code> 可以将任务添加到队列中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use io_uring::{opcode, types::Fixed};
let read_op = opcode::Read::new(Fixed(fid), ptr, len).offset(offset);
let entry = read_op
            .build()
            .user_data(user_data);
unsafe { ring.submission().push(entry)?; }
<span class="boring">}
</span></code></pre></pre>
<p>任务添加完成后，将它提交到内核。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(ring.submit()?, 1);
<span class="boring">}
</span></code></pre></pre>
<p>最后轮询已经完成的任务。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    if let Some(entry) = ring.completion().pop() {
        // do something
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样一来，我们就实现了基于 <code>io_uring</code> 的随机读文件。</p>
<p>注 1: <code>io_uring</code> 目前有三种执行模式：默认模式、poll 模式和内核 poll 模式。如果使用内核 poll 模式，则不一定需要调用提交任务的函数。</p>
<h2><a class="header" href="#利用-io_uring-实现异步读文件接口" id="利用-io_uring-实现异步读文件接口">利用 io_uring 实现异步读文件接口</a></h2>
<p>我们的目标是实现类似这样的接口，把 <code>io_uring</code> 包装起来，仅暴露给开发者一个简单的 <code>read</code> 函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.read(fid, offset, &amp;mut buf).await?;
<span class="boring">}
</span></code></pre></pre>
<p>参考了 <a href="https://github.com/hmwill/tokio-linux-aio">tokio-linux-aio</a> 对 Linux AIO 的异步包装后，我采用下面方法来实现基于 <code>io_uring</code> 的异步读。</p>
<ul>
<li>开发者在使用 <code>io_uring</code> 之前，需要创建一个 <code>UringContext</code>。</li>
<li><code>UringContext</code> 被创建的同时，会在后台运行一个（或多个）用来提交任务和轮询完成任务的 <code>UringPollFuture</code>。
(对应上一章节中读文件的第二步、第三步操作)。</li>
<li>开发者可以从 <code>ctx</code> 调用读文件的接口，用 <code>ctx.read</code> 创建一个 <code>UringReadFuture</code>。在调用 <code>ctx.read.await</code> 后：
<ol>
<li><code>UringReadFuture</code> 会创建一个固定在内存中的对象 <code>UringTask</code>，然后把读文件任务放进队列里，将 <code>UringTask</code> 的地址作为
读操作的用户数据。<code>UringTask</code> 里面有个 channel。</li>
<li><code>UringPollFuture</code> 在后台提交任务。</li>
<li><code>UringPollFuture</code> 在后台轮询已经完成的任务。</li>
<li><code>UringPollFuture</code> 取出其中的用户数据，还原成 <code>UringTask</code> 对象，通过 channel 通知 <code>UringReadFuture</code>
I/O 操作已经完成。</li>
</ol>
</li>
</ul>
<p>整个流程如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/4198311/106355863-b53ca880-6335-11eb-9dfe-0682aefa1093.png" alt="uring" /></p>
<p>这样，我们就可以方便地调用 <code>io_uring</code> 实现文件的异步读取。这么做还顺便带来了一个好处：任务提交可以自动 batching。
通常来说，一次 I/O 操作会产生一次 syscall。但由于我们使用一个单独的 Future 来提交、轮询任务，在提交的时候，
队列里可能存在多个未提交的任务，可以一次全部提交。这样可以减小 syscall 切上下文的开销 (当然也增大了 latency)。
从 benchmark 的结果观察来看，每次提交都可以打包 20 个左右的读取任务。</p>
<h2><a class="header" href="#benchmark" id="benchmark">Benchmark</a></h2>
<p>将包装后的 <code>io_uring</code> 和 <code>mmap</code> 的性能作对比。测试的负载是 128 个 1G 文件，随机读对齐的 4K block。
我的电脑内存是 32G，有一块 1T 的 NVMe SSD。测试了下面 6 个 case：</p>
<ul>
<li>8 线程 mmap。 (mmap_8)</li>
<li>32 线程 mmap。 (mmap_32)</li>
<li>512 线程 mmap。 (mmap_512)</li>
<li>8 线程 8 并发的 <code>io_uring</code>。(uring_8)</li>
<li>8 线程 32 并发的 <code>io_uring</code>。即 8 个 worker thread, 32 个 future 同时 read。(uring_32)</li>
<li>8 线程 512 并发的 <code>io_uring</code>。(uring_512)</li>
</ul>
<p>测试了 Throughput (op/s) 和 Latency (ns)。</p>
<table><thead><tr><th>case</th><th>throughput</th><th>p50</th><th>p90</th><th>p999</th><th>p9999</th><th>max</th></tr></thead><tbody>
<tr><td>uring_8</td><td>104085.77710777053</td><td>83166</td><td>109183</td><td>246416</td><td>3105883</td><td>14973666</td></tr>
<tr><td>uring_32</td><td>227097.61356918357</td><td>142869</td><td>212730</td><td>1111491</td><td>3321889</td><td>14336132</td></tr>
<tr><td>uring_512</td><td>212076.5160505447</td><td>1973421</td><td>3521119</td><td>19478348</td><td>25551700</td><td>35433481</td></tr>
<tr><td>mmap_8</td><td>109697.87025744558</td><td>78971</td><td>107021</td><td>204211</td><td>1787823</td><td>18522047</td></tr>
<tr><td>mmap_32</td><td>312829.53428971884</td><td>100336</td><td>178914</td><td>419955</td><td>4408214</td><td>55129932</td></tr>
<tr><td>mmap_512</td><td>235368.9890904751</td><td>2556429</td><td>3265266</td><td>15946744</td><td>50029659</td><td>156095218</td></tr>
</tbody></table>
<p>发现 mmap 吊打 <code>io_uring</code>。嗯，果然这个包装做的不太行，但是勉强能用。下面是一分钟 latency 的 heatmap。每一组数据的展示顺序是先 mmap 后 <code>io_uring</code>。</p>
<p><strong>mmap_8 / uring_8</strong>
<img src="https://user-images.githubusercontent.com/4198311/106357357-a14a7400-6340-11eb-89df-72e876855557.png" alt="waterfall_mmap_8" />
<img src="https://user-images.githubusercontent.com/4198311/106357364-a60f2800-6340-11eb-9376-2d66ffa7098f.png" alt="waterfall_uring_8" /></p>
<p><strong>mmap_32 / uring_32</strong>
<img src="https://user-images.githubusercontent.com/4198311/106357361-a5769180-6340-11eb-8a85-80180df69ea8.png" alt="waterfall_mmap_32" />
<img src="https://user-images.githubusercontent.com/4198311/106357365-a6a7be80-6340-11eb-81e7-945758dd2092.png" alt="waterfall_uring_32" /></p>
<p><strong>mmap_512 / uring_512</strong>
<img src="https://user-images.githubusercontent.com/4198311/106357363-a5769180-6340-11eb-9704-7c97d9a577a6.png" alt="waterfall_mmap_512" />
<img src="https://user-images.githubusercontent.com/4198311/106357366-a6a7be80-6340-11eb-9b7e-ec4ff168962d.png" alt="waterfall_uring_512" /></p>
<p><img src="https://user-images.githubusercontent.com/4198311/106357531-904e3280-6341-11eb-9577-fcd1a487e6db.png" alt="Throughput-2" /></p>
<p><img src="https://user-images.githubusercontent.com/4198311/106357534-93e1b980-6341-11eb-8974-05575e63b2b7.png" alt="p50 Latency (ns)" /></p>
<h2><a class="header" href="#一些可能的改进" id="一些可能的改进">一些可能的改进</a></h2>
<ul>
<li>看起来现在 <code>io_uring</code> 在我和 Tokio 的包装后性能不太行。之后可以通过对比 Rust / C 在 <code>io_uring</code> nop
指令上的表现来测试 Tokio 这层包装引入的开销。</li>
<li>测试 Direct I/O 的性能。目前只测试了 Buffered I/O。</li>
<li>和 Linux AIO 对比。（性能不会比 Linux AIO 还差吧（痛哭</li>
<li>用 perf 看看现在的瓶颈在哪里。目前 <code>cargo flamegraph</code> 挂上去以后 <code>io_uring</code> 没法申请内存。（占个坑，说不定能出续集</li>
<li>目前，用户必须保证 <code>&amp;mut buf</code> 在整个 read 周期都有效。如果 Future 被 abort，会有内存泄漏的问题。
futures-rs 的类似问题见 https://github.com/rust-lang/futures-rs/issues/1278 。Tokio 目前的
I/O 通过两次拷贝（先到缓存，再给用户）解决了这个问题。</li>
<li>或许可以把写文件和其他操作也顺便包装一下。</li>
</ul>
<hr />
<p>作者简介：</p>
<p>迟先生（skyzh），上海交通大学大三学生，SJTUG 镜像站维护者，沉迷写 Rust。</p>
<h1><a class="header" href="#如何为-rust-语言做贡献--part-1" id="如何为-rust-语言做贡献--part-1">如何为 Rust 语言做贡献 | Part 1</a></h1>
<p>作者：CrLF0710（野喵）/ 后期编辑：张汉东</p>
<hr />
<h2><a class="header" href="#引文" id="引文">引文</a></h2>
<blockquote>
<p>如果你想成为 Rust 贡献者，那看这系列文章会很有帮助。</p>
</blockquote>
<p>本系列文章主要是给大家介绍一下如何为 <code>Rust Project</code> （即 Rust 语言本身）做贡献。</p>
<p>随着时间的推移，<code>Rust Project</code> 也在不断的演化，本文有效范围仅限于当前发表的时间点（2021.02）。</p>
<p>接下来就随我一起熟悉 Rust Project 吧。</p>
<h2><a class="header" href="#熟悉-rust-project" id="熟悉-rust-project">熟悉 Rust Project</a></h2>
<p>简单来说 <code>Rust Project</code> 的主要目标就是设计、开发、维护Rust这门编程语言。</p>
<p><code>Rust Project</code> 主要由下列三部分构成：</p>
<ol>
<li>第一部分是现有的技术积累，包括设计文档、代码仓库、文档教程和技术讨论的积淀。</li>
<li>第二部分是 Rust 的项目组织及其延伸，包括整个 Rust 开发者社区。</li>
<li>第三部分是 Rust 的配套资产（如 CI、服务器、域名，乃至于商标）和会议活动等等。</li>
</ol>
<h2><a class="header" href="#熟悉-rust-代码仓库" id="熟悉-rust-代码仓库">熟悉 Rust 代码仓库</a></h2>
<p>Rust 语言的设计文档、代码仓库、文档教程都是存储在Github上的rust-lang这个组织下的。其中<a href="https://github.com/rust-lang/rust">rust-lang/rust</a>这个仓库是主入口。</p>
<p>感兴趣的话，我们可以用git来直接下载一份下来。注意它是使用了<code>git submodule</code>的，相关联的仓库也都是需要的。</p>
<p>代码仓库大概分成六部分:</p>
<ul>
<li>编译器源码：位于<code>compiler/</code>目录下，由五十多个crate构成。另外还有它会用到的llvm，位于src/llvm-project目录下。</li>
<li>内置库源码：位于<code>library/</code>目录下，有十几个crate。我们平时会使用的core, alloc, std, test这些都在其中。</li>
<li>其他开发工具：位于<code>src/librustdoc/</code>, <code>src/tools/</code>目录下，包括我们平时使用的rustdoc, cargo, miri, clippy 等等工具</li>
<li>文档书架：位于<code>src/doc/</code>目录下，包括官方的the book, reference, nomicon等等的教程和参考文档。</li>
<li>测试用例集：位于<code>src/test/</code>目录下，大部分是编译器的测试用例，也有少量一些rustdoc和其他工具的测试用例。</li>
<li>部署工具和CI脚本：位于<code>src/bootstrap</code>, <code>src/build_helper</code>, <code>src/ci</code>, <code>.github/</code> 这几个地方，这些是用来自动化编译一套完整的rust工具链的。</li>
</ul>
<h2><a class="header" href="#编译一套-rust-工具链" id="编译一套-rust-工具链">编译一套 Rust 工具链</a></h2>
<p>下载好了<code>rust源码</code>之后，我们来试着自己编译一份<code>rust工具链</code>吧！</p>
<p>首先要在你的机器上准备这些东西：<code>python3</code>, <code>ninja</code>, <code>cmake</code>，还有一套<code>c++</code>编译器(<code>g++</code>或者<code>windows</code>下用<code>visual studio</code>)。第一个是用来执行编译脚本的，后两个则是用来编译<code>llvm</code>的。</p>
<p>准备好了之后，把<code>rust</code>目录里的<code>config.toml.example</code>拷贝一份，名叫<code>config.toml</code>。其中大部分内容都不用修改，但是我建议可以把增量编译启用，就是找到其中的<code>#incremental = false</code>这一行，去掉前面的<code>#</code>并且把后面的false改成true。</p>
<p>其他配置选项参考如下，具体作用在配置文件中有注释说明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>compiler-docs = false
submodules = false
configure-args = []
debug = true
codegen-units = 0
default-linker = &quot;cc&quot;
channel = &quot;nightly&quot;
<span class="boring">}
</span></code></pre></pre>
<p><strong>构建Rust的三个阶段：</strong></p>
<p>Rust 是⼀个⾃举的编译器，需要通过旧的编译器来构建最新的版本。所以⼀般是分阶段来完成：</p>
<ol>
<li><code>Stage0</code> 阶段。下载最新<code>beta</code>版的编译器，这些<code>x.py</code>会⾃动完成。你也可以通过修改配置⽂件来使⽤其他版本的Rust。</li>
<li><code>Stage1</code> 阶段，使⽤<code>Stage0</code>阶段下载的<code>beta</code>版编译器来编译从<code>Git</code>仓库⾥下载的代码。最终⽣成<code>Stage1</code>版编译器。但是为了对其优化，还需要进⾏下⼀阶段。</li>
<li><code>Stage2</code>，⽤<code>Stage1</code>版编译器继续对源码进⾏编译，以便⽣成Stage2版编译器。</li>
</ol>
<p>理论上，<code>Stage1</code>和<code>Stage2</code>编译器在功能上是相同的，但实际上还有些细微的差别。</p>
<p>官⽅推荐的具体构建流程如下：</p>
<ol>
<li><code>./x.py check</code> ，先执⾏此命令，检查编译器是否可以构建。</li>
<li><code>./x.py build -i --stage 1</code> ，进⾏<code>Stage 0</code>和<code>Stage 1</code>阶段的构建，最终构建完成Stage1的编译器。</li>
<li><code>./x.py build --stage 2 compiler/rustc</code>，在<code>Stage1</code>基础上进⾏增量式构建，最终编译出<code>Stage2</code>的编译器。</li>
</ol>
<p>整个过程是有点慢的，不考虑一开始的下载部分，编译时间随你的硬件配置不等，一般在20到60分钟左右。其中大约有一半的时间是在编译<code>llvm</code>。好在<code>llvm</code>只要编译一次，后续如果没有版本变化是不需要重新编译的。(<code>config.toml</code>里有个选项在版本变化的时候也不重新编译<code>llvm</code>)另外记得硬盘剩余空间要保证<code>30G</code>以上哦。</p>
<p>然后将其加到Rustup⼯具链中:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// your-target-tripe 类似：aarch64-apple-darwin/x86_64-apple-darwin 等。
&gt; rustup toolchain link stage2 build/{your-target-tripe}/stage2
<span class="boring">}
</span></code></pre></pre>
<p>到此为⽌，准备⼯作就已经做好了。</p>
<p>对这个话题感兴趣的可以继续读读官方准备的书籍<a href="https://rustc-dev-guide.rust-lang.org/">Guide to Rustc Development</a>，里面有更多的讲解。这本书中文社区也在组织翻译<a href="https://github.com/RustcRustc/rustc-dev-guide-zh">Guide to Rustc Development 中文版</a>，欢迎大家参与。</p>
<h2><a class="header" href="#一起成为-rust-contributor-吧" id="一起成为-rust-contributor-吧">一起成为 Rust Contributor 吧</a></h2>
<p>接下来，让我们试着为 Rust 项目来做点事情。<code>Rust Project</code>是非常欢迎大家参与的，参与的门槛是非常的低。</p>
<p>对于想参与贡献的新手来说，可以从比较轻松的任务做起。由此，我来试着难度从低到高列出一些比较适合新手来做的事情。</p>
<h3><a class="header" href="#no1-改进标准库文档" id="no1-改进标准库文档">No.1 改进标准库文档</a></h3>
<p>Rust 的每个标准库函数都在旁边有<code>markdown</code>语法的文档描述。对这一部分的调整改进是门槛最低的。可以多读读标准库的文档，顺便检查每个条目(item)和关联条目的文档描述是否足够的清晰。（特别是标注着<code>Experimental</code>的那些，往往会存在改进空间。）对于没有示例(<code>Example</code>)的部分，可以补充示例。对于标注了<code>unsafe</code>关键字的部分，可以检查下安全性(<code>Safety</code>)一节是否清晰的描述了使用时的约束条件。</p>
<h3><a class="header" href="#no2-改进语言参考手册" id="no2-改进语言参考手册">No.2 改进语言参考手册</a></h3>
<p>Rust 有一个相对冷门的资源叫<a href="https://github.com/rust-lang/reference">The Rust Language Reference</a>，是语言的规格说明的雏形，实际上能做的事情相当多。但是因为人手有限，进度不是很快。对于新手，有很多参加编辑性修改的机会。实质性修改门槛会稍微高一点，需要对语言有比较全面深刻的了解。但是因为是有老手帮助review，对新人来说也是不错的提升自己的机会。缺点是<code>review</code>周期可能会相对较长。</p>
<h3><a class="header" href="#no3-重构清理增加测试用例类任务" id="no3-重构清理增加测试用例类任务">No.3 重构、清理、增加测试用例类任务</a></h3>
<p>Rust里很多地方都有小型的重构、清理任务（而且很多都是故意留给新人练习的），包括<code>rustc</code>,<code>rustdoc</code>,<code>cargo</code>,<code>chalk</code>,<code>polonius</code>之类的地方都会有。可以多关注一下<code>E-easy</code>,<code>E-mentor</code>,<code>E-needs-test</code>这些标签下的问题条目，也不要忘了多去逛逛<code>cargo</code>,<code>chalk</code>等等的单独仓库。</p>
<h3><a class="header" href="#no4-完善编译器的诊断和代码质量检测" id="no4-完善编译器的诊断和代码质量检测">No.4 完善编译器的诊断和代码质量检测</a></h3>
<p>在编译器这一侧，最适合初学者学习的工作有两项，一个是诊断(<code>diagnostics</code>)，负责编译报错信息的完善，尽可能推断出用户的原本意图，并给出更好的错误提示。另一个就是代码质量检测(<code>lint</code>)。代码质量检测检查的是代码中那些不违反基本规则的那些写法，它们是可配置的，编译器可以配置为允许，警告，拒绝和严禁的形式进行响应。<a href="https://rustc-dev-guide.rust-lang.org/diagnostics.html">Guide to Rustc Development中有专门的一节进行讲解</a>，可做的事情也是非常多的。对于一些非常具体情况的检测和反馈，也可以放到<code>clippy</code>这个专门的检测工具中。可以多关注一下<code>A-Diagnostics</code>, <code>A-suggestion-diagnostics</code>, <code>A-lint</code>这些标签下的问题条目，以及<code>clippy</code>仓库中的问题条目。</p>
<h2><a class="header" href="#rust-pr-流程从提交到合并" id="rust-pr-流程从提交到合并">Rust PR 流程：从提交到合并</a></h2>
<p>要提交修改只要在<code>GitHub</code>上 fork 官方的<code>rust</code>仓库，把修改提交到自己的fork仓库里，然后建一个PR(Pull Request)就可以了。</p>
<p>接下来我来试着讲讲提交之后会发生的事情。感兴趣可以了解下，不感兴趣也可以跳过。</p>
<p><strong>PR CI 阶段</strong></p>
<p>官方<code>rust</code>仓库有好几个自动交互机器人。我们首先会接触到的是一个叫<code>rust-highfive</code>的机器人。它负责欢迎新人，并且如果你的 PR 里没写由谁来<code>review</code>的话(格式是<code>r? @XXX</code>)，它会自动把我们的<code>PR</code>随机分配给它觉得合适的人来<code>review</code>。分配的方法是它会看你修改了仓库里哪些文件，然后在相应的负责人员列表里随机分配。并且给你的 PR 加上一个<code>S-waiting-for-review</code>的标签，表示正在等待<code>review</code>的状态。同时 PR CI 会开始运行，如果你的修改有格式问题(没有执行<code>rustfmt</code>之类的)、编译或者单元测试不通过，就会被 PR CI 拦下来，告诉你编译失败。你可以继续调整。</p>
<p><strong>官方 Reviewer 审阅</strong></p>
<p>接下来几天之内往往就会有官方 Reviewer 来审阅我们的修改了。Reviewer 都是官方某个团队的正式成员。因为 PR 都是公开的，在这期间，其他成员、社区爱好者也有可能会帮忙审阅你的代码，帮我们提出修改意见之类的。Reviewer 看了之后也可能要求我们修改。他们会把 PR 状态改成<code>S-waiting-for-author</code>。还有一种情况是这段时间里代码更新导致了合并冲突。机器人会来留言告诉你有合并冲突。这个时候你需要执行一个<code>git</code>的<code>rebase</code>操作，完成对合并冲突的解决，然后更新你的 PR 分支。</p>
<p>很多 PR 会在这一阶段停留一段时间，官方有一个小的分类处理工作组(<code>T-release</code>/<code>WG-triage</code>)，会定期来检查各个 PR 的状态。对于等待作者处理的 PR，15 天左右会留言确认状态；如果 30 天左右没有响应，会留言并关闭 PR。对于等待<code>review</code>的 PR，会在 15 天左右整理成报告，部分会通知 reviewer 确认审阅进度。</p>
<p><strong>PR 合并</strong></p>
<p>Reviewer 觉得你的提交<code>ok</code>了之后就会进入下一阶段了。Reviewer 会给另一个名叫<code>bors</code>的机器人发指令标识审阅通过(<code>@bors r+</code>)。这个命令有俩参数，一个是优先级(<code>p</code>)，优先级高的会在排在队列靠前的位置。一个是是否参与批量合并(<code>rollup</code>)。如果你的贡献足够微小，Reviewer 会把<code>rollup</code>设置为<code>always</code>，永不参与单独测试合并。相反如果你的贡献可能会带来编译性能影响之类的，Reviewer 会把<code>rollup</code>设置为<code>never</code>，永不参与批量测试合并，这样万一以后需要<code>revert</code>的话会比较方便。</p>
<p>接下来就是测试合并阶段了。<code>Bors</code>机器人管理着一个<a href="https://bors.rust-lang.org/queue/rust">PR队列</a>。<code>Bors</code>机器人会按照队列的顺序一次一个 PR 来<strong>先合并</strong>，再测试，通过后推送远端分支并更新关闭相应的 PR。对于那些<code>rollup=always</code>的 PR，<code>bors</code>是不会合并的。官方的一些成员会轮流负责<code>Rollup</code>工作，每次控制<code>Bors</code>机器人来产生一个<code>8~12</code>个 PR 构成的一个高优先级的批量合并的 PR 加到队列里，由<code>bors</code>来测试合并。</p>
<h2><a class="header" href="#小结-2" id="小结-2">小结</a></h2>
<p>这次我们从一个开发者的视角，了解了参与rust项目所需要的一些基本知识和切入点，下一次我们会介绍一下项目组的总体结构以及如何参与一些更大型的工作。到时见！</p>
<hr />
<p>作者介绍：</p>
<p>CrLF0710，C++程序员/ Rust业余爱好者/ Rust Team版本发布团队分类处理工作组（负责参与 Rust Project 的issues 和 PR 分类管理）成员。</p>
<p>业余时间写些<code>Rust</code>代码，也对<code>rustc</code>, <code>cargo</code>, <code>chalk</code>, <code>rustup</code>, <code>rustbook</code>等都做过一些代码贡献。偶尔在知乎Rust主题专栏<a href="https://www.zhihu.com/column/rust-quickstart">《学一点Rust又不会怀孕》</a>上写一些文章。</p>
<h1><a class="header" href="#三月刊" id="三月刊">三月刊</a></h1>
<p><img src="chapter_3/../image/rust_magazine3.png" alt="logo" /></p>
<h3><a class="header" href="#发刊通告-1" id="发刊通告-1">发刊通告</a></h3>
<ul>
<li><a href="chapter_3/./announce.html">发刊通告</a></li>
</ul>
<h3><a class="header" href="#本月社区动态简报-2" id="本月社区动态简报-2">本月社区动态简报</a></h3>
<p>精选自《Rust日报》</p>
<ul>
<li><a href="chapter_3/./lang.html">Rust官方动态</a></li>
<li><a href="chapter_3/./hots.html">社区热点</a></li>
<li><a href="chapter_3/./projects.html">推荐项目</a></li>
<li><a href="chapter_3/./learns.html">学习资源</a></li>
<li><a href="chapter_3/./rust_laoke.html">Rust 唠嗑室本月汇总</a></li>
</ul>
<h3><a class="header" href="#rust-in-production-2" id="rust-in-production-2">Rust in Production</a></h3>
<ul>
<li><a href="chapter_3/./hw_rust_stratovirt.html">华为 | 基于Rust的下一代虚拟化平台-StratoVirt</a></li>
<li><a href="chapter_3/./hw_ndarray.html">华为 | Rust 科学计算多维数组运算库的分析与实践</a></li>
<li><a href="chapter_3/./hw_rust_rvm_wasm_ai.html">华为 | 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型</a></li>
<li><a href="chapter_3/./rust_cpu_affinity.html">蚂蚁集团 CeresDB 团队 | Rust CPU 亲和性(Affinity) 初探</a></li>
<li><a href="chapter_3/./rust_rdma.html">DatenLord | Rust实现RDMA</a></li>
</ul>
<h3><a class="header" href="#学习园地-2" id="学习园地-2">学习园地</a></h3>
<ul>
<li><a href="chapter_3/./no_std_binary.html"><code>no_std</code> 环境下的可执行文件</a></li>
<li><a href="chapter_3/./ink.html">用 Rust 写智能合约 | Hello, Ink! </a></li>
<li><a href="chapter_3/./reservoir.html">「算法」蓄水池算法改进 - 面向抽奖场景保证等概率性</a></li>
<li><a href="chapter_3/./rust-mysql.html">Rust 中使用 MySQL</a></li>
<li><a href="chapter_3/./rust-design-pattern-factory.html">「系列」Rust 设计模式 ｜ 工厂模式</a></li>
<li><a href="chapter_3/./rust_vs_pandas.html">「译」数据操作：Rust vs Pandas</a></li>
<li><a href="chapter_3/./Unsafe_Rust_How_and_when_not_to_use_it.html">「译」Unsafe Rust 的取舍</a></li>
<li><a href="chapter_3/./Rhythm-game-in-Rust-using-bevy.html">「译」基于 Rust 用 Bevy 实现节奏大师游戏</a></li>
<li><a href="chapter_3/./arenas-in-rust.html">「译」Arenas in Rust</a></li>
<li><a href="chapter_3/./toy-front-end-for-llvm-write-in-rust.html">「译」用 Rust 编写 LLVM 的玩具编译器</a></li>
</ul>
<h3><a class="header" href="#系列透过-rust-探索系统的本原" id="系列透过-rust-探索系统的本原">【系列】透过 Rust 探索系统的本原</a></h3>
<ul>
<li><a href="chapter_3/./rust-to-system-essence-concurrent.html">透过 rust 探索系统的本原：并发篇</a></li>
<li><a href="chapter_3/./rust-to-system-essence-safety.html">透过 rust 探索系统的本原：安全篇</a></li>
</ul>
<h3><a class="header" href="#rust-编译器专题-2" id="rust-编译器专题-2">Rust 编译器专题</a></h3>
<ul>
<li><a href="chapter_3/./contribute_to_the_rust_part2.html">如何为 Rust 语言做贡献 | Part 2</a></li>
</ul>
<h1><a class="header" href="#发刊通告-2" id="发刊通告-2">发刊通告</a></h1>
<p>编辑：张汉东</p>
<h3><a class="header" href="#三月发刊通告" id="三月发刊通告">三月发刊通告</a></h3>
<p>三月，万物复苏，万象更新。不知不觉，三月的最后一天到了，《 RustMagazine 中文精选 》2021 年第三期发布了!</p>
<p>每次发布月刊，都会体会到时光流逝的无情。毕竟一年才十二个月，所以月刊一年一共才十二期，现在第三期已经发布了。更重要的是，当月刊发布的时候，也意味着三月即将过去。为了迎接四月的到来，大地作了太多的准备，你呢？你的四月又将为什么样的目标做准备呢？无论如何，加油吧！</p>
<h3><a class="header" href="#社区协作项目动态介绍" id="社区协作项目动态介绍">社区协作项目动态介绍</a></h3>
<p><strong>介绍两个新创建的协作项目：</strong></p>
<ol>
<li><a href="https://github.com/ZhangHanDong/star-rust">Star Rust</a>。该项目用于记录 Rust 开源生态中的明星项目。不同于 awesome-rust ，该项目侧重于记录明星项目，及其介绍、架构、应用、源码解读。</li>
<li><a href="https://github.com/ZhangHanDong/real-world-rust-design-pattern">Real World Rust Design Pattern</a>。该项目用于挖掘 Rust 开源生态中知名项目的设计模式。</li>
</ol>
<p>以上项目是需要社区大家一起完成的，如果你是一个喜欢学习并且输出的人，并且对上面项目感兴趣，欢迎大家一起做贡献。</p>
<p>将来这些内容，也会摘录到本刊中。</p>
<p>**【活动预告】2021.04.10 北京 Rust Meetup **</p>
<p>报名链接 ：  <a href="http://hdxu.cn/ZxJjK">http://hdxu.cn/ZxJjK</a></p>
<p>该活动相关议题内容也请关注下期月刊。</p>
<h3><a class="header" href="#上期二月刊访问数据统计小结" id="上期二月刊访问数据统计小结">上期（二月刊）访问数据统计小结</a></h3>
<p><strong>用户数</strong></p>
<ul>
<li>总用户数 1670 （同比上升 268%)</li>
<li>30天活跃用户数 464</li>
</ul>
<p><strong>浏览量：</strong></p>
<ul>
<li>网页浏览量 ：11,410 （同比上升 349.8%）</li>
<li>唯一身份浏览量 ：7,410</li>
</ul>
<p><strong>读者分布地区排名：</strong></p>
<ul>
<li>中国 （同比上升 212%）</li>
<li>中国香港（同比上升 369%）</li>
<li>中国台湾（同比上升 257%）</li>
<li>新加坡（同比上升 467%）</li>
<li>北美（美国/加拿大）（同比上升 296%）</li>
</ul>
<p><strong>二月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<p>注： 一月刊的 《图解 Rust 所有权》文章依旧最受欢迎，作者：肖猛 </p>
<ul>
<li>《 前端入门 ｜ Rust 和 WebAssembly》，作者: 陈鑫(lencx)</li>
<li>《 实践案例 | 使用 Bevy 游戏引擎制作炸弹人》，作者：Cupnfish</li>
<li>《 蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考 》， 作者：evenyag</li>
<li>《 华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景》，作者：俞一峻等三位</li>
<li>《 DatenLord ｜ Linux 全新异步接口 io_uring 的 Rust 生态盘点》，作者：施继成</li>
</ul>
<p><strong>简报关注分类依次为：</strong></p>
<p>热度基本和一月刊相差无几：</p>
<ul>
<li>学习资源</li>
<li>Rust 官方动态</li>
<li>推荐项目</li>
<li>社区热点</li>
<li>Rust 唠嗑室</li>
</ul>
<p>后续也期待大家投稿。欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！</p>
<h1><a class="header" href="#rust官方动态" id="rust官方动态">Rust官方动态</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑： 张汉东</li>
</ul>
<hr />
<h2><a class="header" href="#建立-async-rust-的共同愿景" id="建立-async-rust-的共同愿景">建立 Async Rust 的共同愿景</a></h2>
<p>2021年3月18日·Niko Matsakis 代表 <a href="https://rust-lang.github.io/wg-async-foundations/">Async Foundations Working Group</a></p>
<p>在 <a href="https://rust-lang.github.io/wg-async-foundations/">异步基础工作组</a> 认为 Rust 能够成为最热门的选择之一为构建分布式系统，从嵌入式设备到基础云服务。无论他们将其用于什么，我们都希望所有开发人员都喜欢使用 Async Rust。为了实现这一点，我们需要将 Async Rust 移至目前的“MVP”状态之外，并使所有人都可以使用它。</p>
<p>我们正在开展合作，为 Async Rust 构建共享的 <a href="https://rust-lang.github.io/wg-async-foundations/vision.html#-the-vision">愿景文档</a> 。<code>我们的目标是让整个社区参与到集体的想象中</code>：我们如何才能使使用异步 I/O 的端到端体验不仅是一种务实的选择，而且是一种快乐的选择？</p>
<p><a href="chapter_3/./async-vision-doc.html">点此阅读该文中文翻译</a></p>
<h2><a class="header" href="#rust-151-稳定版发布" id="rust-151-稳定版发布">Rust 1.51 稳定版发布</a></h2>
<p>$ rustup update stable</p>
<p>该版本主要是带来了 ：</p>
<ol>
<li>Const Generics MVP  ： https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html </li>
<li>顺便  std::array::IntoIter 也稳定了</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T, const N: usize&gt; {
    data: [MaybeUninit&lt;T&gt;; N],
    alive: Range&lt;usize&gt;,
}

impl&lt;T, const N: usize&gt; IntoIter&lt;T, N&gt; {

}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>新的 cargo crate 依赖管理机制。 具体查看 RFC 2957。 简单来说，通过设置 resolver=&quot;2&quot; 来告诉 cargo 启用新的解析 features 方法，从而解决当前因为cargo 默认合并features带来的问题。概述：</li>
</ol>
<ul>
<li>对于 dev dependencies： 当包（package）作为常规依赖项和开发依赖项共享时，仅当当前构建包含开发依赖项时，才启用开发依赖项features</li>
<li>Host Dependencies ：当包作为 常规依赖 和 构建依赖或proc-macro共享时，用于常规依赖的features 将独立于构建依赖或proc-macro。</li>
<li>Target Dependencies: 当包在构建图中多次出现，并且其中一个实例是特定于目标的依赖项时，仅当当前正在构建目标时，才启用特定于目标的依赖项的features。</li>
</ul>
<p>不过这样可能会导致编译时间加长（因为可能多次编译同一个crate），更详细内容可以看 Cargo Guide 的 &quot;Feature Resolver&quot; 小节。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
resolver = &quot;2&quot;
<span class="boring">Or if you're using a workspace
</span>[workspace]
resolver = &quot;2&quot;
<span class="boring">}
</span></code></pre></pre>
<ol start="4">
<li>针对 MacOS 平台对 Debug 模式构建时间做了优化。去掉了之前通过 dsymutil 工具将debug信息收集到.dSYM目录下的方式，而使用新的方式，从而减少debuginfo的构建时间，并显着减少所使用的磁盘空间量。但还期待macOS 用户的更多构建报告。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.dev]
split-debuginfo = &quot;unpacked&quot;
<span class="boring">}
</span></code></pre></pre>
<p>这样设置就可以启用新的行为</p>
<ol start="5">
<li>稳定了很多 API ，就不细说了。值得一提的是 <code>task::Wake</code>现在稳定了。</li>
</ol>
<p><a href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html">https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html</a></p>
<h2><a class="header" href="#rust-2021-edition-计划10月21号发布" id="rust-2021-edition-计划10月21号发布">Rust 2021 Edition 计划10月21号发布</a></h2>
<p>Rust 采用每六周一个小版本和每三年一个 Edition 版本的方式来迭代更新。相比于 2018 Edition，2021 Edition 会是一个相对小的版本，官方计划于 2021年10月21号（1.56）正式发布。目前并没有完全确定下来哪些功能将纳入 2021 Edition，但有部分特性是已经确定好的了，这些特性包括：</p>
<p>Prelude 加入新的 <code>trait</code>：<code>TryFrom / TryInto</code>, <code>FromIterator</code></p>
<p>更 ergonomic 的闭包变量捕获规则。</p>
<p>现在的闭包变量捕获非常严格，就算你只引用了单个 struct 的字段，它也会把整个 struct 捕获进来。新的规则会做到尽量小范围的捕获变量，比如下面两个例子在 2018 Edition 编译不通过，但是 2021 Edition 是可以的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _a = &amp;mut foo.a;
|| &amp;mut foo.b; // (Edition 2018) Error! cannot borrow `foo`

let _a = &amp;mut foo.a;
move || foo.b; // (Edition 2018) Error! cannot move `foo`
改善 or 模式匹配
// 以前需要这么写的或规则匹配：
Some(Enum::A) | Some(Enum::B) | Some(Enum::C) | Some(Enum::D) =&gt; ..

// 2021 Edition 之后可以写成这样了！
Some(Enum::A | Enum::B | Enum::C | Enum::D) =&gt; ..
<span class="boring">}
</span></code></pre></pre>
<p>统一 macro_rules 定义的宏的默认可见性，移除<code>#[macro_export]</code> 和 <code>#[macro_use]</code> 宏：
Rust 所有类型可见性默认都是私有，只有加 pub 或 pub($PATH) 才能修改为公开可见，而 macro_rules 定义的宏却不是这样的，你需要使用 <code>#[macro_export]</code> 才能让这个宏公开。从 2021 Edition 开始，macro_rules 定义的宏默认为私有，同样需要加 pub 或 pub($PATH) 才能修改可见性。<code>#[macro_export] </code>和 <code>#[macro_use]</code> 这两个宏就没什么用了，直接移除。</p>
<p><a href="https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html">链接</a></p>
<h2><a class="header" href="#rust-编译器后端升级为-llvm-12" id="rust-编译器后端升级为-llvm-12">Rust 编译器后端升级为 LLVM 12</a></h2>
<p><a href="https://github.com/rust-lang/rust/pull/81451">链接</a></p>
<h2><a class="header" href="#gloo-一个官方的-rustwasm-项目寻找-maintainer" id="gloo-一个官方的-rustwasm-项目寻找-maintainer">gloo: 一个官方的 rustwasm 项目寻找 maintainer</a></h2>
<p>gloo 是 rustwasm 下的一个官方项目 (801星) , 由于作者不能再维护, 所以在寻找一个maintainer. 感兴趣的小伙伴可以尝试联系一下.</p>
<p><a href="https://github.com/rustwasm/gloo/issues/119">原始issue地址</a></p>
<h2><a class="header" href="#miri运行在wasm上" id="miri运行在wasm上">Miri运行在wasm上！</a></h2>
<p>现在已经有方法可以将miri编译到wasm了。</p>
<p><a href="https://github.com/rust-lang/miri/issues/722#issuecomment-795763551">issue </a></p>
<h1><a class="header" href="#社区热点" id="社区热点">社区热点</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑：张汉东</li>
</ul>
<hr />
<h2><a class="header" href="#华为--openeuler-社区在-3-月-29-日正式成立了-rust-sig" id="华为--openeuler-社区在-3-月-29-日正式成立了-rust-sig">华为 | openEuler 社区在 3 月 29 日正式成立了 Rust SIG</a></h2>
<p>近日，openEuler 社区正式成立了 Rust SIG 组织。在维护 openEuler 操作系统内 Rust 工具链相关软件包的同时，也致力于将上游 Rust 社区优秀开源项目引入到 openEuler 操作系统中。openEuler 社区未来会持续和国内 Rust 社区和相关厂商通力合作，推动 Rust 语言在国内的发展，吸引更多的开发者关注和使用 Rust 语言。</p>
<p>欢迎订阅 rust@openeuler.org 邮件列表，参与到社区讨论中。</p>
<p>订阅方法：</p>
<p>https://openeuler.org/zh/community/mailing-list/ 在这个页面找到 Rust SIG，然后进去有 SubScribe 按钮，输入你到邮箱订阅。然后会收到一封邮件，你回复这封邮件即可。</p>
<h2><a class="header" href="#niko--我们的-aws-rust-团队将如何为-rust-未来的成功做出贡献" id="niko--我们的-aws-rust-团队将如何为-rust-未来的成功做出贡献">Niko | 我们的 AWS Rust 团队将如何为 Rust 未来的成功做出贡献</a></h2>
<p>自今年年初以来，AWS Rust 团队一直在起草我们的章程和宗旨。
章程和宗旨是 AWS 团队用来定义我们的范围和优先事项的框架。
章程告诉你的团队该做什么，宗旨告诉你的团队将如何做到这一点。
由于我们的团队宗旨一直是公开和透明运作的，我们想与您分享我们的章程和宗旨，我们希望您知道我们在做什么。</p>
<p>起草我们的章程很容易。
这只是一句话：AWS Rust 团队致力于让 Rust 为其所有用户提供高效、可靠的服务。
说得够多了！
然而，撰写这些宗旨需要更多的工作。</p>
<p>等等，AWS 有个 Rust 小组？</p>
<p>是的! 事实上，至少从 2017 年开始，AWS 就在多项服务中使用 Rust。
例如，用 Rust 编写的 Firecracker 于 2018 年推出，提供支持 AWS Lambda 和其他无服务器产品的开源虚拟化技术。
最近，AWS 发布了用 Rust 编写的基于 Linux 的容器操作系统 Bottlerocket ，Amazon Elastic Compute Cloud(Amazon EC2) 团队使用 Rust 作为新的 AWS Nitro 系统组件(包括 Nitro Enclaves 等敏感应用程序)的首选语言。
随着在 AWS 中采用 Rust 的增长，我们对 Rust 项目和社区的投资也在增加。
2019年，AWS 宣布赞助 Rust 项目。
2020年，AWS 开始打造 Rust 维护者和贡献者团队，2021年，AWS 联合其他 Rust 用户和 Rust 项目发起了 Rust 基金会。
AWS Rust 团队首先找出了如何最好地与 AWS 和更广泛的开源社区建立联系。
我们知道，我们希望在公开的环境下运作，并成为整个社会的一份子。
与此同时，我们知道我们想要充分利用在 AWS 工作的机会。
起草章程和宗旨是我们找到两者兼顾的方法和过程的一部分。</p>
<p><a href="chapter_3/./how-our-aws-rust-team-will-contribute-to-rusts-future-successes.html">点此阅读该文的中文翻译</a></p>
<h3><a class="header" href="#rust-for-linux-相关" id="rust-for-linux-相关">Rust for Linux 相关</a></h3>
<p><strong>linux-next 分支现在已被合并。</strong></p>
<p>Linus Torvalds 讨论 Rust 适合Linux 的场景</p>
<p>关键内容：</p>
<ol>
<li>Coreutils  的 Rust 版本已经被 Mozilla 主管 Sylvestre Ledru 移植到了 Linux 。有了这些，Ledru启动了Linux并运行了最受欢迎的Debian软件包。</li>
<li>Linux Rust的支持者并不是： “提议将Linux内核重写为Rust“ 。 他们只是专注于向可能编写新代码的世界迈进。 </li>
<li>Rust支持的三个潜在方面是：利用内核中的现有API，体系结构支持，以及处理Rust和C之间的应用程序二进制接口（ABI）兼容性。</li>
<li>Linus 目前到态度是： 等待和观察。 他对 Rust for Linux 是感兴趣的，就个人而言，他绝不会排挤 Rust，但Linus 认为目前这个事情是那些对 Rust 抱有强烈兴趣的人推动的（Linus比较冷静），他想看看最终 Rust 在实践中如何发挥作用。</li>
<li>linux 认为 Rust 可能的场景：Rust的主要首要目标似乎是驱动程序，仅是因为在那里可以找到许多不同的可能目标，并且内核的这些各个部分相当小且独立。这可能不是一个非常有趣的目标。对某些人来说，但这是显而易见的。</li>
<li>Kroah-Hartman 的观点：“一切都归结为如何将用C编写的内核核心结构和生存期规则之间的交互映射到Rust结构和生存期规则中”</li>
<li>尽管几乎可以肯定不会很快看到Linux从C 迁移到Rust，但是接下来的几年估计会非常有趣： 引入基于 Rust 的用户空间程序/ 驱动程序/  基于 Rust 的 内核迁移到 Linux 等。</li>
</ol>
<p>相关链接合集，排序规则：最上面的是最新的</p>
<p>Linux Kernel's Preliminary Rust Code Seeing 64-bit POWER Support
<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Kernel-Rust-PPC64LE">https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Kernel-Rust-PPC64LE</a></p>
<p><a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Rust-Hits-Linux-Next">https://www.phoronix.com/scan.php?page=news_item&amp;px=Rust-Hits-Linux-Next</a></p>
<p><a href="https://www.zdnet.com/article/linus-torvalds-on-where-rust-will-fit-into-linux/">https://www.zdnet.com/article/linus-torvalds-on-where-rust-will-fit-into-linux/</a></p>
<p><a href="https://lore.kernel.org/rust-for-linux/CANiq72nbNxpps+p4wYp03ncrbGH9FFoTfHQZwg_vGdPO41eGmQ@mail.gmail.com/t/">https://lore.kernel.org/rust-for-linux/CANiq72nbNxpps+p4wYp03ncrbGH9FFoTfHQZwg_vGdPO41eGmQ@mail.gmail.com/t/</a></p>
<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/rust?id=c77c8025525c36c9d2b9d82e4539403701276a1d">https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/rust?id=c77c8025525c36c9d2b9d82e4539403701276a1d</a></p>
<h2><a class="header" href="#linux-基金会-和-riscv-基金会-共同推出的-免费-riscv-课程" id="linux-基金会-和-riscv-基金会-共同推出的-免费-riscv-课程">Linux 基金会 和 RISCV 基金会 共同推出的 免费 RISCV 课程</a></h2>
<p>课程发布在 edx.org 上，包括两个课程： </p>
<ul>
<li>Introduction to RISC-V (LFD110x)</li>
<li>Building a RISC-V CPU Core (LFD111x) </li>
</ul>
<p><a href="https://www.zdnet.com/article/linux-foundation-risc-v-international-launch-free-risc-v-training-classes/">https://www.zdnet.com/article/linux-foundation-risc-v-international-launch-free-risc-v-training-classes/</a></p>
<h2><a class="header" href="#rust-and-llvm-in-2021" id="rust-and-llvm-in-2021">Rust and LLVM in 2021</a></h2>
<p>作者是 Rust 的核心团队成员, 之前就职于 Mozilla, 现就职于 Facebook. 写过最初的基于 LLVM 的 Rust 代码生成器, 以及很多 Rust 相关的工作.</p>
<p>该 keynote 讲述的是 Rust 中 LLVM 相关工作:</p>
<p>新的特性. 将LLVM 的提升带到 Rust 中.
LLVM 相关的提升和修复.
未来的挑战.
对于 Rust 编译器层面感兴趣的小伙伴可以深入了解.</p>
<p><a href="https://www.icloud.com/keynote/09ZXbPfbCKm8vCtAnWdfi2xIg#rust-llvm-cgo-2021">keynote地址</a></p>
<h2><a class="header" href="#rust版coreutils现在可以用来跑debian啦" id="rust版coreutils现在可以用来跑debian啦">Rust版coreutils现在可以用来跑Debian啦</a></h2>
<p>现在可以用Rust版的Coreutils (cp, chmod, ls, rm, tail, install..) 来运行Debian啦。</p>
<ul>
<li><a href="https://github.com/uutils/coreutils/">GitHub项目地址</a></li>
<li><a href="https://sylvestre.ledru.info/blog/2021/03/09/debian-running-on-rust-coreutils">阅读更多</a></li>
</ul>
<h2><a class="header" href="#curl-工具一半的漏洞都是关于-c-语言的错误" id="curl-工具一半的漏洞都是关于-c-语言的错误"><code>curl</code> 工具一半的漏洞都是关于 C 语言的错误</a></h2>
<p>作者对这一问题进行了分析，并提到一个观点，如果用 Rust 来写 curl 的话，这些漏洞会减少一半。</p>
<p><a href="https://daniel.haxx.se/blog/2021/03/09/half-of-curls-vulnerabilities-are-c-mistakes/">链接</a></p>
<h2><a class="header" href="#rust-和-c-速度比较" id="rust-和-c-速度比较">Rust 和 C 速度比较</a></h2>
<p>Rust 和 C 的编程风格差异很大，但两者开发的程序在运行速度和内存使用情况上大致相同。语言在理论上可以实现什么，但在实践中如何使用它们之间有很大的区别。作者总结了Rust 和 C 各自在哪些地方会更快。</p>
<p>简而言之</p>
<ul>
<li>Rust 可以在必要时以足够底层的方式对其进行优化，使其达到与 C 一样的性能；</li>
<li>Rust 拥有更高层次的抽象，便捷的内存管理和丰富的第三方库；</li>
<li>Rust 最大的潜力在于无畏并发（fearless concurrency）能力。</li>
</ul>
<p><a href="https://kornel.ski/rust-c-speed">文章链接</a></p>
<h2><a class="header" href="#github-action-将-rust-warning-转为-review-comments" id="github-action-将-rust-warning-转为-review-comments">GitHub Action 将 Rust warning 转为 review comments</a></h2>
<p>Rust Action 可以在出发执行后，将 Rust check 的 warning 转为 code review 的 comments。</p>
<p><a href="https://twitter.com/greyblake/status/1370117541436219393?s=20">ReadMore</a></p>
<h2><a class="header" href="#intellij-rust-changelog-143" id="intellij-rust-changelog-143">INTELLIJ RUST CHANGELOG #143</a></h2>
<p>为类似函数的程序宏提供初步支持。现在，插件可以扩展这种程序性宏调用；因此，它们自动获得声明性宏已经具备的一些功能：高亮显示、名称解析、有限的代码完成、意图等。</p>
<p><img src="https://intellij-rust.github.io/assets/posts/changelog-143/function-like-proc-macro-support.gif" alt="gif" /></p>
<h2><a class="header" href="#veloren-09" id="veloren-09">Veloren 0.9</a></h2>
<p>一款开源多人RPG游戏，今天发布了!会在3月20日格林威治时间18:00发布在公共服务器上!</p>
<p>《Veloren》是一款多人体素RPG游戏。它的灵感来自《魔方世界》、《塞尔达传说:荒野之息》、《矮人要塞》和《我的世界》等游戏。</p>
<p>Veloren是完全开源的，使用GPL 3授权。它使用原始图形，音乐和其他资产社区创建的资产。它的开发社区和用户社区都是受贡献者驱动的:开发者、玩家、艺术家和音乐家一起开发游戏。</p>
<p><a href="https://veloren.net/">文章链接</a></p>
<h2><a class="header" href="#actix-actor-framework-v011-出來了" id="actix-actor-framework-v011-出來了">Actix Actor Framework v0.11 出來了</a></h2>
<p><code>~40%</code> 的效能改善，升级到 Tokio v1 </p>
<p><a href="https://github.com/actix/actix/blob/master/actix/CHANGES.md">Actix 0.11 Change Log</a></p>
<h2><a class="header" href="#知乎-搜索引擎研发rust-工程师" id="知乎-搜索引擎研发rust-工程师">知乎| 搜索引擎研发（Rust) 工程师</a></h2>
<p>岗位职责</p>
<ul>
<li>负责搜索引擎平台架构建设，优化系统稳定性，设计良好的架构支持业务快速迭代</li>
<li>抽象通用的搜索引擎部署方案，用于快速支持各大垂直搜索引擎</li>
<li>参与知乎搜索业务优化</li>
</ul>
<p>任职要求：</p>
<ul>
<li>有扎实的编程能力，有良好的数据结构和算法基础</li>
<li>良好的团队合作精神，较强的沟通能力</li>
<li>熟悉 Linux 开发环境，熟悉 Go/Rust 语言，熟悉网络编程、多线程编程</li>
<li>熟悉搜索引擎，对 Elasticsearch、Kubernetes 有使用经验者优先</li>
<li>有高可靠分布式系统架构设计经验者优先</li>
</ul>
<p>知乎搜索Rust 开源项目： https://github.com/zhihu/rucene</p>
<p>联系邮箱:</p>
<p><a href="chapter_3/zhihu.com">zl 【at】 zhihu 点 com</a></p>
<h2><a class="header" href="#蚂蚁集团校招开启rust-实习生看过来" id="蚂蚁集团校招开启rust-实习生看过来">蚂蚁集团校招开启：Rust 实习生看过来</a></h2>
<p>@2021.11.1～2022.10.31毕业的应届生可看 ，要推荐的可以找我咨询 ，也可直接联系。</p>
<p>招聘部门：</p>
<ul>
<li>
<p>蚂蚁智能监控团队JD（内有联系方式）： <a href="https://mp.weixin.qq.com/s/mi5woh-btWEEsc8ruSww7Q">https://mp.weixin.qq.com/s/mi5woh-btWEEsc8ruSww7Q</a></p>
</li>
<li>
<p>蚂蚁机密计算部门: 直接联系方式：微信32713933， email shoumeng.ysm@antgroup.com</p>
</li>
</ul>
<p>部门相关信息看下面链接：</p>
<p><a href="https://mp.weixin.qq.com/s/9t6_RrgSujrosDVphlzebg">https://mp.weixin.qq.com/s/9t6_RrgSujrosDVphlzebg</a></p>
<h2><a class="header" href="#327-号-深圳-rust-meetup-视频和资料" id="327-号-深圳-rust-meetup-视频和资料">3.27 号 深圳 Rust Meetup 视频和资料</a></h2>
<p>活动PPT和现场视频链接：</p>
<ul>
<li><a href="https://disk.solarfs.io/sd/6e7b909b-133c-49f7-be0f-a51f65559665">https://disk.solarfs.io/sd/6e7b909b-133c-49f7-be0f-a51f65559665</a></li>
</ul>
<p>B 站：</p>
<ul>
<li><a href="https://b23.tv/aKsBq3">https://b23.tv/aKsBq3</a></li>
<li><a href="https://b23.tv/UR07IW">https://b23.tv/UR07IW</a></li>
</ul>
<h1><a class="header" href="#本月简报--推荐项目-2" id="本月简报--推荐项目-2">本月简报 | 推荐项目</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑：杨楚天</li>
</ul>
<h2><a class="header" href="#lens-rs" id="lens-rs">lens-rs</a></h2>
<ul>
<li><a href="https://github.com/TOETOE55/lens-rs">仓库链接</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/358678675">文章链接</a></li>
</ul>
<p>lens-rs 是一个 lens 的 rust 实现。</p>
<h2><a class="header" href="#tinyvm" id="tinyvm">tinyvm</a></h2>
<ul>
<li><a href="https://github.com/mkhan45/tinyvm">仓库链接</a></li>
</ul>
<p>tinyvm 是一个堆栈字节码虚拟机的最小化可用实现。这个 VM  可以运行一个简单的图灵完备的指令集。核心代码只有 250 行，并且有大量注释。</p>
<h2><a class="header" href="#maple" id="maple">maple</a></h2>
<ul>
<li><a href="https://github.com/lukechu10/maple">仓库链接</a></li>
</ul>
<p>maple 是一个用 WASM 实现的响应式 DOM 库，没用到虚拟 DOM，而是在渲染过程中细粒度响应式地更新 DOM。</p>
<h2><a class="header" href="#byo-linker" id="byo-linker">byo-linker</a></h2>
<ul>
<li><a href="https://github.com/andrewhalle/byo-linker">仓库链接</a></li>
</ul>
<p>byo-linker 是一个极简的链接器，用于帮助理解链接器的实现方法。</p>
<h2><a class="header" href="#rs_pbrt" id="rs_pbrt">rs_pbrt</a></h2>
<ul>
<li><a href="https://github.com/wahn/rs_pbrt">仓库链接</a></li>
<li><a href="https://www.janwalter.org/doc/rust/pbrt/index.html">文档链接</a></li>
<li><a href="https://www.rs-pbrt.org/blog/v0-9-0-release-notes/">文章链接</a></li>
</ul>
<p>rs_pbrt 是经典书籍 <em>Physically Based Rendering: From Theory to Implementation</em> 的 rust 实现。</p>
<h2><a class="header" href="#flume" id="flume">flume</a></h2>
<ul>
<li><a href="https://github.com/zesterer/flume">仓库链接</a></li>
</ul>
<p>flume 是一个 mpmc 的 channel 库，其用法和 <code>std::sync::mpsc</code> 基本一致，代码里没包含任何 <code>unsafe</code>。</p>
<h2><a class="header" href="#ferris-fetch" id="ferris-fetch">ferris-fetch</a></h2>
<ul>
<li><a href="https://github.com/irevenko/ferris-fetch">仓库链接</a></li>
</ul>
<p>ferris-fetch 可以用于获取 rust 工具链以及操作系统的信息。</p>
<h2><a class="header" href="#station-iapetus" id="station-iapetus">Station Iapetus</a></h2>
<ul>
<li><a href="https://github.com/mrDIMAS/StationIapetus">仓库链接</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/m8suco/station_iapetus_the_game_written_in_rust_based_on/">文章链接</a></li>
</ul>
<p>Station Iapetus 是一个用 <a href="https://github.com/mrDIMAS/rg3d">rg3d</a> 开发的第三人称射击游戏，仍处于早期开发阶段。</p>
<h2><a class="header" href="#veloren" id="veloren">Veloren</a></h2>
<ul>
<li><a href="https://github.com/veloren/veloren">仓库链接</a></li>
<li><a href="https://veloren.net/">主页链接</a></li>
</ul>
<p>Veloren 是一个像素风的多人 RPG 游戏，其灵感来自《魔方世界》、《塞尔达传说:荒野之息》、《矮人要塞》和《我的世界》等游戏。</p>
<h2><a class="header" href="#mlc" id="mlc">mlc</a></h2>
<ul>
<li><a href="https://github.com/becheran/mlc">仓库链接</a></li>
</ul>
<p>mlc 可以用于检查 html 和 markdown 中的无效链接。</p>
<h2><a class="header" href="#kamu" id="kamu">Kamu</a></h2>
<ul>
<li><a href="https://github.com/kamu-data/kamu-cli">仓库链接</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/kamu-data/kamu-cli/master/docs/readme_files/dataset_graph.png" alt="img" /></p>
<p>Kamu 是 <a href="https://github.com/kamu-data/open-data-fabric">Open Data Fabric</a> 的 rust 实现。</p>
<h2><a class="header" href="#miniwasm" id="miniwasm">MiniWASM</a></h2>
<ul>
<li><a href="https://github.com/thedjinn/MiniWASM">仓库链接</a></li>
</ul>
<p>MiniWASM 是一个极简的 Rust WebAssembly 的项目模版。</p>
<h2><a class="header" href="#rkyv" id="rkyv">rkyv</a></h2>
<ul>
<li><a href="https://github.com/djkoloski/rkyv">仓库链接</a></li>
<li><a href="https://davidkoloski.me/blog/rkyv-is-faster-than/">文章链接</a></li>
</ul>
<p>rkyv 是一个反序列框架，作者号称框架的速度比 serde_json 还要快。</p>
<h2><a class="header" href="#ter" id="ter">ter</a></h2>
<ul>
<li><a href="https://github.com/schulke-214/ter">仓库链接</a></li>
</ul>
<p>ter 是一个 cli 程序，可以用类似自然语言的命令去做一些文字处理工作，例如过滤或者替换。</p>
<h2><a class="header" href="#ipipe" id="ipipe">ipipe</a></h2>
<ul>
<li><a href="https://github.com/Eolu/ipipe">仓库链接</a> </li>
<li><a href="https://www.reddit.com/r/rust/comments/m0rh4p/im_making_a_crossplatform_namedpipe_api_in_rust/">文章链接</a></li>
</ul>
<p>ipipe 是一个跨平台的命名管道库。</p>
<h2><a class="header" href="#gloo" id="gloo">Gloo</a></h2>
<ul>
<li><a href="https://github.com/rustwasm/gloo">仓库链接</a></li>
</ul>
<p>Gloo 是一个模块化的工具箱库，可以用于 Wasm 项目的开发。</p>
<h2><a class="header" href="#aws-lambda-rust-runtime" id="aws-lambda-rust-runtime">aws-lambda-rust-runtime</a></h2>
<ul>
<li><a href="https://github.com/awslabs/aws-lambda-rust-runtime">仓库链接</a></li>
</ul>
<p>aws-lambda-rust-runtime 是一个AWS Lambda Functions 的 runtime。</p>
<p>其中包括：</p>
<ul>
<li><code>lambda-runtime</code> crate 用于提供 AWS Lambda 的 runtime</li>
<li><code>lambda-http</code> crate 用来写 AWS Lambda 的 API 网关代理事件</li>
</ul>
<h2><a class="header" href="#synth" id="synth">synth</a></h2>
<ul>
<li><a href="https://github.com/openquery-io/synth">仓库链接</a></li>
</ul>
<p>synth 是一个声明式的数据生成器，其主要特性有：</p>
<ul>
<li>数据即代码</li>
<li>导入已有数据</li>
<li>数据自动推导</li>
<li>不限定特定数据库</li>
<li>语义化数据类型</li>
</ul>
<h2><a class="header" href="#tifs" id="tifs">TiFS</a></h2>
<ul>
<li><a href="https://github.com/Hexilee/tifs">仓库链接</a></li>
</ul>
<p>TiFS 是一个基于 TiKV 的分布式 POSIX 文件系统，具有分区容限和严格的一致性。</p>
<h2><a class="header" href="#一个基于-wasmrustsimd-技术栈实现的音乐合成器" id="一个基于-wasmrustsimd-技术栈实现的音乐合成器">一个基于 wasm+rust+simd 技术栈实现的音乐合成器</a></h2>
<p><a href="https://notes.ameo.design/fm.html">链接</a></p>
<h2><a class="header" href="#influxdb-iox-基于apache-arrow-开发的新的-influxdb-核心" id="influxdb-iox-基于apache-arrow-开发的新的-influxdb-核心">InfluxDB IOx： 基于Apache Arrow 开发的新的 InfluxDB 核心</a></h2>
<ul>
<li><a href="https://github.com/influxdata/influxdb_iox">仓库链接</a></li>
</ul>
<p>InfluxDB是一个开源时间序列数据库</p>
<p>目前频繁开发中，正处于项目早期，感兴趣的可以及早关注</p>
<h2><a class="header" href="#speedy2d-兼容-opengl-es-20-的图像库" id="speedy2d-兼容-opengl-es-20-的图像库">Speedy2D: 兼容 OpenGL (ES) 2.0+ 的图像库</a></h2>
<ul>
<li><a href="https://github.com/QuantumBadger/Speedy2D">仓库链接</a></li>
</ul>
<p>Speedy2D 是一个拥有硬件加速, 简单易上手的 API的图像库, 可以方便的绘制 各种形状, 图像 和 文本.</p>
<p>目标:</p>
<ul>
<li>最简单的 Rust API 来创建 window, 渲染图像和文本, 处理输入.</li>
<li>兼容任意带有 OpenGL 2.0+ 和 OpenGL ES 2.0+ 的设备</li>
<li>非常快</li>
</ul>
<h2><a class="header" href="#idcard-cn-v001" id="idcard-cn-v001">idcard-cn v0.0.1</a></h2>
<ul>
<li><a href="https://github.com/huangjj27/idcard-cn">仓库链接</a></li>
</ul>
<p>过去的一周时间小编翻看了一些基于 Rust 的身份证识别库（如 https://crates.io/crates/rust-idcard ),基本上只提供了身份证证件号码和其他文本信息的读取，而缺少其他根据《中华人民共和国身份证法》需要提供的指纹和照片信息的读取。于是小编决定将这些信息结构化，并且统一为信息完全的特质库，并且提供了一些相应符合生活常识的类型对读取的身份信息进行处理</p>
<h2><a class="header" href="#qovery-engine---rust库可在云服务上自动化部署应用程序" id="qovery-engine---rust库可在云服务上自动化部署应用程序">Qovery Engine - Rust库,可在云服务上自动化部署应用程序</a></h2>
<ul>
<li><a href="https://github.com/Qovery/engine">仓库链接</a></li>
</ul>
<p>Qovery Engine是一个开源抽象层库，仅需几分钟，它就可以轻松地在AWS，GCP，Azure和其他云提供商上部署应用程序。Qovery引擎是用Rust编写的，并利用Terraform，Helm，Kubectl和Docker来管理资源。</p>
<ul>
<li>零基础架构管理： Qovery Engine为您初始化，配置和管理您的Cloud帐户。</li>
<li>支持多个云：Qovery Engine可以在AWS，GCP，Azure和任何云提供商上使用。</li>
<li>在Kubernetes之上： Qovery Engine在更高的抽象级别上利用了Kubernetes的功能。</li>
<li>Terraform和Helm： Qovery Engine使用Terraform和Helm文件来管理基础结构和应用程序部署。</li>
<li>强大的CLI：使用提供的Qovery Engine CLI在您的Cloud帐户上无缝部署您的应用程序。</li>
<li>Web界面： Qovery通过qovery.com提供Web界面。</li>
</ul>
<h2><a class="header" href="#linfa--rust写的统计学习综合工具箱" id="linfa--rust写的统计学习综合工具箱">Linfa : Rust写的统计学习综合工具箱</a></h2>
<ul>
<li><a href="https://rust-ml.github.io/linfa/">官网</a></li>
<li><a href="https://github.com/rust-ml/linfa">仓库地址</a></li>
</ul>
<h2><a class="header" href="#cargo-quickinstall-020版本发布" id="cargo-quickinstall-020版本发布">cargo-quickinstall 0.2.0版本发布</a></h2>
<p>[cargo-quickinstall (https://crates.io/crates/cargo-quickinstall)] 有点类似于Homebrew的Bottles（二进制包）概念，但用于 Rust。</p>
<p>示例：</p>
<pre><code>cargo quickinstall ripgrep
</code></pre>
<p>作者认为：在此之前，通常将二进制文件托管在Bintray（homebrew serves）上，但是该服务正在逐步淘汰，因此需要更换它。</p>
<h2><a class="header" href="#rust编写的清理应用程序的-czkawka-300发布" id="rust编写的清理应用程序的-czkawka-300发布">Rust编写的清理应用程序的 Czkawka 3.0.0发布</a></h2>
<ul>
<li><a href="https://github.com/qarmin/czkawka">仓库地址</a></li>
</ul>
<p>完全用Safe Rust 和 gtk 实现，且跨平台，多功能应用程序，可查找重复项，空文件夹，相似图像等。</p>
<h2><a class="header" href="#graphgate-032-发布" id="graphgate-032-发布">GraphGate 0.3.2 发布.</a></h2>
<ul>
<li><a href="https://github.com/async-graphql/graphgate">仓库地址</a></li>
</ul>
<p>用 Rust 实现的GraphQL API网关。</p>
<p>为什么要用Rust来实现？</p>
<p>​Rust是我最喜欢的编程语言。它既安全又快速，很适合开发API网关。</p>
<h2><a class="header" href="#libretranslate-rs" id="libretranslate-rs">libretranslate-rs</a></h2>
<ul>
<li><a href="https://github.com/DefunctLizard/libretranslate-rs/">仓库地址</a></li>
</ul>
<p>一个可以替代谷歌翻译的自由/开源软件(Rust编写!)，使用的是 <a href="https://libretranslate.com/">libretranslate.com</a>的 API。</p>
<h2><a class="header" href="#tide-acme通過lets-encrypt自動獲得https證書" id="tide-acme通過lets-encrypt自動獲得https證書">tide-acme：通過Let's Encrypt自動獲得HTTPS證書</a></h2>
<ul>
<li><a href="https://github.com/http-rs/tide-acme">仓库地址</a></li>
</ul>
<p>Let's Encrypt 是個很常用的免費ssl證書服務</p>
<p>作者結合了tide與Let's Encrypt做了一個自動取得證書給tide使用的範例</p>
<h2><a class="header" href="#cleanit-rust实现的可以通过-grpc-控制-roomba-系列扫地机器人的框架" id="cleanit-rust实现的可以通过-grpc-控制-roomba-系列扫地机器人的框架">CleanIt: Rust实现的可以通过 gRPC 控制 Roomba 系列扫地机器人的框架</a></h2>
<ul>
<li><a href="https://github.com/Sollimann/CleanIt">仓库地址</a></li>
</ul>
<p>还在开发中。</p>
<p>发现 <a href="https://www.irobot.cn/roomba/">Roomba系列机器人吸尘器</a> 是中国广东的公司。</p>
<h2><a class="header" href="#task-stream-一个能运行在no_std的全局异步任务spawner" id="task-stream-一个能运行在no_std的全局异步任务spawner">task-stream 一个能运行在no_std的全局异步任务spawner</a></h2>
<ul>
<li><a href="https://crates.io/crates/task-stream">仓库地址</a></li>
</ul>
<p>task-stream是一个全局任务spawner，可以在no_std中运行。</p>
<p>它提供了用于异步任务的spawner，以及异步延迟函数。</p>
<p>它是为库作者设计的。 在第三方库中，可以生成子任务，而无需关心执行程序主程序使用的子任务。</p>
<h2><a class="header" href="#shipyard-05了" id="shipyard-05了">Shipyard 0.5了</a></h2>
<ul>
<li><a href="https://crates.io/crates/shipyard">仓库地址</a></li>
</ul>
<p>這是一個ECS框架 速度比上一版增加快了2倍</p>
<h1><a class="header" href="#本月简报--学习资源-1" id="本月简报--学习资源-1">本月简报 | 学习资源</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>后期编辑：苏胤榕（DaviRain）</li>
</ul>
<h2><a class="header" href="#rust-常见疑问汇总" id="rust-常见疑问汇总">Rust 常见疑问汇总</a></h2>
<p>Rust tg 群 「Rust 众」总结了这份 Rust 常见疑问汇总。</p>
<p>本期摘录：</p>
<ol>
<li>如何在特质(trait)里添加异步函数？</li>
</ol>
<p>目前 Rust 不支持在特质里直接添加异步函数，但可以使用 <a href="https://crates.io/crates/async-trait">async-trait</a> 这个库来实现。这个库会将异步函数改写为返回 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> 的普通函数以绕过目前语言层面的限制，但也因此有堆分配以及动态分发这两个额外的代价，所以不会被直接添加到 Rust 语言中。</p>
<p>在特质里不支持使用异步函数是由于异步函数本质上是一个返回 <code>impl Future&lt;Output = T&gt;</code> 的函数，而目前 Rust 的类型系统还无法表达在特质的方法的返回类型上使用 impl Trait。有两个已经通过的 RFC 旨在解决这一问题：<a href="https://rust-lang.github.io/rfcs/1598-generic_associated_types.html">RFC 1598</a> 泛型关联类型和 <a href="https://rust-lang.github.io/rfcs/2071-impl-trait-existential-types.html">RFC 2071</a> <code>impl Trait</code> 存在类型，但它们的编译器支持还在实现中。</p>
<ol start="2">
<li>为什么 Rust 生成的程序体积比较大？如何最小化程序体积？</li>
</ol>
<p>有多个因素使得 Rust 在默认情况下有着相对较大的程序体积，包括了单态化、调试符号、标准库等。一般来说，Rust 偏向于为性能优化而非更小的体积。</p>
<p>通常使用发布模式编译（--release），以及（在 Linux 和 macOS 下）使用 strip 删除符号信息可以在一定程度上缩小程序体积。更多方法可以参考 <a href="https://github.com/johnthagen/min-sized-rust"><code>Minimizing Rust Binary Size</code></a>，对这一问题有较完整的介绍。</p>
<p>欢迎贡献：</p>
<p>更多阅读： <a href="https://rust-zh.github.io/faq/">https://rust-zh.github.io/faq/</a></p>
<h2><a class="header" href="#c-to-rust---or-how-to-render-your-mindset" id="c-to-rust---or-how-to-render-your-mindset">C++ to Rust - or how to render your mindset</a></h2>
<p>作者打算使用 Rust 重新实现 C++教程 <code>&lt;&lt;Ray tracing in One Weekend&gt;&gt;</code>，本文目标人群是对于 Rust 感兴趣的，或者对图像渲染感兴趣的人。</p>
<p>通过本教程，最终会得到下面的预览图。</p>
<p>整个过程， 作者既给出了<code>C++</code>代码， 也给出了<code>Rust</code>代码，对于熟悉 C++的同学，可以更加清晰的了解两种语言的不同。</p>
<p><a href="https://jduchniewicz.com/posts/2021/02/c-to-rust-or-how-to-render-your-mindset/">链接</a></p>
<h2><a class="header" href="#rust-algorithms-用-rust-写算法的教科书" id="rust-algorithms-用-rust-写算法的教科书">rust-algorithms 用 Rust 写算法的教科书</a></h2>
<p>作者 @EbTech 是应用数学出生，因此本书提供的算法主要包括应用数学（傅里叶变换等）的算法以及图的算法使用 Rust 的实现。</p>
<p><a href="https://github.com/EbTech/rust-algorithms">仓库</a></p>
<h2><a class="header" href="#回顾异步rust" id="回顾异步rust">回顾异步Rust</a></h2>
<p>parity 工程师 tomaka 这篇博文，总结了他在日常开发中遇到的 Rust 异步的一些关键问题，值得一读。</p>
<p><a href="https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c">阅读</a></p>
<h2><a class="header" href="#rust-提防转义序列-n" id="rust-提防转义序列-n">Rust: 提防转义序列 \n</a></h2>
<p><a href="https://github.com/serde-rs/serde">serde</a>是在Rust生态系统最流行的crate，一个用于高效地序列化和deseri一个LIZING数据结构。它支持多种数据格式，包括JSON，YAML，MessagePack等。与许多其他（反）序列化器不同，它不使用运行时反射，而是使用Rust的引人注目的特征系统。这使Serde异常有效，因为数据结构本质上知道如何序列化或反序列化自身，并且它们通过实现<code>Serialize</code>or<code>Deserialize</code>特性来实现。幸运的是，这要归功于大多数类型，这要归功于derive宏。您可能会像我一样遇到陷阱，在这篇博客文章中，作者想特别谈一谈：<strong>转义序列。</strong></p>
<p><a href="https://d3lm.medium.com/rust-beware-of-escape-sequences-85ec90e9e243#ee0e-58229fc84d02">ReadMore</a></p>
<h2><a class="header" href="#bevy-physics-weekend-项目" id="bevy-physics-weekend-项目">bevy-physics-weekend 项目</a></h2>
<p>这个项目是使用 Rust 编程语言和 Bevy 游戏引擎对 <a href="https://gamephysicsweekend.github.io/">Game Physics in a Weekend</a>这本书的实践。这对我来说是一个学习练习，以便更好地理解如何使用 Bevy 和数学库 glam 来实现物理引擎。项目</p>
<p><a href="https://github.com/bitshifter/bevy-physics-weekend">地址</a></p>
<h2><a class="header" href="#rust-优化技巧" id="rust-优化技巧">Rust 优化技巧</a></h2>
<p>如果您希望用 Rust 编写速度更快的代码，那么有好消息!Rust 让编写快速代码可以变得非常容易。对零成本抽象的关注、缺乏隐式装箱和静态内存管理意味着，即使是 naïve 代码也往往比其他语言中的同类代码要快，当然也比任何同等安全的语言的代码要快。但是，也许像大多数程序员一样，您在整个编程生涯中都不必担心机器的任何细节，而现在您想要更深入地了解并找出重写的 Python 脚本的真正原因。 Rust 的运行速度快了 100 倍，并使用了十分之一的内存。毕竟，它们都做相同的事情并在相同的 CPU 上 运行，对吧？</p>
<p>因此，这里有一个优化指南，针对那些知道如何编程，但可能不知道代码如何 CPU 上映射到真实的 1 和 0 的人。我将尝试编写关于优化 Rust 代码的实用技巧，并解释为什么它比替代方法更快，最后我们将以 Rust 标准库中的一个案例研究作为结束。</p>
<p><a href="https://gist.github.com/little-dude/674de61df7f48547bdcc5bbe2860563d">原文地址</a></p>
<h2><a class="header" href="#用rust给我的操作系统写乒乓pong" id="用rust给我的操作系统写乒乓pong">用Rust给我的操作系统写乒乓（Pong）</a></h2>
<p>我们上一讲结束了为我们的操作系统编写图形驱动程序和事件驱动程序。我们还添加了几个系统调用来处理绘图原语以及处理键盘和鼠标输入。现在我们将使用这些动画来制作简单的pong游戏。就像《hello world》是对所有编程语言的测试，《pong》也是对我们所有图形和事件系统的测试。</p>
<p><a href="https://blog.stephenmarz.com/2021/02/22/writing-pong-in-rust/">文章链接</a></p>
<h2><a class="header" href="#rust-style-guidelines" id="rust-style-guidelines">Rust Style Guidelines</a></h2>
<p>rust-guidelines 收集了用于编写Rust代码的新出现的原理，约定，抽象和最佳实践。</p>
<p><a href="https://doc.rust-lang.org/1.0.0/style/README.html">Docs</a></p>
<p><a href="https://github.com/rust-lang/rust-guidelines">GitHub</a></p>
<h2><a class="header" href="#避免使用rust进行单线程内存访问错误" id="避免使用rust进行单线程内存访问错误">避免使用Rust进行单线程内存访问错误</a></h2>
<p>在本文中，我们将研究单线程C ++中的几种内存访问错误，以及Rust如何防止我们犯这些错误。我写了一篇简短的文章，展示了C ++中的内存访问错误以及Rust如何阻止我们访问这些错误。目录：Returning references to temporariesShort lifetimesReferenes to container contentsTricky lifetime extensions</p>
<p><a href="https://radekvit.medium.com/avoiding-single-threaded-memory-access-bugs-with-rust-for-c-developers-2b7fc9c877ec">阅读原文</a></p>
<h2><a class="header" href="#rust-web开发人员路线图" id="rust-web开发人员路线图">Rust Web开发人员路线图</a></h2>
<p>超详细 Rust Web 开发人员的路线图。</p>
<p><img src="chapter_3/../image/web-rust-road.png" alt="" /></p>
<p><a href="https://github.com/anshulrgoyal/rust-web-developer-roadmap">github</a></p>
<h2><a class="header" href="#rust-中返回引用的各种策略" id="rust-中返回引用的各种策略">Rust 中返回引用的各种策略</a></h2>
<p>本文总结了常见的返回引用的几种方式，强烈推荐。</p>
<p><a href="https://bryce.fisher-fleig.org/strategies-for-returning-references-in-rust/">原文链接</a></p>
<h2><a class="header" href="#learning-rust-structs-and-traits" id="learning-rust-structs-and-traits">Learning Rust: Structs and Traits</a></h2>
<p>这是一系列学习 Rust 视频的第三部分，<code>Structs and Traits</code>， 内容相对比较简单， 有喜欢看视频学习 Rust 的小伙伴可以翻墙看一下。</p>
<p><a href="https://youtu.be/tYfA5rjrhqk">油管视频</a></p>
<h2><a class="header" href="#教程如何在rust中实现一个迭代器" id="教程如何在rust中实现一个迭代器">教程：如何在Rust中实现一个迭代器</a></h2>
<p>这篇教程中你将会学到如何为一个树结构实现迭代器。</p>
<p><a href="https://aloso.github.io/2021/03/09/creating-an-iterator">阅读更多</a></p>
<h2><a class="header" href="#博客rust-命名空间" id="博客rust-命名空间">【博客】Rust 命名空间</a></h2>
<p>关于Rust中命名空间的内容讲解。</p>
<p><a href="https://aloso.github.io/2021/03/10/rusts-universes.html">链接</a></p>
<h2><a class="header" href="#我是如何使用-rust-大幅提高笔记软件的性能的" id="我是如何使用-rust-大幅提高笔记软件的性能的">我是如何使用 Rust 大幅提高笔记软件的性能的？</a></h2>
<p><a href="https://github.com/giganotes">Giganotes</a> 是作者开发的一个笔记软件，作者尝试使用 Rust 来提高软件的性能，并取得了很好的成效。</p>
<p><a href="https://www.reddit.com/r/rust/comments/m14agf/how_i_significantly_improved_giganotes_app/">链接</a></p>
<h2><a class="header" href="#learn-wgpu系列教程终于完全升级到了07版本" id="learn-wgpu系列教程终于完全升级到了07版本">learn wgpu系列教程终于完全升级到了0.7版本！</a></h2>
<p>wgpu 创建渲染管道的方式已经进行了改进。大多数属于自己的字段都被分组为结构，例如 <a href="https://docs.rs/wgpu/0.7.0/wgpu/struct.MultisampleState.html">MultisampleState</a> 。这意味着简单的管道更容易创建，因为我们可以对我们不关心的字段使用<code>Default::Default()</code>或<code>None</code>。</p>
<p><a href="https://sotrh.github.io/learn-wgpu/">Read More</a> </p>
<p><a href="https://github.com/sotrh/learn-wgpu">Github</a> </p>
<h2><a class="header" href="#教你如何用rg3d制作一个射击游戏" id="教你如何用rg3d制作一个射击游戏">教你如何用Rg3d制作一个射击游戏！</a></h2>
<p>教你如何用Rg3d制作一个射击游戏系列教程更新第二章了！</p>
<p>Rg3d是一个使用Rust编写的游戏引擎，渲染后端用的是OpenGl的Rust绑定：glutin ，说到这个教程出现的原因，很心酸的想贴上这段话：</p>
<blockquote>
<p>I have a simple question for the community: what stops you from using the engine? The lack of tutorials, immaturity, different approaches (no-ecs for example, or maybe you have your reason you want to share? I need to know what should be done first to make engine more newcomer-friendly. I have ~10 years of experience in gamedev and some things may be not obvious to me, so I need your help.</p>
</blockquote>
<p>消息是Rg3d的作者在Discord上发布的，时间是2月16日的时候，发布之后有不少人表达了自己的想法，同时现在你看到的教程，也正是通过这次调查得到大家反馈之后才出的。作者本人在Discord上对大家的提问回复都很及时，Rust社区本身不是很大，同时Rust游戏社区就更小了，但是仍然有很多人对此不断耕耘，所以如果你对游戏开发很有兴趣，同时也是Rust厨的话，一直还没有去尝试过使用Rust开发游戏的你，一定要去感受一下使用Rust开发游戏！</p>
<p><a href="https://rg3d.rs/tutorials/2021/03/09/tutorial2.html">Read More</a></p>
<h2><a class="header" href="#rust-异步不是有色函数" id="rust-异步不是有色函数">Rust 异步不是有色函数！</a></h2>
<p>本篇blog名字是<code>Rust's async isn't f#@king colored!</code></p>
<p>本篇blog衍生自15年的一篇著名blog：<a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">What Color is Your Function?</a>，在这篇blog种将编程语言的函数调用区分为不同的颜色，特别指出多种语言种的异步调用和同步函数是两种不同的颜色，在编写程序的时候会给程序员造成一些痛苦。而文中所说go、java之类的则不属于这类语言，详细的可以去看看原文。</p>
<p>而本篇blog也就沿着上面提到的这篇blog讨论了Rust异步编程种是否存在同样的问题。结论已经被标题出卖了，Rust异步不是有色函数！</p>
<p><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">What Color is Your Function?</a></p>
<p><a href="https://www.hobofan.com/blog/2021-03-10-rust-async-colored/">Rust's async isn't f#@king colored!</a></p>
<h2><a class="header" href="#rust的异步是有颜色-但没什么大不了" id="rust的异步是有颜色-但没什么大不了">Rust的异步是有颜色, 但没什么大不了</a></h2>
<p>语言设计领域的一个争议点是 <code>有色函数</code>， 即将函数分为异步函数和非异步函数。这个术语来源于2015年一篇名为<code>《What Color is Your Function?》</code>的文章, 它用颜色来比喻JavaScript和其他带有显式异步函数的语言中的同步和异步函数之间常常令人痛苦的不匹配。</p>
<p>Rust 中，也有很多人讨论这个问题， 比如前几天有一片文章 <code>Rust’s async isn’t f#@king colored!</code>。</p>
<p>这里作者将通过原始的定义和实践，来表达自己的观点: Rust 是有颜色的。</p>
<p><a href="https://morestina.net/blog/1686/rust-async-is-colored">原文链接</a></p>
<h2><a class="header" href="#看到toml文件真是相见恨晚" id="看到toml文件真是相见恨晚">看到Toml文件，真是相见恨晚</a></h2>
<p>有位作者在<code>Reddit</code>发表了一篇帖子：<code>I really love TOML files</code>。</p>
<blockquote>
<p>“我没在使用Rust之前，并不了解Toml文件。现在我想用它来做任何事。” 这不就是传说中的：相见恨晚嘛。</p>
</blockquote>
<p>为什么<code>Toml</code>文件会被人喜爱？下面有人评论： “对于许多简单的配置，它们真的很酷！ 它们没有YAML陌生性，也没有JSON的字符串性，并且它们大多是扁平的，几乎没有级别缩进。”</p>
<p><a href="https://www.reddit.com/r/rust/comments/m37zya/i_really_love_toml_files/">详细链接</a></p>
<h2><a class="header" href="#使用rg3d编写的射击游戏" id="使用rg3d编写的射击游戏">使用rg3d编写的射击游戏</a></h2>
<p>用Rust写游戏:神枪在手，说抖不抖。</p>
<p>本教程是系列教程的后续部分，我们将使用rg3d游戏引擎制作3D射击游戏。</p>
<p><a href="https://rg3d.rs/tutorials/2021/03/11/tutorial3.html">详细链接</a></p>
<h2><a class="header" href="#rust-和-c-速度比较-1" id="rust-和-c-速度比较-1">Rust 和 C 速度比较</a></h2>
<p>Rust 和 C 的编程风格差异很大，但两者开发的程序在运行速度和内存使用情况上大致相同。语言在理论上可以实现什么，但在实践中如何使用它们之间有很大的区别。作者总结了Rust 和 C 各自在哪些地方会更快。</p>
<p>简而言之</p>
<ul>
<li>Rust 可以在必要时以足够底层的方式对其进行优化，使其达到与 C 一样的性能；</li>
<li>Rust 拥有更高层次的抽象，便捷的内存管理和丰富的第三方库；</li>
<li>Rust 最大的潜力在于无畏并发（fearless concurrency）能力。</li>
</ul>
<p><a href="https://kornel.ski/rust-c-speed">文章链接</a></p>
<h2><a class="header" href="#为什么-rust-和-go-一起更好" id="为什么-rust-和-go-一起更好">为什么 Rust 和 Go 一起更好？</a></h2>
<p>简单，性能和开发者的生产力，使得 Go 成为创建面向用户应用服务的理想语言。更好的控制粒度使得 Rust 成为底层操作的理想语言。这并不意味着非得二选一，反而两者一起使用时会具有很高的灵活性和性能。</p>
<p>本文讨论了 Rust 和 Go 的优缺点，以及如何互相补充支持。</p>
<p><a href="https://thenewstack.io/rust-vs-go-why-theyre-better-together/?s=09">文章链接</a></p>
<h2><a class="header" href="#使用-rust-写一个-postgres-sql-打印器-part-i" id="使用-rust-写一个-postgres-sql-打印器-part-i">使用 Rust 写一个 Postgres SQL 打印器: Part I</a></h2>
<p>这是作者<code>pg-pretty</code>项目项目的一系列文章第一篇。</p>
<p>作者不能忍受非格式化的代码，对于大型项目来说，统一风格可以消除很多理解障碍。但是作者没有找到一个很好的 Postgres SQL 风格打印器，所以打算自己动手写一个。</p>
<p><a href="https://blog.urth.org/2021/03/14/writing-a-postgres-sql-pretty-printer-in-rust-part-1/">原文链接</a></p>
<h2><a class="header" href="#crust-of-rust-the-drop-check" id="crust-of-rust-the-drop-check">Crust of Rust: The Drop Check</a></h2>
<p>这是 <code>Crust of Rust</code> 系列视频的最新一期: <code>The Drop Check</code>, 相信很多小伙伴对 Drop check 都很感兴趣，可以翻墙看一下。</p>
<p><a href="https://youtu.be/Das3XSWo1GU">油管视频</a></p>
<h2><a class="header" href="#rust-vs-go为什么它们一起会更好" id="rust-vs-go为什么它们一起会更好">《Rust vs. Go》:为什么它们一起会更好</a></h2>
<p>来自 Jonathan Turner and Steve Francia 的 blog，虽然其他人可能认为 Rust 和 Go 是有竞争力的编程语言，但 Rust 和 Go 团队都不这么认为。恰恰相反，我们的团队非常尊重其他人正在做的事情，并将这些语言视为对整个软件开发行业现代化状态的共同愿景的赞美。</p>
<p>注 Steve Francia【@spf13】 是隔壁 go 社区大佬，
<a href="https://thenewstack.io/rust-vs-go-why-theyre-better-together/">更多请看</a></p>
<h2><a class="header" href="#如何使用-rust-发邮件" id="如何使用-rust-发邮件">如何使用 Rust 发邮件</a></h2>
<p>在 Rust 中发送电子邮件可以通过两种方式实现：使用 SMTP 服务器或使用带有 API 的第三方服务，如 AWS SES 或 Sendgrid。</p>
<p><a href="https://kerkour.com/blog/rust-send-email/">详细实现请看</a></p>
<h2><a class="header" href="#构建async-rust的共同愿景" id="构建async-rust的共同愿景">构建Async Rust的共同愿景</a></h2>
<p>近期，Rust官方博客推出了一篇文章，《Building a shared vision for Async Rust》：构建Async Rust的共同愿景。</p>
<p>Rust Async基金会工作组认为,Rust可以成为构建分布式系统（从嵌入式设备到基础云服务）的最受欢迎选择之一。不管他们用它做什么，我们都希望所有的开发者都喜欢使用Async-Rust。为了实现这一点，我们需要将Async Rust从现在的“MVP”状态转移出去，尽可能让每个人都能使用。</p>
<p><a href="https://blog.rust-lang.org/2021/03/18/async-vision-doc.html">文章地址</a></p>
<h2><a class="header" href="#rust-的-零大小类型zst-的神奇应用" id="rust-的-零大小类型zst-的神奇应用">Rust 的 零大小类型(ZST) 的神奇应用</a></h2>
<p>Rust 中有 零大小类型的概念，简称 <code>ZST</code> (Zero-Sized Types). 这些类型不会在他们的布局上包含任何的信息。 但是这并不意味着他们不重要,本文将深入解释 ZST 的设计理念和应用。 感兴趣的小伙伴可以看一下。</p>
<p><a href="https://www.hardmo.de/article/2021-03-14-zst-proof-types.md">原文链接</a></p>
<h2><a class="header" href="#lens-rs-指路" id="lens-rs-指路">lens-rs 指路</a></h2>
<p>来自 <code>脚趾头</code> 的知乎投稿。作者之前使用 <code>Rust</code> 实现了 <code>lens</code>， 本文主要说明如何来把玩这个库 <code>len-rs</code>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/358678675">原文链接</a></p>
<h2><a class="header" href="#使用-rust-构建-openstreetmap-应用-part-vi" id="使用-rust-构建-openstreetmap-应用-part-vi">使用 Rust 构建 OpenStreetMap 应用: Part VI</a></h2>
<p><code>使用 Rust 构建 OpenStreetMap 应用</code> 的最新章节， 结合之前的内容， 本章结束会完成一个基本的应用。</p>
<p><a href="https://blogg.bekk.no/building-an-openstreetmap-app-in-rust-part-vi-8cfc8c3f7798">原文链接</a></p>
<h2><a class="header" href="#使用-rust-iterator-的一些技巧" id="使用-rust-iterator-的一些技巧">使用 Rust Iterator 的一些技巧</a></h2>
<p>作者总结了 Rust Iterator 相关的几条技巧，感觉还不错。</p>
<p><a href="https://robinmoussu.gitlab.io/blog/post/2021-03-25_rust_iterators_tips_and_tricks/">链接</a></p>
<h2><a class="header" href="#pin-and-suffering" id="pin-and-suffering">Pin and suffering</a></h2>
<p><code>Cool bear</code>系列的最新文章，可以让你深入的了解 <code>Rust</code> 中的 <code>async</code>。</p>
<p><a href="https://fasterthanli.me/articles/pin-and-suffering">原文链接</a></p>
<h2><a class="header" href="#2021年去哪里学习-rust" id="2021年去哪里学习-rust">2021年去哪里学习 Rust</a></h2>
<p>2021 年了，去哪里学习 Rust 呢？</p>
<p>本文总结列出了一系列的 Rust 学习资料，想学习的 Rust 的小伙伴可以看看。</p>
<p><a href="https://loige.co/where-to-go-to-learn-rust-in-2021/">原文链接</a></p>
<h2><a class="header" href="#rusts-module-system-explained" id="rusts-module-system-explained">Rusts Module System Explained</a></h2>
<p>本文详细的介绍了 Rust 模块系统，从为什么需要模块系统？ 到如何使用的非常详细，希望对模块系统深入掌握的同学可以看看。</p>
<p><a href="https://aloso.github.io/2021/03/28/module-system.html">原文链接</a></p>
<h2><a class="header" href="#libp2p-指南" id="libp2p-指南">LibP2p 指南</a></h2>
<p>这个教程展示如何使用Rust和出色的libp2p库构建一个非常简单的点对点应用程序。</p>
<p><a href="https://blog.logrocket.com/libp2p-tutorial-build-a-peer-to-peer-app-in-rust/">阅读</a></p>
<p><a href="https://github.com/zupzup/rust-peer-to-peer-example">示例代码</a></p>
<h2><a class="header" href="#指南-写一个-微ecs--entity-component-system系统" id="指南-写一个-微ecs--entity-component-system系统">指南： 写一个 微ECS （ Entity Component System）系统</a></h2>
<p>通过编写一个简单的 ECS 系统来学习什么是 ECS 。</p>
<p><a href="https://ianjk.com/ecs-in-rust/">阅读</a></p>
<h2><a class="header" href="#系列文章学会飞行使用-rust--神经网络--遗传算法-来模拟进化" id="系列文章学会飞行使用-rust--神经网络--遗传算法-来模拟进化">【系列文章】学会飞行：使用 Rust / 神经网络 / 遗传算法 来模拟进化</a></h2>
<ul>
<li><a href="https://pwy.io/en/posts/learning-to-fly-pt1/">Part I</a></li>
<li><a href="https://pwy.io/en/posts/learning-to-fly-pt2/">Part II</a></li>
<li><a href="https://pwy.io/en/posts/learning-to-fly-pt3/">Part III</a></li>
</ul>
<h1><a class="header" href="#rust-唠嗑室本月汇总" id="rust-唠嗑室本月汇总">Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
<li>后期编辑：高宪凤</li>
</ul>
<hr />
<h2><a class="header" href="#rust唠嗑室第19期---启动-openra-rs-项目乱聊" id="rust唠嗑室第19期---启动-openra-rs-项目乱聊">《Rust唠嗑室》第19期 - 启动 OpenRA-rs 项目+乱聊</a></h2>
<p><strong>时间</strong>：2021/03/02 20:30-21:30</p>
<p><strong>主讲人</strong>：Mike</p>
<p><strong>内容</strong>：</p>
<p><a href="https://github.com/OpenRA/OpenRA">OpenRA</a> 是开源重制版红警，不过目前已经实现的部分只是红警1，红警2尚未完成。目前OpenRA是用C#写的。我们来憧憬一下，如果OpenRA用Rust重新实现会怎样？</p>
<p>如果做，那就基于Rust最热的bevy游戏引擎来做。对Rust游戏开发感兴趣的都来出出主意吧。</p>
<p>我们会先启动一个学习型的项目，openra-rs内部分享甚至会成为一个专门的视频系列。敬请期待。</p>
<p><a href="https://www.bilibili.com/video/BV1NU4y1p7B6">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<ul>
<li>https://github.com/OpenRA/OpenRA</li>
</ul>
<hr />
<h2><a class="header" href="#rust唠嗑室第20期---软件选型方法以rust为例" id="rust唠嗑室第20期---软件选型方法以rust为例">《Rust唠嗑室》第20期 - 软件选型方法，以Rust为例</a></h2>
<p><strong>时间</strong>：2021/03/16 20:30-21:30</p>
<p><strong>主讲人</strong>：Andy</p>
<p><strong>内容</strong>：软件选型方法</p>
<p>跟大家聊聊软件选型的方法，内容：</p>
<ol>
<li>基础模型：天上不会掉馅饼定理、丑小鸭定理、康威定律、包线；</li>
<li>抽象：函数、对象、类型、Trait；</li>
<li>架构：服务端开源组件的取舍；</li>
<li>实例：ImmuxDB从v1到v2的架构调整。</li>
</ol>
<p>本次演示使用Rust作示例。</p>
<p><a href="https://www.bilibili.com/video/BV1mN411Q7Mw">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<ul>
<li>https://immux.cn</li>
<li>https://github.com/immux/immux</li>
</ul>
<h1><a class="header" href="#华为--基于rust的下一代虚拟化平台-stratovirt" id="华为--基于rust的下一代虚拟化平台-stratovirt">华为 | 基于Rust的下一代虚拟化平台-StratoVirt</a></h1>
<p>作者： 徐飞 / 后期编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#stratovirt是什么" id="stratovirt是什么">StratoVirt是什么</a></h2>
<p>Strato，取自stratosphere，意指地球大气层中的平流层，大气层可以保护地球不受外界环境侵害，而平流层则是大气层中最稳定的一层；类似的，虚拟化技术是操作系统平台之上的隔离层，既能保护操作系统平台不受上层恶意应用的破坏，又能为正常应用提供稳定可靠的运行环境；以Strato入名，寓意为保护openEuler平台上业务平稳运行的轻薄保护层。同时，Strato也承载了项目的愿景与未来： 轻量、灵活、 安全和完整的保护能力。</p>
<p>StratoVirt是计算产业中面向云数据中心的企业级虚拟化平台，实现了一套架构统一支持虚拟机、容器、Serverless三种场景，在轻量低噪、软硬协同、安全等方面具备关键技术竞争优势。StratoVirt在架构设计和接口上预留了组件化拼装的能力和接口，StratoVirt可以按需灵活组装高级特性直至演化到支持标准虚拟化，在特性需求、应用场景和轻快灵巧之间找到最佳的平衡点。</p>
<div align=center> <img src="chapter_3/.\sratovirt-images\StratoVirt.png" width="280" height="280" /></div>
<h2><a class="header" href="#为什么选择rust" id="为什么选择rust">为什么选择Rust</a></h2>
<p>在项目成立初期，我们调研了业界成熟基于C语言开发的虚拟化软件-QEMU，统计了在过去十几年中QEMU的CVE问题，发现其中有将近一半是因为内存问题导致的，例如缓冲区溢出、内存非法访问等等。如何有效避免产生内存问题，成为我们在编程语言选型方面的重要考虑。因此，专注于安全的Rust语言进入我们视线。</p>
<ul>
<li>Rust语言拥有强大的类型系统、所有权系统、借用和生命周期等机制，不仅保证内存安全，还保证并发安全，极大的提升软件的质量。在支持安全性的同时，具有零成本抽象特点，既提升代码的可读性，又不影响代码的运行时性能。</li>
<li>Rust语言拥有强大的软件包管理器和项目管理工具-Cargo
<ul>
<li>Cargo能够对项目的依赖包进行方便、统一和灵活的管理。项目所有的依赖包都定义在Cargo.toml文件中，开发者可以按需使用来自Rust官方仓库crates.io的各类功能包。</li>
<li>Cargo集成了完整的代码管理工具，例如项目创建（cargo new）、构建（cargo build）、清理（cargo clean）、测试（cargo test）、运行（cargo Run）等等。</li>
<li>Cargo在代码静态扫描方面提供相应的工具，能够进一步提升开发者编码风格和代码质量。
<ul>
<li>cargo fmt：使用符合rust-lang定义的Rust代码风格来规范Rust代码。</li>
<li>cargo check：可以对本地项目库和所有依赖进行编译检查，它会通过对项目进行编译来执行代码检查。</li>
<li>cargo clippy：一个Rust语言的lint工具集合包，包含了超过350种lint规则。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#stratovirt的优势" id="stratovirt的优势">StratoVirt的优势</a></h2>
<p>StratoVirt是openEuler最稳定、最坚固的保护层。它重构了openEuler虚拟化底座，具有以下六大技术特点。</p>
<ul>
<li>强安全性与隔离性
<ul>
<li>采用内存安全语言Rust编写， 保证语言级安全性；</li>
<li>基于硬件辅助虚拟化实现安全多租户隔离，并通过seccomp进一步约束非必要的系统调用，减小系统攻击面；</li>
</ul>
</li>
<li>轻量低噪
<ul>
<li>轻量化场景下冷启动时间&lt;50ms，内存底噪&lt;4M；</li>
</ul>
</li>
<li>高速稳定的IO能力
<ul>
<li>具有精简的设备模型，并提供了稳定高速的IO能力；</li>
</ul>
</li>
<li>资源伸缩
<ul>
<li>具有ms级别的设备伸缩时延，为轻量化负载提供灵活的资源伸缩能力；</li>
</ul>
</li>
<li>全场景支持
<ul>
<li>完美支持X86和Arm平台：X86支持VT，鲲鹏支持Kunpeng-V，实现多体系硬件加速； </li>
<li>可完美集成于容器生态，与Kubernetes生态完美对接，在虚拟机、容器和serverless场景有广阔的应用空间；</li>
</ul>
</li>
<li>扩展性
<ul>
<li>架构设计完备，各个组件可灵活地配置和拆分；</li>
<li>设备模型可扩展，可扩展PCIe等复杂设备规范，实现标准虚拟机演进； </li>
</ul>
</li>
</ul>
<h2><a class="header" href="#stratovirt的架构" id="stratovirt的架构">StratoVirt的架构</a></h2>
<p>StratoVirt核心架构自顶向下分为三层：</p>
<ul>
<li>OCI兼容接口：兼容qmp协议，具有完备的OCI兼容能力。</li>
<li>BootLoader：抛弃传统的BIOS + GRUB启动模式，实现了更轻更快的BootLoader，并达到极限启动时延。</li>
<li>MicroVM：充分利用软硬协同能力；精简化设备模型；低时延资源伸缩能力；</li>
</ul>
<div align=center> <img src="chapter_3/.\sratovirt-images\StratoVirt-arch.png" width="500" height="500" /></div>
<p>StratoVirt<a href="https://gitee.com/openeuler/stratovirt">源码目录</a>解析主要分为四部分：</p>
<ul>
<li>address_space：地址空间模拟，实现地址堆叠等复杂地址分配模式。</li>
<li>boot_loader：内核引导程序，实现快速加载和启动功能。</li>
<li>device_model：仿真各类设备，可扩展，可组合。</li>
<li>machine_manager：提供虚拟机管理接口，兼容QMP等常用协议，可扩展。</li>
</ul>
<div align=center> <img src="chapter_3/.\sratovirt-images\code_directory.png" width="400" height="400" /></div>
<p>当前StratoVirt开源代码中实现的是轻量化虚拟机模型，是能实现运行业务负载的最小的设备集合。因此LightMachine是StratoVirt最重要的顶层数据结构，它的逻辑上分为CPU模拟管理，地址空间管理，IO设备模拟管理（包括中断控制器和bus数据结构中管理各类仿真设备，例如virtio设备，serial设备等），如下图右侧所示：</p>
<div align=center> <img src="chapter_3/.\sratovirt-images\light_machine.png" /></div>
<p>首先，我们先看一下address_space地址空间模拟实现功能：</p>
<div align=center> <img src="chapter_3/.\sratovirt-images\address_space.png" /></div>
<ul>
<li>内存地址空间通过Region组成树形层次关系，支持地址堆叠和优化级。</li>
<li>通过快速映射算法形成扁平地址空间（Flat View)。</li>
<li>通过设置Listener监听地址空间变化，执行相关回调函数。</li>
</ul>
<p>其次，我们再看一下CPU模拟实现功能：</p>
<div align=center> <img src="chapter_3/.\sratovirt-images\CPU.png" /></div>
<ul>
<li>基于KVM暴露接口实现虚拟CPU的硬件加速。</li>
<li>通过ArchCPU结构隐藏体系架构（aarch64和x86_64）差异，具体实现位于体系架构相关目录中。</li>
<li>Arc反向索引该CPU所属的LightMachine虚拟机对象，使得后续在虚拟机内扩展设备时，CPU可访问该对象。</li>
</ul>
<p>最后，我们再看一下IO设备模拟功能：</p>
<p>轻量化虚拟机的主要设备均通过VirtioMMIO协议实现，下图右侧是VirtioMmioDevice的通用数据结构。</p>
<div align=center> <img src="chapter_3/.\sratovirt-images\IO.png" /></div>
<p>在IO设备初始化阶段，通过VirtioMMIO协议协商前后端都可以访问的virtio queue、中断事件以及通知事件等等。当前端VM有IO请求时，将请求数据写入virtio queue中，通过通知事件告知后端StratoVirt；后端监听通知事件发生时，读取virtio queue中的请求数据，根据请求数据进行IO处理，IO请求处理完成后，并以中断事件方式通知前端VM。</p>
<div align=center> <img src="chapter_3/.\sratovirt-images\IO_process.png" width="500" height="300" /></div>
<h2><a class="header" href="#stratovirt未来" id="stratovirt未来">StratoVirt未来</a></h2>
<p>StratoVirt的发展路标为，通过一套架构，支持轻量虚拟机和标准虚拟机两种模式：</p>
<ul>
<li>轻量虚拟机模式下，单虚机内存底噪小于4MB，启动时间小于50ms，且支持ms级时延的设备极速伸缩能力，当前已经开发完毕，2020年9月已经在openEuler社区开源；</li>
<li>标准虚拟机模式下，可支持完整的机器模型，启动标准内核镜像，可以达成Qemu的能力，同时在代码规模和安全性上有较大优势。 </li>
</ul>
<h2><a class="header" href="#关注我们" id="关注我们">关注我们</a></h2>
<p>StratoVirt当前已经在openEuler社区（openEuler是一个开源、免费的Linux发行版平台，将通过开放的社区形式与全球的开发者共同构建一个开放、多元和架构包容的软件生态体系）开源。在未来的一段时间我们将开展一系列主题的分享，让大家更加详细的了解StratoVirt实现，非常期待您的围观和加入！</p>
<p>项目地址：https://gitee.com/openeuler/stratovirt</p>
<p>项目wiki：https://gitee.com/openeuler/stratovirt/wikis</p>
<p>项目交流：<a href="https://mailweb.openeuler.org/postorius/lists/virt.openeuler.org/">virt邮件列表</a>或是提交一个<a href="https://gitee.com/openeuler/stratovirt/issues">issue</a>。</p>
<h1><a class="header" href="#华为--rust-科学计算多维数组运算库的分析与实践" id="华为--rust-科学计算多维数组运算库的分析与实践">华为 | Rust 科学计算多维数组运算库的分析与实践</a></h1>
<p>作者： 李原 / 后期编辑： 张汉东</p>
<blockquote>
<p>此文来自于 3.27号 深圳 Meetup 大会
3月27日活动PPT和现场视频链接：  <a href="https://disk.solarfs.io/sd/6e7b909b-133c-49f7-be0f-a51f65559665">https://disk.solarfs.io/sd/6e7b909b-133c-49f7-be0f-a51f65559665</a></p>
</blockquote>
<hr />
<h3><a class="header" href="#介绍-2" id="介绍-2">介绍</a></h3>
<p>Rust ndarray是一个由Rust官方团队中资深科学计算专家bluss开发的开源项目，实现了基于rust的矩阵和线性运算。目标是在Rust中建立类似于numpy和openblas的科学计算社区。它是机器视觉、数据挖掘、生物信息等多类科学计算库的基础，社区中的主要用户为一些相关技术的高校或者研究所。笔者参与该开源项目的整体规划为面向社区中的各种场景，打通ndarray的南向技术栈，利用编译器、并行化、软硬件协同等技术实现功能、性能的突破，为整个Rust科学计算生态打下扎实的底座。</p>
<p>而ndarray目前来自于社区的需求有嵌入式环境的适配、基础机制的完善以及空间利用率、运算性能上的提升等。为了nostd、灵活步长、广播机制及并行计算等。下面具体展开介绍。</p>
<h3><a class="header" href="#no_std化" id="no_std化">no_std化</a></h3>
<p>首先是ndarray的no_std化工作，它主要解决ndarray在嵌入式环境下的适配问题。std是Rust标准库的简称，由核心库和其他一些功能模块组成。其中核心库包含了类型、指针、同步、内存管理等语言核心功能，其余部分则包含了文件管理、操作系统适配、线程管理、网络等非核心或硬件架构相关功能。Rust编译器在编译和生成最终二进制文件(rlib)时会默认将标准库全部包含进去。而no_std就是指让编译器在编译时不主动引入标准库，而是由编程人员按需引入相关功能模块。这一机制主要是用在嵌入式开发中，除了标准库在无操作系统的裸机环境下可能无法编译的因素外，更是因为在嵌入式环境中，文件存储占用的资源是非常宝贵的，为了降低成本必须要尽可能得节省空间。no_std环境下，每个生成的rlib文件会比std环境下生成的节省200kb左右的空间。而一个项目一般会依赖多个rlib文件，所以可以从总体上节省很多资源。</p>
<p>除了这种方法，还可以通过将整个标准库编译成动态链接库的方法，在有多个rlib存在时使他们链接到同一个动态链接库，也能显著得降低空间占用。这里我们只分享第一种，也就是no_std的方法。</p>
<p>我们要让一个Rust库支持no_std环境主要做的事有两件：</p>
<p>第一件事是解决自身对std的依赖。</p>
<p>主要方法有三条：</p>
<ol>
<li>在使用语言核心功能时，使用核心库代替标准库</li>
<li>当需要使用核心库没有的功能时，手动引入额外功能模块</li>
<li>使用条件编译进行功能裁剪。</li>
</ol>
<p>Rust中的条件编译主要由开发者自定义的feature实现，通过在程序的各个部分添加属性，判断不同的feature类型实现条件编译。</p>
<p>第二件事是解决依赖库对std的依赖。主要方法有两个，首先肯定是修改依赖模块，让其也实现no_std化，技术实现上和第一步相同，但面对的问题会呈递归式增加，因为要实现依赖模块的no_std化，就还要实现依赖模块的依赖模块的no_std化，以此类推。所以这里一般是采用第二种方法，也就是使用Cargo的条件引入功能，相信做过Rust开发的人都知道每个项目都有一个Cargo.toml文件，就是通过修改这个配置文件，让Cargo根据不同的feature判断是否引入no_std的替代版本。</p>
<p>用ndarray的no_std化来举例说明。ndarray作为一个开源项目，对no_std的需求，其实也是来源于社区用户。这一需求在去年被RustCV社区（一个专门从事于用rust开发计算机视觉算法的开源社区）的owner提出，他的想法是将ndarray应用于嵌入式环境下的机器人芯片上，从而在机器人上搭载基于ndarray开发的各种CV算法。笔者也参与了相关的issue讨论并承担了这个任务。所做的工作和上面讲的步骤可以一一对应。这里有一个小技巧，就是在项目的lib.rs文件里加入这么一句use core as std就能很方便地在整个项目中用核心库代替标准库，而不用修改所有use std的语句。除了核心库之外，ndarray还大量使用了标准库alloc模块中的Vec、Slice等功能，因此需要在lib.rs中手动引入alloc模块。而对于无法通过单个模块导入的浮点数计算功能，比如求对数、指数函数等，就通过加入属性来实现条件编译，只有在std环境下才编译带有该属性的程序实体。这里程序实体在狭义上就是指各个函数，因为和C的基于宏的条件编译不同，Rust的条件编译是基于属性的，所以无法在函数内部像C一样通过使用宏而选择编译各条语句，而是根据属性的不同判断带有这个属性的程序实体是否要被编译。</p>
<p>对于ndarray的各依赖模块，其中矩阵乘法模块是专门对其进行了no_std化。而其他的库，如BLAS、Serde序列化、rayon多线程，都使用了Cargo的条件引入功能，在no_std环境下要么引入相应的no_std版本，要么使其不可用。</p>
<h3><a class="header" href="#灵活步长" id="灵活步长">灵活步长</a></h3>
<p>接下来介绍多维数组中步长的使用。这里需要首先介绍一下ndarray中多维数组的内存模型。该内存模型包含数据，数据指针，维度和步长四个部分。它和numpy一个显著的区别就是使用静态维度，也就是1至6维的维度和步长全部由固定长度的数组表示，这是因为Rust语言本身的特性，之后会继续展开。当然ndarray本身也是支持动态可扩展的数组作为维度的。静态维度的数组运算速度比动态维度要快很多，但是缺点是不同维度之间的交互逻辑比较不便和复杂。</p>
<p>而步长顾名思义，就是每一列的相邻索引位置在内存中的距离，它决定了指针遍历数组的顺序。ndarray的重要功能之一，就是可以通过不同的步长表示，表达出物理结构相同，而逻辑结构不同的数组，这样做最大的好处，就是可以节省新建数组的时间和空间开销，在数据量大的应用场景，比如各种大数据应用、生物信息研究中，这样的好处无疑是巨大的。 而在某些场景下，步长的不同也会显著地影响算法和程序运行的效率。 </p>
<p>最经典的例子便是C风格数组和Fortune风格数组的区别。C风格数组的最后一列上的元素在内存上是相邻的，第一列上的元素是内存上相隔最远。而Fortune刚好相反，第一列上的元素在内存上相邻，最后一列最远。这两种不同风格的数组排布，在不同的运算场景下，效率会有巨大的差异，因为数组遍历时的空间连续性，对访问的速度会有显著的影响，如果运算逻辑是以第一列为优先，那一定是Fortune排布更快，反之则是C风格更快。另一个角度来理解，在内存排布相同的情况下，C风格的数组和Fortran风格的数组在逻辑结构上互为转置。</p>
<p>在上述基础上，负步长的定义和作用便油然而生。即当我们想以相反的顺序访问数组的某一列时，只需要将该列的步长调整为原来的负值即可，而不用重新申请内存空间存放顺序相反的数据。例如我们想求一张图片的翻转，因为图片数据一般是长、宽、RGB三个维度组成的数组，所以只需将水平轴的步长改为原来的相反数，便可以得到翻转后的图片数据而不用复制一张同样大小的图片。而非连续步长也可以理解为一种方便的切片表示方法，他通过让指针在内存中跳跃而非依次遍历的方式得到原来数组的切片。这在神经网络训练的提取特征点场景中使用相当广泛。而更为特殊的还有零步长的形式，相当于是将某一切片复制了许多份。这是之后要讲的广播特性的实现基础。</p>
<p>而要实现这些步长使用方法，主要要解决下面三个问题：即步长的合法性、连续性判断以及寻址算法。合法性保证了在自定义步长时的程序是安全的，其中最重要的就是保证指针在依据步长在内存中移动时，不能在不同的坐标指向相同的内存，否则会造成读写错误。连续性是指该步长表示下的数组在内存排布上是否是连续的。如果是连续的，那么在复制和遍历时就能当做一整块内存来处理，效率会快很多很多。另外还有寻址算法，这一部分也很重要，因为如果寻址错误会导致访问到数组数据之外的内存数据，造成程序漏洞。具体的计算分为计算指针位置和计算寻址时的偏移量两部分，在此不再展开。</p>
<h3><a class="header" href="#广播特性" id="广播特性">广播特性</a></h3>
<p>在多维数组运算中，广播是一个极其重要的概念，它定义了不同维度的数组之间的交互逻辑。举个最简单的例子，一个二维数组和一维数组相乘时，将一维数组重复多次，就扩展成了一个二维数组，再将两个二维数组对应元素相乘，就得到了想要的结果。这样的运算是很常见的，比如地理上计算多个地标到原点的距离、数据挖掘聚类时的离散度计算等。而当多个不同维度的数组进行运算时，广播机制会按照类似的规则将每个数组扩展到同样的维度长度，然后再进行运算，在机器学习中常常会计算两个一维输入之间的协方差矩阵，那么就需要用到这样的机制。</p>
<p>ndarray社区早在六年前就提出要实现广播机制，但直到21年都没有人解决它。其实这并不是因为广播不重要，而是由于Rust语言本身的语法限制问题。</p>
<p>具体来说，当两个数组进行广播时，是无法确定返回值的类型的——之前说过ndarray采用的都是静态维度，也就是长度固定的数组，比如一维就是[usize;1]，二维就是[usize;2]。对Rust来说，[usize;1]和[usize;2]是不同的类型，这是出于对内存安全的考虑。另外还有不固定长度的usize数组。而不固定长度的usize数组不能作为返回值，因为它的空间大小是运行时确定而非编译时确定，而Rust要求函数的参数、返回值大小都必须是编译时确定的，这是为了保证函数调用时程序堆栈的大小确定。所以n维数组作为返回值时它的维度也必须是确定的——要么是1，要么是2、3。。。或者聪明一点，和第一个输入值的维度相同，或者和第二个输入值的维度相同。这在广播里是不够的，因为它要返回的是两个输入维度之间的较长者，这个逻辑听起来很简单，但对编译器来说根本做不到，因为其并没有在函数声明中进行推断的功能。C语言是没有这个问题的，因为C中根本就没有静态维度的概念，不管是多长的数组，都只是一个地址的引用而已。其他的动态语言类似Java，Python也没有这个问题，因为它们的所有对象几乎都是引用类型，这也导致了它们在每次访问对象时都会进行一次解引用，效率当然就没有C和Rust那么快。那Rust能不能想C一样返回地址的引用？也不可以，这是因为Rust作为一门内存安全语言有所有权的限制，在广播这个函数内创建的n维数组，是不能返回它的地址的，因为它的所有权在函数结束时就消亡了。那返回所有权呢？更不行，因为刚才说了，它的大小无法在编译时确定。</p>
<p>所以这个问题有没有解决方法呢？之前说过ndarray也是支持动态数组作为维度的，动态数组是指如vec，box等类型，它们使用智能指针使得虽然他们持有的内存空间动态变化，但是本身大小是固定的，所以能作为返回类型。笔者也在社区中提出过在广播中使用动态数组作为返回值的维度，但马上就被owner否决掉了，因为Rust里的动态数组运行效率太过缓慢。</p>
<p>但是万事都有解决的途径， 如果我们让编译器不用自己执行这个判断两个输入数组之中哪个维度更大的过程，而是直接告诉它应该返回什么大小维度的数组，那么广播就可以实现。具体来说，维度有零维到六维加上动态维度8种类型，如果我们写一个宏，为它们之间8*8=64种交互的情况都分别实现一个广播函数，那么在每一种情况中返回维度大小都是能够确定的。这种方法理论上是可行的，但实现起来却会遇到更大的问题。试想一下，如果一个函数需要使用两个数组的广播，此时数组维度是不确定的，那么它该调用哪个广播函数？难道再将这个函数为64种情况全部都实现一遍吗？显然不现实。</p>
<p>但是这个问题可以通过Rust语法中特有的聚合类型来解决。我们把数组间广播的实现放在一个自定义的trait里，这个trait用一个泛型参数来代表将要与trait实体进行广播的数组，并且在内部用一个聚合类型Output表示进行广播后输出的数组。然后使用宏为所有类型的数组都实现该trait。这样，我们在进行任意维度的数组间的广播时，只需要在where语句中添加一个限定条件，即数组实现了该trait，就能使用广播特性。实际上对Rust编译器有深入了解的人应该知道，编译器在单态化过程中会将所有泛型展开成具体的类型，每一次展开都会生成单独的一份代码。所以这种方法和上面那种方法其实在本质上是一样的。不过目前Rust编译器团队正在尝试多态化的实现，可以在编译过程中为类似的函数只生成一份代码，有兴趣的话可以自行研究。</p>
<p>但是这样的方法会限定广播间的数组必须含有同样的数据类型，这样的限制有点严格，而且函数声明看起来也过于冗长。所以在此思路上，我们再进行简化，只为数组的维度实现该trait，并且将该trait命名为DimMax，顾名思义就是两个维度之间的较大者。</p>
<p>那么，还能不能再简化，把where语句中额外的限定条件也去掉？即为两个任意长度的维度D1和D2实现该trait。这听起来很美好，但是又会再次受到Rust语法的限制——聚合类型也必须在定义时就确定——要么是手动确定，要么来自于输入值中的其他聚合类型。但我个人觉得这个问题可以解决——能不能修改编译器的特征实现机制，让其变得更聪明一点，比如在进行trait实现的编译过程中，允许进行静态常量的计算。因为静态维度的长度肯定是一个常量。所以在编译时对该常量进行计算，比如获取两个常量之间的最大值，然后获得一个确定的聚合类型，应该也是可行的。当然这只是我个人目前的猜想，能不能实现还需要对Rust编译器进行更深入的研究。不过目前还是可以在某些常见的情况下省去该限制，即相同维度间进行广播以及和与零维进行广播，在这两种情况下广播结果的维度都是本身，所以可以直接添加到对维度的定义中，在这两种特定情况下就能避免添加where语句的限制。</p>
<h3><a class="header" href="#并行计算加速" id="并行计算加速">并行计算加速</a></h3>
<p>最后，我想分享一下ndarray在并行计算方面的现状及发展。ndarray目前使用rayon库在部分场景下实现了多线程并行加速。rayon是一个基于迭代器实现的多线程并行库。它的核心思想是将一个迭代器拆成数个不同方向的子迭代器，同时将迭代的任务分配到各个子迭代器上，再用work-stealing算法分配到多个线程实现并行化。它要求迭代器必须满足以下三点：1.可以按从前向后和从后向前两个方向进行迭代2.可以随时求出剩余元素的个数3.可以从中间索引分割成两个互斥的，和父迭代器相同性质的子迭代器，如图所示。</p>
<p>ndarray在数组的单个元素遍历、按某一特定维度遍历、以及多数组运算对应元素操作时按元素遍历这几种场景下实现了多线程加速。其后又增加了Lanes迭代器并行。Lanes直译过来是泳道，如果我们将一个N维的数组去掉某一维，看成一个N-1维的数组，那这个数组的每一个元素就变成了一个一维向量，这个向量就叫做泳道。它的主要应用场景是在二维以上的矩阵乘法中，此时结果矩阵中的每一个元素都是两条泳道的向量积，这种计算在文本分类、自然语言处理等深度学习场景中也是很常见的。</p>
<p>除了多线程，还有另一个重要的并行加速方法，就是simd（Single instruction, multiple data）单指令多数据加速。即在一条机器指令的执行期间执行多个数据的计算操作。举个简单的例子，arm架构下的vaddq_s32指令，就可以在一条指令执行时间内，计算两个128位向量的和，每个向量各包含4个32位整数，因此相比于普通的循环加法要快了4倍。不同的硬件架构都有相适配的simd指令集，比如x86架构的avx、avx512、SSE指令集，arm的neon、asimd指令集等等。想要通过simd指令给ndarray中的n维数组运算加速，需要三个步骤：1.让Rust标准库支持各种架构simd指令。这个正是官方的simd工作组在做的事情。这是一项工作量很大的事，光是支持arm架构代码量就在10w行以上，x86更是接近20w行，还不包括一些要对编译器的修改。2.基于各种指令实现通用运算的simd加速。比如诞生于OpenCV的universal intrinsic，它提供了诸如向量点乘、矩阵乘法、距离计算、排序等多种通用计算接口及它们的实现，可以通过这些接口将计算转换成simd向量的计算以实现算法的加速。但universal intrinsic对一般开发者而言并不好用，因为它不能自动生成适配cpu向量寄存器长度的simd指令，需要用户手动来选择，因此可能造成simd性能利用不全或者因指令不适配而导致程序崩溃。这就引出了第3个步骤，也就是cpu的simd配置的自动检测和simd指令的自动适配，让所有simd指令对用户透明化。最后，还有潜在的第4个步骤，也就是编译器的自动向量化，使所有的运算都能通过编译器自动生成simd指令。这是一个极为艰深的方向，目前有很多LLVM的成员在研究这方面的实现，但也是困难重重，读者感兴趣的话可以尝试研究。</p>
<p>这里再介绍一下Rust标准库中的stdarch仓库，这个库作为标准库的一部分为所有Rust开发者提供了各种常见硬件架构的simd指令集，由官方的simd工作组和库团队成员负责开发和维护，但目前除了x86平台的各种特性在去年年末刚刚稳定(stable)之外，其他架构都还处于unstable状态，因此整个simd特性还不能在稳定的Rust版本中使用，也需要各方开发者前来贡献。stdarch和Rust编译器、LLVM都有密切的联系。stdarch负责对不同架构、不同版本的指令集进行模块分类、封装和测试，并提供给用户相应的函数接口。底层的汇编实现和汇编优化是在Rust编译器和LLVM中，因此stdarch需要对编译器和LLVM的实现进行封装。这里分为两种情况，一种是各架构通用的simd接口，例如加减乘除、位运算等，这些指令会在编译器的代码生成部分静态调用LLVM的相关接口进行实现，再由stdarch使用extern “platform-intrinsics”关键字进行引入和封装。另一种是各架构提供的专用指令，例如x86的vcomi指令、arm的vsli指令等，一般是针对特定的计算场景提供，比如vsli代表向左位移再插入相应元素。这种情况下需要通过静态链接的形式调用llvm中的相关实现并进行封装。而stdarch中提供的接口依然是区分架构和向量寄存器长度的，而我提到的simd透明化或者说usimd，就是在此基础上向用户屏蔽掉硬件差异，以提供更通用的计算接口。</p>
<p>此文主要由一些n维数组运算库ndarray的具体问题及技术解决展开，引出一些对Rust语言、以及科学计算领域技术的延伸和思考。希望对大家的Rust学习和开发有所帮助。</p>
<h1><a class="header" href="#华为--基于-tvm-rust-runtime-和-wasm-沙箱运行-ai-模型" id="华为--基于-tvm-rust-runtime-和-wasm-沙箱运行-ai-模型">华为 | 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型</a></h1>
<p>作者： 王辉 / 后期编辑： 张汉东</p>
<blockquote>
<p>此文来自于 3.27号 深圳 Meetup 大会
3月27日活动PPT和现场视频链接：  <a href="https://disk.solarfs.io/sd/6e7b909b-133c-49f7-be0f-a51f65559665">https://disk.solarfs.io/sd/6e7b909b-133c-49f7-be0f-a51f65559665</a></p>
</blockquote>
<hr />
<h1><a class="header" href="#基于tvm-rust-runtime和wasm沙箱运行ai模型" id="基于tvm-rust-runtime和wasm沙箱运行ai模型">基于TVM Rust Runtime和WASM沙箱运行AI模型</a></h1>
<h2><a class="header" href="#说明-1" id="说明-1">说明</a></h2>
<p>本文介绍了一种WASM与TVM在AI领域的结合方案：依托TVM端到端深度学习编译全栈的能力，将AI框架训练好的模型编译成WASM字节码，然后在运行时环境中通过Wasmtime进行图加载进而实现模型的无缝迁移部署。</p>
<h2><a class="header" href="#图解tvm和wasm技术" id="图解tvm和wasm技术">图解TVM和WASM技术</a></h2>
<h3><a class="header" href="#tvm与rust运行时" id="tvm与rust运行时">TVM与Rust运行时</a></h3>
<img src="https://tvm.apache.org/assets/images/about-image.svg" alt="TVM Framework" width="800"/>
<p>作为Apache基金会的顶级开源项目，TVM是用于深度学习领域的一个全栈编译器，旨在高效地在任何硬件平台进行模型的编译优化和部署工作。通过统一的中间表示层（包括Relay和Tensor IR两层），TVM可将AI框架训练的模型编译成与后端硬件架构无关的计算图表达，然后基于统一运行时实现不同环境下的计算图加载和执行操作。</p>
<p>为实现上述的图加载执行操作，TVM制定了一套抽象的运行时接口，并根据不同的运行时环境提供多种编程语言的接口实现（包括C++、Python、Rust、Go及Javascript等），本文主要介绍TVM Rust运行时的接口定义。TVM Rust运行时接口主要包含<code>tvm_rt</code>和<code>tvm_graph_rt</code>两个crate，前者完全实现了TVM runtime API的Rust接口，而后者则具体实现了TVM graph运行时的Rust版本；本文着重针对<code>tvm_graph_rt</code>的接口实现展开介绍。</p>
<ul>
<li>
<p>结构体定义</p>
<p>| 结构体名称 | 功能介绍 |
| :--------- | :------- |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/struct.DLTensor.html">DLTensor</a> | Plain C Tensor object, does not manage memory. |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/struct.DsoModule.html">DsoModule</a> | A module backed by a Dynamic Shared Object (dylib). |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/struct.Graph.html">Graph</a> | A TVM computation graph. |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/struct.GraphExecutor.html">GraphExecutor</a> | An executor for a TVM computation graph. |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/struct.SystemLibModule.html">SystemLibModule</a> | A module backed by a static system library. |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/struct.Tensor.html">Tensor</a> | A n-dimensional array type which can be converted to/from <code>tvm::DLTensor</code> and <code>ndarray::Array</code>. <code>Tensor</code> is primarily a holder of data which can be operated on via TVM (via <code>DLTensor</code>) or converted to <code>ndarray::Array</code> for non-TVM processing. |</p>
</li>
<li>
<p>枚举定义</p>
<p>| 枚举名称 | 功能介绍 |
| :------- | :------- |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/enum.ArgValue.html">ArgValue</a> | A borrowed TVMPODValue. Can be constructed using <code>into()</code> but the preferred way to obtain a <code>ArgValue</code> is automatically via <code>call_packed!</code>. |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/enum.RetValue.html">RetValue</a> | An owned TVMPODValue. Can be converted from a variety of primitive and object types. Can be downcasted using <code>try_from</code> if it contains the desired type. |
| <a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/enum.Storage.html">Storage</a> | A <code>Storage</code> is a container which holds <code>Tensor</code> data. |</p>
</li>
<li>
<p>常量定义</p>
<ul>
<li><a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/constant.DTYPE_FLOAT32.html">DTYPE_FLOAT32</a></li>
<li><a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/constant.DTYPE_FLOAT64.html">DTYPE_FLOAT64</a></li>
<li><a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/constant.DTYPE_INT32.html">DTYPE_INT32</a></li>
<li><a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/constant.DTYPE_UINT32.html">DTYPE_UINT32</a></li>
</ul>
</li>
<li>
<p>trait定义</p>
<ul>
<li><a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/trait.Module.html">Module</a></li>
<li><a href="https://tvm.apache.org/docs/api/rust/tvm_graph_rt/trait.PackedFunc.html">PackedFunc</a></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#wasm与wasi" id="wasm与wasi">WASM与WASI</a></h3>
<img src="https://www.virusbulletin.com/files/cache/f1eb0edbac94a7c83b2d8dda10dbf716_f3050.jpg" alt="WASM Introduction" width="600"/>
<p><a href="https://webassembly.org/">WebAssembly技术</a>（WASM）是一个基于二进制操作指令的栈式结构的虚拟机，其可以被编译为机器码，进而更快、高效地执行本地方法和硬件资源；当然凭借WASM强大的安全和可移植特性，其不仅可以嵌入浏览器增强Web应用，也可以应用于服务器、IoT等场景。</p>
<p>由于浏览器领域天然具备屏蔽后端硬件平台的特点，WASM技术本身不需要考虑浏览器后端的运行时环境；但是面向非Web领域必须要针对不同的操作系统进行适配和兼容（文件读写、时钟同步、中断触发等），针对这种情况WASM社区提出了一套全新的WASI标准（WASM System Interface）。正如WASM是面向逻辑机层面的汇编语言一样，WASI是一套面向逻辑操作系统的标准接口，目的是为了实现WASM平台在不同操作系统间的无缝迁移运行。针对WASI标准的详细解读，请查阅<a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">此博文</a>。</p>
<h2><a class="header" href="#方案介绍" id="方案介绍">方案介绍</a></h2>
<h3><a class="header" href="#前期调研" id="前期调研">前期调研</a></h3>
<p>当前业界针对WASM技术在AI领域已经有了比较多的探索：<a href="https://blog.tensorflow.org/2020/03/introducing-webassembly-backend-for-tensorflow-js.html">TF.js社区</a>基于WASM编译传统手写算子提升执行速度；<a href="https://tvm.apache.org/2020/05/14/compiling-machine-learning-to-webassembly-and-webgpu">TVM社区</a>基于WASM编译模型用于浏览器领域的模型推理；还有利用WASM可移植性解决算子库与硬件设备不兼容的问题（详见<a href="https://github.com/google/XNNPACK">XNNPACK</a>）等等。</p>
<h3><a class="header" href="#方案设计" id="方案设计">方案设计</a></h3>
<p>之前我们团队分享了WASM与AI领域结合的初步思路（详见<a href="https://leonwanghui.github.io/machine-learning/2020/04/15/some-thoughts-on-using-wasm-in-ml.html">此处</a>），正如TF.js和TVM社区开展的探索工作，我们发现WASM具有的可移植性天然地解决了AI模型在全场景落地的问题：针对传统深度学习框架定义的模型，用户在不同硬件环境上进行模型训练/推理时必须要进行额外的定制化开发工作，甚至需要单独开发一套推理引擎系统。</p>
<p>那么如何利用WASM的可移植性实现硬件环境的统一呢？以MindSpore深度学习框架为例，如果我们把MindSpore模型分别从宏观和微观的角度来分析，宏观来看它就是一张基于MindSpore IR定义的<strong>计算图</strong>，微观来看它是一系列MindSpore<strong>算子</strong>的集合。那么我们就可以尝试分别从计算图和算子的维度将WASM与深度学习框架进行结合，也就是提出<code>WASM计算图</code>和<code>WASM算子库</code>这两种概念。</p>
<ul>
<li>
<p>WASM计算图</p>
<p>WASM计算图，顾名思义就是将训练好的模型（包括模型参数）编译成WASM字节码，然后在Runtime环境中通过WASM Runtime加载便可直接进行模型推理，借助WASM的可移植性可以实现任何环境下的模型推理工作：</p>
<ul>
<li>Web领域通过<code>Emscripten</code>工具将WASM字节码加载到JS Runtime中进而在浏览器中执行；</li>
<li>非Web领域通过<code>Wasmtime</code>工具加载WASM字节码到系统环境中执行。
对于WASM计算图这种情况，由于训练好的模型（和参数）都是提前保存在系统环境中，因此需要引入<code>WASI</code>接口与系统资源进行交互，进而完成离线加载模型的操作。所以在选择WASM Runtime的时候需要选择支持WASI（WASM System Interface）标准的工具（例如<code>Wasmtime</code>），或者也可以像TVM社区那样简单粗暴地直接对Emscripten进行WASI扩展。</li>
</ul>
</li>
<li>
<p>WASM算子库</p>
<p>WASM算子库相对来说比较好理解，就是把单个算子编译成WASM字节码，然后对上层框架提供一种封装好的算子调用接口。但是和传统手写算子的调用方式不同，框架需要通过一种类似于动态链接的方式来加载WASM算子，但考虑到当前WASM本身不支持动态链接的方式，因此需要提前将所有编译好的WASM算子进行整合，然后对框架层提供算子库的调用接口。</p>
</li>
</ul>
<p>通过对上述两种思路进行分析比较，同时在<strong>借鉴了TVM社区已有工作</strong>的情况下，我们决定首先从<code>WASM计算图</code>这条路开始进行深入探索，最大程度地利用TVM全栈编译的能力快速实现方案的原型。</p>
<h3><a class="header" href="#方案实现" id="方案实现">方案实现</a></h3>
<img src="chapter_3/./hw-tvm/TVM-graph-solution.png" alt="TVM Graph Solution" width="800"/>
<ul>
<li>
<p>WASM图编译</p>
<p>如上图所示，我们可以利用TVM Relay的Python接口直接把模型编译成<code>graph.o</code>的可执行文件，但是需要注意的是生成的graph.o文件无法直接被WASM runtime模块识别，必须首先要通过TVM的Rust runtime加载然后通过Rust编译器把图中所示的<code>WASM Graph Builder</code>模块直接编译成WASM字节码（即图中的<code>wasm_graph.wasm</code>文件）。为什么非得要经过这一步繁琐的转换呢？主要是因为<code>graph.o</code>文件中包含了Relay和TVM IR的原语，我们无法直接将这些原语转换成WASM的原语，具体转换的步骤这里就不做赘述了。</p>
</li>
<li>
<p>WASM图加载</p>
<p>图加载阶段（由上图看来）似乎是非常简单的，但是实际情况要复杂地多。首先，WASM的运行时针对WASM IR定义了一整套汇编层面的用户接口，这对于上层应用开发者来说是极度不友好的；其次，WASM当前只支持整数类型（例如i32、u64等）作为函数参数，这就导致深度学习领域的张量类型无法通过原生方式传入；更别说还要增加thread、SIMD128这些高级特性的支持等等。</p>
<p>当然每个新领域的探索都离不开各种各样的问题，而且解决问题本身就是技术/科研人员的本职工作，所以我们没有寄希望于WASM社区而是主动尝试解决这些问题：既然WASM没有面向上层用户的高级API，我们就根据自己的需求开发一套；虽然WASM不支持传入Struct或Pointer，我们可以通过Memory机制将数据提前写入到WASM内存中然后将内存地址转成i32类型作为函数参数。虽然有些改动有点“反人类”，但是它可以清晰地展示出我们的思路和想法，这就已经足够了。</p>
</li>
</ul>
<p>由于篇幅有限，此处附上项目实现的<a href="https://github.com/apache/incubator-tvm/tree/master/apps/wasm-standalone">完整代码</a>，欢迎感兴趣的大佬进行交流讨论。</p>
<p>如下展示的是项目整体的codebase：</p>
<pre><code>wasm-standalone/
├── README.md
├── wasm-graph      // WASM图生成模块
│   ├── build.rs    // build脚本
│   ├── Cargo.toml  // 项目依赖包
│   ├── lib         // 通过TVM Relay API编译生成的计算图的存放目录
│   │   ├── graph.json
│   │   ├── graph.o
│   │   ├── graph.params
│   │   └── libgraph_wasm32.a
│   ├── src         // WASM图生成模块源代码
│   │   ├── lib.rs
│   │   ├── types.rs
│   │   └── utils.rs
│   └── tools       // Relay Python API编译脚本的存放目录
│       ├── build_graph_lib.py
└── wasm-runtime    // WASM图生成模块
    ├── Cargo.toml
    ├── src         // WASM图生成模块源代码
    │   ├── graph.rs
    │   ├── lib.rs
    │   └── types.rs
    └── tests      // WASM图生成模块测试用例
        └── test_graph_resnet50
</code></pre>
<p>为了让大家对该方案有一个更形象具体的理解，我们准备了一个简单的原型：通过TVM Relay API将基于ONNX生成的ResNet50模型编译成<code>wasm_graph_resnet50.wasm</code>文件，然后在运行时环境中通过Wasmtime加载WASM完成模型推理功能（具体操作流程详见<a href="https://github.com/apache/incubator-tvm/blob/master/apps/wasm-standalone/README.md#poc-guidelines">此处</a>）。</p>
<h2><a class="header" href="#未来规划" id="未来规划">未来规划</a></h2>
<h3><a class="header" href="#tvm社区联动" id="tvm社区联动">TVM社区联动</a></h3>
<p>正如前面所说的，该方案仍处于<strong>试验</strong>阶段，因此我们会和TVM社区一起共同探索更多可能性，目前初步规划的特性有：</p>
<ul>
<li>支持基于SIMD128的数据并行处理；</li>
<li>进一步完善TVM社区的Rust runtime API模块，使其能原生支持WASM Memory特性的对接；</li>
<li>基于WASM后端的AutoTVM优化；</li>
<li>更多网络支持。</li>
</ul>
<h3><a class="header" href="#wasm算子库" id="wasm算子库">WASM算子库</a></h3>
<p>当前我们只是针对WASM计算图这个方向进行了深入探索，但如果要是将WASM技术与深度学习框架（比如MindSpore）相结合的话，WASM算子库的方向可能会释放更大的潜能。这里首先列举几个更适合WASM算子库的场景：</p>
<ul>
<li>很多深度学习框架本身已经定义了自己的IR以及编译流水线，只有WASM算子库可以无缝地与这些框架的图编译层相融合；</li>
<li>WASM计算图只能用于模型推理，而WASM算子库可以适用于模型训练/验证/推理等场景；</li>
<li>在可移植性这个层面，WASM计算图无法提供其内部算子的一致性保证，而WASM算子库真正实现了端边云全场景中算子的可移植性。</li>
</ul>
<img src="chapter_3/./hw-tvm/TVM-kernel-solution.png" alt="TVM Kernel Solution" width="800"/>
<p>如上图所示，我们计划从WASM算子库这个层面梳理出一套端到到的集成方案（优先覆盖上述几个场景），真正实现WASM技术在AI领域全场景的结合。</p>
<h2><a class="header" href="#加入我们" id="加入我们">加入我们</a></h2>
<p>为了更好地推动Rust编程语言生态在AI领域的落地，我们发起了一个叫Rusted AI的非商业性组织，任何对Rust和AI技术感兴趣的开发者均可申请加入，社区当前提供如下几种交流渠道：</p>
<ul>
<li><strong>Rusted AI微信群</strong>：欢迎添加小助手的微信（微信号：<code>mindspore0328</code>，备注：<code>Rusted AI</code>），认证通过后小助手会将您拉进Rusted AI讨论群</li>
<li><strong>GitHub Teams</strong>：社区当前依托GitHub Teams提供公开讨论的渠道，由于GitHub Teams仅对组织成员开放，请以邮件形式发送<code>个人GitHub ID</code>至<a href="chapter_3/wanghui71leon@gmail.com">wanghui71leon@gmail.com</a>，认证通过后即可参与<a href="https://github.com/orgs/tinyms-ai/teams/rustedai">社区话题讨论</a></li>
<li><strong>生态众筹项目</strong>：近期社区发布了<a href="https://github.com/tinyms-ai/awesome-rusted-ai">awesome-rusted-ai</a>众筹项目，用于记录所有与Rust语言和AI领域联动相关的开源项目</li>
</ul>
<h1><a class="header" href="#蚂蚁集团-ceresdb-团队--rust-cpu-affinity-初探" id="蚂蚁集团-ceresdb-团队--rust-cpu-affinity-初探">蚂蚁集团 CeresDB 团队 | Rust CPU Affinity 初探</a></h1>
<p>作者：Ruihang Xia / 后期编辑：张汉东</p>
<h1><a class="header" href="#brief" id="brief">Brief</a></h1>
<p>在看 <a href="https://cassandra.apache.org/">Apache Cassandra</a> 的时候了解到 <a href="https://www.scylladb.com/">ScyllaDB</a> 能在完全兼容它的情况下性能提升很多，通过进一步了解接触到了 thread per core 这种架构，这篇文章从一个简单的 cache 结构出发，实现了三个不同的方案，并对它们进行比较，最后给出了在这个过程中学习到的一些东西。</p>
<p>Thread Per Core 简单来说就是将应用的每一个线程绑定到一个计算核心上，通过 sharding 的方式将计算拆解分配到对应的核上。这是一种 shared nothing 的方式，每个核单独持有计算所需要的数据，独立完成计算任务，从而避免掉多余的线程同步开销。同时每个核心和工作线程一一对应，减少上下文切换的开销。</p>
<p>在 <a href="https://github.com/waynexia/shard-affinity">waynexia/shard-affinity</a> 中，我分别用普通的不做限制调度、local set 给计算任务分组以及 绑定任务、核心与线程三种方式实现同一个目的的 cache 结构。这三种实现分别对应 <em>shard-affinity/load/src</em> 目录下的 <em>threading-rs</em>, <em>local_set-rs</em> 和 <em>affinity-rs</em> 三个文件。接下来将对这三种方法实现方法进行分析。下文提到的原始代码都在这个仓库里面，为了简洁进行了部分省略。</p>
<h1><a class="header" href="#cache" id="cache">Cache</a></h1>
<p>假设我们有一个类似 <code>Map&lt;Id, Data&gt;</code> 的结构，它缓存了我们所需要的数据，请求分为对它进行 <code>append()</code> 或者 <code>get()</code>，通过读写锁进行线程同步并提供内部可变性，对外暴露 <code>&amp;self</code> 的接口。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CacheCell {
    items: RwLock&lt;Map&lt;Id, RwLock&lt;Item&gt;&gt;&gt;,
}

impl CacheCell {
    pub fn get(&amp;self, id: Id, size: usize) -&gt; Option&lt;Bytes&gt;{}
    pub fn append(&amp;self, id: usize, bytes: Bytes) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>首先为了能让多个任务在同时操作 cache 的时候仍能得到符合预期的结果，我们可以使用 lock-free 的结构，或者对它加上一把锁将并发的操作串行化。而我们发现对不同的 id 进行的操作并不会互相影响。所以可以将线程同步所影响的结构粒度变小，以这个 cache 所参考的 gorilla in-memory data structure 为例，将 id 分为进行分组，由对应的 cell 进行管理。将锁的粒度变小，以支持更高的并发操作。</p>
<img src="chapter_3/ceresdb/gorilla-fig7.png" width="75%">
<blockquote>
<p>图一，from <a href="https://www.vldb.org/pvldb/vol8/p1816-teller.pdf">Gorilla</a> paper Fig.7: Gorilla in-memory data structure.</p>
</blockquote>
<p>选这个结构作为实例有两个原因，首先这是一个实际生产系统所使用的结构，比较有实际意义；并且它比较简单易于实现，而且本身就已经对 id 进行了 sharding，方便进行后续的使用。</p>
<h1><a class="header" href="#threading" id="threading">Threading</a></h1>
<p>先来看比较常见的做法，拿若干个 <code>cache</code> 放一起合成一个 <code>Vec&lt;Cache&gt;&gt;</code>，根据每次请求的 id 路由到对应的 cache 进行操作。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ThreadingLoad{
    pub fn append(&amp;self, id: Id, bytes: Bytes) {
        self.shards[route_id(id)].append(id, bytes);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>而在使用的时候，则是开一个多线程的 tokio runtime，向里面 spawn 不同 id 的请求。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rt = Builder::new_multi_thread().build();
let load = ThreadingLoad::new();

rt.spawn(async move {
    let id = random::&lt;usize&gt;();
    load.append(id, bytes);
})
<span class="boring">}
</span></code></pre></pre>
<p>在这之后，由 tokio 去调度任务执行，完成之后给我们结果，我们不用关心这个任务具体是怎样被调度的，产生的计算发生在哪个核上。而且我们底下的所有结构都付出了代价让它们 <code>Send</code> 和 <code>Sync</code>，也不用去担心一个对象同时被多个东西操作会出现奇怪的结果。</p>
<h1><a class="header" href="#localset" id="localset">LocalSet</a></h1>
<p>这里是使用 tokio 的 <a href="https://docs.rs/tokio/1.3.0/tokio/task/struct.LocalSet.html">LocalSet</a> 来实现的。它能将指定的任务绑在同一个线程上进行执行。这样子带来的好处就是我们可以使用 <code>!Send</code> 的东西了。</p>
<p>具体来说，由上面我们知道不同的 id 之间的操作不会互相影响，所以能够将锁粒度变小。同样的，不同 id 的任务计算所需要用到的数据也不会重叠，也就是避免了一份数据可能被多个内核同时访问的场景，从而不需要考虑我们的修改对其他内核的可见性。基于这一点，之前付出的性能代价来给数据实现 <code>Send</code> 和 <code>Sync</code> 也可以被节省下来。比如引用计数可以从 <code>Arc</code> 变成 <code>Rc</code>，或者说所有为了保证可见性所加的指令屏障都可以去掉。</p>
<p>从实现来看，在我的这台有十六个逻辑核心的设备上，将所有的 shards 分给15个线程进行管理，另外一个来进行任务的分发，任务分发线程与其余每个线程之间都有一个 channel 来进行任务的传输。这里分发的任务有两种：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Task {
    Append(Id, Bytes, oneshot::Sender&lt;()&gt;),
    Get(Id, usize, oneshot::Sender&lt;()&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>每个里面包含对应任务所需要的参数，以及一个用于通知任务完成的 channel。每次请求到来时，任务分发线程组装好所需要的参数，根据 id 发送给对应的执行线程，之后等待执行结果。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn append(&amp;self, id: Id, bytes: Bytes) {
    let (tx, rx) = oneshot::channel();
    let task = Task::Append(id, bytes, tx);
    self.txs[route_id(id)].send(task).unwrap();

    rx.await.unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#affinity" id="affinity">Affinity</a></h1>
<p>在上面的实现中，我们只是将一组任务所需要的数据和计算绑在了一起，避免线程同步的开销。在运行中核心之间负载不均衡的时候，能够观察到明显的操作系统调度的行为。这样子只减少了开始提到的两种开销中的一种，上下文切换的开销仍然还在。操作系统的调度很多时候并不能明白应用的行为，所以在第三种方法中我们将每个线程与核绑定起来，或者是说告诉操作系统要去如何调度我们的线程。</p>
<p>线程的分配和上面 LocalSet 方案一样，将 shards 分配到除了一个分发线程之外的其余线程中，并每个线程绑一个核。通过 <a href="https://crates.io/crates/core_affinity">core_affinity</a> crate 来设置 <a href="https://en.wikipedia.org/wiki/Processor_affinity">cpu affinity</a>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let core_ids = core_affinity::get_core_ids().unwrap();
core_affinity::set_for_current(_);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for core_id in core_ids {
    thread::spawn(move || {
        core_affinity::set_for_current(core_id);
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>除了设置了 cpu affinity 之外，还有其他地方与上一种方案不同。首先这里在 channels 中分发的是已经构造好的 future，而不是分发参数之后再构造；其次这里的 runtime 是一个简单的 FIFO 队列；最后每个线程的 caches 通过 thread local storage 的方式存储。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.runtime.spawn(route_id(id), async move {
    thread_local! (static SHARD:AffinityShard = AffinityShard::new() );

    SHARD.with(|shard| {
        shard.append(id, bytes);
    });

    tx.send(()).unwrap();
});
<span class="boring">}
</span></code></pre></pre>
<p>这些区别只是单纯展现实现差异，并且由于 cache 内部的内存还是采用的默认分配器从堆上分配，这里的 TLS 实际上也没有起到什么作用，后文会继续提到这个点。</p>
<p>在这种情况下，每个计算线程可以在一定程度上简化成一个单线程模型进行考虑，整个系统也变成了非抢占式、协作的调度，利用 rust 的 coroutine 由任务自己在需要等待资源的时候通过 await yield 出来。除了之前提到的那些方面之外相信还有许多其他可以开发的空间。</p>
<p>以及这种 affinity 的方案也是一个能很好的在应用侧进行 NUMA 实践的场景，结合前面提到的 TLS，另一种方法就是使用一个感知 NUMA 的内存分配器。不过我的设备并不支持 NUMA，所以没有进行进一步的测试。</p>
<h1><a class="header" href="#test" id="test">Test</a></h1>
<p>在 <em>shard_affinity/src</em> 下有三个 binary 代码文件，分别是对三种情况进行的一个简单的测试。工作负载的参数可以在 <em>shard_affinity/src/lib.rs</em> 下看到。在我的环境下，三个方案以 128 并发分别进行 1024 次写以及 4096 次读 16KB 的数据耗时如下。为了让数据集中，将 id 的范围设置到了 0 至 1023.</p>
<img src="chapter_3/ceresdb/result.png" width="75%">
<blockquote>
<p>图二，本地进行测试结果。纵坐标为延时（毫秒），越低越好。</p>
</blockquote>
<p>可以看到，local set 和 affinity 两种方案的表现并不如 threading 的好。初步分析时在 local set 和 affinity 两种方案下都是由一个线程做入口进行任务生成和分发，即多出了额外的任务路由开销，在测试的时候能看到 cpu 的负载也是一高多底，而且由于模拟的任务单个执行时间都比较短，路由线程也会更先到达瓶颈。</p>
<p>在将工作线程数都调整为 8 （逻辑核心数量的一半）之后，可以看到 threading 和 affinity 的差别有所减小。对于目前仍然存在的 gap，通过 flamegraph 分析可能是 affinity 需要对每个任务收发请求和结果带来的.</p>
<img src="chapter_3/ceresdb/adjust-worker.png" width="75%">
<blockquote>
<p>图三，调整 worker 数量之后的结果。纵坐标为延时（毫秒），越低越好。</p>
</blockquote>
<p>由于所有的内存数据，即状态都被预先分散到各个核上，因此对 sharding 的方案也有要求。当 affinity 由于热点等原因出现负载不均衡时，进行 re-balance 一般会是一个比较耗时的操作，灵活性这方面不如 threading 模式。此外计算的分布方法也很重要，比如目前由一个线程向其他线程分发的方式就在测试中出现了问题。考虑到实际的系统计算负载的组成更加复杂，如何很好的分散计算任务也是需要慎重决定的。</p>
<h1><a class="header" href="#others" id="others">Others</a></h1>
<p>在 affinity 的实现中，为了展示大部分组件都是手造的简单模型。而 thread per core 其实已经有许多优秀的框架能够简化在这种架构下开发的难度，比如开头提到的 <a href="https://www.scylladb.com/">scylladb</a> 所使用的框架 <a href="http://seastar.io/">seastar</a>，这篇文章的写作过程中也参考了它们的很多文档。rust 也有类似的框架 <a href="https://crates.io/crates/glommio">glommio</a>，这是一个比较新的库，前不久刚放出第一个比较正式的 release。</p>
<p>在 thread per core 架构下，除了应用的逻辑需要发生变化，许多常用的组件也都要产生改动，为了一般多线程场景设计的那些向线程同步付出了代价的结构如使用了 Arc 的地方是不是可以换成 Rc 等，这些都是需要考虑的。也希望能围绕这个发展出很好的生态。</p>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>
<p>在简单的对比过不同方法的实现和性能之后，从我的观点来看 thread per core 是一个非常值得尝试的方法，它能够在某种程度上简化开发时所考虑的场景，也很适合目前动辄几十上百核的服务器，而且也有 <a href="https://www.scylladb.com/">scylladb</a> 这种成熟的实践。不过这个对于已经基本成型的系统来说所需要作的改动比较大。我们期望 thread per core 带来的提升是通过减小同步开销以及提高的缓存命中率实现更低的延时以及更平稳的性能，而且这些改动所能带来的提升与增加的复杂度，工作量和风险性相比则需要进行权衡。</p>
<h1><a class="header" href="#关于我们-1" id="关于我们-1">关于我们</a></h1>
<p>我们是蚂蚁智能监控技术中台的时序存储团队，我们正在使用 Rust 构建高性能、低成本并具备实时分析能力的新一代时序数据库，欢迎加入或者推荐，目前我们也正在寻找优秀的实习生，也欢迎广大应届同学来我们团队实习，请联系：jiachun.fjc@antgroup.com</p>
<h1><a class="header" href="#datenlord--用-rust实现-rdma" id="datenlord--用-rust实现-rdma">DatenLord | 用 Rust实现 RDMA</a></h1>
<p>作者：王璞 / 后期编辑：张汉东</p>
<hr />
<p>RDMA是常用于高性能计算(HPC)领域的高速网络，在存储网络等专用场景也有广泛的用途。RDMA最大的特点是通过软硬件配合，在网络传输数据的时候，完全不需要CPU/内核参与，从而实现高性能的传输网络。最早RDMA要求使用InfiniBand (IB)网络，采用专门的IB网卡和IB交换机。现在RDMA也可以采用以太网交换机，但是还需要专用的IB网卡。虽然也有基于以太网卡用软件实现RDMA的方案，但是这种方案没有性能优势。</p>
<p>RDMA在实际使用的时候，需要采用特定的接口来编程，而且由于RDMA在传输数据的过程中，CPU/内核不参与，因此很多底层的工作需要在RDMA编程的时候自行实现。比如RDMA传输时涉及的各种内存管理工作，都要开发者调用RDMA的接口来完成，甚至自行实现，而不像在socket编程的时候，有内核帮忙做各种缓存等等。也正是由于RDMA编程的复杂度很高，再加上先前RDMA硬件价格高昂，使得RDMA不像TCP/IP得到广泛使用。</p>
<p>本文主要介绍我们用Rust对RDMA的C接口封装时碰到的各种问题，并探讨下如何用Rust对RDMA实现safe封装。下面首先简单介绍RDMA的基本编程方式，然后介绍下采用Rust对RDMA的C接口封装时碰到的各种技术问题，最后介绍下后续工作。我们用Rust实现的RDMA封装已经开源，包括<a href="https://github.com/datenlord/rdma-sys">rdma-sys</a>和<a href="https://github.com/datenlord/async-rdma">async-rdma</a>，前者是对RDMA接口的unsafe封装，后者是safe封装（尚未完成）。</p>
<h2><a class="header" href="#rdma编程理念" id="rdma编程理念">RDMA编程理念</a></h2>
<p>先首先简要介绍下RDMA编程，因为本文重点不是如何用RDMA编程，所以主要介绍下RDMA的编程理念。RDMA的全称是Remote Direct Memory Access，从字面意思可以看出，RDMA要实现直接访问远程内存，RDMA的很多操作就是关于如何在本地节点和远程节点之间实现内存访问。</p>
<p>RDMA的数据操作分为“单边”和“双边”，双边为send/receive，单边是read/write，本质都是在本地和远程节点之间共享内存。对于双边来说，需要双方节点的CPU共同参与，而单边则仅仅需要一方CPU参与即可，对于另一方的CPU是完全透明的，不会触发中断。根据上述解释，大家可以看出“单边”传输才是被用来传输大量数据的主要方法。但是“单边”传输也面临这下列挑战：</p>
<ol>
<li>
<p>由于RDMA在数据传输过程中不需要内核参与，所以内核也无法帮助RDMA缓存数据，因此RDMA要求在写入数据的时候，数据的大小不能超过接收方准备好的共享内存大小，否则出错。所以发送方和接收方在写数据前必须约定好每次写数据的大小。</p>
</li>
<li>
<p>此外，由于RDMA在数据传输过程中不需要内核参与，因此有可能内核会把本地节点要通过RDMA共享给远程节点的内存给交换出去，所以RDMA必须要跟内核申请把共享的内存空间常驻内存，这样保证远程节点通过RDMA安全访问本地节点的共享内存。</p>
</li>
<li>
<p>再者，虽然RDMA需要把本地节点跟远程节点共享的内存空间注册到内核，以防内核把共享内存空间交换出去，但是内核并不保证该共享内存的访问安全。即本地节点的程序在更新共享内存数据时，有可能远程节点正在访问该共享内存，导致远程节点读到不一致的数据；反之亦然，远程节点在写入共享内存时，有可能本地节点的程序也正在读写该共享内存，导致数据冲突或不一致。使用RDMA编程的开发者必须自行保证共享内存的数据一致性，这也是RDMA编程最复杂的关键点。</p>
</li>
</ol>
<p>总之，RDMA在数据传输过程中绕开了内核，极大提升性能的同时，也带来很多复杂度，特别是关于内存管理的问题，都需要开发者自行解决。</p>
<h2><a class="header" href="#rdma的unsafe封装" id="rdma的unsafe封装">RDMA的unsafe封装</a></h2>
<p>RDMA的编程接口主要是C实现的<a href="https://github.com/linux-rdma/rdma-core">rdma-core</a>，最开始我们觉得用Rust的<a href="https://github.com/rust-lang/rust-bindgen">bingen</a>可以很容易生成对rdma-core的Rust封装，但实际中却碰到了很多问题。</p>
<p>首先，rdma-core有大量的接口函数是inline方式定义，至少上百个inline函数接口，bindgen在生成Rust封装时直接忽略所有的inline函数，导致我们必须手动实现。Rust社区有另外几个开源项目也实现了对rdma-core的Rust封装，但是都没有很好解决inline函数的问题。此外，我们在自行实现rdma-core的inline函数Rust封装时，保持了原有的函数名和参数名不变。</p>
<p>其次，rdma-core有不少宏定义，bindgen在生成Rust封装时也直接忽略所有的宏定义，于是我们也必须手动实现一些关键的宏定义，特别是要手动实现rdma-core里用宏定义实现的接口函数和一些关键常量。</p>
<p>再有，rdma-core有很多数据结构的定义用到了union，但是bindgen对C的union处理得不好，并不是直接转换成Rust里的union。更严重的是rdma-core的数据结构里还用到匿名union，如下所示：</p>
<pre><code class="language-C">struct ibv_wc {
    ...
	union {
		__be32		imm_data;
		uint32_t	invalidated_rkey;
	};
    ...
};
</code></pre>
<p>由于Rust不支持匿名union，针对这些rdma-core的匿名union，bindgen在生成的Rust binding里会自动生成union类型的名字，但是bindgen自动生成的名字对开发者很不友好，诸如<code>ibv_flow_spec__bindgen_ty_1__bindgen_ty_1</code>这种名字，所以我们都是手动重新定义匿名union，如下所示：</p>
<pre><code class="language-Rust">#[repr(C)]
pub union imm_data_invalidated_rkey_union_t {
    pub imm_data: __be32,
    pub invalidated_rkey: u32,
}

#[repr(C)]
pub struct ibv_wc {
    ...
    pub imm_data_invalidated_rkey_union: imm_data_invalidated_rkey_union_t,
    ...
}
</code></pre>
<p>再次，rdma-core里引用了很多C的数据结构，诸如<code>pthread_mutex_t</code>和<code>sockaddr_in</code>之类，这些数据结构应该使用<a href="https://github.com/rust-lang/libc">Rust libc</a>里定义好的，而不是由bindgen再重新定义一遍。所以我们需要配置bindgen不重复生成libc里已经定义好的数据结构的Rust binding。</p>
<p>简单一句话总结下，bindgen对生成rdma-core的unsafe封装只能起到一半作用，剩下很多工作还需要手动完成，非常细碎。不过好处是，RDMA接口已经稳定，此类工作只需要一次操作即可，后续几乎不会需要大量更新。</p>
<h2><a class="header" href="#rdma的safe封装" id="rdma的safe封装">RDMA的safe封装</a></h2>
<p>关于RDMA的safe封装，有两个层面的问题需要考虑：</p>
<ul>
<li>如何做到符合Rust的规范和惯例；</li>
<li>如何实现RDMA操作的内存安全。</li>
</ul>
<p>首先，关于RDMA的各种数据结构类型，怎样才能封装成对Rust友好的类型。rdma-core里充斥着大量的指针，绝大多数指针被bindgen定义为<code>*mut</code>类型，少部分定义为<code>*const</code>类型。在Rust里，这些裸指针类型不是<code>Sync</code>也不是<code>Send</code>，因此不能多线程访问。如果把这些裸指针转化为引用，又涉及到生命周期问题，而这些指针指向的数据结构都是rdma-core生成的，大都需要显式的释放，比如<code>struct ibv_wq</code>这个数据结构由<code>ibv_create_wq()</code>函数创建，并由<code>ibv_destroy_wq()</code>函数释放：</p>
<pre><code class="language-C">struct ibv_wq *ibv_create_wq(...);

int ibv_destroy_wq(struct ibv_wq *wq);
</code></pre>
<p>但是用Rust开发RDMA应用的时候，Rust代码并不直接管理<code>struct ibv_wq</code>这个数据结构的生命周期。进一步，在Rust代码中并不会直接修改rdma-core创建的各种数据结构，Rust代码都是通过调用rdma-core的接口函数来操作各种RDMA的数据结构/指针。所以对Rust代码来说，rdma-core生成的各种数据结构的指针，本质是一个句柄/handler，这个handler的类型是不是裸指针类型并不重要。于是，为了在Rust代码中便于多线程访问，我们把rdma-core返回的裸指针类型都转换成<code>usize</code>类型，当需要调用rdma-core的接口函数时，再从usize转换成相应的裸指针类型。这么做听上去很hack，但背后的原因还是很显而易见的。进一步，对于在rdma-core中需要手动释放的资源，可以通过实现Rust的<code>Drop trait</code>，在<code>drop()</code>函数中调用rdma-core相应的接口实现资源自动释放。</p>
<p>其次，关于RDMA的内存安全问题，这部分工作尚未完成。目前RDMA的共享内存访问安全问题在学术界也是个热门研究课题，并没有完美的解决方案。本质上讲，RDMA的共享内存访问安全问题是由于为了实现高性能网络传输、绕过内核做内存共享带来的，内核在内存管理方面做了大量的工作，RDMA的数据传输绕过内核，因此RDMA无法利用内核的内存管理机制保证内存安全。如果要把内核在内存管理方面的工作都搬到用户态来实现RDMA共享内存访问安全，这么做的话一方面复杂度太高，另一方面也不一定有很好的性能。</p>
<p>在实际使用中，人们会对RDMA的使用方式进行规约，比如不允许远程节点写本地节点的共享内存，只允许远程节点读。但即便是只允许远程读取，也有可能有数据不一致的问题。比如远程节点读取了共享内存的前半段数据，本地节点开始更新共享内存。假定本地节点更新的数据很少而远程节点读取的数据很多，因此本地节点更新的速度比远程节点读取的速度快，导致有可能本地节点在远程节点读后半段数据前更新完毕，这样远程节点读取的是不一致的数据，前半段数据不包括更新数据但是后半段包括更新数据。远程节点读到的这个不一致的数据，既不是先前真实存在的某个版本的数据，也不是全新版本的数据，破坏了数据一致性的保证。</p>
<p>针对RDMA内存安全问题，一个常见的解决方案是采用无锁(Lock-free)数据结构。无锁数据结构本质上就是解决并发访问下保证内存安全问题，当多个线程并发修改时，无锁数据结构保证结果的一致性。针对上面提到的远程读、本地写的方式，可以采用<a href="https://en.wikipedia.org/wiki/Seqlock">Seqlock</a>来实现。即每块RDMA的共享内存空间关联一个序列号(sequence number)，本地节点每次修改共享内存前就把序列号加一，远程节点在读取开始和结束后检查序列号是否有变化，没有变化说明读取过程中共享内存没有被修改，序列号有变化说明读取过程中共享内存被修改，读到了有可能不一致的数据，则远程节点重新读取共享内存。</p>
<p>如果要放宽对RDMA的使用规约，即远程节点和本地节点都可以读写共享内存的场景，那么就需要采用更加复杂的算法或无锁数据结构，诸如<a href="https://en.wikipedia.org/wiki/Copy-on-write">Copy-on-Write</a>和<a href="https://en.wikipedia.org/wiki/Read-copy-update">Read-Copy-Update</a>等。内核中大量使用Copy-on-Write和Read-Copy-Update这两种技术来实现高效内存管理。这方面的工作有不少技术难度。</p>
<h2><a class="header" href="#后续工作" id="后续工作">后续工作</a></h2>
<p>下一步在完成对RDMA的safe封装之后，我们规划用Rust实现对RDMA接口函数的异步调用。因为RDMA都是IO操作，非常适合异步方式来实现。</p>
<p>对RDMA接口函数的异步处理，最主要的工作是关于RDMA的完成队列的消息处理。RDMA采用了多个工作队列，包括接收队列(RQ)，发送队列(SQ)以及完成队列(CQ)，这些队列一般是RDMA的硬件来实现。其中发送队列和接收队列的功能很好理解，如字面意思，分别是存放待发送和待接收的消息，消息是指向内存中的一块区域，在发送时该内存区域包含要发送的数据，在接收时该内存区域用于存放接收数据。在发送和接收完成后，RDMA会在完成队列里放入完成消息，用于指示相应的发送消息或接收消息是否成功。用户态RDMA程序可以定期不定期查询完成队列里的完成消息，也可以通过中断的方式在CPU收到中断后由内核通知应用程序处理。</p>
<p>异步IO本质上都是利用Linux的epoll机制，由内核来通知用户态程序某个IO已经就绪。对RDMA操作的异步处理，方法也一样。RDMA是通过创建设备文件来实现用户态RDMA程序跟内核里的RDMA模块交互。在安装RDMA设备和驱动后，RDMA会创建一个或多个字符设备文件，<code>/dev/infiniband/uverbsN</code>，N从0开始，有几个RDMA设备就有几个<code>uverbsN</code>设备文件。如果只有一个那就是<code>/dev/infiniband/uverbs0</code>。用户态RDMA程序要实现针对RDMA完成队列的异步消息处理，就是采用Linux提供的epoll机制，对RDMA的<code>uverbsN</code>设备文件进行异步查询，在完成队列有新消息时通知用户态RDMA程序来处理消息。</p>
<p>关于RDMA的封装，这块工作我们还没有完成，我们打算把RDMA的safe封装以及对RDMA的共享内存管理都实现，这样才能方便地使用Rust进行RDMA编程，同时我们欢迎有感兴趣的朋友一起参与。</p>
<h1><a class="header" href="#建立-async-rust-的共同愿景-1" id="建立-async-rust-的共同愿景-1">建立 Async Rust 的共同愿景</a></h1>
<p>译者：<a href="https://github.com/NiZerin">NiZerin</a></p>
<blockquote>
<p>原文链接：<a href="https://blog.rust-lang.org/2021/03/18/async-vision-doc.html">https://blog.rust-lang.org/2021/03/18/async-vision-doc.html</a></p>
</blockquote>
<hr />
<p>2021年3月18日·Niko Matsakis 代表 <a href="https://rust-lang.github.io/wg-async-foundations/">Async Foundations Working Group</a></p>
<p>在 <a href="https://rust-lang.github.io/wg-async-foundations/">异步基础工作组</a> 认为 Rust 能够成为最热门的选择之一为构建分布式系统，从嵌入式设备到基础云服务。无论他们将其用于什么，我们都希望所有开发人员都喜欢使用 Async Rust。为了实现这一点，我们需要将 Async Rust 移至目前的“MVP”状态之外，并使所有人都可以使用它。</p>
<p>我们正在开展合作，为 Async Rust 构建共享的 <a href="https://rust-lang.github.io/wg-async-foundations/vision.html#-the-vision">愿景文档</a> 。<code>我们的目标是让整个社区参与到集体的想象中</code>：我们如何才能使使用异步 I/O 的端到端体验不仅是一种务实的选择，而且是一种快乐的选择？</p>
<h3><a class="header" href="#愿景文件始于现状" id="愿景文件始于现状">愿景文件始于现状...</a></h3>
<p>“视觉文档”以一连串字符开头。每个角色都取决于由其背景决定的特定 Rust 值（例如，性能，生产率等）；这种背景也告诉了他们使用 Rust 时所带来的期望。</p>
<p>让我向您介绍一个角色，<a href="https://rust-lang.github.io/wg-async-foundations/vision/characters/grace.html">格蕾丝（Grace）</a> 。作为一名经验丰富的 C 开发人员，Grace 习惯了高性能和控制能力，但是她喜欢使用 Rust 获得内存安全性的想法。这是她的传记：</p>
<blockquote>
<p>Grace 从事 C 和 C++ 的编写已经有很多年了。她习惯于破解许多底层细节，以哄骗自己的代码获得最大的性能。她还经历了由于 C 中的内存错误而导致的史诗般的调试会话。她对 Rust 感兴趣：她喜欢这样的想法：获得与 C 相同的控制和性能，但又从内存安全性中获得了生产力上的好处。她目前正在尝试将 Rust 引入她正在使用的某些系统中，并且她还在考虑将 Rust 用于一些新项目。</p>
</blockquote>
<p>对于每个角色，我们都会编写一系列<a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo.html">“现状”故事</a> ，描述他们在尝试实现目标时面临的挑战（通常以戏剧性的方式失败！）。这些故事不是虚构的。它们是对使用 Async Rust 的人们的真实体验的综合，这是通过访谈，博客文章和推文向我们报告的。为了给您一个想法，我们目前有两个示例：一个示例，其中<a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/grace_deploys_her_service.html">Grace必须调试她编写的自定义未来</a> ，而另一个示例中，Alan（来自GC语言的程序员）<a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/alan_runs_into_stack_trouble.html">遇到堆栈溢出并必须调试原因</a> 。</p>
<p>编写“现状”故事有助于我们弥补<a href="https://en.wikipedia.org/wiki/Curse_of_knowledge">知识的诅咒</a> ：从事 Async Rust 工作的人们往往是 Async Rust 的专家。我们已经习惯了提高生产效率所需的<a href="https://github.com/rust-lang/async-book/tree/a927107bfe501a44dde1560a5942b1471c11c71d/src/07_workarounds">解决方法</a> ，并且我们知道一些小技巧可以帮助您摆脱困境。这些故事可帮助我们评估所有剪纸对仍在学习中的人所产生的累积影响。这为我们提供了我们需要确定优先级的数据。</p>
<h3><a class="header" href="#然后告诉我们我们将如何对其进行更改" id="然后告诉我们我们将如何对其进行更改">然后告诉我们我们将如何对其进行更改</a></h3>
<p>当然，愿景文档的最终目标不仅是告诉我们我们现在在哪里，而且还要告诉我们我们要去往何处以及如何到达那里。一旦我们在现状故事方面取得了良好进展，下一步将是开始集思广益地讨论<a href="https://rust-lang.github.io/wg-async-foundations/vision/shiny_future.html">“光明的未来”</a> 的故事。</p>
<p>闪亮的未来故事讲述了异步世界在未来2或3年后会是什么样。通常，他们将重播与“现状”故事相同的场景，但结局会更好。例如，也许格蕾丝（Grace）可以使用调试工具，该工具能够诊断卡住的任务并告诉她阻止任务的未来类型，因此她不必遍历日志。也许编译器可以警告Alan有关可能的堆栈溢出的信息，或者（更好的是）我们可以调整设计以select首先避免出现此问题。这个想法是雄心勃勃的，并且首先将重点放在我们要创建的用户体验上；我们将找出整个过程中的步骤（如果需要的话，还可以调整目标）。</p>
<h3><a class="header" href="#让整个社区参与" id="让整个社区参与">让整个社区参与</a></h3>
<p>异步愿景文档提供了一个论坛，在该论坛上，Async Rust 社区可以为 Async Rust 用户规划出色的整体体验。Async Rust 的设计初衷是不具有“一刀切”的思维方式，我们也不想改变这种状况。我们的目标是为端到端体验建立一个共同的愿景，同时保留我们已建立的松散耦合，面向探索的生态系统。</p>
<p>我们用于编写愿景文档的过程鼓励积极协作和“积极的总和”思考。它从集思广益期开始，在此期间，我们旨在收集尽可能多的“现状”和“光明的未来”故事。这个头脑风暴期持续了六个星期，直到四月底。在前两个星期（直到2021-04-02），我们仅收集“现状”故事。之后，我们将接受“现状”和“光明的未来”这两个故事，直到头脑风暴期结束为止。最后，帽从头脑风暴时期，我们将选择优胜者奖项，如“最幽默的故事”或“必须扶持贡献者”。</p>
<p>头脑风暴期结束后，工作组负责人将开始着手将各种故事和光明的未来汇编成一个连贯的草案。该草案将由社区和 Rust 团队进行审查，并根据反馈进行调整。</p>
<h3><a class="header" href="#想帮忙" id="想帮忙">想帮忙？</a></h3>
<p>如果您想帮助我们编写愿景文档，我们很乐意为您贡献自己的经验和愿景！目前，我们专注于创建现状故事。我们正在寻找人们撰写 PR 或谈论他们在问题或其他方面的经验。如果您想开始使用，请查看有关<a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/template.html">现状故事的模板</a> -它具有打开 PR 所需的所有信息。另外，您可以查看<a href="https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision.html">“如何实现愿景”</a> 页面，其中详细介绍了整个愿景文档过程。</p>
<h1><a class="header" href="#我们的-aws-rust-团队将如何为-rust-未来的成功做出贡献" id="我们的-aws-rust-团队将如何为-rust-未来的成功做出贡献">我们的 AWS Rust 团队将如何为 Rust 未来的成功做出贡献</a></h1>
<p>译者：<a href="https://github.com/NiZerin">NiZerin</a></p>
<blockquote>
<p>原文链接：<a href="https://aws.amazon.com/cn/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/">How our AWS Rust team will contribute to Rust’s future successes</a></p>
</blockquote>
<hr />
<p>自今年年初以来，AWS Rust 团队一直在起草我们的章程和宗旨。
章程和宗旨是 AWS 团队用来定义我们的范围和优先事项的框架。
章程告诉你的团队该做什么，宗旨告诉你的团队将如何做到这一点。
由于我们的团队宗旨一直是公开和透明运作的，我们想与您分享我们的章程和宗旨，我们希望您知道我们在做什么。</p>
<p>起草我们的章程很容易。
这只是一句话：AWS Rust 团队致力于让 Rust 为其所有用户提供高效、可靠的服务。
说得够多了！
然而，撰写这些宗旨需要更多的工作。</p>
<p>等等，AWS 有个 Rust 小组？</p>
<p>是的! 事实上，至少从 2017 年开始，AWS 就在多项服务中使用 Rust。
例如，用 Rust 编写的 Firecracker 于 2018 年推出，提供支持 AWS Lambda 和其他无服务器产品的开源虚拟化技术。
最近，AWS 发布了用 Rust 编写的基于 Linux 的容器操作系统 Bottlerocket ，Amazon Elastic Compute Cloud(Amazon EC2) 团队使用 Rust 作为新的 AWS Nitro 系统组件(包括 Nitro Enclaves 等敏感应用程序)的首选语言。
随着在 AWS 中采用 Rust 的增长，我们对 Rust 项目和社区的投资也在增加。
2019年，AWS 宣布赞助 Rust 项目。
2020年，AWS 开始打造 Rust 维护者和贡献者团队，2021年，AWS 联合其他 Rust 用户和 Rust 项目发起了 Rust 基金会。
AWS Rust 团队首先找出了如何最好地与 AWS 和更广泛的开源社区建立联系。
我们知道，我们希望在公开的环境下运作，并成为整个社会的一份子。
与此同时，我们知道我们想要充分利用在 AWS 工作的机会。
起草章程和宗旨是我们找到两者兼顾的方法和过程的一部分。</p>
<h3><a class="header" href="#我们的宗旨" id="我们的宗旨">我们的宗旨</a></h3>
<p>在 AWS，开发人员对每件事都起草宗旨。
它们是传达团队、项目或其他类型的一种有效方式。
作为 AWS 的新手，我们中的一位(Niko)刚刚开始学习 Rust，他真的很着迷。
你可能会开始看到它们出现在各式各样的地方。
下面的每个原则都包含了一个核心信念或原则，这些信念或原则将指导我们团队的决策。
它们特定于我们的团队，帮助我们专注于交付价值。
这些宗旨不是用来写了就忘的。
它们在日常运营中被积极的使用，帮助指导我们找出如何解决权衡问题的方法。</p>
<h4><a class="header" href="#宗旨0我们是一个-aws-团队" id="宗旨0我们是一个-aws-团队">宗旨0：我们是一个 AWS 团队。</a></h4>
<blockquote>
<p>我们是 AWS 团队。
我们主导了用于在云中构建运营服务的工具和开发机制。
我们利用我们与 AWS 服务的近在咫尺来收集帮助我们改进 Rust 的见解。</p>
</blockquote>
<p>Rust 一直受益于它是一种“实践者”的语言。
起初，Rust 使用 Servo 项目来指导它；浏览器有非常苛刻的性能要求，因此将语言推向了许多有趣的方向。
随着 Rust 采用率的增长，由此产生的反馈帮助将 Rust 扩展到越来越多的领域。
为此，我们希望该团队充分利用 AWS 提供的功能。
在 AWS，Rust 被用于提供各种服务，例如 Amazon Simple Storage Service(Amazon S3)、Amazon Elastic Compute Cloud(Amazon EC2)、Amazon CloudFront 等。
我们可以与这些团队密切合作，了解哪些工作做得很好，哪些需要改进，然后将这些经验带回 Rust。
我们还可以与正在部署 Rust 内置系统的 AWS 客户合作，了解他们的需求。
这个宗旨还有另一个关键点。
作为一个 AWS 团队，我们有一个重点。
我们将自己的角色--与 Rust 社区中的其他人一起--视为帮助改进 Rust for the Cloud。
这是我们最了解的。
我们也很高兴看到 Rust 在所有其他领域都在增长，但我们认为最好是其他人在这方面发挥带头作用，由我们的团队担任辅助角色。</p>
<h4><a class="header" href="#宗旨1我们是一个开放团队" id="宗旨1我们是一个开放团队">宗旨1：我们是一个开放团队。</a></h4>
<blockquote>
<p>我们是一个开放团队。
分享和协作我们的设计可以提高我们团队的质量和价值，包括 AWS。</p>
</blockquote>
<p>我们是 AWS 团队，但我们也是 Rust 的贡献者，这一宗旨意味着我们将本着开放和透明的精神运营。
例如，Niko 计划在想法完全成型之前继续在他的 BaySteps 博客上发布想法，他指望 Rust 社区继续在这些想法上探索。</p>
<h4><a class="header" href="#宗旨2我们帮助-rust-团队兑现承诺" id="宗旨2我们帮助-rust-团队兑现承诺">宗旨2：我们帮助 Rust 团队兑现承诺。</a></h4>
<blockquote>
<p>我们帮助 Rust 团队兑现承诺。
我们和 Rust 团队的使命一样，不仅要使系统编程高效、安全和多产，而且要让新的开发者能够轻易上手。</p>
</blockquote>
<p>我们热爱 Rust，因为它专注于使人们能够构建具有强大安全保证的高性能、并发系统。</p>
<ul>
<li>一种系统级语言</li>
<li>快速、并发、安全</li>
</ul>
<p>然而，除了它的技术属性之外，Rust 的另一个核心价值对我们来说非常重要：可访问性。
我们所说的可访问性，是指积极寻找进入壁垒，并拆除它们。
有时这些障碍是技术性的，而另一些时候，这些障碍是社会障碍。
无论哪种方式，我们都认同 Rust 的信念，即向更广泛的开发者开放系统编程。</p>
<h4><a class="header" href="#宗旨3我们支持我们所在的社区" id="宗旨3我们支持我们所在的社区">宗旨3：我们支持我们所在的社区。</a></h4>
<blockquote>
<p>我们支持我们所在的社区。
我们做自己份内的“必要的事情”，比如对问题进行分类，整理积压工作，指导其他贡献者并让他们参与进来，参与设计讨论，以及修复错误。</p>
</blockquote>
<p>开源需要的不仅仅是程序员。
有很多工作要做；这并不总是很有趣，但很重要。
这一宗旨与第一个宗旨(“我们是AWS团队”)相辅相成。
在讨论这一原则时，我们提到了我们在云方面拥有第一手专业知识，但我们还希望其他领域能够起到带头作用。
这一宗旨是说，我们将帮助支持领导这项工作的人们，无论是通过审查、指导，还是仅仅通过参与讨论和提出我们的两点意见。</p>
<h4><a class="header" href="#宗旨4我们帮助连接-aws-和-rust-生态系统" id="宗旨4我们帮助连接-aws-和-rust-生态系统">宗旨4：我们帮助连接 AWS 和 Rust 生态系统。</a></h4>
<blockquote>
<p>我们帮助连接 AWS 和 Rust 生态系统。
我们帮助 AWS 团队驾驭 All Things Rust，并促进他们积极参与他们所依赖的项目。</p>
</blockquote>
<p>我们的部分工作是将其他 AWS 团队与 Rust 生态系统和 Rust 项目联系起来。
我们希望所有使用 Rust 的 AWS 开发人员都能参与维护和改进我们使用的库或编译器本身。
这一努力将会带来大量的好处。
当然，这将有助于维持库，并将确定优化或其他改进的机会，从而使我们的 AWS 服务受益。
双赢。</p>
<h4><a class="header" href="#宗旨5我们专注于我们最了解的事情我们不会尝试做每件事" id="宗旨5我们专注于我们最了解的事情我们不会尝试做每件事">宗旨5：我们专注于我们最了解的事情；我们不会尝试做每件事。</a></h4>
<blockquote>
<p>我们专注于我们最了解的事情；我们不会尝试做每一件事。
我们的团队包括 Rust 编译器、语言设计和 Tokio 堆栈方面的领导者，这些都是我们能够产生最大影响的领域。</p>
</blockquote>
<p>这篇关于比较优势的文章有一个主题--我们的团队将专注于我们最擅长的事情，并支持其他人做同样的事情。
不过，这一原则的要点是强调句子中的“焦点”一词。
我们很容易把自己分散得太细，无法提供高价值，我们真的希望我们的团队避免这种情况。</p>
<h4><a class="header" href="#除非你知道更好的" id="除非你知道更好的">除非你知道更好的…</a></h4>
<p>传统上，每条宗旨都以“除非你知道更好的信条”开头。
这个想法是，宗旨总是随着环境的变化而变化。
这些是我们目前的宗旨，我们希望随着我们更多地了解 AWS 和 Rust 社区合作的最佳方式，它们会不断发展。</p>
<h1><a class="header" href="#no_std-环境下的可执行文件" id="no_std-环境下的可执行文件"><code>no_std</code> 环境下的可执行文件</a></h1>
<p>作者: 吴翱翔@pymongo / 后期编辑： 张汉东</p>
<blockquote>
<p>原文: <a href="https://pymongo.github.io/#/2021/03/statically_linked_executable.md">no_std binary(static link)</a></p>
</blockquote>
<p>由于作者身边只有 linux 操作系统的设备，所以本文内容仅探讨 Rust/C/C++ 在 linux 操作系统下 no_std 的可执行文件</p>
<p>本文更多探讨的是编译生成纯静态链接没有动态链接的 no_std 可执行文件，不仅连 Rust 的标准库也不用，连操作系统自带的 C 标准库也不用的环境</p>
<p>推荐这个 <a href="https://fasterthanli.me/series/making-our-own-executable-packer">Making our own executable packer</a>(linux) 系列文章: </p>
<p>在介绍Rust如何编译运行 no_std 的可执行文件之前，先看看汇编和 C/C++ 是如何编译 no_std 的可执行文件</p>
<h2><a class="header" href="#汇编语言编译可执行文件" id="汇编语言编译可执行文件">汇编语言编译可执行文件</a></h2>
<p>x86 汇编主要有两种语法，一是 Unix 的 AT&amp;T syntax，另一个则是 windows 的 Intel syntax</p>
<p>由于 AT&amp;T 有贝尔实验室，而 Unix 操作系统和 C 语言都是贝尔实验室发明的，所以 linux 的 gcc 和 as 都用 AT&amp;T 汇编语法</p>
<p>如果想用 Intel 汇编语法可以用 llvm 或 nasm 工具</p>
<p>rustc 生成的汇编默认是 Intel 语法，可以传入 llvm 参数让 rustc 生成 AT&amp;T 语法的汇编代码</p>
<blockquote>
<p>rustc --emit asm -C llvm-args=-x86-asm-syntax=att main.rs</p>
</blockquote>
<p>以这个网站<a href="https://cs.lmu.edu/%7Eray/notes/gasexamples/">GNU Assembler Examples</a>
介绍的第一段汇编代码为准</p>
<p>编译运行这段代码有两个方法:</p>
<blockquote>
<p>gcc -c s.s &amp;&amp; ld s.o &amp;&amp; ./a.out</p>
</blockquote>
<p>或者用as工具(GNU assembler (GNU Binutils))</p>
<blockquote>
<p>as s.s &amp;&amp; ld s.o &amp;&amp; ./a.out</p>
</blockquote>
<p>可以用 ldd 工具校验编译生成的可执行文件是不是 statically linked (没有引入任何动态链接库)</p>
<p>汇编的劣势在于代码跟硬件架构绑定，gcc 编译这段汇编代码时加上<code>-m32</code>参数指定生成32位的可执行文件时就会报错</p>
<h2><a class="header" href="#c-编译-no_std-可执行文件" id="c-编译-no_std-可执行文件">C 编译 no_std 可执行文件</a></h2>
<p>用 gcc 或 clang 的 <code>-nostdlib</code>参数很容易生成无动态链接库的可执行文件</p>
<pre><code>[w@w-manjaro temp]$ echo &quot;int main(){return 0;}&quot; &gt; main.c &amp;&amp; gcc -nostdlib main.c &amp;&amp; ldd ./a.out
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000001000
        statically linked
</code></pre>
<p>C 在 no_std 的环境下程序的入口函数名字不能是 main,要改成 _start</p>
<pre><code>[w@w-manjaro temp]$ echo &quot;int _start(){return 0;}&quot; &gt; main.c &amp;&amp; gcc -nostdlib main.c &amp;&amp; ldd ./a.out
        statically linked
</code></pre>
<p>当然也可以让 gcc 加上<code>-m32</code>参数生成32位的可执行文件</p>
<p>注意在 mac 或 windows 上用gcc 或 clang 的 <code>-nostdlib</code>参数可能会报错</p>
<pre><code>$ clang -nostdlib c.c
ld: dynamic main executables must link with libSystem.dylib for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<p>根据苹果开发者文档，<a href="https://developer.apple.com/library/archive/qa/qa1118/_index.html">Apple does not support statically linked binaries on Mac OS X</a></p>
<p>可能 macOS 要用特殊的 ld 工具或稍微复杂点的方法才能编译纯静态链接的可执行文件，不过这不在本文的探讨范围内了</p>
<h2><a class="header" href="#rust-编译-no_std-可执行文件" id="rust-编译-no_std-可执行文件">Rust 编译 no_std 可执行文件</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]
#![feature(lang_items,asm)]

<span class="boring">fn main() {
</span>/// entry_point/start_address of process, since the linker looks for a function named `_start` by default
#[no_mangle]
extern &quot;C&quot; fn _start() -&gt; ! {
    exit(0); // macOS: illegal hardware instruction
}

fn exit(code: isize) -&gt; ! {
    unsafe {
        asm!(
            &quot;syscall&quot;,
            in(&quot;rax&quot;) 60, // exit
            in(&quot;rdi&quot;) code,
            options(noreturn)
        );
    }
}

#[lang = &quot;eh_personality&quot;]
extern &quot;C&quot; fn eh_personality() {}

#[panic_handler]
fn my_panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}
<span class="boring">}
</span></code></pre></pre>
<p>源码在我<a href="https://github.com/pymongo/no_std_binary/blob/main/main.rs">这个仓库</a>，linux 下的编译方法:</p>
<blockquote>
<p>rustc -C link-arg=-nostartfiles main.rs</p>
</blockquote>
<p>或者将以下两行写到<code>.cargo/config.toml</code>中</p>
<pre><code>[target.'cfg(target_os = &quot;linux&quot;)']
rustflags = [&quot;-C&quot;, &quot;link-arg=-nostartfiles&quot;]
</code></pre>
<p>如果只是编译 no_std 环境下的 动态链接库(cdylib)，则不需要加上述 rustc 参数</p>
<h1><a class="header" href="#用-rust-写智能合约--hello-ink" id="用-rust-写智能合约--hello-ink">用 Rust 写智能合约 | Hello, Ink!</a></h1>
<p>作者：李大狗（李骜华）/ 后期编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#什么是-wasm-智能合约" id="什么是-wasm-智能合约">什么是 WASM 智能合约？</a></h2>
<p>以往，我们谈到智能合约，都是基于 EVM 的 Solidity 智能合约。</p>
<p>目前，随着智能合约技术的发展，出现了一种新的可能性：WASM 智能合约，</p>
<p>WASM 并非一门新的编程语言，而是一种全新的底层二进制语法。</p>
<blockquote>
<p>WASM（WebAssembly）是一种新的字节码格式，是一种全新的底层二进制语法，它所编译的代码指令体积小，可移植，加载快并兼容WEB的全新格式。WASM可以支持C/C++/RUST/GO等多种语言编写合约后编译出节码，且不同语言有附带丰富的底层标准库可供调用。</p>
<p>WASM 的优势：</p>
<p>作为一种全新的字节码格式，WASM通过自身的创新和优化，使得在使用其对所支持的语言进行编写后的代码指令具有体积小，可以在运存，硬盘存储，带宽占有上得到更多的优化，在节省了区块链网络资源，也明显的提升了网络传输效率。</p>
<p>在智能合约上使用WASM，也将拥有以上特点，最明显的方面就是占用资源更少，运行合约更快速和稳定，并且网络传输信息更加高效。这可以使得区块链网络上部署更多的智能合约，也可以使得用户在使用智能合约时能获得更好的体验感。</p>
<p>——WASM智能合约优势分析：https://zhuanlan.zhihu.com/p/344347968</p>
</blockquote>
<p>从目前的趋势上来看，Substrate、ETH 2.0等公链与多家联盟链，均表示将支持 WASM 智能合约。</p>
<h2><a class="header" href="#可以用什么语言编写-wasm-智能合约" id="可以用什么语言编写-wasm-智能合约">可以用什么语言编写 WASM 智能合约？</a></h2>
<p>Wasm 扩展了智能合同开发者可用的语言系列，包括 Rust、C/C++、C#、Typescript、Haxe 和 Kotlin。这意味着你可以用你熟悉的任何语言编写智能合约。</p>
<p>从适配性上来说，Rust 语言目前与 WASM 智能合约的适配性更好，工具链更全，而且写出来的智能合约更加安全。</p>
<p>所以，本系列将以 Subtrate 上的 Ink! 智能合约为例，开始 WASM 智能合约的 101 课程。</p>
<p>本文对 Ink! 官方教程有所参考：</p>
<blockquote>
<p>https://substrate.dev/substrate-contracts-workshop</p>
</blockquote>
<h2><a class="header" href="#rust-环境配置" id="rust-环境配置">Rust 环境配置</a></h2>
<h3><a class="header" href="#1--rust-环境配置" id="1--rust-环境配置">1.  Rust 环境配置</a></h3>
<p>在 MacOS 或者 Ubuntu 等 Linux 操作系统上，我们可以通过一行命令很容易的安装 Rust：</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>除此之外还要安装<code>nightly</code>版本：</p>
<pre><code>rustup install nightly
</code></pre>
<p>Windows 下的安装，请参考：</p>
<pre><code>https://forge.rust-lang.org/infra/other-installation-methods.html
</code></pre>
<h3><a class="header" href="#2-将-rust-添加到环境中" id="2-将-rust-添加到环境中">2. 将 Rust 添加到环境中</a></h3>
<p>将如下语句添加到<code>~/.bashrc</code>或<code>~/.zshrc</code>中：</p>
<pre><code>export PATH=~/.cargo/bin:$PATH
</code></pre>
<p>然后：</p>
<pre><code>source ~/.bashrc # source ~/.zshrc
</code></pre>
<h3><a class="header" href="#3-换源" id="3-换源">3. 换源</a></h3>
<p>通过设置如下环境变量，我们把 Rust 源切换到国内：</p>
<pre><code class="language-bash">export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup
</code></pre>
<p>在<code>~/.cargo/config</code>文件中写入如下内容：</p>
<pre><code>[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
replace-with = 'ustc'
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;
</code></pre>
<h2><a class="header" href="#ink-环境配置" id="ink-环境配置">Ink! 环境配置</a></h2>
<p>在配置了基本的 Rust 环境后，我们可以配置 Ink! 所需的开发环境了。</p>
<pre><code class="language-bash"># for substrate
rustup component add rust-src --toolchain nightly
rustup target add wasm32-unknown-unknown --toolchain stable
# for canvas node 
cargo install canvas-node --git https://github.com/paritytech/canvas-node.git --tag v0.1.4 --force --locked
# for ink!CLI
cargo install cargo-contract --vers 0.10.0 --force --locked
</code></pre>
<p>我们还要安装/升级<code>binaryen</code>，Binaryen 是 WebAssembly 的编译器。</p>
<p>Mac 上安装：</p>
<pre><code class="language-bash"># for mac
brew upgrade binaryen # 如果没安装用 brew install
</code></pre>
<p>Linux 上安装：</p>
<h2><a class="header" href="#创建一个-ink-项目" id="创建一个-ink-项目">创建一个 ink! 项目</a></h2>
<p>执行如下命令：</p>
<pre><code>cargo contract new flipper
</code></pre>
<p>创建完成后进入文件夹：</p>
<pre><code>cd flipper/
</code></pre>
<p>合约项目目录结构：</p>
<pre><code>flipper
|
+-- lib.rs                &lt;-- Contract Source Code
|
+-- Cargo.toml            &lt;-- Rust Dependencies and ink! Configuration
|
+-- .gitignore
</code></pre>
<h2><a class="header" href="#合约测试" id="合约测试">合约测试</a></h2>
<pre><code>cargo +nightly test
</code></pre>
<p>一切顺利的话会输出如下结果：</p>
<pre><code>$ cargo +nightly test
    running 2 tests
    test flipper::tests::it_works ... ok
    test flipper::tests::default_works ... ok

    test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#合约编译" id="合约编译">合约编译</a></h2>
<pre><code>cargo +nightly contract build
</code></pre>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq16ioatj30mu0n6wj1.jpg" alt="image-20210323213148674" /></p>
<p>如果顺利的话，目录下会生成<code>target/ink</code>文件夹，里面包含如下文件：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq12tx3jj30si04caan.jpg" alt="image-20210323205600627" /></p>
<p>其中，<code>flipper.contract</code> 是部署时要用的合约文件，可以视为<code>solidity</code>合约中的<code>bin</code>文件。</p>
<p><code>metadata.json</code>是元数据，可以视为<code>solidity</code>合约中的<code>abi</code>文件。</p>
<h2><a class="header" href="#合约部署" id="合约部署">合约部署</a></h2>
<p>通过<code>canvas</code>启动一个本地运行的开发节点！</p>
<pre><code>canvas --dev --tmp
</code></pre>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq15c98vj30si04caan.jpg" alt="An image of the terminal starting a Substrate node" /></p>
<p>打开如下网址，会这个页面会自动连接本地启动的开发节点：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq17aigpj30wq0ln7cz.jpg" alt="image-20210323210306845" /></p>
<p>上传<code>flipper.contract</code>这个文件：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq19w3y0j30z80iqq48.jpg" alt="Contracts code page for deploying Flipper" /></p>
<p>一路点击进行部署：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq1avddtj31c10u0q6a.jpg" alt="image-20210323210730452" /></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq17hukij31200qmacj.jpg" alt="image-20210323210747989" /></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq18snwhj30u00xb40w.jpg" alt="image-20210323210811846" /></p>
<h2><a class="header" href="#合约调用" id="合约调用">合约调用</a></h2>
<p>点击<code>Execute</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq1bnzbuj30xw0i6jss.jpg" alt="image-20210323210928445" /></p>
<p>选择<code>get():bool</code>函数，点击「调用」：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq18ec75j31ck0u0q6r.jpg" alt="image-20210323211004303" /></p>
<p>返回调用结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxq1929ldj30wg0codgq.jpg" alt="image-20210323211027286" /></p>
<h2><a class="header" href="#flipper-源码解读" id="flipper-源码解读">Flipper 源码解读</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2018-2020 Parity Technologies (UK) Ltd.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

use ink_lang as ink;

#[ink::contract]
pub mod flipper {
    #[ink(storage)]
    pub struct Flipper {
        value: bool,
    }

    impl Flipper {
        /// Creates a new flipper smart contract initialized with the given value.
        #[ink(constructor)]
        pub fn new(init_value: bool) -&gt; Self {
            Self { value: init_value }
        }

        /// Creates a new flipper smart contract initialized to `false`.
        #[ink(constructor)]
        pub fn default() -&gt; Self {
            Self::new(Default::default())
        }

        /// Flips the current value of the Flipper's bool.
        #[ink(message)]
        pub fn flip(&amp;mut self) {
            self.value = !self.value;
        }

        /// Returns the current value of the Flipper's bool.
        #[ink(message)]
        pub fn get(&amp;self) -&gt; bool {
            self.value
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn default_works() {
            let flipper = Flipper::default();
            assert_eq!(flipper.get(), false);
        }

        #[test]
        fn it_works() {
            let mut flipper = Flipper::new(false);
            assert_eq!(flipper.get(), false);
            flipper.flip();
            assert_eq!(flipper.get(), true);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#1--cfg和cfg_attr的使用" id="1--cfg和cfg_attr的使用">1.  <code>cfg</code>和<code>cfg_attr</code>的使用</a></h3>
<p><code>cfg</code>是 Rust 中的特殊属性， 它允许我们编译基于标志的代码并传递给编译器。</p>
<p>在本合约中，我们可以看到：</p>
<pre><code>#[cfg(test)]
</code></pre>
<p>这个标识意味着下面的代码是单元测试。</p>
<h3><a class="header" href="#2-impl-关键字" id="2-impl-关键字">2. impl 关键字</a></h3>
<blockquote>
<p>Implement some functionality for a type.</p>
<p>为一种类型做函数实现。</p>
</blockquote>
<p>标准的模板是：</p>
<pre><code>struct Example {
    number: i32,
    # 许多变量……
}

impl Example {
    fn boo() {
        println!(&quot;boo! Example::boo() was called!&quot;);
    }

    fn answer(&amp;mut self) {
        self.number += 42;
    }
		# 许多函数……
}

</code></pre>
<p>套用到本合约中，首先我们定义本合约的<code>struct</code>：</p>
<pre><code>pub struct Flipper {
	value: bool, # 其中包含一个变量 value
}
</code></pre>
<p>然后对<code>struct</code>进行补充实现：</p>
<pre><code>impl Flipper {
	……
}
</code></pre>
<h3><a class="header" href="#3---inkconstructor与inkmessage" id="3---inkconstructor与inkmessage">3.  <code> #[ink(constructor)]</code>与<code>#[ink(message)]</code></a></h3>
<p><code> #[ink(constructor)]</code>表示这行语句函数是合约的构造函数，相当于<code>solidity</code>合约中的<code>constructor</code>。</p>
<blockquote>
<p>https://docs.soliditylang.org/en/v0.7.2/contracts.html#constructor</p>
</blockquote>
<p><code>#[ink(message)]</code>表示这行语句下面的函数是合约的普通函数，如例子中的<code>get</code>函数：</p>
<pre><code>/// Returns the current value of the Flipper's bool.
#[ink(message)]
pub fn get(&amp;self) -&gt; bool {
	self.value
}
</code></pre>
<hr />
<p>作者简介：</p>
<p>李大狗（李骜华），上海对外经贸大学区块链技术与应用研究中心副主任、柏链教育 CTO、FISCO BCOS（微众银行区块链框架）区块链认证讲师、5 年区块链工程师、北京大学硕士。
研究领域包括：区块链系统、共识机制、智能合约、区块链应用、数字身份等。</p>
<h1><a class="header" href="#蓄水池算法改进---面向抽奖场景保证等概率性" id="蓄水池算法改进---面向抽奖场景保证等概率性">蓄水池算法改进 - 面向抽奖场景保证等概率性</a></h1>
<p>作者：huangjj / 后期编辑：张汉东</p>
<blockquote>
<p>免责声明：禁止任何个人或团体使用本文研究成果用于实施任何违反中华人民共和国法律法规的活动
如有违反，均与本文作者无关</p>
</blockquote>
<hr />
<h2><a class="header" href="#正文" id="正文">正文</a></h2>
<p>在我们通常遇到的抽奖场景，于年会时将所有人的编号都放到箱子里面抽奖，然后每次抽出中奖者
决定奖项。而在这过程中，因为先抽中者已经确定了奖项，然后不能够参与后续的奖项的抽奖；而后
续参与抽奖的人员则其实会以越来越低的概率参与抽奖:</p>
<blockquote>
<p>例：在上述场景中共有 \( n \) 人参与抽取 \( m ( \lt n) \) 个奖项，</p>
<p>抽取第一个奖项概率为： \( { m \over n } \)</p>
<p>那么因为抽了第一个奖项，剩下 \( n - 1 \) 人参与 \( m - 1 \) 个奖项，被抽中的概率
为 \( m - 1 \over n - 1 \)。
那么 \( m \lt n \Rightarrow -m \gt -n \Rightarrow mn - m \gt nm - n \Rightarrow m(n-1) \gt n(m - 1) \Rightarrow { m \over n } \gt { m - 1 \over n - 1 }\)，
即如果前面的奖项没有抽到，后面抽到奖项的概率会更低。</p>
</blockquote>
<p>因此，在人数 \( n \) 大于奖项数 \( m \) 的时候，我们通过以越来越低的概率干涉前面
已经取得取得奖项的结果，来保证先参与抽奖的人中奖的概率随着人数的增多中奖的概率也变低，
最后中奖的概率为 \( m \over n \)。但是在实际场景中，\( m \) 个奖项可能不仅相同
（如划分了一二三等奖），因此对于蓄水池算法的改进提出了新的要求：</p>
<ul>
<li>不论人数多少（当还是要保证有人来参与抽奖 \( n \gt 1\) )所有人获得特定奖项的概率相同</li>
<li>每当新来一人参与抽奖时，如果他没有中奖，可以即场告知未中</li>
</ul>
<h2><a class="header" href="#算法描述与等概率性证明" id="算法描述与等概率性证明">算法描述与等概率性证明</a></h2>
<p>我们分两种情况讨论：</p>
<ul>
<li>一种是当人数不足以覆盖所有的奖项的场景（ \(n \lt m \) )，</li>
<li>另外一种是当抽奖人数远大于所有奖项加起来的数目。（ \( n \gt m \)）。</li>
</ul>
<p>然后我们再回来看看能不能找到一种很方便的方法桥接两种情况。</p>
<p>同时，我们假设 \( m \) 个奖项两两互不相同。</p>
<h3><a class="header" href="#抽奖人数不足时-n-lt-m--" id="抽奖人数不足时-n-lt-m--">抽奖人数不足时（ \(n \lt m \) )</a></h3>
<p>因为当人数不足时，所有参与者都能抽奖，因此我们要保证每个人获得特定奖项的概率为 \( 1 \over m \)。
算法描述：</p>
<blockquote>
<p>记 \( Choosen \) 为容量为 \( m \) 的数组，
\( Choosen[k] (1 \le k \le m) \) 表示第 k 个奖项的当前占有情况，
初始值为 \( None \),</p>
<p>\( Players \) 为参与参与抽奖的人的序列</p>
<ol>
<li>令 \( i := 1 \)，当 \( i \le n \) 时，做如下操作：
<ul>
<li>产生随机数 \( r_1 (1 \le r_1 \le i) \)</li>
<li>如果 \( r_1 \lt i \)，\( Choosen[i] := Choosen[r_1] \)</li>
<li>\( Choosen[r_1] := Players[i] \)</li>
<li>\( i := i + 1 \)</li>
</ul>
</li>
<li>当 \( i \le m \) 时，做如下操作：
<ul>
<li>产生随机数 \( r_2 (1 \le r_2 \le i) \)</li>
<li>如果 \( r_2 \lt i \):
<ul>
<li>\( Choosen[i] := Choosen[r_2] \)</li>
<li>\( Choosen[r_2] := None \)</li>
</ul>
</li>
<li>\( i := i + 1 \)</li>
</ul>
</li>
</ol>
</blockquote>
<h4><a class="header" href="#等概率性证明" id="等概率性证明">等概率性证明</a></h4>
<p>我们先证明，在填入中奖者的第 \( k (1 \le k \le m) \) 轮过程中，能够保证对于前 \( k \)
个奖项中的每一个奖项，每一位中奖者抽中其中第 \( i (1 \le i \le k) \) 个奖项的概率为
\(1 \over k \)，证明如下：</p>
<p>我们采用数学归纳法来证明：</p>
<ol>
<li><strong>奠基</strong>：当 \( k = 1 \) 时，易知该中奖者一定会抽中第一个奖项，前一个奖项中只有第一个
选项，所以此时每一位中奖者抽中第 \( k = 1 \) 的概率为 \( 1 = { 1 \over 1 } = { 1 \over k } \);</li>
<li><strong>归纳</strong>:
<ul>
<li>假设当 \(k = j (1 \le j \lt m) \)时，每一位抽奖者抽中第 \( i (1 \le i \le j) \)的概率为
\( 1 \over j \)</li>
<li>当 \( k = j + 1 \), 有：
<ul>
<li>第 \( j + 1 \) 位抽奖着抽中任意第 \( i' (1 \le i' \le j + 1) \) 个奖项的概率为 \( 1 \over { j + 1 } \)
（假设产生的随机数 \( r_1、r_2 \) 足够的均匀）;</li>
<li>对于前 \( j \) 位抽奖者，每一位都有 \( 1 \over { j + 1 } \)，的概率将自己的奖项更换位第 \( j + 1 \)个奖项；</li>
<li>对于前 \( j \) 位抽奖者，每一位依然占有原有第 \( i' \) 个奖项的概率为：</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>\[ \begin{equation}
\begin{aligned}
P\{前 j 位抽奖者 j + 1 轮中仍然持有 i' \} &amp; = P\{前 j 位抽奖者j轮已经持有 i' \} \cdot P\{第 j + 1 位抽奖者没有抽中 i' \} \\
&amp; = P\{前 j 位抽奖者j轮已经持有 i' \} \cdot (1 - P\{第 j + 1 位抽奖者抽中 i' \}) \\
&amp; = \frac{1}{j} \cdot (1 - \frac{1}{j+1}) \\
&amp; = \frac{1}{j} \cdot \frac{j}{j+1} \\
&amp; = \frac{1}{j + 1} \\
&amp; = \frac{1}{k} \\
\end{aligned}
\label{1.1} \tag{1.1}
\end{equation}
\]</p>
<p>由上，可知每一轮迭代之后，前 \( k \) 个奖项对于已经参与的 \( k \)中奖者来说抽中的概率均等，为 \( 1 \over k \)，
故到了第 \( n \) 轮操作后，我们可以通过不断填充 \( None \)值来稀释概率，最后达到 \( 1 \over m \) 的等概率性。</p>
<p>特殊地，当 \( n == m \) 时，每个抽奖者抽到特定奖项的概率也为 \(1 \over n \)。</p>
<h3><a class="header" href="#抽奖人数足够多时-n-gt-m--" id="抽奖人数足够多时-n-gt-m--">抽奖人数足够多时（ \(n \gt m \) )</a></h3>
<p>类似地，当 \(n \gt m \)时，对于每一个抽奖序号 \( k \gt m \) 的抽奖者，我们生成随机数 \( r_3(1 \le r_3 \le n) \)，并且在
\( r_3 \le m \) 的时候，替换对应原本占有奖项的抽奖者；可以证明在这种情况下，能保证每个人抽到特定奖项的概率为 \(1 \over n \)<sup class="footnote-reference"><a href="#1">1</a></sup>。</p>
<h3><a class="header" href="#整合后的算法" id="整合后的算法">整合后的算法</a></h3>
<blockquote>
<p>记 \( Choosen \) 为容量为 \( m \) 的数组，
\( Choosen[k] (1 \le k \le m) \) 表示第 \( k \) 个奖项的当前占有情况，
初始值为 \( None \),</p>
<p>\( replaced \) 为原本已经中奖，但是被人替换的抽奖者</p>
<p>\( Players \) 为参与参与抽奖的人的序列，每次只能获取一个 \( player \)</p>
<p>记 \( n := 0 \)为当前参与抽奖的人数</p>
<ol>
<li>在抽奖结束前，每次遇到一个新的 \( player \) 执行以下操作：
<ul>
<li>\( placed := None \)</li>
<li>\( n := n + 1 \)</li>
<li>产生随机数 \( r (1 \le r \le n) \)</li>
<li>如果 \( r \le m \)：
<ul>
<li>\( replaced := Choosen[r] \)</li>
<li>\( Choosen[r] := player \)</li>
</ul>
</li>
<li>如果 \( r \lt n \) 并且 \( n \le m \)：
<ul>
<li>\( Choosen[n] := replaced \)</li>
</ul>
</li>
</ul>
</li>
<li>在抽奖结束时，如果 \( n \lt m \), 执行以下操作：
<ul>
<li>\( i := n \)</li>
<li>当 \( i \lt m \)时，重复执行以下操作：
<ul>
<li>\( i := i + 1 \)</li>
<li>产生随机数 \( r_2 (1 \le r_2 \le i) \)</li>
<li>如果 \( r_2 \lt i \):
<ul>
<li>\( Choosen[i] := Choosen[r_2] \)</li>
<li>\( Choosen[r_2] := None \)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<h2><a class="header" href="#程序实现" id="程序实现">程序实现</a></h2>
<h3><a class="header" href="#rust" id="rust">Rust</a></h3>
<p>作者偏好 <a href="https://kaisery.gitbooks.io/trpl-zh-cn/">Rust 编程语言</a>，故使用 Rust 实现。</p>
<h4><a class="header" href="#特质trait" id="特质trait">特质（trait）</a></h4>
<p>Rust 中的<a href="https://kaisery.gitbooks.io/trpl-zh-cn/ch10-02-traits.html">特质（trait）</a>
是其用于复用行为抽象的特性，尽管比起 Java 或 C# 的接口 （Interface）更加强大，但在此文中，
熟悉 Java/C# 的读者把特质视作接口就可以了。</p>
<h3><a class="header" href="#建模与实现" id="建模与实现">建模与实现</a></h3>
<p>如下所示：</p>
<pre><code class="language-rs">extern crate rand;
use rand::random;
use rand::seq::SliceRandom;
use rand::thread_rng;

trait ReservoirSampler {
    // 每种抽样器只会在一种总体中抽样，而总体中所有个体都属于相同类型
    type Item;

    // 流式采样器无法知道总体数据有多少个样本，因此只逐个处理，并返回是否将样本纳入
    // 样本池的结果，以及可能被替换出来的样本
    fn sample(&amp;mut self, it: Self::Item) -&gt; (bool, Option&lt;Self::Item&gt;);

    // 任意时候应当知道当前蓄水池的状态
    fn samples(&amp;self) -&gt; &amp;[Option&lt;Self::Item&gt;];
}

struct Lottery&lt;P&gt; {
    // 记录当前参与的总人数
    total: usize,

    // 奖品的名称与人数
    prices: Vec&lt;Price&gt;,

    // 当前的幸运儿
    lucky: Vec&lt;Option&lt;P&gt;&gt;,
}

#[derive(Clone, Debug)]
struct Price {
    name: String,
    cap: usize,
}

impl&lt;P&gt; ReservoirSampler for Lottery&lt;P&gt; {
    type Item = P;

    fn sample(&amp;mut self, it: Self::Item) -&gt; (bool, Option&lt;Self::Item&gt;) {
        let lucky_cap = self.lucky.capacity();

        self.total += 1;

        // 概率渐小的随机替换
        let r = random::&lt;usize&gt;() % self.total + 1;
        let mut replaced = None;
        if r &lt;= lucky_cap {
            replaced = self.lucky[r - 1].take();
            self.lucky[r - 1] = Some(it);
        }

        if self.total &lt;= lucky_cap &amp;&amp; r &lt; self.total {
            self.lucky[self.total - 1] = replaced.take();
        }

        (r &lt;= lucky_cap, replaced)
    }

    fn samples(&amp;self) -&gt; &amp;[Option&lt;Self::Item&gt;] {
        &amp;self.lucky[..]
    }
}

impl&lt;P: Debug&gt; Lottery&lt;P&gt; {
    fn release(self) -&gt; Result&lt;Vec&lt;(String, Vec&lt;P&gt;)&gt;, &amp;'static str&gt; {
        let lucky_cap = self.lucky.capacity();

        if self.lucky.len() == 0 {
            return Err(&quot;No one attended to the lottery!&quot;);
        }

        let mut final_lucky = self.lucky.into_iter().collect::&lt;Vec&lt;Option&lt;P&gt;&gt;&gt;();
        let mut i = self.total;
        while i &lt; lucky_cap {
            i += 1;

            // 概率渐小的随机替换
            let r = random::&lt;usize&gt;() % i + 1;
            if r &lt;= lucky_cap {
                final_lucky[i - 1] = final_lucky[r - 1].take();
            }
        }
        println!(&quot;{:?}&quot;, final_lucky);

        let mut result = Vec::with_capacity(self.prices.len());
        let mut counted = 0;
        for p in self.prices {
            let mut luck = Vec::with_capacity(p.cap);

            for i in 0 .. p.cap {
                if let Some(it) = final_lucky[counted + i].take() {
                    luck.push(it);
                }
            }

            result.push((p.name, luck));
            counted += p.cap;
        }

        Ok(result)
    }
}

// 构建者模式（Builder Pattern），将所有可能的初始化行为提取到单独的构建者结构中，以保证初始化
// 后的对象(Target)的数据可靠性。此处用以保证所有奖品都确定后才能开始抽奖
struct LotteryBuilder {
    prices: Vec&lt;Price&gt;,
}

impl LotteryBuilder {
    fn new() -&gt; Self {
        LotteryBuilder {
            prices: Vec::new(),
        }
    }

    fn add_price(&amp;mut self, name: &amp;str, cap: usize) -&gt; &amp;mut Self {
        self.prices.push(Price { name: name.into(), cap });
        self
    }

    fn build&lt;P: Clone&gt;(&amp;self) -&gt; Lottery&lt;P&gt; {
        let lucky_cap = self.prices.iter()
            .map(|p| p.cap)
            .sum::&lt;usize&gt;();

        Lottery {
            total: 0,
            prices: self.prices.clone(),
            lucky: std::vec::from_elem(Option::&lt;P&gt;::None, lucky_cap),
        }
    }
}

fn main() {
    let v = vec![8, 1, 1, 9, 2];
    let mut lottery = LotteryBuilder::new()
        .add_price(&quot;一等奖&quot;, 1)
        .add_price(&quot;二等奖&quot;, 1)
        .add_price(&quot;三等奖&quot;, 5)
        .build::&lt;usize&gt;();


    for it in v {
        lottery.sample(it);
        println!(&quot;{:?}&quot;, lottery.samples());
    }

    println!(&quot;{:?}&quot;, lottery.release().unwrap());
}
</code></pre>
<h2><a class="header" href="#优点-2" id="优点-2">优点</a></h2>
<ul>
<li>流式处理，可以适应任意规模的参与人群</li>
<li>在保证每一位抽奖者都有相同的概率获得特定奖项的同时，还能保证每一个抽奖者的获得的奖项均不相同</li>
</ul>
<h2><a class="header" href="#缺点-2" id="缺点-2">缺点</a></h2>
<ul>
<li>所有参与抽奖的人都必须<strong>依次</strong>经过服务器处理，因为需要获知准确的总人数来保证等概率性。
一个改进的方法是，在人数足够多的时候，将总人数用总人数的特定数量级替代（给后续参加者的
一点点小福利——但是因为总人数足够多，所以总体中奖概率还是很低），在客户端完成中奖的选定</li>
<li><strong>等概率性完全依赖随机数 <code>r</code> 生成</strong>。 因为奖品初始化时不需要考虑打乱顺序，因此如果在
随机这一步被技术破解，使得抽奖者可以选择自己能获取的奖项，则会破坏公平性。改进方案是，
在 <code>release</code> 的时候再一次对奖品顺序进行随机的打乱。</li>
<li>这种抽奖方式还限定了每人只能抽取一次奖品，否则会出现一个人占有多个奖项的情况。</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>可以参考<a href="https://huangjj27.gitlab.io/reservoirsampling/#%E5%85%AC%E5%B9%B3%E6%80%A7%E7%AD%89%E6%A6%82%E7%8E%87--frackn--%E6%8A%BD%E5%8F%96-%E8%AF%81%E6%98%8E">博主以前的博客</a></p>
</div>
<h2><a class="header" href="#下一步可能展开的工作" id="下一步可能展开的工作">下一步可能展开的工作</a></h2>
<p>目前所有抽奖者都按照相等的概率抽奖，而在一些场景下可能按照一些规则给与某些抽奖者优惠
（例如绩效越高的员工中奖概率越大），因此下一步可能考虑如何按照权重赋予每位抽奖者各自的
中奖概率。</p>
<h2><a class="header" href="#致谢" id="致谢">致谢</a></h2>
<p>感谢茶壶君（<a href="https://github.com/ksqsf">@ksqsf</a>）一语惊醒梦中人，清楚明确地表达了需求；
感谢张汉东老师 (<a href="https://github.com/ZhangHanDong">@ZhangHanDong</a>)老师提点了之后可以开展研究的方向；
感谢在这次讨论中提供意见的其他 Rust 社区的朋友，谢谢你们！</p>
<h2><a class="header" href="#作者介绍" id="作者介绍">作者介绍</a></h2>
<p>huangjj，Rust 爱好者，公众号：坏姐姐日常入门 Rust。</p>
<h1><a class="header" href="#rust入门系列rust-中使用-mysql" id="rust入门系列rust-中使用-mysql">「Rust入门系列」Rust 中使用 MySQL</a></h1>
<p>作者：张军军 / 后期编辑：张汉东</p>
<blockquote>
<p>这个系列的文章，我计划给大家讲解如何在Rust中使用Mysql作为存储，先从简单的开始，然后在后面展示如何在开发<code>Web api</code>中使用。</p>
</blockquote>
<h2><a class="header" href="#数据表" id="数据表">数据表</a></h2>
<p>本次我会使用一张订单表<code>order</code>。订单表的具体<code>schema</code>如下。</p>
<pre><code class="language-sql">CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) NOT NULL,
  `age` int(11) NOT NULL,
  `id_card` varchar(128) NOT NULL,
  `last_update` date NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 插入测试数据
insert into student (name, age, id_card, last_update) values ('张三', 23, '123456789X', CURRENT_DATE());
insert into student (name, age, id_card, last_update) values ('李四', 24, '8382353902', CURRENT_DATE())
</code></pre>
<h2><a class="header" href="#创建应用程序" id="创建应用程序">创建应用程序</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo new mysql-test-01
<span class="boring">}
</span></code></pre></pre>
<p>由于要使用<code>Mysql</code>的驱动，所以添加依赖到<code>Cargo.toml</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
mysql = &quot;*&quot; // 通配符*表示可以使用任何版本，通常会拉取最新版本
chrono = &quot;0.4&quot;
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我使用<code>chrono</code>来处理日期和时间列。具体 可以参考<a href="https://docs.rs/chrono/0.4.19/chrono/"> <code>https://docs.rs/chrono/0.4.19/chrono/</code></a></p>
<h2><a class="header" href="#开始" id="开始">开始</a></h2>
<p>在main.rs中导入命名空间</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mysql::*;
use mysql::prelude::*;
use chrono::prelude::*; // 用来处理日期
<span class="boring">}
</span></code></pre></pre>
<p>获取<code>Mysql</code>连接</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let url = &quot;mysql://root:password@localhost:3306/MYDB&quot;;
    let pool = Pool::new(url).unwrap(); // 获取连接池
    let mut conn = pool.get_conn().unwrap();// 获取链接
}
</code></pre></pre>
<p>先跑一下，确保可以打开一个连接</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo run
<span class="boring">}
</span></code></pre></pre>
<p>第一次下载和编译所有依赖，可能需要一点点时间，看到命令行编译过去了，表示和数据库已经打通了。</p>
<h2><a class="header" href="#流式查询" id="流式查询">流式查询</a></h2>
<p>流式查询，其实结果数据是逐行读取的。 好处就是，整个数据永远不会存储在内存中，如果要读取大量数据，使用<code>query_iter</code>很好。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> conn.query_iter(&quot;select * from student&quot;)
        .unwrap()
        .for_each(|row| {
            let r: (i32, String, i32, String, NaiveDate) = from_row(row.unwrap());
            println!(&quot;{}, {},{},{}, {:?}&quot;, r.0, r.1, r.2, r.3, r.4);
        });
<span class="boring">}
</span></code></pre></pre>
<p>上面代码中的<code>row</code>的类型是<code>mysql_common::row::Row</code>，这种类型把数据以字节的形式存储。所以这里需要把低级的字节转换成我们想要的类型比如<code>i32,String</code>等，这里我使用了<code>from_row</code>。注意，转换后的数据以元组的形式返回，其中每一项和选择列的顺序相同。</p>
<h2><a class="header" href="#聚合查询结果" id="聚合查询结果">聚合查询结果</a></h2>
<p>其实， 可以将查询结果收集到Vec中。 Vec中的每个元素都是一个元组。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 输出到Vec
let res: Vec&lt;(i32, String, i32, String, NaiveDate)&gt; =
	conn.query(&quot;select * from student&quot;).unwrap();
for r in res {
    println!(&quot;{}, {},{},{}, {:?}&quot;, r.0, r.1, r.2, r.3, r.4);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>query</code>函数已经将字节转换为选择的数据类型，因此不需要再转换了。 需要注意的就是，这里必须明确元组的数据类型。 否则，编译器没办法做转换。</p>
<h2><a class="header" href="#结果到结构体" id="结果到结构体">结果到结构体</a></h2>
<p>使用元组也可以。 但是我们实际写代码时，数据表列数多，最普遍的做法就是定义一个结构体。比如这里叫<code>Student</code>, 然后，可以使用<code>query_map</code>将查询结果映射到<code>Student</code>对象。这里
不需要置顶元组的数据类型，编译器会自动推导字段类型根据Student类型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Student {
    id: u64,
    name: String,
    age: u16,
    id_card: String,
    last_changed_on: NaiveDate,
}

let res = conn.query_map(
    &quot;select * from student&quot;,
    |(id, name, age, id_card, update)| Student {
        id: id,
        name: name,
        age: age,
        id_card: id_card,
        last_changed_on: update,
    },
).expect(&quot;Query failed.&quot;);

for i in res {
    println!(
        &quot;{}, {},{},{}, {:?}&quot;,
        i.id, i.name, i.age, i.id_card, i.last_changed_on
    )
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#单条数据查询" id="单条数据查询">单条数据查询</a></h3>
<p>查询特定数据行，可能会出现下面几种情况</p>
<ul>
<li>找到，返回实际数据</li>
<li>没有找到行</li>
<li>发生错误</li>
</ul>
<p>所以，使用query_first函数返回的是Option的结果。 需要将其解包两次才可以获取实际的行数据。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // 条件查询，查询单个数据
let res = conn.query_first(&quot;select * from student where name = '张三'&quot;)
.map(
    // Unpack Result
    |row| {
        row.map(|(id, name, age, id_card, update)| Student {
            id: id,
            name: name,
            age: age,
            id_card: id_card,
            last_changed_on: update,
        })
    },
);

match res.unwrap() {
    Some(student) =&gt; println!(
        &quot;{}, {},{},{}, {:?}&quot;,
        student.id, student.name, student.age, student.id_card, student.last_changed_on
    ),
    None =&gt; println!(&quot;Sorry no student found.&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#命名参数的使用" id="命名参数的使用">命名参数的使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let res = conn
        .exec_first(
            &quot;select * from student where name = :name&quot;,
            params! {
                &quot;name&quot; =&gt; &quot;李四&quot;
            },
        )
        .map(
            // Unpack Result
            |row| {
                row.map(|(id, name, age, id_card, update)| Student {
                    id: id,
                    name: name,
                    age: age,
                    id_card: id_card,
                    last_changed_on: update,
                })
            },
        );
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#总结-4" id="总结-4">总结</a></h2>
<ul>
<li>经常使用的时间处理库：<code>chrono</code></li>
<li>流式查询使用： <code>query_iter</code></li>
<li>输出到Vec使用：<code>query</code></li>
<li>映射到结构体使用： <code>query_map</code></li>
<li>获取单条数据使用：<code>query_first</code></li>
<li>命名参数查询使用：<code>exec_first</code></li>
</ul>
<h1><a class="header" href="#系列设计模式之工厂模式" id="系列设计模式之工厂模式">「系列」设计模式之工厂模式</a></h1>
<p>作者：苏胤榕（DaviRain） / 后期编辑：张汉东</p>
<hr />
<h1><a class="header" href="#创建型设计模式-之-工厂模式" id="创建型设计模式-之-工厂模式">创建型设计模式 之 工厂模式</a></h1>
<blockquote>
<p>工厂方法模式 (虚拟构造函数，Virtual Constructor, Factory Method）</p>
</blockquote>
<h2><a class="header" href="#意图" id="意图">意图</a></h2>
<p>工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。在Rust中的实现就是提供一个抽象的trait，结构体实现该trait。</p>
<h2><a class="header" href="#问题" id="问题">问题</a></h2>
<p>假如你正在开发一款应用，最初的版本只能处理的业务逻辑只有单一的一个，比如开始只有简单的邮寄个人信的业务。而后面随着业务的扩大，需要增加邮寄公司订单业务。</p>
<p>如果代码其余部分与现有的类已经存在耦合关系，那么向程序中添加新类其实没有那么容易。</p>
<p>如果以后需要在程序支持另一种新的业务类型，很可能需要再次对这些代码进行大幅修改。</p>
<p>最后，你将不得不编写纷繁复杂的代码，根据不同的业务类，在应用中进行不同的处理。</p>
<h2><a class="header" href="#解决方案" id="解决方案">解决方案</a></h2>
<p>工厂方法模式建议使用特殊的工厂方法代替对象构造函数的直接调用。对象的创建仍然通过new运算符，只是该运算符改在工厂中调用。工厂方法返回的对象通常被称作“产品”。</p>
<p>虽然看似很简单，我们只是改变了程序中调用构造函数的位置。但是我们可以在子类中重写工厂方法，从而改变其创建产品的类型。（这里的话在Rust中是有新的结构体实现抽象的triat）仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还应该将其返回类型声明为这一共有接口。</p>
<h2><a class="header" href="#工厂方法模式结构" id="工厂方法模式结构">工厂方法模式结构</a></h2>
<ul>
<li>产品将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。</li>
<li>具体产品是产品接口的不同实现。</li>
<li>创建者类声明返回产品对象的工厂方法。该方法的返回对象必须与产品接口相匹配。你可以将工厂方法声明为抽象方法，强制要求每个子类以不同的方式实现该方法。或者，也可以在基础工厂方法中返回默认产品类型。注意。尽管它的名字是创建者，但他最主要的职责并不是创建产品。一般来说，创建者类包含一些与产品相关的核心业务逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来。</li>
</ul>
<h2><a class="header" href="#示例结构图" id="示例结构图">示例结构图</a></h2>
<p><img src="chapter_3/../image/rust-design-pattern-factory.png" alt="" /></p>
<h2><a class="header" href="#代码" id="代码">代码</a></h2>
<pre><pre class="playground"><code class="language-rust">enum ProductType {
    Product1,
    Product2,
}

// 定义接口
trait Product {
    fn show(&amp;self);
}

// 工厂模式
trait Factory {
    fn make_product(&amp;self, product_type : ProductType) -&gt; Box&lt;dyn Product&gt;;
}

struct ConcreteProduct1(String);
struct ConcreteProduct2(String);

impl Product for ConcreteProduct1 {
    fn show(&amp;self) {
        println!(&quot;red color, {}&quot;, self.0);
    }
}

impl Product for ConcreteProduct2  {
    fn show(&amp;self) {
        println!(&quot;blue color, {}&quot;, self.0);
    }
}

struct SimpleFactory;

impl SimpleFactory {
    fn new() -&gt; Self {
        Self
    }
}

impl Factory for SimpleFactory {
    fn make_product(&amp;self, color_type : ProductType) -&gt; Box&lt;dyn Product&gt; {
        match color_type {
            ProductType::Product1 =&gt; Box::new(ConcreteProduct1(&quot;blue&quot;.to_string())),
            ProductType::Product2 =&gt; Box::new(ConcreteProduct2(&quot;red&quot;.to_string())),
        }
    }
}

fn main() {
    let factory =  SimpleFactory::new();
    let product = factory.make_product(ProductType::Product1);
    product.show();
    let product = factory.make_product(ProductType::Product2);
    product.show();
}
</code></pre></pre>
<h2><a class="header" href="#工厂方法模式适合应用的场景" id="工厂方法模式适合应用的场景">工厂方法模式适合应用的场景</a></h2>
<ul>
<li>当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法
<ul>
<li>工厂方法将创建产品的代码和实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码</li>
</ul>
</li>
<li>如果你希望用户能扩展你软件库或架构的内部组件，可使用工厂方法
<ul>
<li>通过将需要实现的共同特性的接口特性抽象为trait， 当有新的结构体时，将该结构体实现拥有共同特性的trait。从而实现新组件的假如，而不会破坏别的代码结构。</li>
</ul>
</li>
<li>如果你希望复用现有对象对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。</li>
</ul>
<h2><a class="header" href="#实现方法" id="实现方法">实现方法</a></h2>
<ul>
<li>让所有的产品都遵循统一triat接口，该接口必须声明对所有产品都有意义的方法</li>
<li>在工厂trait中添加一个工厂方法，该方法的返回类型都必须遵循通用的产品接口（返回的是由Box包裹起来的trait对象）</li>
<li>在创建者代码中找到对于产品构造函数的所有引用，将它们依次替换为对于工厂方法的调用。，同时将创建产品的代码移入工厂方法。</li>
<li>为工厂方法中的每种产品编写一个结构体，然后将该结构体实现抽象出来的统一triat，并将基本方法中的相关创建代码移动到工厂方法中。</li>
<li>如果代码经过上述移动之后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象trait方法。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。</li>
</ul>
<h2><a class="header" href="#工厂方法模式优缺点" id="工厂方法模式优缺点">工厂方法模式优缺点</a></h2>
<ul>
<li>优点
<ul>
<li>你可以避免创建者和具体产品之间的紧密耦合</li>
<li>单一职责原则，你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护</li>
<li>开闭原则，无需更改现有客户端代码你就可以在程序中引入新的产品类型。</li>
</ul>
</li>
<li>缺点
<ul>
<li>应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#译数据操作rust-vs-pandas" id="译数据操作rust-vs-pandas">「译」数据操作：Rust vs Pandas</a></h1>
<p>译者：<a href="https://github.com/pi-pi-miao">pi-pi-miao</a> / 后期编辑：张汉东</p>
<blockquote>
<p>原文：<a href="https://able.bio/haixuanTao/data-manipulation-pandas-vs-rust--1d70e7fc">Data Manipulation: Pandas vs Rust</a></p>
</blockquote>
<hr />
<blockquote>
<p>Rust requires a lot more work compared to Pandas, but, Rust is way more flexible and performant.</p>
</blockquote>
<p>与 pandas 相比，rust 需要做更多的工作，但是 rust 使用起来更灵活，更出色</p>
<h2><a class="header" href="#介绍-3" id="介绍-3">介绍</a></h2>
<p>pandas 是 python 的主要数据分析包，但是由于很多原因，如果没有使用 numpty 等工具的话，原生 python 在数据分析等方面性非常差，pandas 是由 Wes McKinney 开发的，并且将这些操作封装到漂亮的 api 中，方便 python 开发者使用其进行数据分析</p>
<p>rust 因为具有出色的数据性能，这也是为什么 rust 不需要像 pandas 那样进行 api 的包装</p>
<p>我相信在 rust 进行数据操作的方法是构建一堆数据结构，但是我可能理解错了，如果是这样的话，请告诉我</p>
<p>下面是我的经验和推理用来比较 rust 和 pandas</p>
<h2><a class="header" href="#数据" id="数据">数据</a></h2>
<p>性能基准是在这个非常随机的数据集上完成的：<a href="https://www.kaggle.com/START-UMD/gtd">这里</a>，它提供了大约160,000行/ 130列，总大小为 150Mb 的数据，这个数据集的大小对应于我经常遇到的数据集类型，这就是我选择这个数据集的原因，他并不是世界上最大的数据集，更多的学习应该在更大的数据集上进行</p>
<p>已经合并将使用另一个随机数据集已经完成 <a href="https://datacatalog.worldbank.org/dataset/world-development-indicators">这里</a>, the<code>WDICountry.csv</code></p>
<h2><a class="header" href="#1读取和即时数据" id="1读取和即时数据">1、读取和即时数据</a></h2>
<h3><a class="header" href="#pandas" id="pandas">[pandas]</a></h3>
<p>在 pandas 读取和即时数据非常简单，默认情况会处理很多数据质量问题</p>
<pre><code class="language-python">import pandas as pd

path = &quot;/home/peter/Documents/TEST/RUST/terrorism/src/globalterrorismdb_0718dist.csv&quot;
df = pd.read_csv(path)
</code></pre>
<p>[rust] 读取 CSV 文件</p>
<p>对于 rust 来说，管理质量差的数据是非常乏味的，在有些数据集中，有些字段是空的，有些行格式不好，有些没有使用 utf-8 编码</p>
<p>要打开 csv，我使用了 csv crate ，它不但能解决上面所有的问题，所以读取可以使用 csv</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = &quot;/home/peter/Documents/TEST/RUST/terrorism/src/foo.csv&quot;
let mut rdr = csv::Reader::from_path(path).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>由于格式化质量差，我的使用如下</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;    
use encoding_rs::WINDOWS_1252;
use encoding_rs_io::DecodeReaderBytesBuilder;

// ...

    let file = File::open(path)?;
    let transcoded = DecodeReaderBytesBuilder::new()
        .encoding(Some(WINDOWS_1252))
        .build(file);
    let mut rdr = csv::ReaderBuilder::new()
        .delimiter(b',')
        .from_reader(transcoded);
<span class="boring">}
</span></code></pre></pre>
<p>[参考]<a href="https://stackoverflow.com/questions/53826986/how-to-read-a-non-utf8-encoded-csv-file">https://stackoverflow.com/questions/53826986/how-to-read-a-non-utf8-encoded-csv-file*</a></p>
<h3><a class="header" href="#rust即时数据" id="rust即时数据">[rust]即时数据</a></h3>
<p>为了实现数据的即时化，我使用<a href="https://serde.rs/">Serde</a> 将我的数据序列化和反序列化</p>
<p>要使用 Serde，需要对数据进行 struct 化，使用 struct 是我的代码遵循基于模型的编程范式，每个字段都有一个定义好的类型，它还能让我能在 struct 之上实现 trait 和方法</p>
<p>然而，我想要的数据有130列...而且它看起来没有办法自动生成 struct的 定义，为了避免手动定义，我必须构建自己的结构生成器</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inspect(path: &amp;str) {
    let mut record: Record = HashMap::new();

    let mut rdr = csv::Reader::from_path(path).unwrap();

    for result in rdr.deserialize() {
        match result {
            Ok(rec) =&gt; {
                record = rec;
                break;
            }
            Err(e) =&gt; (),
        };
    }
    // Print Struct
    println!(&quot;#[skip_serializing_none]&quot;);
    println!(&quot;#[derive(Debug, Deserialize, Serialize)]&quot;);
    println!(&quot;struct DataFrame {{&quot;);
    for (key, value) in &amp;record {
        println!(&quot;    #[serialize_always]&quot;);

        match value.parse::&lt;i64&gt;() {
            Ok(n) =&gt; {
                println!(&quot;    {}: Option&lt;i64&gt;,&quot;, key);
                continue;
            }
            Err(e) =&gt; (),
        }
        match value.parse::&lt;f64&gt;() {
            Ok(n) =&gt; {
                println!(&quot;    {}: Option&lt;f64&gt;,&quot;, key);
                continue;
            }
            Err(e) =&gt; (),
        }
        println!(&quot;    {}: Option&lt;String&gt;,&quot;, key);
    }
    println!(&quot;}}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>生成的 struct 如下</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

#[skip_serializing_none]
#[derive(Debug, Clone, Deserialize, Serialize)]
struct DataFrame {
    #[serialize_always]
    individual: Option&lt;f64&gt;,
    #[serialize_always]
    natlty3_txt: Option&lt;String&gt;,
    #[serialize_always]
    ransom: Option&lt;f64&gt;,
    #[serialize_always]
    related: Option&lt;String&gt;,
    #[serialize_always]
    gsubname: Option&lt;String&gt;,
    #[serialize_always]
    claim2: Option&lt;String&gt;,
    #[serialize_always]

    // ...
<span class="boring">}
</span></code></pre></pre>
<p>skip_serializing_none : 避免在 csv 中出现空字段的错误</p>
<p>serialize_always : 固定写入 csv 的时候的字段的数量</p>
<p>现在我有了自己的结构体，我使用 serde 序列化来填充结构体的向量</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let mut records: Vec&lt;DataFrame&gt; = Vec::new();

    for result in rdr.deserialize() {
        match result {
            Ok(rec) =&gt; {
                records.push(rec);
            }
            Err(e) =&gt; println!(&quot;{}&quot;, e),
        };
    }
<span class="boring">}
</span></code></pre></pre>
<p>这生成了我的向量结构体，赞</p>
<p>一般来说，在使用rust的时候，你不应该期望像使用 python 那样流畅的工作</p>
<p>结论</p>
<pre><code>在读取/实例化数据的时候，pandas轻而易举的赢得了rust的csv
</code></pre>
<h2><a class="header" href="#2过滤" id="2过滤">2、过滤</a></h2>
<p>[pandas]</p>
<p>pandas 的过滤方法有很多种，对我来说最常见的方法是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>df = df[df.country_txt == &quot;United States&quot;]
df.to_csv(&quot;python_output.csv&quot;)
<span class="boring">}
</span></code></pre></pre>
<p>[rust]</p>
<p>要在 rust 中使用过滤，可以参考 rust 的<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">向量文档</a></p>
<p>有一大堆向量的过滤方法，有狠多还是 nightly 的特性，这些特性在发布的时候非常适合数据操作，对于这个用例我使用了 retain 方法，因为它完全符合我的需求</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  records.retain(|x| &amp;x.country_txt.unwrap() == &quot;United States&quot;);
    let mut wtr =
        csv::Writer::from_path(&quot;output_rust_filter.csv&quot;)?;

    for record in &amp;records {
        wtr.serialize(record)?;
    }
<span class="boring">}
</span></code></pre></pre>
<p>pandas 和 rust 的最大区别是 rust 过滤使用了闭包（比如 python 中的 lambda 函数）而 pandas 过滤式基于列的 pandas API，这意味着 rust 可以制造更复杂的过滤器，在我看来这也增加了可读性</p>
<h3><a class="header" href="#性能" id="性能">性能</a></h3>
<table><thead><tr><th align="left"></th><th align="left">时间</th><th align="left">内存（Gb）</th></tr></thead><tbody>
<tr><td align="left">pandas</td><td align="left">3.0s</td><td align="left">2.5 Gb</td></tr>
<tr><td align="left">rust</td><td align="left">1.6s 🔥 -50%</td><td align="left">1.7 Gb 🔥 -32%</td></tr>
</tbody></table>
<p>即使我们使用 pandas 的 api 来过滤，我们也可以使用 rust 获得更好的性能</p>
<h3><a class="header" href="#结论-2" id="结论-2">结论</a></h3>
<p>在过滤这方面，rust 更快，并且性能更好</p>
<h2><a class="header" href="#3分组" id="3分组">3、分组</a></h2>
<h3><a class="header" href="#pandas-1" id="pandas-1">[pandas]</a></h3>
<p>分组式 python 中使用 pipline 的重要组成部分，如下：</p>
<pre><code class="language-python">df = df.groupby(by=&quot;country_txt&quot;, as_index=False).agg(
    {&quot;nkill&quot;: &quot;sum&quot;, &quot;individual&quot;: &quot;mean&quot;, &quot;eventid&quot;: &quot;count&quot;}
)
df.to_csv(&quot;python_output_groupby.csv&quot;)
</code></pre>
<p>[rust]</p>
<p>对于分组 感谢： <a href="https://able.bio/insideoutclub">David Sanders</a> 分组恶意使用下面</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use itertools::Itertools;


// ...

#[derive(Debug, Deserialize, Serialize)]
struct GroupBy {
    country: String,
    total_nkill: f64,
    average_individual: f64,
    count: f64,
}

// ... 

    let groups = records
        .into_iter()
        // .sorted_unstable_by(|a, b| Ord::cmp(&amp;a.country_txt, &amp;b.country_txt))
        .group_by(|record| record.country_txt.clone())
        .into_iter()
        .map(|(country, group)| {
            let (total_nkill, count, average_individual) = group.into_iter().fold(
                (0., 0., 0.),
                |(total_nkill, count, average_individual), record| {
                    (
                        total_nkill + record.nkill.unwrap_or(0.),
                        count + 1.,
                        average_individual + record.individual.unwrap_or(0.),
                    )
                },
            );
            lib::GroupBy {
                country: country.unwrap(),
                total_nkill,
                average_individual: average_individual / count,
                count,
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
    let mut wtr =
        csv::Writer::from_path(&quot;output_rust_groupby.csv&quot;)
            .unwrap();

    for group in &amp;groups {
        wtr.serialize(group)?;
    }
<span class="boring">}
</span></code></pre></pre>
<p>虽然这个解决方案不像 pandas 那样优雅，但是为这种场景提供了更好的灵活性</p>
<p>我认为除了 sum and fold 之外，更多的 reduction 方法将会大大提高 rust 中 map-reduce 式操作的开发体验。</p>
<h3><a class="header" href="#性能-1" id="性能-1">性能</a></h3>
<table><thead><tr><th align="left"></th><th align="left">时间</th><th align="left">内存（Gb）</th></tr></thead><tbody>
<tr><td align="left">pandas</td><td align="left">2.78s</td><td align="left">2.5 Gb</td></tr>
<tr><td align="left">rust</td><td align="left">2.0s🔥 -35%</td><td align="left">1.7Gb🔥 -32%</td></tr>
</tbody></table>
<h3><a class="header" href="#结论-3" id="结论-3">结论：</a></h3>
<p>虽然性能更好的是 rust，我建议在 map-reduce 方法使用 pandas，因为它似乎更合适。</p>
<h2><a class="header" href="#4mutation" id="4mutation">4、Mutation</a></h2>
<h3><a class="header" href="#pandas-2" id="pandas-2">[pandas]</a></h3>
<p>在 pandas 身上做 mutation 的方法有很多，我通常为了性能和功能风格做下面的方式</p>
<pre><code class="language-python">df[&quot;computed&quot;] = df[&quot;nkill&quot;].map(lambda x: (x - 10) / 2 + x ** 2 / 3)
df.to_csv(&quot;python_output_map.csv&quot;)
</code></pre>
<h3><a class="header" href="#rust-1" id="rust-1">[rust]</a></h3>
<p>rust 在 mutation 可以使用 iter</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   records.iter_mut().for_each(|x: &amp;mut DataFrame| {
        let nkill = match &amp;x.nkill {
            Some(nkill) =&gt; nkill,
            None =&gt; &amp;0.,
        };

        x.computed = Some((nkill - 10.) / 2. + nkill * nkill / 3.);
    });

    let mut wtr = csv::Writer::from_path(
        &quot;output_rust_map.csv&quot;,
    )?;
    for record in &amp;records {
        wtr.serialize(record)?;
    }
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#性能-2" id="性能-2">性能</a></h3>
<table><thead><tr><th align="left"></th><th align="left">时间</th><th align="left">内存（Gb）</th></tr></thead><tbody>
<tr><td align="left">pandas</td><td align="left">12.82s</td><td align="left">4.7Gb</td></tr>
<tr><td align="left">rust</td><td align="left">1.58s🔥 -87%</td><td align="left">1.7Gb🔥 -64%</td></tr>
</tbody></table>
<p>在我看来 mutation 就是 pandas 和 rust 的区别所在，pandas 在这方面表现非常糟糕</p>
<h3><a class="header" href="#结论-4" id="结论-4">结论</a></h3>
<p>rust 天生适合 mutation 操作</p>
<h2><a class="header" href="#5-merge" id="5-merge">5. Merge</a></h2>
<h3><a class="header" href="#python" id="python">[python]</a></h3>
<p>一般来说 merge 操作在 python 中式非常高效的</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>df_country = pd.read_csv(
    &quot;/home/peter/Documents/TEST/RUST/terrorism/src/WDICountry.csv&quot;
)

df_merge = pd.merge(
    df, df_country, left_on=&quot;country_txt&quot;, right_on=&quot;Short_Name&quot;
)
df_merge.to_csv(&quot;python_output_merge.csv&quot;)
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#rust-2" id="rust-2">[rust]</a></h3>
<p>对于 rust 的 struct 来说这是一个棘手的部分，对我来说解决合并的办法式添加一个嵌套字段，这里包含我们要合并的另一个结构体，我首先为新数据创建一个新的结构体和新的堆</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[skip_serializing_none]
#[derive(Clone, Debug, Deserialize, Serialize)]
struct DataFrameCountry {
    #[serialize_always]
    SNA_price_valuation: Option&lt;String&gt;,
    #[serialize_always]
    IMF_data_dissemination_standard: Option&lt;String&gt;,
    #[serialize_always]
    Latest_industrial_data: Option&lt;String&gt;,
    #[serialize_always]
    System_of_National_Accounts: Option&lt;String&gt;,
    //...

// ...

    let mut records_country: Vec&lt;DataFrameCountry&gt; = Vec::new();
    let file = File::open(path_country)?;
    let transcoded = DecodeReaderBytesBuilder::new()
        .encoding(Some(WINDOWS_1252))
        .build(file);
    let mut rdr = csv::ReaderBuilder::new()
        .delimiter(b',')
        .from_reader(transcoded); 

    for result in rdr.deserialize() {
        match result {
            Ok(rec) =&gt; {
                records_country.push(rec);
            }
            Err(e) =&gt; println!(&quot;{}&quot;, e),
        };
    }
<span class="boring">}
</span></code></pre></pre>
<p>然后，我将这个新结构与前面的结构克隆到一个惟一的特定字段上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl DataFrame {
    fn add_country_ext(&amp;mut self, country: Option&lt;DataFrameCountry&gt;) {
        self.country_merge = Some(country)
    }
}

//...

    for country in records_country {
        records
            .iter_mut()
            .filter(|record| record.country_txt == country.Short_Name)
            .for_each(|x| {
                x.add_country_ext(Some(country.clone()));
            });
    }
    let mut wtr =
        csv::Writer::from_path(&quot;output_rust_join.csv&quot;)
            .unwrap();
    for record in &amp;records {
        wtr.serialize(record)?;
    }
<span class="boring">}
</span></code></pre></pre>
<p>为了方便和更好的可比性，我复制了数据，但是如果您能够管理它，可以传递引用。</p>
<p>好了!🚀</p>
<p>除此之外，嵌套结构在 CSV 中还不能序列化  对于 rust <a href="https://github.com/BurntSushi/rust-csv/pull/197">这里</a></p>
<p>所以我必须把它改写成:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DataFrame {
    fn add_country_ext(&amp;mut self, country: Option&lt;DataFrameCountry&gt;) {
        self.country_ext = Some(format!(&quot;{:?}&quot;, country))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后我们归并</p>
<h3><a class="header" href="#性能-3" id="性能-3">性能</a></h3>
<table><thead><tr><th align="left"></th><th align="left">时间</th><th align="left">内存（Gb）</th></tr></thead><tbody>
<tr><td align="left">pandas</td><td align="left">22.47s</td><td align="left">11.8Gb</td></tr>
<tr><td align="left">rust</td><td align="left">5.48s🔥 -75%</td><td align="left">2.6 Gb🔥 -78%</td></tr>
</tbody></table>
<h3><a class="header" href="#结论-5" id="结论-5">结论</a></h3>
<p>Rust 可以通过嵌套结构体的方式来实现和 pandans 一样的 merge 功能这并不是真正的一对一比较，在这种情况下，这将取决于您的用例。</p>
<h2><a class="header" href="#最后的结论" id="最后的结论">最后的结论</a></h2>
<p>这次比较之后，我的收获如下</p>
<p>​        使用 pandas 的时候，可以 使用小的 csv（&lt;1M行），进行简单的操作数据清理</p>
<p>​        使用 rust 的时候，你可以进行复杂的操作，内存大或者耗时的 piplines，可以自定义构建函数，扩展软件</p>
<p>rust 和 pandas 相比，rust 提供了非常好的灵活性，以及 rust 比 pandas 可以使用多线程的能力，可以并行操作，我相信 rust 可以解决 pandas 不能解决的问题</p>
<p>此外在任何平台上（ web，安卓或者嵌入式 ）上运行 rust 也是 pandas 无法做到的，并且 rust 也可以为尚未解决的挑战提供了新的解决方案</p>
<h2><a class="header" href="#性能-4" id="性能-4">性能</a></h2>
<p>性能表也给了我们更加深入了解 rust 的期望，我相信对于大数据处理方面，rust 会提高2-50倍的性能提升，随着时间的推移，rust 比着 python 内存使用量会大大的减少</p>
<h2><a class="header" href="#免责声明" id="免责声明">免责声明</a></h2>
<p>在很多方面，pandas 可以被优化，但是优化式有代价的，无论使硬件(例如集群 Cluster  #Dask, GPU #Cudf)，还是依赖于这些优化包的可靠性和维护。</p>
<p>我非常喜欢使用原生 rust 的原因是，rust 不需要额外的硬件，也不需要额外的软件包，此解决方案不需要额外的抽象层，这使得 rust 在很多方面更加直观</p>
<h2><a class="header" href="#代码库" id="代码库">代码库</a></h2>
<h3><a class="header" href="#git-repository" id="git-repository">Git repository</a></h3>
<p><a href="https://github.com/haixuanTao/Data-Manipulation-Rust-Pandas">点击这里</a></p>
<h1><a class="header" href="#译unsafe-rust-的取舍" id="译unsafe-rust-的取舍">「译」Unsafe Rust 的取舍</a></h1>
<p>译者： （ <a href="https://github.com/MATRIXKOO">MATRIXKOO</a> 和 <a href="https://github.com/NiZerin">NiZerin</a> ） / 后期编辑： 张汉东</p>
<blockquote>
<p>原文：<a href="https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/">Unsafe Rust: How and when (not) to use it</a></p>
</blockquote>
<hr />
<h2><a class="header" href="#在本中我将说明您需要了解的有关unsafe-rust的所有信息我将专注于以下几个方面来讲解" id="在本中我将说明您需要了解的有关unsafe-rust的所有信息我将专注于以下几个方面来讲解">在本中，我将说明您需要了解的有关<code>unsafe Rust</code>的所有信息。我将专注于以下几个方面来讲解。</a></h2>
<ul>
<li>有关于<code>unsafe Rust</code>代码的误解</li>
<li>什么时候不使用<code>unsafe</code>代码</li>
<li>处理未初始化的内存</li>
<li>不可处理的异常</li>
<li>内在机制</li>
<li>内联汇编</li>
<li>接口外部功能</li>
<li>编写<code>unsafe Rust</code>代码的工具</li>
</ul>
<h2><a class="header" href="#关于unsafe-rust代码的几个误解" id="关于unsafe-rust代码的几个误解">关于<code>unsafe Rust</code>代码的几个误解</a></h2>
<p>在解释如何以及何时使用<code>unsafe Rust</code>（或不使用）之前，我想先说明一些关于 Rust 中不安全代码的常见误解。</p>
<p>###误解1：所有 Rust 代码都不安全
不是的。
区别是微妙的，但是安全的 Rust 代码不能违反安全保证，只要编译器和它所构建的不安全代码都没有任何允许这种情况发生的bug。
因此，与其他低级语言不同，在其他低级语言中，代码的安全性取决于每一行代码和编译器实现，您可以显著减少需要审核错误的攻击面。</p>
<p><a href="https://plv.mpi-sws.org/rustbelt/">RustBelt</a> 项目从数学上证明，如果你有一部分安全代码和一部分不安全代码来保护它的不变量，那么只要不安全代码不允许，安全代码就不能破坏保证。</p>
<p>顺便说一句，不变量是一种条件，它不会被某一类型的所有方法或模块的所有函数改变。</p>
<p>从统计上讲，在 Crates.io 上发现的 Rust 代码中，只有不到1%是不安全的代码-这可能不到现有代码的50%，但仍然应该是一个足够有代表性的样本-而且许多项目里没有任何不安全的代码行。</p>
<h3><a class="header" href="#误解2它依赖于标准库代码其中包含许多不安全因素" id="误解2它依赖于标准库代码其中包含许多不安全因素">误解2：它依赖于标准库代码，其中包含许多不安全因素</a></h3>
<p>是的，标准库有比普通项目更多的不安全代码，这是意料之中的，因为它提供的许多抽象不能在<code>Safe Rust</code>中有效地实现，或者根本不能实现。
此外，我们可以放心，标准库已经收到了更多的审查，因此比您的项目更值得信赖。</p>
<p>这并不是说它是完美的-毕竟，过去也发现了很多错误。
尽管如此，在验证和模糊标准库的大部分方面还是做了很好的工作，这使得所有的 Rust 代码都更加安全。</p>
<h3><a class="header" href="#误解3一旦我们编写了-unsafe-代码就感觉打开了地狱之门" id="误解3一旦我们编写了-unsafe-代码就感觉打开了地狱之门">误解3：一旦我们编写了 <code>unsafe</code> 代码，就感觉打开了地狱之门</a></h3>
<p>不是的。 <a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">Rustonomicon</a> 仔细地列出了不安全代码授予您的额外权限，以换取您保证维护该部分代码中的安全常量。
例如，您可以：</p>
<ul>
<li>取消引用原始指针</li>
<li>调用<code>unsafe</code>函数(包括C函数、编译器内部函数和原始分配器)</li>
<li>实现<code>unsafe</code>traits</li>
<li>改变静态变量</li>
<li>访问联合体内的成员</li>
</ul>
<p>然而，即使是那些看起来可能是安全的代码，也可能会产生你应该注意的后果：</p>
<ul>
<li>原始指针不能保证指向它们声称要指向的数据的有效实例，因此取消对它们的引用可能会导致空域(很可能是分段错误)，或者更糟糕的是，会导致类型混乱，在这种情况下，您破坏了数据，破坏了程序的状态，可能会造成不利的影响。</li>
<li>调用<code>unsafe</code>函数有使用不符合其安全要求的参数调用它们的风险，这可能会造成可利用的漏洞。</li>
<li>为未能维护其不变式的类型实现<code>unsafe</code> traits 还可能导致调用方无意中导致其安全要求失败，并可能造成不利的影响。</li>
<li>在另一个线程中观察静态变量时对其进行改变可能会导致数据竞争和读取异常，这意味着读取的值不再需要与旧值或新值相关。
根据读取的类型和使用方式的不同，这也可能导致未定义的行为，可能会造成不利的影响。</li>
<li>访问联合体的字段可能会让您将数据解释为它们不表示有效实例的类型，或者观察未初始化的数据(如果类型的长度不同，一个字段可以包括另一个字段的填充)，这两种情况都会导致未定义的行为和可能被利用的漏洞。</li>
</ul>
<p>因此，尽管不安全代码并不像某些人所说的那样可怕，但需要小心安全地处理它。
然后，您可以在不安全代码的基础上编写安全代码。</p>
<h3><a class="header" href="#误解4只要不会有人意外地使用参数调用我的安全代码从而导致下面的不安全代码失败我就没问题" id="误解4只要不会有人意外地使用参数调用我的安全代码从而导致下面的不安全代码失败我就没问题">误解4：只要不会有人意外地使用参数调用我的安全代码，从而导致下面的不安全代码失败，我就没问题</a></h3>
<p>不是的。
一旦您在不安全的代码之上提供了一个安全接口，您的代码要么无论如何都会维护安全常量，要么您的代码是不健全的。</p>
<p>有些人对不健全的感觉非常强烈，没有理由大发雷霆。
这仍然是一个错误，你应该公开和冷静地解决它。
如果错误可以通过更仔细的设计来解决，那就去做吧。
同时，您可以公开声明您的代码不健全，用户需要格外小心，以免违反安全常量。
如果你想出了一个合理的设计，就把所有发布的不完善的版本都撤回，并报告漏洞。</p>
<h3><a class="header" href="#误解5我试过运行它它运行得很好" id="误解5我试过运行它它运行得很好">误解5：我试过运行它，它运行得很好</a></h3>
<p>未定义行为的问题不在于它会直接失败。
事实上，它可能永远不会失败。
在您将代码投入生产之前，它也可能一直正常工作，在这一点上，它可能会灾难性地失败。
或者，它可能会起作用，直到黑客尝试它，并手工制作正确的输入，以破解您的不健全的代码。
现在，您的所有用户都在其PC上安装了密码勒索特洛伊木马程序。</p>
<p>即使多次运行它，也不能保证下一次就能正常工作。
正如哥伦比亚号航天飞机灾难所显示的那样，仅仅因为它成功了135次并不意味着它在第136次尝试中就不会失败。</p>
<p>###但如果这只发生在内存泄漏时呢？
内存泄漏无法可靠地避免，并且本身不会对内存安全构成任何危险-尽管操作系统可能会停止您的程序，或者在您耗尽可用内存时简单地崩溃，但这在最坏的情况下会导致拒绝服务。
因此，它被认为超出了内存安全保障的范围，<code>mem：：forget</code>成为一个安全函数。
如果您的代码依赖于一些不泄漏的值来保证安全性，那么在某些时候，泄漏可能就会发生，安全保证的损失将由您承担。</p>
<p>请注意，这个误解是如此常见，直到Rust1.0之后，它才最终允许安全代码泄漏。
这种不安全来源的解决方案通常是泄漏放大-在尝试不安全操作之前，泄漏所有可能由泄漏导致的可观察到的损坏状态，然后将所有东西重新组合在一起。
这样，泄漏会变得更大，有时甚至更大，但至少不会破坏内存安全。</p>
<h3><a class="header" href="#好的我明白了-一旦我的项目中有一行不安全的代码所有其他代码都必须小心以免违反安全规则" id="好的我明白了-一旦我的项目中有一行不安全的代码所有其他代码都必须小心以免违反安全规则">好的，我明白了。 一旦我的项目中有一行不安全的代码，所有其他代码都必须小心，以免违反安全规则</a></h3>
<p>因此，通常的做法是在模块中创建不安全的代码。
这通常不打算从外部使用，但有时它可以是公开的，因为如果人们想要承担随后的责任以换取性能(或其他东西)，他们可能会在代码中使用不安全的方法。</p>
<p>下一步是编写另一个模块，该模块将使用前面提到的不安全代码提供安全接口。
这个模块应该是允许所有其他用例的最低抽象，如果您愿意的话，它是核心功能。
省略所有可以通过构建此安全代码来实现的内容。
这是需要仔细审核的部分。</p>
<p>最后，在您的安全API之上编写您想让人们使用的实际接口。
因为您处于安全的 Rust 区域，所以这段代码不需要太多关注。
如果您在核心接口实现上做得很好，编译器将维护其所有保证。</p>
<p>既然我们已经消除了与<code>unsafe</code> Rust 代码相关的误解，在进入实际代码之前，我们只有一件事要讨论。</p>
<h2><a class="header" href="#什么时候不该用-unsafe" id="什么时候不该用-unsafe">什么时候不该用 <code>unsafe</code></a></h2>
<p>通常, <code>unsafe</code> 实际上是在追求性能的过程中使用的。但是，正如我在 <a href="https://blog.logrocket.com/how-to-write-crap-rust-code">How to write CRaP Rust code</a> 中所写的那样，即使只是作为要测试的快照和作为基准进行基准测试，也应该始终运行较慢但是安全的版本。</p>
<p>只是因为使用 <code>unsafe</code> 的代码有时可以更快，并不意味着一定要这样做。合理的评估情况, 在保持原有速度或者更快的时候, 就应该继续使用 <code>safe</code> 版本的代码。</p>
<p>例如，在尝试加快 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">Benchmark Game</a> 条目之一作为练习时，我想通过使用数组而不是 <code>Vec</code> 来减少内存分配，这需要一些不安全的代码来处理未初始化的数据。但是，事实证明改用数组的版本要比基于 <code>Vec</code> 的版本慢，因为这个我就没继续下去了。克里夫·比佛尔（ Cliff L. Biffle ）在 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">Benchmark Game</a> 一书中也谈到了类似的经历。 使用 <code>unsafe</code> 不仅会让编译器减少对代码的安全性的保证，也减少了要做的检查,因此实际上可能会禁用某些优化以避免破坏代码。因此，在切换到 <code>unsafe</code> 之前，请务必先进行评估，进尽量保持  <code>safe</code> 的代码。</p>
<p>好的，让我们开始吧！</p>
<h3><a class="header" href="#处理未初始化的内存" id="处理未初始化的内存">处理未初始化的内存</a></h3>
<p>当 Rust 版本更新到1.0.0时，标准库有一个 <code>unsafe</code> 函数来获取未初始化的内存: <code>std::mem::uninitialized</code> (还有 <code>std::mem::zeroed</code>（），但是两者之间的唯一区别是 后者将返回的内存区域用0初始化)。</p>
<p>人们普遍认为这是个坏主意，现在该函数已经处于废弃 (<code>deprecated</code>) 状态，建议使用<code>std::mem::MaybeUnit</code> 类型代替。 未初始化的麻烦的原因是，该值可能会在恐慌 (<code>panic</code>)或在之前返回时隐式删除。 例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = std::mem::uninitialized();
this_function_may_panic();
mem::forget(x);
<span class="boring">}
</span></code></pre></pre>
<p>如果 <code>this_function_may_panic</code> 函数实际上 <code>panic </code> 了，则x会在我们调用 <code>forget</code> 之前就被 <code>drop</code> 。但是，删除未初始化的值是未定义的行为，并且由于删除通常是隐式的，因此很难避免这种情况。因此， <code>MaybeUninit</code> 被设计为能够处理潜在的未初始化数据。该类型永远不会自动 <code>drop</code> （如 <code>std::mem::ManuallyDrop</code> ），编译器知道该类型可能未初始化，并且具有许多函数来正确处理未初始化的数据。</p>
<p>让我们回顾一下。我们可能不会调用 <code>std::ptr::read</code> 去读未初始化内存。我们甚至不能引用它（ <code>&amp;</code> 或者 <code>&amp;mut</code> ），因为引用规则要求引用的值必须是引用类型的有效实例，而未初始化的数据不是这种情况(除了使用 <code>MaybeUninit&lt;_&gt;</code> ，因为这显然不需要初始化）。</p>
<p>因此，我们也不应该 <code>drop</code>，因为这会创建一个可变的引用（注意，<code>fn drop(&amp;mut self))</code> 。我们可以将其转换为其他允许储存未初始化数据的类型( 创建一个未初始化的数组还是最简洁的方法)或用 <code>std :: ptr :: write</code>  到从  <code>as_mut_ptr()</code> 方法获得的指针，又或者使用 <code>MaybeUninit</code> 等等。请注意，即使类型未初始化，我们也可以分配给 <code>MaybeUninit</code> ，因为类型不会 <code>drop</code> 。</p>
<p>举例来说，假设我们要使用一个函数创建一个值数组。数组的没有实现 <code>Copy</code> 或没有const 的 <code>initializer</code> ，或者 <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a>  由于某种原因无法优化 <code>double</code> 。这种时候就用 <code>unsafe</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{MaybeUninit, transmute};

unsafe {
    // first part: initialize the array. This is one of the rare cases where
    // directly calling `assume_init` is OK, because an array of
    // `MaybeUninit` may contain uninitialized data.
    
    // 第一部分: 初始化这个数组。这种就是几种特殊情况之一，直接
    // 调用 `assume_init` 是可行的,因为 `MaybeUninit` 可以放未初		// 始化数组
    let mut array: [MaybeUninit&lt;MyType&gt;; 256] =
        MaybeUninit::uninit().assume_init();

    // second part: initialize the data. This is safe because we assign
    // to a `MaybeUninit`, which is exempt from `drop`.
    
    //  第二部分: 初始化数据。因为 `Maybeuninit` 避免了 `drop`
    for (i, elem) in array.iter_mut().enumerate() {
        *elem = MaybeUninit::new(calculate_elem(i));
    }

    // third part: transmute to the initialized array. This works because
    // `MaybeUninit&lt;T&gt;` is guaranteed to have the same Layout as `T`.
    
   // 第三部分: 转换成初始化过的数组。这是可行的，因为 `MaybeUninit&lt;T&gt;` 保证了数据填充是和 `T` 一致的
    transmute::&lt;_, [MyType; 256]&gt;(array)
}
<span class="boring">}
</span></code></pre></pre>
<p>如果任何 <code>calculate_elem(_)</code> 调用失败，则将删除整个 <code>MaybeUninits</code> 数组。 因为 <code>MaybeUninit</code> 不会 <code>drop</code> ，所以现在所有的数据都将泄漏。</p>
<p>为了避免这种情况，我们应该加入额外的移动语义的部分:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{forget, MaybeUninit, transmute};

// first extra part: We need a &quot;guard&quot; that drops all *initialized* elements
// on drop

// 加入的第一个额外部分: 我们需要一个 &quot;guard&quot;(守护) 来销毁所有初始化过的元素

struct Guard&lt;'a&gt; {
    // a mutable ref to access the array from
    array: &amp;'a mut [MaybeUninit&lt;MyType&gt;; 256],
    // the index until which all elements are initialized
    index: usize,
    // 一个可变引用允许用索引访问,使得所有元素都被初始化
}

impl Drop for Guard&lt;'_&gt; {
    // drop all elements that are initialized
    // 销毁所有被初始化的元素
    fn drop(&amp;mut self) {
        for i in 0..self.index {
            unsafe {
                std::ptr::drop_in_place(self.array[i].as_mut_ptr());
            }
        }
    }
}

unsafe {
    let mut array: [MaybeUninit&lt;MyType&gt;; 256] =
        MaybeUninit::uninit().assume_init();

    // second extra part: here we initialize the guard. From here on, it
    // borrows our array mutably. All access will be done through the guard
    // (because the borrow checker won't let us access `array` directly
    // while it's mutably borrowed).
    
    // 加入的第二个额外部分: 这里我们用 `&amp;mut array` 初始化了 `guard`。
    // (当使用可变借用时，借用检查器并不让我们直接访问数组)
    let mut guard = Guard { array: &amp;mut array, index: 0 };
    for i in 0..256 {
        guard.array[guard.index] = MaybeUninit::new(calculate_elem(i));
        // update the index so `drop` will include the newly created element.
        // 更新索引，使得包含新创建的元素
        guard.index += 1;
    }
    // third extra part: forget the guard to avoid dropping the initialized
    // elements and also end the borrow.
    
    // 加入的第三部分: 调用 `forget` ,销毁 `guard`，防止内存泄漏
    forget(guard);

    transmute::&lt;_, [MyType; 256]&gt;(array)
}
<span class="boring">}
</span></code></pre></pre>
<p>如果你认为只是为了初始化数组居然就需要这么多步骤，你是对的。同样，在这一点上，一定要衡量对性能的影响。当然不是和 <code>Vec &lt;MyType&gt;</code> 比。</p>
<p>无论如何，这显示了处理未初始化数据的规范方法：标志一个不变量(“在<code>index</code> 之前的都应该不可变 ”)，对其进行维护(“写入一个元素后索引增加”)，你可以从中受益——在这种情况下，<code>panic</code> 时也不会发生泄漏。</p>
<p>这种方法也适用于其他数据结构，但那里通常使用不同的不变量。例如，<code>Vec</code> 在 <code>resize</code> 操作前, 将内存拷贝一份放在后备内存里，并将长度设置为零，并在操作完成后将其恢复(发生泄漏时,泄漏的内存其实是比 <code>vec</code> 长度要大的)。这确保了 <code>drop</code> 不会用在未初始化或已经释放的内存上。</p>
<p>取决于不同的数据机构，这个不变量将变的晦涩难懂。例如，可以使用一个 <code>bit set</code> 对初始化的元素进行编码，因此需要比普通数组多八分之一的内存，但允许随机访问任意元素。在这种情况下，将是“初始化和 <code>bit set</code> 一一对应”。 Rust的<code> HashMaps</code> 基本上是这样做的。</p>
<blockquote>
<p>译者注:  bit set 其实就是位示图法</p>
</blockquote>
<h3><a class="header" href="#不可变的转换" id="不可变的转换">不可变的转换</a></h3>
<p>Rust关于引用的规则非常严格——在每个给定的时间点可以读取或写入多少变量。 但是有时候我们确实需要稍微改变规则。</p>
<p>为此，Rust为内部可变性提供了一种(显然得用 <code>unsafe</code>)类型，它可以使用 <code>get(＆self)</code>方法从不可变的借项中获得一个可变的指针(当然不是引用)。 还有一个<code>get_mut(&amp;mut self)</code> 的方法，该方法向内容返回可变的借用。</p>
<p>这意味着编译器将假定所有 <code>UnsafeCell</code> 中的内容都被引用了。 标准库在顶层提供了许多安全抽象，特别是 <code>Cell</code>，<code>RefCell</code> ，<code>RwLock</code> ，<code>Mutex</code> 和各种<code>Atomic*</code>类型。</p>
<blockquote>
<p>译者注: Atomic* 的意思是以Atomic开头的类型 , 这是<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>的一种</p>
</blockquote>
<p>例如，<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html">AtomicBool</a> 的定义如下(为简洁起见删除了注释)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AtomicBool {
    v: UnsafeCell&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>当然，该实现必须确保避免数据竞争(是指在非线程安全的情况下，多线程对同一个地址空间进行写操作)，通过 LLVM 内部函数使用实际的原子操作来完成的。 我还没有检查即将到来的  <a href="https://github.com/bytecodealliance/cranelift">Cranelift</a> 后端的功能，但它似乎也有某种类似的实现。 同样，在直接使用 <code>UnsafeCell</code> 之前，请检查是否有任何 <code>safe</code> 的替代品可用，虽然确定 <code>unsafe</code> 是否会给你带来足够的性能提升(或其他好处)。</p>
<h3><a class="header" href="#使用cpu的特有指令集" id="使用cpu的特有指令集">使用CPU的特有指令集</a></h3>
<p>Rust的标准库在<code>std:: arch</code> 模块中有按CPU类型分类的固有函数。它们都被定义为 <code>unsafe</code> 的，主要是因为它们可能未在你的CPU上实现。 幸运的是，有一种规范的方法可以确保你在编译时或运行时拥有相应的CPU。</p>
<p>假设你以&quot;标准&quot;的方式编写了算法，看了生成的汇编，觉得编译器生成的代码不够好。是时候掏出&quot;屠龙刀&quot;了。 但基本上就是在 Rust 里编写汇编了(因为 <code>arch</code> 内部函数是和不同架构一一对应的)。 如上所述，你需要确保用户的平台和你的一致。 以下代码显示了在编译时和运行时检查 CPU是否支持的方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// compile time check 编译时检查
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
mod simd {
    fn calculate() -&gt; .. {
        // this is a std library macro that allows us to safely access CPU
        // features by doing runtime detection
        // 这里是标准库的一个宏，通过它我们可用进行CPU的编译器检查
        
        if is_x86_feature_detected!(&quot;avx2&quot;) {
            // code using avx2 intrinsics here
        } else if is_x86_feature_detected!(&quot;sse2&quot;)
            // code using sse2 intrinsics here
        } else {
            // code using no special features, using e.g. avx2 intrinsics
            // would be UB!
        }
    }
}

#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
mod simd {
    // fallback code here
}
<span class="boring">}
</span></code></pre></pre>
<p>此示例仅具有针对x86和x86_64架构的专用代码，以及各种运行时检测到的CPU功能。 如果你希望程序在其他平台(例如ARM-NEON)上使用SIMD内部函数，则需要添加另一个 <code>#[cfg]</code> 声明。不用多说，最后你就得写上不少代码。</p>
<p>除了可用性之外，一些指令还要考虑内存对齐。 为了简化 <code>bit</code> ，内存对齐告诉我们有些地址的最后几位必须为零。 例如，一个32位值的对齐方式可能为 <code>4</code> ，这意味着其地址的最后两位应为零。 请参阅库文档以获取详细信息，并参考 <a href="chapter_3/">上一章</a> 以获取适当的帮助。</p>
<h3><a class="header" href="#内联汇编" id="内联汇编">内联汇编</a></h3>
<p>假设你正在编写内核，并且需要使用堆栈指针来处理一些&quot;奇怪&quot;的事情，或者其他不得不需要用汇编的地方。 Rust有两个 <code>FFI</code> 接口：一个是C语言，另一个是汇编。 不幸的是，这既不稳定又不安全，所以你就得使用<code>nightly</code> 版本来编译<code>#[feature(asm)]</code> 和 <code>unsafe</code> 的块。 显然，Rust无法检查你在汇编中所做的事情。 使用内联汇编的细节不在本文讨论范围之内。 请查看 <a href="https://doc.rust-lang.org/1.8.0/book/inline-assembly.html">Rust Book chapter</a>  或者 <a href="https://rust-lang.github.io/rfcs/2873-inline-asm.html">RFC text</a>。 就本文而言，不需要你熟悉 <code>FFI</code> 。</p>
<h3><a class="header" href="#与其他语言交互" id="与其他语言交互">与其他语言交互</a></h3>
<p>假如你有非常庞大的 C 代码库，并希望将其移至 Rust，不用多说，这是一项艰巨的任务。你可以先使用外部函数接口来重写代码库的一小部分，然后逐个模块进行重写，直到整个程序都用 Rust 编写，然后你就可以扔掉C了(😀)(顺带一说 <a href="https://people.gnome.org/%7Efederico/blog/a-rust-api-for-librsvg.html">librsvg</a> 就是这样做的)。或者在 C ++ 中使用 Rust。</p>
<p>无论如何，你都得在安全的，充满温暖的 Rust 世界与艰难而又无情的世界之间架起一座桥梁。既然外面的世界很危险，显然你得用 <code>unsafe</code> 与之交互。 首先，请确保你拥有正确的接口，以免你在调试时踩坑。 <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>（用于从 Rust 访问 C ）和<a href="https://github.com/eqrion/cbindgen/">cbindgen</a>（用于从 C 访问 Rust）的工具箱就显得非常有用。 如果你从 C ( 使用C接口的C++ ) 访问 Rust，请注意对象的生命周期，并将Rust对象的生存期保留在Rust代码中-也就是说，让Rust删除它们; 而对于 C 的指针，就让 C 处理它们。众所周知，Rust 有非常特殊的管理生命周期的方法，记住你的需求。</p>
<p>另一方面，如果将 C（(或是C++ 使用了 <code>extern</code> ) 包装在Rust中，则会发现 C 库通常还需要考虑数据的生命周期。一旦有了绑定，就尝试考虑类型的生命周期的问题。 unofficial patterns book 有这样一章 <a href="https://rust-unofficial.github.io/patterns/patterns/ffi-intro.html">instructive chapter</a>  。</p>
<p>如果与 C++ 交互，需要使用 <a href="https://docs.rs/cxx">cxx</a> 。但是，请注意，与通常的 <code>bindings generators</code> 不同，<code>cxx</code> 不会用 <code>unsafe</code> 标记你的函数 ！我在这里的看法是，绑定机制部分是在 Rust 中构建的，一部分是在 C++ 中构建的，它是否是 <code>safe</code> 的，这取决于你审查 C++ 的代码。你可能仍然希望将结果接口包装在一个友好的接口中，并且不会以不安全的方式被滥用。</p>
<h2><a class="header" href="#编写-unsafe-rust-的工具" id="编写-unsafe-rust-的工具">编写 <code>unsafe rust</code> 的工具</a></h2>
<p>正如我们所见，编写 <code>unsafe</code> Rust比 <code>safe</code> 的 Rust 需要多做许多工作，因为这样将不再依靠编译器检查。 因此，要踏上这条道路，最好先&quot;带上&quot;下面的这些工具：</p>
<h3><a class="header" href="#miri" id="miri">Miri</a></h3>
<p><a href="https://github.com/rust-lang/miri">Miri </a>是 <code>Rustc</code> 的 MIR (中级中间语言)，这是 Rust 在移交给 <code>LLVM</code> 或者<code>Cranelift</code>之前用来优化程序的中间表示，是一种解释器。 你可以用 <code>rustup</code> 运行 <code>rustup component add miri</code> 安装它。 它跑在  <code>cargo miri</code> 上-例如，<code> cargo miri test</code> 将在解释器中运行测试。 Miri 采用了很多可以检测未定义行为的技术，例如访问未初始化的数据，并会指出问题所在。 但是，它只会在被执行的代码上检测未定义行为，因此不能完整的覆盖代码。 </p>
<h3><a class="header" href="#clippy-and-rust-lints" id="clippy-and-rust-lints">Clippy and Rust lints</a></h3>
<p>Rust的官方 lints (静态分析工具) 中有很多对编写 <code>unsafe</code>  有帮助的 lint。 至少，missing_safety_docs棉绒将帮助您将所有不安全方法的要求记录在案。 另外，Rust编译器默认情况下不会激活所有棉绒； 致电rustc -W help将显示最新列表。</p>
<h3><a class="header" href="#prusti" id="prusti">Prusti</a></h3>
<p><a href="https://github.com/viperproject/prusti-dev">Prusti</a>  仍在开发中（目前在更新到最新的稳定Rust时存在一些问题，因此最新的稳定版本针对某些2018 Rust编译器），但是这个工具非常有前景，可让你在数学上验证给定特定条件的代码的安全性。</p>
<p>基本上，你可以用数学证明代码中某些不变量是 &quot;真的&quot; 保持不变的，这对于必须支持不安全代码的不变量的安全抽象是理想的。 有关更多信息，请参见<a href="https://viperproject.github.io/prusti-dev/user-guide/">用户指南</a>。</p>
<h3><a class="header" href="#fuzzers" id="fuzzers">Fuzzers</a></h3>
<p><a href="https://rust-fuzz.github.io/book/">Rust Fuzz Book</a> 列出了许多可与Rust一起使用的 <code>Fuzzer</code> (模糊测试器)。目前，可使用的<code>Fuzzer</code> 有 <a href="https://github.com/rust-fuzz/cargo-fuzz">cargo-fuzz/libfuzzer</a> 和 <a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy Lop / afl.rs</a>的。两者都将为的代码创建大量的测试输入，并运行它以查找触发崩溃的某种组合。</p>
<blockquote>
<p>译者注: 这个地方的 Fuzzer 是安全测试里面常用的模糊测试工具, 常见的就是上文提到的AFL 。而这种随机生成的测试样例被用于保证代码覆盖率, 每当遇到 crash (崩溃的样例) 并会记录下, 提示此处可能有漏洞。</p>
</blockquote>
<p>为了检测未初始化内存的使用，<a href="https://github.com/Shnatsel/libdiffuzz">libdiffuzz</a>是一个侵入式内存分配器，它将使用不同的值来初始化每个内存分配。通过运行两次代码并比较结果，可以确定未初始化内存的哪一部分是造成了问题。更不错的是，<code>memory sanitizer</code>  是每天更新的（<a href="https://github.com/rust-lang/rust/issues/39699">tracking lssue</a>列出了各种<code>memory sanitizer</code>及其在各个平台上的支持），会监测每一次对未初始化内存的读取，哪怕没有造成任何问题。 </p>
<p>尽管从统计学上讲， <code>Fuzzer</code> 比普通的属性测试更有可能找到代码路径，但不能保证他们会在任何时间后找到特定的代码路径。比如说我曾经遇到的标记化函数的 <code>bug</code>，就是由我在互联网上的一个随机文档中发现的一个 <code>unicode</code> 宽的空格触发的，当在运行了数十亿个测试案例的模糊测试一周后也并未发现。Rust fuzz 在 <a href="https://github.com/rust-fuzz/trophy-case">trophy case</a> 上展示了不少没被 Fuzzing 到的 <code>bug</code>。如果你找到一个同样的 <code>bug</code> ，请添加它。</p>
<blockquote>
<p>译者注: Fuzzer 不保证100%的代码覆盖率, 因为种子是随机的</p>
</blockquote>
<p><a href="https://github.com/jakubadamw/rutenspitz">rutenspitz</a> 是一个过程宏，非常适合对状态代码（例如数据结构）进行模型测试。模型测试意味着您拥有一个 “模型” ，即一个简单但缓慢的版本，可以对要确保的行为进行建模，然后使用它来测试不安全的实现。然后它将生成一系列操作，以测试相等关系是否成立。如果你遵循了我的上述建议，则应该已经有一个安全的实施方案可以进行测试。 </p>
<h2><a class="header" href="#a-hrefhttpslogrocketcomsignuplogrocketa-full-visibility-into-production-rust-apps" id="a-hrefhttpslogrocketcomsignuplogrocketa-full-visibility-into-production-rust-apps"><a href="https://logrocket.com/signup">LogRocket</a>: Full visibility into production Rust apps</a></h2>
<p>(广告时间到) 调试 Rust 应用程序是艰辛的，当我们遇到难以重现的问题时更是如此。 如果希望监视和跟踪 Rust 应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间，请尝试 <a href="https://logrocket.com/signup">LogRocket</a>。 </p>
<p><img src="chapter_3/../image/unsafe_rust.png" alt="" /></p>
<p><code>LogRocket</code> 就像Web应用程序中的 <code>DVR</code> ，实际上记录了 Rust 应用程序中发生的所有事情。 它可以汇总并报告问题发生时应用程序所处的状态，而不用猜测为什么会发生问题。 <code>LogRocket</code> 还会监视应用程序的性能，报告诸如客户端CPU负载，客户端内存使用情况等指标。 </p>
<p>走一条 rust debug 现代化之路吧!  <a href="https://logrocket.com/signup">点击即用</a>.</p>
<h1><a class="header" href="#译基于-rust-用-bevy-实现节奏大师游戏" id="译基于-rust-用-bevy-实现节奏大师游戏">「译」基于 Rust 用 Bevy 实现节奏大师游戏</a></h1>
<p>译者：<a href="https://github.com/suhanyujie">suhanyujie</a>/ 后期编辑：张汉东</p>
<blockquote>
<p>原文链接：https://caballerocoll.com/blog/bevy-rhythm-game/</p>
</blockquote>
<p>本文相关：</p>
<blockquote>
<p>Rust中文社群线上学习室 | 使用 Bevy 实现节奏大师游戏 
⁣&gt; </p>
<ul>
<li>01 <a href="https://rust-lang.feishu.cn/minutes/obcnw4jtr2832779jmg373wz">录屏</a></li>
<li>02 <a href="https://rust-lang.feishu.cn/minutes/obcnxrrm878zw3q7c9z7bx6p">录屏⁣</a></li>
</ul>
<p>Rust 中文社群 飞书群 邀请你加入：</p>
<ul>
<li>对话群： https://applink.feishu.cn/TeLAcbDR </li>
<li>话题群：https://applink.feishu.cn/TeLD868w</li>
</ul>
</blockquote>
<hr />
<h2><a class="header" href="#正文-1" id="正文-1">正文</a></h2>
<p>在这个教程中，我们基于 Rust 使用 Bevy 引擎实现一个节奏大师游戏。目的是展现如何用 Bevy 实现一些东西，特别是一些更高级的功能，如着色器，状态，和音频。</p>
<p>如果你想在进入学习之前看看最终的代码，你可以在<a href="https://github.com/guimcaballero/bevy_rhythm">这里</a>找到仓库，并且下面是一个游戏视频：</p>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_working_menu_and_game.mp4">视频资源</a></p>
<p>这款游戏很简单：箭头飞过屏幕，玩家必须在正确的时间内按下正确的方向键才能让箭头消失。如果玩家成功地做到了这一点，他们将获得积分。否则，箭头会旋转着掉下来。箭头会有不同的速度，每个箭头颜色不同。游戏还有一个选择歌曲的菜单，以及一个简单的地图制作器来帮助创建歌曲地图。</p>
<h2><a class="header" href="#bevy" id="bevy">Bevy</a></h2>
<p><a href="https://bevyengine.org/">Bevy</a> 是一个数据驱动的游戏引擎。它使用起来非常简单，令人愉悦。它使用 <a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a> 来管理游戏实体及其行为。</p>
<p>Bevy 有一个很受欢迎的社区，所以如果你对本教程有任何疑问，可以查阅 <a href="https://bevyengine.org/learn/book/introduction/">Bevy book</a>，浏览[示例]](https://github.com/bevyengine/bevy/tree/master/examples)，或者加入<a href="https://discord.gg/gMUk5Ph">官方的 Discord</a> 进行提问。</p>
<p>如果你发现教程中存在错误，请在这里开一个 <a href="https://github.com/guimcaballero/bevy_rhythm/issues">Issue</a>，我会修正它。</p>
<h2><a class="header" href="#前期准备" id="前期准备">前期准备</a></h2>
<p>在本教程中，你需要熟悉 Rust。你不必成为专家，我们不会使用任何的黑魔法。虽然不是必须的，但强烈建议你去了解一下 ECS 的工作原理。</p>
<p>如果你想阅读一些更简单的教程，我建议你阅读<a href="https://mbuffett.com/posts/bevy-snake-tutorial/">基于 Rust，使用 Bevy 实现贪吃蛇</a>，或者<a href="https://caballerocoll.com/blog/bevy-chess-tutorial/"> Bevy 实现国际象棋</a>教程，可以详细了解基础知识。</p>
<p>此外，我们将在本教程中使用着色器和 <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a>。这两种知识不是必须的，因为我会提供要使用的代码，但了解 GLSL 会使你可以修改更多的东西，并让游戏真正属于你自己的。</p>
<p>如果你之前从未使用过着色器，可以参考下面这些推荐链接开始学习：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=u5HAYVHsasc">Shadertoy 入门</a>：介绍并使用 <a href="https://www.shadertoy.com/">Shadertoy</a>。</li>
<li>Unity 着色器编码入门 —— <a href="https://www.youtube.com/watch?v=9WW5-0N1DsI">一款即兴的在线课程</a>：介绍在 Unity 中使用着色器。非 Unity 官方指定的大部分资料都在这儿。</li>
<li><a href="https://www.youtube.com/watch?v=C0uJ4sZelio">Unity 教程：着色器的实用介绍 —— 第一部分</a>：与上面类似。</li>
</ul>
<h2><a class="header" href="#创建一个项目" id="创建一个项目">创建一个项目</a></h2>
<p>和往常一样，我们使用 <code>cargo new bevy_rhythm &amp;&amp; cd bevy_rhythm</code> 创建一个空 Rust 项目。你现在可以打开该 crate 项目。并用你喜欢的编辑器打开 <code>Cargo.toml</code>，把 <code>bevy</code> 加入到依赖项中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;bevy_rhythm&quot;
version = &quot;0.1.0&quot;
authors = [&quot;You &lt;your@emailhere.com&gt;&quot;]
edition = &quot;2018&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
bevy = &quot;0.4&quot;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#快速编译" id="快速编译">快速编译</a></h2>
<p>我建议你启用快速编译，以确保开发过程不会太烦躁。以下是我们需要准备的：</p>
<ul>
<li>1.LLD 链接器：普通链接器会有点慢，所以我们把其换成 LLD 链接器进行加速：
<ul>
<li>Ubuntu: <code>sudo apt-get install lld</code></li>
<li>Arch: <code>sudo pacman -S lld</code></li>
<li>Windows: <code>cargo install -f cargo-binutils and rustup component add llvm-tools-preview</code></li>
<li>MacOS: <code>brew install michaeleisel/zld/zld</code></li>
</ul>
</li>
<li>2.为该项目启用 Rust 的 nightly 版本：rustup 工具链安装 nightly 版，并且在项目目录中设置 rustup 为 nightly 进行启用。</li>
<li>3.把<a href="https://github.com/bevyengine/bevy/blob/master/.cargo/config_fast_builds">这个文件</a>的内容拷贝到 <code>bevy_rhythm/.cargo/config</code> 中。</li>
</ul>
<p>以上就是所有要准备的事情了，现在运行游戏来编译所有的库。编译完成后，你应该在命令行中看到 <code>Hello, world!</code>。</p>
<p>注意：如果你看到游戏性能很差，或者看到<a href="https://github.com/guimcaballero/bevy_rhythm/issues/1">加载资源很慢</a>，你可以用 <code>cargo run --release</code> 的编译模式下运行。编译时间可能会稍长一些，但游戏运行会更加流畅！ </p>
<h2><a class="header" href="#开始-1" id="开始-1">开始</a></h2>
<p>任何 Bevy 游戏的第一步都是增加小段示例代码来启动应用的。打开 <code>main.rs</code>，并将已有的 <code>main</code> 函数替换为下面的内容：</p>
<pre><pre class="playground"><code class="language-rust">use bevy::{input::system::exit_on_esc_system, prelude::*};

fn main() {
    App::build()
        // 抗锯齿设置 samples 为 4
        .add_resource(Msaa { samples: 4 })
        // 设置 WindowDescriptor 资源修改标题和窗口大小
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_plugins(DefaultPlugins)
        .add_system(exit_on_esc_system.system())
        .run();
}
</code></pre></pre>
<p>如果你使用 <code>cargo run</code> 运行程序，你会看到一个空白窗口：</p>
<p><img src="https://caballerocoll.com/images/bevy_empty_window.png" alt="" /></p>
<p>这一步设置 Bevy <code>App</code>，添加默认插件。这将包括转换、输入、窗口等游戏运行所需的元素。如果你不需要这些功能， Bevy 是模块化的，你可以选择只开启你需要的功能。我们要新增这些插件，所以需要使用 <code>add_plugins</code> 和 <code>DefaultPlugins</code>。</p>
<p>我们还添加了两个资源：<code>Msaa</code> 和 <code>WindowDescriptor</code>，分别用于配置 anti-aliasing，以及窗口大小和标题。最后，我们添加了 Bevy 的 <code>exit_on_esc_system</code>，它的作用是按下 esc 键时关闭游戏。</p>
<h2><a class="header" href="#bevy-中的-ecs" id="bevy-中的-ecs">Bevy 中的 ECS</a></h2>
<p>下面是 ECS 如何在 Bevy 中工作的介绍。如果你已经知道它是如何工作的，可以<a href="https://caballerocoll.com/blog/bevy-rhythm-game/#adding-a-setup-system">跳过本节</a>。这和我们的游戏无关，我将使用 <a href="https://bevyengine.org/learn/book/getting-started/ecs/">Bevy book</a> 中的例子来说明它是如何运作的。你不需要复制这里的代码，只需读懂它即可。</p>
<p>Bevy 的 ECS 是 <a href="https://github.com/Ralith/hecs">hecs</a> 的一个分支版本。它使用 Rust 结构体作为组件，不需要添加宏或其他复杂的东西。例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 有两个字段的结构体组件
struct Position { 
    x: f32,
    y: f32
}

// 元组组件
struct Name(String);

// 我们甚至可以使用标记组件
struct Person;
<span class="boring">}
</span></code></pre></pre>
<p>Systems are just normal Rust functions, that have access to <code>Querys</code>:
&gt;这个“系统”中可以使用正常的 Rust 函数，访问 <code>Querys</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_names(mut query: Query&lt;(&amp;Position, &amp;mut Name), With&lt;Person&gt;&gt;) {
    for (pos, mut name) in query.iter_mut() {
        name.0 = format!(&quot;position: ({}, {})&quot;, pos.x, pos.y);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一次查询可以访问组件中所有实体。在前面的示例中，<code>query</code> 参数允许我们迭代包括 <code>Person</code> 组件在内以及 <code>Position</code> 和 <code>Name</code> 等组件实体。因为我们用 <code>&amp;mut Name</code> 替代 <code>&amp;Name</code>，所以可以对实体进行修改。如果对 <code>&amp;Name</code> 类型的该值进行修改，Rust 会报错。</p>
<p>有时候我们想要只在游戏开始时运行一次的机制。我们可以通过“启动系统”来做到这一点。“启动系统”和“普通系统”完全一样，唯一的区别是我们将如何把它加到游戏中，这会在后面进行详细讲解。下面是一个使用 <code>Commands</code> 生成一些实体的“启动系统”：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup(commands: &amp;mut Commands) {
    commands
        .spawn((Position { x: 1., y: 2. }, Name(&quot;Entity 1&quot;.to_string())))
        .spawn((Position { x: 3., y: 9. }, Name(&quot;Entity 2&quot;.to_string())));
}
<span class="boring">}
</span></code></pre></pre>
<p>Bevy 也有资源的概念，它可以保存全局数据。例如，内置的 <code>Time</code> 资源给我们提供游戏中的当前时间。为了在“系统”中使用这类资源，我们需要用到 <code>Res</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn change_position(mut query: Query&lt;&amp;mut Position&gt;, time: Res&lt;Time&gt;) {
    for mut pos in query.iter_mut() {
        pos.x = time.seconds_since_startup() as f32;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们自定义资源也很简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一个简单的资源
struct Scoreboard {
    score: usize,
}

// 另一个资源，它实现了 Default trait
#[derive(Default)]
struct OtherScore(f32);
<span class="boring">}
</span></code></pre></pre>
<p>我们有两种方法初始化资源：第一种是使用 <code>.add_resource</code> 并提供我们需要的结构体，另一种是实现了 <code>Default</code> 和 <code>FromResources</code> 的 <code>.init_resource</code>。</p>
<p>下面我们如何把它们加到游戏中：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::build()
        // 新增资源的第一种方法
        .add_resource(Scoreboard { score: 7 })
        // 第二种方法，通过 Default 的初始化加载资源
        .init_resource::&lt;OtherScore&gt;()

        // 增加“启动系统”，游戏启动时只会运行一次
        .add_startup_system(setup.system())
        // 增加一个“普通系统”，每一帧都会运行一次
        .add_system(set_names.system())
        .add_system(change_position.system())
        .run();
}
</code></pre></pre>
<p>Another cool thing Bevy has are Plugins, which we've already seen when we used <code>DefaultPlugins</code> in the previous section. Plugins allow us to wrap features that belong together, which then let's us enable and disable them together easily. Plugins also provide organization, which is the main purpose we'll be creating our own in this tutorial.
&gt;Bevy 还有一个很酷的东西是插件，我们在上一节使用 <code>DefaultPlugins</code> 时看到了。插件可以让我们将一些特性包装在一起，这可以让我们很容易地启用和禁用它，插件也提供了组织功能，这也是我们在这篇教程中自定义插件地主要功能点。</p>
<p>如果有些东西不清楚，不用担心，我们会在后面更详细地解释所有内容。</p>
<h2><a class="header" href="#增加系统设置" id="增加系统设置">增加系统设置</a></h2>
<p>每个游戏都需要一个相机来渲染对象，所以我们将从如何添加一个生成相机的“启动系统”开始。因为这是一款 2D 游戏，所以我们要使用 <code>Camera2dBundle</code>。</p>
<pre><pre class="playground"><code class="language-rust">use bevy::{input::system::exit_on_esc_system, prelude::*};

fn main() {
    App::build()
        // 设定[抗锯齿](https://cn.bing.com/search?q=%E7%BB%98%E5%88%B6+%E6%8A%97%E9%94%AF%E9%BD%BF&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=%E7%BB%98%E5%88%B6+%E6%8A%97%E9%94%AF%E9%BD%BF)，samples 参数值为 4
        .add_resource(Msaa { samples: 4 })
        // 设定 WindowDescriptor 资源，定义我们需要的标题和窗口大小
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_startup_system(setup.system()) // &lt;--- New
        .add_plugins(DefaultPlugins)
        .add_system(exit_on_esc_system.system())
        .run();
}

fn setup(commands: &amp;mut Commands) {
    commands.spawn(Camera2dBundle::default());
}
</code></pre></pre>
<p>bundle 是组件的集合。在本例中，<code>Camera2dBundle</code> 将创建一个包含 <code>Camera</code>，<code>OrthographicProjection</code>，<code>VisibleEntities</code>，<code>Transform</code> 和 <code>GlobalTransform</code> 的 实体。其中大部分是我们玩游戏时不需要用到的，所以我们使用抽象的 <code>Camera2dBundle</code> 添加组件。</p>
<p>注意：我们还可以使用一个元组代替 bundle 来添加所有组件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup(commands: &amp;mut Commands) {
    commands.spawn((Camera::default(), OrthographicProjection::default(), VisibleEntities::default(), Transform::default(), GlobalTransform::default()));
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码实际上还不能运行，因为我们还需要在 camera 和投影组件中设置一些字段，但我觉得它明确地体现了使用 bundle 和元组来添加结构是很相似的。</p>
<h2><a class="header" href="#加载精灵" id="加载精灵">加载精灵</a></h2>
<p>在这部分中，我们会添加一些“精灵”，让它们四处移动。为此，我们需要创建一个 <code>assets</code> 目录，我们将存储一些<a href="https://github.com/guimcaballero/bevy_rhythm/tree/main/assets/images">图像</a>和<a href="https://github.com/guimcaballero/bevy_rhythm/tree/main/assets/fonts">字体文件</a>。目录中有两个子文件夹，图像和字体。你可以点击前面提到的链接，从 GitHub 仓库下载。</p>
<p>你的资源目录应该如下所示：</p>
<pre><code>assets
├── fonts
│   └── FiraSans-Bold.ttf
└── images
    ├── arrow_blue.png
    ├── arrow_border.png
    ├── arrow_green.png
    └── arrow_red.png
</code></pre>
<p>我们将使用带颜色的箭头来表示不同速度的箭头，并使用带边框的箭头来标记目标区域。</p>
<p>有了这些静态资源，我们就可以开始编写一些游戏动画了。我们将创建一个 <code>arrows.rs</code> 文件，它将包含生成，移动，清除箭头等相关操作。首先要做的是为“箭头精灵”保留资源，这样我们就不必在每次创建箭头时重新加载它们：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;

/// 为箭头保留材料和资源
struct ArrowMaterialResource {
    red_texture: Handle&lt;ColorMaterial&gt;,
    blue_texture: Handle&lt;ColorMaterial&gt;,
    green_texture: Handle&lt;ColorMaterial&gt;,
    border_texture: Handle&lt;ColorMaterial&gt;,
}
impl FromResources for ArrowMaterialResource {
    fn from_resources(resources: &amp;Resources) -&gt; Self {
        let mut materials = resources.get_mut::&lt;Assets&lt;ColorMaterial&gt;&gt;().unwrap();
        let asset_server = resources.get::&lt;AssetServer&gt;().unwrap();

        let red_handle = asset_server.load(&quot;images/arrow_red.png&quot;);
        let blue_handle = asset_server.load(&quot;images/arrow_blue.png&quot;);
        let green_handle = asset_server.load(&quot;images/arrow_green.png&quot;);
        let border_handle = asset_server.load(&quot;images/arrow_border.png&quot;);
        ArrowMaterialResource {
            red_texture: materials.add(red_handle.into()),
            blue_texture: materials.add(blue_handle.into()),
            green_texture: materials.add(green_handle.into()),
            border_texture: materials.add(border_handle.into()),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过实现 <code>FromResources</code> trait，在我们调用 <code>.init_resource::&lt;ArrowMaterialResource&gt;()</code> 时，Bevy 会管理并初始化资源，在进程中加载图片。</p>
<p>如你所看到的，实际的资源加载是 <code>Handle&lt;ColorMaterial&gt;</code> 而不是 <code>ColorMaterials</code>。这样，当我们创建箭头实例时，我们可以使用对应的 handle，并且它们将复用已存在的资源，而不是每个都各自独有一份。</p>
<h2><a class="header" href="#生成并移动箭头" id="生成并移动箭头">生成并移动箭头</a></h2>
<p>我们接下来要做的是生成箭头并在屏幕上移动它们。我们从实现每秒生成一个箭头的“系统”开始。箭头会包含一个名为 <code>Arrow</code> 的空（结构体）组件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 箭头组件
struct Arrow;

/// 跟踪何时生成新箭头
struct SpawnTimer(Timer);

/// 生成箭头
fn spawn_arrows(
    commands: &amp;mut Commands,
    materials: Res&lt;ArrowMaterialResource&gt;,
    time: Res&lt;Time&gt;,
    mut timer: ResMut&lt;SpawnTimer&gt;,
) {
    if !timer.0.tick(time.delta_seconds()).just_finished() {
        return;
    }

    let transform = Transform::from_translation(Vec3::new(-400., 0., 1.));
    commands
        .spawn(SpriteBundle {
            material: materials.red_texture.clone(),
            sprite: Sprite::new(Vec2::new(140., 140.)),
            transform,
            ..Default::default()
        })
        .with(Arrow);
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个系统中，我们使用了 <code>Timer</code>，这是 Bevy 中执行每隔 <code>x</code> 秒重复操作的最佳方式。我们使用 <a href="https://rust-unofficial.github.io/patterns/patterns/newtype.html">newtype 模式</a>进行封装，这样我们能够把 <code>SpawnTimer</code> 与其他的定时器区分开。我们需要使用形如 <code>.add_resource(SpawnTimer(Timer::from_seconds(1.0, true)))</code> 的调用方式进行初始化，调用稍后会进行。将 <code>true</code> 作为参数值传递表示计时器结束时会再次重复执行。</p>
<p>要使用计时器，我们必须手动调用它的 <code>tick</code> 方法，入参 time 是距离上次调用所间隔的时间差，然后我们可以使用 <code>just_finished</code> 来查看定时器是否完成。实际上我们所做的是提前检查定时器是否完成来确保 <code>spawn_arrows</code> 系统每秒只运行一次。</p>
<p>系统的其余部分将创建一个 <code>Transform</code> 组件，我们将其添加到箭头组件中，它会返回 <code>SpriteBundle</code> 从而生成箭头，并给箭头实体一个来自 <code>ArrowMaterialResource</code> 的红色纹理。我们使用 <code>Commands</code> 中的 <code>with</code> 方法添加了 <code>Arrow</code> 组件。这样，我们创建的实体将拥有所有的 <code>SpriteBundle</code> 和 <code>Arrow</code> 组件。</p>
<p>注意：这个系统只是临时的，并且它会被在某个特定时间内生成箭头的东西所覆盖。</p>
<p>现在，我们生成的那些箭头就在那了，我们需要用另一个系统让它们向右移动：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 箭头前移
fn move_arrows(time: Res&lt;Time&gt;, mut query: Query&lt;(&amp;mut Transform, &amp;Arrow)&gt;) {
    for (mut transform, _arrow) in query.iter_mut() {
        transform.translation.x += time.delta_seconds() * 200.;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>move_arrows</code> 使用 <code>Query</code> 来获取所有带有 <code>Transform</code> 和 <code>Arrow</code> 组件的实体，并通过增加 x 坐标值来将它们向右移动一点点。我们还使用了 <code>Time::delta_seconds()</code> 来根据当前帧到上一帧的时间来增加距离。 </p>
<p>我们把这些 <code>ArrowMaterialResource</code> 和 <code>SpawnTimer</code> 等系统连接到一个插件中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArrowsPlugin;
impl Plugin for ArrowsPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app
            // 初始化资源
            .init_resource::&lt;ArrowMaterialResource&gt;()
            .add_resource(SpawnTimer(Timer::from_seconds(1.0, true)))
            // 增加 system
            .add_system(spawn_arrows.system())
            .add_system(move_arrows.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们现在可以将 <code>main.rs</code> 改为如下内容：</p>
<pre><pre class="playground"><code class="language-rust">use bevy::{input::system::exit_on_esc_system, prelude::*};

mod arrows;
use arrows::ArrowsPlugin;

fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin) // &lt;--- New
        .run();
}

fn setup(commands: &amp;mut Commands) {
    commands.spawn(Camera2dBundle::default());
}
</code></pre></pre>
<p>我们需要做的只是增加 <code>.add_plugin(ArrowsPlugin)</code>，这样所有的系统和资源就被正确地集成在 <code>arrows.rs</code> 中。</p>
<p>如果你运行程序，你会看到箭头在屏幕上飞舞：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_red_arrows_moving.mp4">视频资源</a></p>
</blockquote>
<h2><a class="header" href="#类型和常量" id="类型和常量">类型和常量</a></h2>
<p>我们在上一节中对一些值硬编码了。因此我们需要重新使用它们，我们要新建一个小模块来保存我们的常量。创建一个名为 <code>consts.rs</code> 的文件，并添加以下内容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 箭头移动的速度
pub const BASE_SPEED: f32 = 200.;

/// 箭头生成时的 X 坐标值，应该在屏幕之外
pub const SPAWN_POSITION: f32 = -400.;

/// 箭头应该被正确点击时的 X 坐标值
pub const TARGET_POSITION: f32 = 200.;

/// 点击箭头时的容错间隔
pub const THRESHOLD: f32 = 20.;

/// 箭头从刷出到目标区域的总距离
pub const DISTANCE: f32 = TARGET_POSITION - SPAWN_POSITION;
<span class="boring">}
</span></code></pre></pre>
<p>其中一些常数稍后才会用到。在 <code>main.rs</code> 中增加 <code>mod consts</code>，以导入模块使其可用。我们可以在 <code>arrows.rs</code> 中的 <code>spawn_arrows</code> 和 <code>move_arrows</code> 替换掉对应硬编码的值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::consts::*;

fn spawn_arrows(
    commands: &amp;mut Commands,
    materials: Res&lt;ArrowMaterialResource&gt;,
    time: Res&lt;Time&gt;,
    mut timer: ResMut&lt;SpawnTimer&gt;,
) {
    if !timer.0.tick(time.delta_seconds()).just_finished() {
        return;
    }

    let transform = Transform::from_translation(Vec3::new(SPAWN_POSITION, 0., 1.));
    commands
        .spawn(SpriteBundle {
            material: materials.red_texture.clone(),
            sprite: Sprite::new(Vec2::new(140., 140.)),
            transform,
            ..Default::default()
        })
        .with(Arrow);
}

/// 箭头前移
fn move_arrows(time: Res&lt;Time&gt;, mut query: Query&lt;(&amp;mut Transform, &amp;Arrow)&gt;) {
    for (mut transform, _arrow) in query.iter_mut() {
        transform.translation.x += time.delta_seconds() * BASE_SPEED;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们的箭头在屏幕上移动，但他们都面向相同的方向、相同的速度移动，且颜色相同。为了能够区分它们，我们将创建两个不同的枚举，一个用于表示方向（上、下、左、右），一个表示速度（慢、中、快）。</p>
<p>注意：我们把它叫做 <code>Directions</code> 而非 <code>Direction</code>，因为后者是一个<a href="https://docs.rs/bevy/0.4.0/bevy/prelude/enum.Direction.html"> Bevy 枚举</a>。通过给它取一个稍微不一样的名字，防止混淆带来的麻烦。</p>
<p>让我们创建一个 <code>types.rs</code> 文件，并把上面提到的枚举值放于其中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::consts::*;
use bevy::input::{keyboard::KeyCode, Input};
use core::f32::consts::PI;

#[derive(Copy, Clone, Debug, PartialEq)]
pub enum Directions {
    Up,
    Down,
    Left,
    Right,
}
impl Directions {
    /// 检查相应的方向键是否被按下
    pub fn key_just_pressed(&amp;self, input: &amp;Input&lt;KeyCode&gt;) -&gt; bool {
        let keys = match self {
            Directions::Up =&gt; [KeyCode::Up, KeyCode::D],
            Directions::Down =&gt; [KeyCode::Down, KeyCode::F],
            Directions::Left =&gt; [KeyCode::Left, KeyCode::J],
            Directions::Right =&gt; [KeyCode::Right, KeyCode::K],
        };

        keys.iter().any(|code| input.just_pressed(*code))
    }

    /// 返回此方向的箭头的旋转角度
    pub fn rotation(&amp;self) -&gt; f32 {
        match self {
            Directions::Up =&gt; PI * 0.5,
            Directions::Down =&gt; -PI * 0.5,
            Directions::Left =&gt; PI,
            Directions::Right =&gt; 0.,
        }
    }

    /// 返回此方向的箭头的 y 坐标值
    pub fn y(&amp;self) -&gt; f32 {
        match self {
            Directions::Up =&gt; 150.,
            Directions::Down =&gt; 50.,
            Directions::Left =&gt; -50.,
            Directions::Right =&gt; -150.,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们添加 <code>Directions</code> 枚举。并且已经实现了三种不同的方法。</p>
<p><code>key_just_pressed</code>，用于检查被按下的方向键。我已经决定增加 <code>D, F, J, K</code> 作为可能的键，因为我键盘上的方向键比较小。如果你是 FPS 玩家，你可以使用 <code>W, S, A, D</code>，或者 VIM 世界的 <code>K, J, H, L</code> 来替代它们。</p>
<p>注意：如果你不太习惯使用迭代器，下面是用传统的方法实现 <code>key_just_pressed</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 检查与方向对应的按键是否被按下
pub fn key_just_pressed(&amp;self, input: &amp;Input&lt;KeyCode&gt;) -&gt; bool {
    match self {
        Up =&gt; input.just_pressed(KeyCode::Up) || input.just_pressed(KeyCode::D),
        Down =&gt; input.just_pressed(KeyCode::Down) || input.just_pressed(KeyCode::F),
        Left =&gt; input.just_pressed(KeyCode::Left) || input.just_pressed(KeyCode::J),
        Right =&gt; input.just_pressed(KeyCode::Right) || input.just_pressed(KeyCode::K),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>rotation</code> 表示我们需要将“箭头精灵”旋转多少度以将其指向正确的方向。<code>y</code> 表示箭头的 <code>y</code> 坐标值。我决定把箭头的顺序调整为 <code>Up, Down, Left, Right</code>，但如果你喜欢其他顺序，你可以自己修改。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, Debug)]
pub enum Speed {
    Slow,
    Medium,
    Fast,
}
impl Speed {
    /// 返回箭头移动的实际速度
    pub fn value(&amp;self) -&gt; f32 {
        BASE_SPEED * self.multiplier()
    }
    /// Speed 乘数
    pub fn multiplier(&amp;self) -&gt; f32 {
        match self {
            Speed::Slow =&gt; 1.,
            Speed::Medium =&gt; 1.2,
            Speed::Fast =&gt; 1.5,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来，我们添加了 <code>Speed</code> 枚举。我们实现了两个方法：一个是乘法，它表示箭头应该相对于 <code>BASE_SPEED</code> 所移动的距离；另一个是 <code>value</code>，它是执行乘法运算得到的值。</p>
<p>这是一部分代码，我不希望特别复杂！接下来要添加的类型是 <code>ArrowTime</code> 和 <code>SongConfig</code>。前者记录何时生成一个箭头，以及它的方向和速度。第二个将保存所有箭头实体的列表：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug)]
/// 跟踪记录箭头应该在什么时候生成，以及箭头的速度和方向。
pub struct ArrowTime {
    pub spawn_time: f64,
    pub speed: Speed,
    pub direction: Directions,
}

#[derive(Debug)]
pub struct SongConfig {
    pub arrows: Vec&lt;ArrowTime&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们的 <code>ArrowTime</code> 有个问题。在内部，我们需要知道箭头什么时候生成，但在生成它时，我们希望指定应该在什么时候点击它。因为每个箭头都有不同的速度，所以仅仅减去几秒是不够的。为了解决这个问题，我们要创建一个 <code>new</code> 函数，包含 <code>click_time</code>，<code>speed</code> 和 <code>direction</code>，并设置相应的 <code>spawn_time</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ArrowTime {
    fn new(click_time: f64, speed: Speed, direction: Directions) -&gt; Self {
        let speed_value = speed.value();
        Self {
            spawn_time: click_time - (DISTANCE / speed_value) as f64,
            speed,
            direction,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为了进行测试，我们将创建一个函数，它返回硬编码的 <code>SongConfig</code>，其中包含了不同的速度和方向的箭头：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_config() -&gt; SongConfig {
    SongConfig {
        arrows: vec![
            ArrowTime::new(1., Speed::Slow, Directions::Up),
            ArrowTime::new(2., Speed::Slow, Directions::Down),
            ArrowTime::new(3., Speed::Slow, Directions::Left),
            ArrowTime::new(4., Speed::Medium, Directions::Up),
            ArrowTime::new(5., Speed::Fast, Directions::Right),
        ],
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，我们可以进入 <code>main.rs</code> 并将 <code>setup</code> 系统修改成下方所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod types;

fn setup(commands: &amp;mut Commands) {
    let config = types::load_config();

    commands
        .spawn(Camera2dBundle::default())
        .insert_resource(config);
}
<span class="boring">}
</span></code></pre></pre>
<p>注意：我们使用 <code>insert_resource</code> 替代 <code>add_resource</code> 或 <code>init_resource</code>，因为后者是 <code>AppBuilder</code>，前者是用在 <code>Commands</code> 中。</p>
<p>如果我们现在运行游戏，没有任何变化，但仍然是能运行的，这很棒！我们进入 <code>arrows.rs</code> 文件，修改它使它能根据 <code>SongConfig</code> 中的列表生成箭头。</p>
<h2><a class="header" href="#定时生成箭头" id="定时生成箭头">定时生成箭头</a></h2>
<p>现在我们有了一个要生成的箭头列表，我们可以删除所有定时器的内容，并修改 <code>spawn_arrows</code> 系统来检查每一帧刷出的箭头。</p>
<p>我们可以想到的第一个实现是循环遍历 <code>SongConfig</code> 中的所有箭头，并检查哪些箭头应该在当前帧中生成。这是可行的，但我们会在每一帧都循环遍历一个可能会很大的数组。我们硬编码的只有 5 个箭头，这不成问题，但一整首歌的情况下，箭头可能会超过 1000 个，就算电脑很快，玩家也不希望游戏让它们的 CPU “热”起来。</p>
<p>相反，我们将假设 <code>SongConfig</code> 中的箭头是有序的。我们需要在歌曲开始前将它们进行排序，这很简单。了解了这一点，我们只能先检查列表中的第一个箭头，如果它应该被生成出来，我们也会检查下一个箭头，一次类推，直到我们到达那个不需要再生成的箭头为止。由于箭头是有序的，如果一个箭头不需要生成，那么其后的箭头也无需生成。在这之后，我们需要移除列表中已经被生成的箭头。 </p>
<p>我们还需要给 <code>Arrow</code> 新增 <code>Speed</code> 和 <code>Directions</code> 字段：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在顶部
use crate::types::*;

/// “精灵实体”上的组件
struct Arrow {
    speed: Speed,
    direction: Directions,
}

/// 生成箭头
fn spawn_arrows(
    commands: &amp;mut Commands,
    mut song_config: ResMut&lt;SongConfig&gt;,
    materials: Res&lt;ArrowMaterialResource&gt;,
    time: Res&lt;Time&gt;,
) {
    // 我们得到了从启动到当前的时间（secs）以及到最后一次迭代的时间（secs_last），这样我们就可以检查是否有箭头应该在这个窗口中生成。

    // 歌曲在启动后 3 秒开始，所以减去 3 秒。
    let secs = time.seconds_since_startup() - 3.;
    let secs_last = secs - time.delta_seconds_f64();

    // 计数器用于计算列表中产生和删除箭头数量
    let mut remove_counter = 0;
    for arrow in &amp;song_config.arrows {
        // 列表是有序的，所以我们遍历检查直到第一个不满足条件为止
        // 检查箭头是否应该在当前帧和下一帧之间的时间点生成
        if secs_last &lt; arrow.spawn_time &amp;&amp; arrow.spawn_time &lt; secs {
            remove_counter += 1;

            // 根据速度得到与之匹配的箭头素材（纹理）
            let material = match arrow.speed {
                Speed::Slow =&gt; materials.red_texture.clone(),
                Speed::Medium =&gt; materials.blue_texture.clone(),
                Speed::Fast =&gt; materials.green_texture.clone(),
            };

            let mut transform =
                Transform::from_translation(Vec3::new(SPAWN_POSITION, arrow.direction.y(), 1.));
            // 按一定的方向旋转箭头
            transform.rotate(Quat::from_rotation_z(arrow.direction.rotation()));
            commands
                .spawn(SpriteBundle {
                    material,
                    sprite: Sprite::new(Vec2::new(140., 140.)),
                    transform,
                    ..Default::default()
                })
                .with(Arrow {
                    speed: arrow.speed,
                    direction: arrow.direction,
                });
        } else {
            break;
        }
    }

    // 移除列表中生成的箭头
    for _ in 0..remove_counter {
        song_config.arrows.remove(0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面这段代码，我们来分析一下它。</p>
<p>在“系统”开始时，我们先获取游戏已经开始多久了，以及“系统”最后一次运行的时间点。我们使用 <a href="https://docs.rs/bevy/0.4.0/bevy/core/struct.Time.html#method.delta_seconds_f64">delta_seconds_f64</a> 来获取，它返回自最后一次游戏更新以来的时间。有了这两个值，我们就能知道该生成哪个箭头。因为 Bevy 不会每纳秒都更新（不代表所有的游戏引擎），所以如果只是简单地检查 <code>spawn_time</code> 是否等于当前时间会导致我们跳过需要处理的箭头。例如，我们可能有一个箭头，它刷出的时间被设为 <code>3.0</code>。Bevy 可以在 <code>2.99</code> 时运行这个“系统”，然后 <code>3.01</code> 时运行一次。由于箭头被指定为在 <code>3.0</code> 时生成，它就与运行“系统”的时间不匹配，导致它永远不会生成。</p>
<p>我们换个方法，在“系统”开始时检查当前时间和最后结束时的时间，对于上面的举例，在第二次运行该“系统”时，就会有 <code>secs = 3.01</code> 以及 <code>secs_last = 2.99</code>，因为我们的箭头产生的时间超过 <code>secs_last</code>，但小于下一帧的 <code>secs</code>，所以能够生成。大功告成！</p>
<p>有了这个，我们可以对 <code>move_arrows</code> 做一下小修改，让它兼顾速度的影响，可以使用我们之前创建的 <code>Speed::value()</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 把箭头向前移动
fn move_arrows(time: Res&lt;Time&gt;, mut query: Query&lt;(&amp;mut Transform, &amp;Arrow)&gt;) {
    for (mut transform, arrow) in query.iter_mut() {
        transform.translation.x += time.delta_seconds() * arrow.speed.value();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>很酷，现在每个箭头都显示了正确的颜色，并以相应的速度移动：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_colored_arrows_moving_at_speed.mp4">视频资源</a></p>
</blockquote>
<h2><a class="header" href="#增加目标区域箭头" id="增加目标区域箭头">增加目标区域箭头</a></h2>
<p>现在我们将使用 <code>border_texture</code> 去创造目标箭头，以便玩家能够知道何时应该按下按键。为此，我们将创建另一个“启动系统”，<code>setup_target_arrows</code> 以及一个标记组件，<code>TargetArrow</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TargetArrow;

fn setup_target_arrows(commands: &amp;mut Commands, materials: Res&lt;ArrowMaterialResource&gt;) {
    use Directions::*;
    let directions = [Up, Down, Left, Right];

    for direction in directions.iter() {
        let mut transform =
            Transform::from_translation(Vec3::new(TARGET_POSITION, direction.y(), 1.));
        transform.rotate(Quat::from_rotation_z(direction.rotation()));
        commands
            .spawn(SpriteBundle {
                material: materials.border_texture.clone(),
                sprite: Sprite::new(Vec2::new(140., 140.)),
                transform,
                ..Default::default()
            })
            .with(TargetArrow);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为了创建四个箭头，我们创建了一个有四个方向值的数组，然后循环调用 <code>border_texture</code> 和空的 <code>TargetArrow</code> 组件。</p>
<p>不要忘记在 <code>ArrowsPlugin</code> 中添加 <code>setup_target_arrows</code> 作为“启动系统”：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArrowsPlugin;
impl Plugin for ArrowsPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.init_resource::&lt;ArrowMaterialResource&gt;()
            .add_startup_system(setup_target_arrows.system())
            .add_system(spawn_arrows.system())
            .add_system(move_arrows.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>好了，我们现在把“目标区域箭头”准备好了。</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_target_arrows.mp4">视频资源</a></p>
</blockquote>
<h2><a class="header" href="#按键按下时清除箭头" id="按键按下时清除箭头">按键按下时清除箭头</a></h2>
<p>现在我们有了目标箭头，我们接下来要实现一个“系统”，它的作用是，当箭头刷出时，并且如果在特定的阈值内，用户点击了正确的操作键，箭头就会消失。我们将创建一个名为 <code>despawn_arrows</code> 的新“系统”：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 用户在箭头到达尽头前按下正确的按键，箭头消失。
fn despawn_arrows(
    commands: &amp;mut Commands,
    query: Query&lt;(Entity, &amp;Transform, &amp;Arrow)&gt;,
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    for (entity, transform, arrow) in query.iter() {
        let pos = transform.translation.x;

        // 检查按下按键时，是否是在特定的阈值内
        if (TARGET_POSITION - THRESHOLD..=TARGET_POSITION + THRESHOLD).contains(&amp;pos)
            &amp;&amp; arrow.direction.key_just_pressed(&amp;keyboard_input)
        {
            commands.despawn(entity);
        }

        // 当箭头离开屏幕时，箭头消失
        if pos &gt;= 2. * TARGET_POSITION {
            commands.despawn(entity);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们使用 <code>Query</code> 来查询所有实现了 <code>Transform</code> 和 <code>Arrow</code> 的实体。我们在查询中添加了 <code>Entity</code>，这样可以访问实体的“id”，然后我们可以在 <code>Commands::despawn()</code> 中根据它来消除实体。然后我们循环所有箭头，并检查 x 坐标值是否在点击的阈值内，如果是，则消除箭头。还有第二个检查，当箭头被错过离开屏幕时，它在最后也会被消除。它是在 x 坐标值大于等于 <code>2. * TARGET_POSITION</code> 时消除。 </p>
<p>记得用 <code>.add_system(despawn_arrows.system())</code> 将“系统”添加到 <code>ArrowsPlugin</code> 中，这样，运行游戏时，当我们斜着看的时候，也可以将其视为一种游戏！</p>
<h2><a class="header" href="#增加基础-ui" id="增加基础-ui">增加基础 UI</a></h2>
<p>在这一节中，我们将实现一些基本的 UI，目前只是显示了歌曲中的当前时间。我们会把它保存在 <code>ui.rs</code> 中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;

fn setup_ui(
    commands: &amp;mut Commands,
    asset_server: ResMut&lt;AssetServer&gt;,
    mut color_materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
) {
    let font = asset_server.load(&quot;fonts/FiraSans-Bold.ttf&quot;);
    let material = color_materials.add(Color::NONE.into());

    commands
        // 时间文本节点
        .spawn(NodeBundle {
            style: Style {
                position_type: PositionType::Absolute,
                position: Rect {
                    left: Val::Px(10.),
                    top: Val::Px(10.),
                    ..Default::default()
                },
                ..Default::default()
            },
            material: material.clone(),
            ..Default::default()
        })
        .with_children(|parent| {
            parent
                .spawn(TextBundle {
                    text: Text {
                        value: &quot;Time: 0.0&quot;.to_string(),
                        font: font.clone(),
                        style: TextStyle {
                            font_size: 40.0,
                            color: Color::rgb(0.9, 0.9, 0.9),
                            ..Default::default()
                        },
                    },
                    ..Default::default()
                })
                .with(TimeText);
        });
}

struct TimeText;
<span class="boring">}
</span></code></pre></pre>
<p>在这个系统中，我们使用了父子关系模式（parenting），使得子实体可以相对于父实体进行转换。当我们把子实体加到父实体中后，给它一个合适的命名 <code>with_children</code>，它的参数是一个闭包，闭包接受一个类似于 <code>Commands</code> 的结构体类型 <code>ChildBuilder</code> 参数。在这个例子中，我创建了一个 <code>NodeBundle</code> 作为父实体，并将 <code>TextBundle</code> 作为子实体添加到其中。我们使用类似于 css 风格的 <code>Style</code> 组件让父节点坐落在屏幕的左上角。我们给文本实体增加了 <code>TimeText</code> 标记组件，这样我们就可以查询它，并且可以在任意帧中修改它。</p>
<p>现在，我们可以添加一个“系统”，它可以在每一帧中更新文本：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_time_text(time: Res&lt;Time&gt;, mut query: Query&lt;(&amp;mut Text, &amp;TimeText)&gt;) {
    // 歌曲在实时启动 3 秒后开始
    let secs = time.seconds_since_startup() - 3.;

    // 在歌曲开始播放前不做任何处理
    if secs &lt; 0. {
        return;
    }

    for (mut text, _marker) in query.iter_mut() {
        text.value = format!(&quot;Time: {:.2}&quot;, secs);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>该系统使用内置的 <code>Time</code> 资源，以及具有 <code>Text</code> 和 <code>TimeText</code> 的组件的实体查询。之后，我们只需要循环遍历它们并更新文本值。在实际情况中，应该只有一个实体能匹配上查询，所以我们可以只需获取第一个实体并完成此次操作，但无论如何我还是倾向于使用循环。这样，如果将来我们决定创建多个“系统”，我们就不必修改其中的代码了。</p>
<p>我们通过创建一个插件来完成该代码文件的编写：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UIPlugin;
impl Plugin for UIPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.add_startup_system(setup_ui.system())
            .add_system(update_time_text.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，进入 <code>main.rs</code>，把 <code>CameraUiBundle</code> 加到 <code>setup</code> “系统”中，并导入插件：</p>
<pre><pre class="playground"><code class="language-rust">use bevy::{input::system::exit_on_esc_system, prelude::*};

mod arrows;
use arrows::ArrowsPlugin;
mod consts;
mod types;
mod ui;
use ui::UIPlugin;

fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin)
        .add_plugin(UIPlugin) // &lt;--- 新代码
        .run();
}

fn setup(commands: &amp;mut Commands) {
    let config = types::load_config();

    commands
        .spawn(Camera2dBundle::default())
        .spawn(CameraUiBundle::default()) // &lt;--- 新代码
        .insert_resource(config);
}
</code></pre></pre>
<p><code>CameraUiBundle</code> 和 <code>Camera2dBundle</code> 很类似，但对于 UI 元素。如果不显式地添加它，文本就不会显示。因为我们之前已经添加了它，现在可以运行游戏，在屏幕上可以看到华丽地文字：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_time_text.mp4">视频资源</a></p>
</blockquote>
<h2><a class="header" href="#增加得分" id="增加得分">增加得分</a></h2>
<p>在本节中，我们将创建得分系统，以便于玩家能过够在每次玩耍后看到自己的表现。为此，我们打开另一个文件 <code>score.rs</code>。在其中，我们将创建一个新的资源来记录分数以及正确的箭头和失败的箭头数量：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::consts::*;

#[derive(Default)]
pub struct ScoreResource {
    corrects: usize,
    fails: usize,

    score: usize,
}

impl ScoreResource {
    /// 增加合适的次数值以及得分
    pub fn increase_correct(&amp;mut self, distance: f32) -&gt; usize {
        self.corrects += 1;

        // 根据按下的按键的及时性获取一个 0 到 1 的值
        let score_multiplier = (THRESHOLD - distance.abs()) / THRESHOLD;
        // 最少增加 10 分，最多不超过 100 分。
        let points = (score_multiplier * 100.).min(100.).max(10.) as usize;
        self.score += points;

        points
    }

    /// 统计失败的次数
    pub fn increase_fails(&amp;mut self) {
        self.fails += 1;
    }

    // Getters

    pub fn score(&amp;self) -&gt; usize {
        self.score
    }
    pub fn corrects(&amp;self) -&gt; usize {
        self.corrects
    }
    pub fn fails(&amp;self) -&gt; usize {
        self.fails
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>ScoreResource</code> 是一个简单的结构体，它有三个 <code>usize</code> 类型的私有字段。我们没有将字段设计成公有，而是设计成成员属性的 getter 和 setter。通过这种方式，增加合适的箭头数量的唯一方法是通过 <code>increase_correct</code>，它也能增加积分，我们需要保证有了这个方法后不会又编写另一个类似功能的方法。在这款游戏中，我们不需要这样，因为我们只需在一个地方增加分数，但对于其他更大的项目而言，这种做法更让我们有信心维护，它不会造成意料之外的漏洞。</p>
<p>我们把这个资源添加到 <code>main.rs</code>，并加上下面的引入代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod score;
use score::ScoreResource;
<span class="boring">}
</span></code></pre></pre>
<p>使用下面的代码替换 <code>main</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .init_resource::&lt;ScoreResource&gt;() // &lt;--- New
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin)
        .add_plugin(UIPlugin)
        .run();
}
</code></pre></pre>
<p>完成之后，我们就能使用“系统”上的资源了。也就是说，我们对 <code>arrows.rs</code> 文件中的 <code>despawn_arrows</code> 系统做一些调整，这样，当箭头消失时，就会触发调用增加积分方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::ScoreResource;

/// 当它们到达终点时，正确点击了按钮，就会消除箭头
fn despawn_arrows(
    commands: &amp;mut Commands,
    query: Query&lt;(Entity, &amp;Transform, &amp;Arrow)&gt;,
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    
    // 新代码
    mut score: ResMut&lt;ScoreResource&gt;,
) {
    for (entity, transform, arrow) in query.iter() {
        let pos = transform.translation.x;

        // 检查箭头是否是在阈值内点击的
        if (TARGET_POSITION - THRESHOLD..=TARGET_POSITION + THRESHOLD).contains(&amp;pos)
            &amp;&amp; arrow.direction.key_just_pressed(&amp;keyboard_input)
        {
            commands.despawn(entity);

            // 新代码
            let _points = score.increase_correct(TARGET_POSITION - pos);
        }

        // 离开屏幕时，箭头消失
        if pos &gt;= 2. * TARGET_POSITION {
            commands.despawn(entity);

            // 新代码
            score.increase_fails();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>改动很简单，我们增加 <code>mut score: ResMut&lt;ScoreResource&gt;</code> 作为系统的参数，以便我们可以编辑得分，我们添加了一个 <code>increase_correct</code> 方法，它会帮助我们增加积分，并且还有一个 <code>increase_fails</code> 方法，用于表示箭头离开屏幕消失时，积分增加失败。</p>
<p>现在，拥有一个得分系统很不错，但如果玩家无法看到自己的表现，那就没啥价值了！我们需要在 UI 模板中加一些东西，以显示分数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::ScoreResource;

// 新代码
struct ScoreText;
fn update_score_text(score: ChangedRes&lt;ScoreResource&gt;, mut query: Query&lt;(&amp;mut Text, &amp;ScoreText)&gt;) {
    for (mut text, _marker) in query.iter_mut() {
        text.value = format!(
            &quot;Score: {}. Corrects: {}. Fails: {}&quot;,
            score.score(),
            score.corrects(),
            score.fails()
        );
    }
}

pub struct UIPlugin;
impl Plugin for UIPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.add_startup_system(setup_ui.system())
            .add_system(update_time_text.system())
            .add_system(update_score_text.system()); // &lt;--- 新代码
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>update_score_text</code> 中，我们使用 <code>ChangedRes</code>，而非普通的 <code>Res</code>。它们的区别在于后者会在每一帧都会运行一次，而 <code>ChangedRes</code> 只会在资源发生改变时才会运行。这很酷，因为分数不会再每一帧里都发生变化，所以这样可以节省一些开销，只需在需要时才更新文本。然后，它在具有 <code>ScoreText</code> 组件的实体上设置文本值（和 <code>TimeText</code> 一样，应该只有一个，但为什么要限制）。</p>
<p>我们还要修改 <code>setup_ui</code> 中的一些东西，在第二次产生 <code>NodeBundle</code> 和 <code>TextBundle</code> 时，使用 <code>ScoreText</code> 组件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_ui(
    commands: &amp;mut Commands,
    asset_server: ResMut&lt;AssetServer&gt;,
    mut color_materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
) {
    let font = asset_server.load(&quot;fonts/FiraSans-Bold.ttf&quot;);
    let material = color_materials.add(Color::NONE.into());

    commands
        // Time 文本节点
        .spawn(NodeBundle {
            style: Style {
                position_type: PositionType::Absolute,
                position: Rect {
                    left: Val::Px(10.),
                    top: Val::Px(10.),
                    ..Default::default()
                },
                ..Default::default()
            },
            material: material.clone(),
            ..Default::default()
        })
        .with_children(|parent| {
            parent
                .spawn(TextBundle {
                    text: Text {
                        value: &quot;Time: 0.0&quot;.to_string(),
                        font: font.clone(),
                        style: TextStyle {
                            font_size: 40.0,
                            color: Color::rgb(0.8, 0.8, 0.8),
                            ..Default::default()
                        },
                    },
                    ..Default::default()
                })
                .with(TimeText);
        })
        
        // 新代码
        .spawn(NodeBundle {
            style: Style {
                position_type: PositionType::Absolute,
                position: Rect {
                    left: Val::Px(10.),
                    bottom: Val::Px(10.),
                    ..Default::default()
                },
                ..Default::default()
            },
            material,
            ..Default::default()
        })
        .with_children(|parent| {
            parent
                .spawn(TextBundle {
                    text: Text {
                        value: &quot;Score: 0. Corrects: 0. Fails: 0&quot;.to_string(),
                        font,
                        style: TextStyle {
                            font_size: 40.0,
                            color: Color::rgb(0.8, 0.8, 0.8),
                            ..Default::default()
                        },
                    },
                    ..Default::default()
                })
                .with(ScoreText);
        });
}
<span class="boring">}
</span></code></pre></pre>
<p>我已经打算把这个文本设置在屏幕的左下角，但如果你想练习，你可以尝试把它设置在左上角时间文本的下面。</p>
<p>试试吧！运行游戏，看看我们的成果如何：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_score_text.mp4">视频资源</a></p>
</blockquote>
<p>你可以随心所欲地为 UI 增减东西！我们在这里所做的是比较基础地展示文本。</p>
<h2><a class="header" href="#从配置文件中加载数据" id="从配置文件中加载数据">从配置文件中加载数据</a></h2>
<p>目前我们游戏中的箭头是硬编码的。目前这一切都还好，但我们希望玩家能创作自己的歌曲。我们不会通过制作自定义文件格式或任何花哨的东西使配置复杂化，所以我们将通过 <a href="https://en.wikipedia.org/wiki/TOML">TOML</a> 和 <a href="https://github.com/serde-rs/serde">serde</a> 库，来使用经过试用和测试的 <a href="https://en.wikipedia.org/wiki/TOML">TOML</a> 格式。这两个 crate 将帮助我们非常容易地实现 <code>SongConfig</code> 结构的 TOML 序列化和反序列化。</p>
<p>向 <code>Cargo.toml</code> 文件加入以下内容：</p>
<pre><code class="language-toml">toml = &quot;0.5.8&quot;
serde = &quot;1.0.118&quot;
serde_derive = &quot;1.0.118&quot;
</code></pre>
<p>我们现在可以编辑 <code>types.rs</code> 文件，并且导入准备好的类型和反序列化格式，向 <code>Directions</code> 和 <code>Speed</code> 类型中增加 <code>Deserialize</code> 和 <code>Serialize</code> trait 实现声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;

use serde_derive::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;

#[derive(Copy, Clone, Debug, PartialEq, Deserialize, Serialize)]
pub enum Directions {
    Up,
    Down,
    Left,
    Right,
}
#[derive(Copy, Clone, Debug, Deserialize, Serialize)]
pub enum Speed {
    Slow,
    Medium,
    Fast,
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们有个小问题。我们的 <code>ArrowTime</code> 结构体有 <code>spawn_time</code> 字段，但是我们想在 TOML 文件中写入点击时间，所以我们不能直接在 Serde 中使用 <code>ArrowTime</code> 和 <code>SongConfig</code>。我们会通过创建两个新结构体来解决这个问题，<code>ArrowTimeToml</code> 和 <code>SongConfigToml</code>，它们对应的数据将会被包含在 TOML 文件中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize, Debug)]
struct SongConfigToml {
    pub name: String,
    pub filename: String,
    pub arrows: Vec&lt;ArrowTimeToml&gt;,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct ArrowTimeToml {
    pub click_time: f64,
    pub speed: Speed,
    pub direction: Directions,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>name</code> 字段用于存储歌曲的名称，<code>filename</code> 是音频文件的路径，<code>arrows</code> 是 <code>ArrowTimeTomls</code> 列表。<code>ArrowTimeToml</code> 和 <code>ArrowTime</code> 的字段大部分一样，不同的是前者有 <code>click_time</code>，后者没有，取而代之的是 <code>spawn_time</code>。</p>
<p>我们也会把 <code>ArrowTime::new</code> 的入参改为 <code>ArrowTimeToml</code> 类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ArrowTime {
    fn new(arrow: &amp;ArrowTimeToml) -&gt; Self {
        let speed_value = arrow.speed.value();
        Self {
            spawn_time: arrow.click_time - (DISTANCE / speed_value) as f64,
            speed: arrow.speed,
            direction: arrow.direction,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们在 <code>SongConfig</code> 加几个字段，用来保存名称和音频：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SongConfig {
    pub name: String,
    pub song_audio: Handle&lt;AudioSource&gt;,
    pub arrows: Vec&lt;ArrowTime&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们用 <code>Handle&lt;AudioSource&gt;</code> 保存音频，当我们把 <code>SongConfigToml</code> 转换为 <code>SongConfig</code> 时，我们会使用 <code>AssetServer</code> 加载它。</p>
<p>最后，我们将修改 <code>load_config</code> 来从文件中加载 <code>SongConfig</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_config(path: &amp;str, asset_server: &amp;AssetServer) -&gt; SongConfig {
    // 打开文件并读取内容
    let mut file = File::open(format!(&quot;assets/songs/{}&quot;, path)).expect(&quot;Couldn't open file&quot;);
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)
        .expect(&quot;Couldn't read file into String&quot;);

    // 使用 toml 和 Serde 进行解析
    let parsed: SongConfigToml =
        toml::from_str(&amp;contents).expect(&quot;Couldn't parse into SongConfigToml&quot;);

    // 处理箭头
    let mut arrows = parsed
        .arrows
        .iter()
        .map(|arr| ArrowTime::new(arr))
        .collect::&lt;Vec&lt;ArrowTime&gt;&gt;();
    // 根据 spawn_time 对箭头排序
    arrows.sort_by(|a, b| a.spawn_time.partial_cmp(&amp;b.spawn_time).unwrap());

    // 加载音频歌曲，并进行处理
    let song_audio = asset_server.load(&amp;*format!(&quot;songs/{}&quot;, parsed.filename));

    SongConfig {
        name: parsed.name,
        song_audio,
        arrows,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>只有几行代码，但是很直接：先打开文件并读取文件的内容，使用 toml 库中的 <code>from_str</code> 方法解析文件内容，然后修改 <code>ArrowTimeTomls</code> 数组为 <code>ArrowTimes</code> 数组，我们使用 <code>AssetServer::load</code> 加载歌曲音频，然后返回新构建的 <code>SongConfig</code>。</p>
<p>注意：<code>AssetServer::load</code> 将在 <code>assets</code> 文件夹中搜索文件。<code>File::open</code> 不会从根目录开始查找，所以我们需要手动地将 <code>assets</code> 加到路径前缀中。</p>
<p>我们还需要修改 <code>main.rs</code> 中的 <code>setup</code> “系统”，修改 <code>load_config</code> 的调用方式，把 <code>AssetServer</code> 作为参数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup(commands: &amp;mut Commands, asset_server: Res&lt;AssetServer&gt;) {
    let config = types::load_config(&quot;test.toml&quot;, &amp;asset_server);

    commands
        .spawn(Camera2dBundle::default())
        .spawn(CameraUiBundle::default())
        .insert_resource(config);
}
<span class="boring">}
</span></code></pre></pre>
<p>我们将在 <code>assets</code> 中创建一个 <code>songs</code> 文件夹，可以在其中保存所有的歌曲文件和对应的音频。现在，我们将创建一个名为 <code>test.toml</code> 的占位文件。你可以随意修改 arrows 以获得更详细的内容，现在只做一些简单测试：</p>
<pre><code>name = &quot;Test song&quot;
filename = &quot;audio.mp3&quot;

arrows = [
    { click_time = 1.00, speed = &quot;Slow&quot;, direction = &quot;Up&quot; },
    { click_time = 3.00, speed = &quot;Slow&quot;, direction = &quot;Down&quot; },
    { click_time = 5.00, speed = &quot;Fast&quot;, direction = &quot;Left&quot; },
    { click_time = 5.00, speed = &quot;Slow&quot;, direction = &quot;Right&quot; },
    { click_time = 7.00, speed = &quot;Slow&quot;, direction = &quot;Up&quot; },
    { click_time = 8.00, speed = &quot;Medium&quot;, direction = &quot;Up&quot; },
    { click_time = 9.00, speed = &quot;Slow&quot;, direction = &quot;Left&quot; },
    { click_time = 10.00, speed = &quot;Slow&quot;, direction = &quot;Right&quot; },
    { click_time = 10.50, speed = &quot;Medium&quot;, direction = &quot;Right&quot; },
    { click_time = 11.00, speed = &quot;Slow&quot;, direction = &quot;Up&quot; },
    { click_time = 11.00, speed = &quot;Slow&quot;, direction = &quot;Down&quot; },
]
</code></pre>
<p>现在，（合法地）下载你最喜欢的歌曲，将其放在 <code>assets/songs</code> 中，并将其命名为 <code>audio.mp3</code>。</p>
<p>你的 assets 目录应该如下方所示：</p>
<pre><code>assets
├── fonts
│   └── FiraSans-Bold.ttf
├── images
│   ├── arrow_blue.png
│   ├── arrow_border.png
│   ├── arrow_green.png
│   └── arrow_red.png
└── songs
    ├── audio.mp3
    └── test.toml
</code></pre>
<p>现在运行游戏，应该和上一节没有太大不同，只是你得到的箭头是根据外部文件配置加载的！如果你问我的话，我觉得相当酷 :)。</p>
<h2><a class="header" href="#播放音频" id="播放音频">播放音频</a></h2>
<p>你可能注意到，在上一节中，我们做了一些加载歌曲的逻辑，但当我们玩游戏时，歌曲还是不能播放。现在，我们来实现播放！为此，我新建了一个文件，<code>audio.rs</code>，其中只含有一个“系统”：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>audio.rs
use crate::types::SongConfig;
use bevy::prelude::*;

fn start_song(audio: Res&lt;Audio&gt;, time: Res&lt;Time&gt;, config: Res&lt;SongConfig&gt;) {
    // 歌曲将在实时的 3 秒后开始播放
    let secs = time.seconds_since_startup();
    let secs_last = secs - time.delta_seconds_f64();

    if secs_last &lt;= 3. &amp;&amp; 3. &lt;= secs {
        audio.play(config.song_audio.clone());
    }
}

pub struct AudioPlugin;
impl Plugin for AudioPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.add_system(start_song.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>start_song</code> 使用 <code>Audio</code> 资源，在进入游戏 3 秒后开始播放歌曲。如你所看到的，我们使用了与“生成箭头”相同的方法。</p>
<p>注意：我们本可以复用 <code>Timer</code>，但当我们制作一个菜单来选择歌曲时，会带来一定的复杂度。何况尝试使用定时器重写，是个很不错的练习方式！</p>
<p>在 <code>main.rs</code> 中，我们添加以下内容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs
mod audio;
use audio::AudioPlugin;
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>main</code> 函数中，在所有插件加载的最后，添加 <code>.add_plugin(AudioPlugin)</code>。现在运行游戏应该会让歌曲播放了，因为计时器在运行！</p>
<p>至此，我们完成了游戏核心实现。你可以自由地在此基础上构建你自己地东西，但我建议你再往后看看，因为我们将致力于让游戏更加✨漂亮✨。</p>
<h2><a class="header" href="#美化失败的箭头" id="美化失败的箭头">美化失败的箭头</a></h2>
<p>首先，我们可以改进失败箭头的外观。目前，它们只是飞向远处。我们希望给玩家一些暗示，提醒他们那个箭头失败了。</p>
<p>我们要做的是让箭头在穿过目标区域后，“脱离”那条线。为了实现这一点，我们在 <code>arrows.rs</code> 中的 <code>move_arrows</code> 函数中加点东西：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 箭头前移
fn move_arrows(time: Res&lt;Time&gt;, mut query: Query&lt;(&amp;mut Transform, &amp;Arrow)&gt;) {
    for (mut transform, arrow) in query.iter_mut() {
        transform.translation.x += time.delta_seconds() * arrow.speed.value();

        // 新加代码
        let distance_after_target = transform.translation.x - (TARGET_POSITION + THRESHOLD);
        if distance_after_target &gt;= 0.02 {
            transform.translation.y -= time.delta_seconds() * distance_after_target * 2.;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们所做的是获取目标到目标区域箭头符号的 <code>x</code> 坐标距离差，如果是正的，意味着它已经移动到目标区域外，我们就在它的 <code>y</code> 坐标减去一点，这样它就会下降。通过 <code>time.delta_seconds() * distance_after_target</code>，我们让每一帧的下降因子变大，这会让箭头以弧线的形式下降。<code>2.</code> 只是一个特定的常量，使弧线更好看（我觉得是），你可以根据你自己的意愿调整它！</p>
<p>效果见下方链接的视频：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_arrows_falling.mp4">视频资源</a></p>
</blockquote>
<p>很好，我们再给它加点效果。我们让箭头在下降时收缩并旋转：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 箭头前移
fn move_arrows(time: Res&lt;Time&gt;, mut query: Query&lt;(&amp;mut Transform, &amp;Arrow)&gt;) {
    for (mut transform, arrow) in query.iter_mut() {
        transform.translation.x += time.delta_seconds() * arrow.speed.value();

        let distance_after_target = transform.translation.x - (TARGET_POSITION + THRESHOLD);
        if distance_after_target &gt;= 0.02 {
            // 一旦箭头穿过目标区域，则开始下落
            transform.translation.y -= time.delta_seconds() * distance_after_target * 2.;

            // 根据箭头地距离改变下降因子（比例）
            let scale = ((100. - distance_after_target / 3.) / 100.).max(0.2);
            transform.scale = Vec3::splat(scale);

            // 根据距离和速度旋转箭头
            transform.rotate(Quat::from_rotation_z(
                -distance_after_target * arrow.speed.multiplier() / 460.,
            ));
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这是一串充满魔力的数字和公式，我在经过多次不同的尝试得出的结论。我建议你试试其它内容！</p>
<p>我们将其分析一下：首先，我们使用一个随着箭头移动而减小的公式来获得一个比例。然后，使用 <code>max</code> 来确保比例至少为 <code>0.2</code>。之后，我们使用 <a href="https://docs.rs/bevy/0.4.0/bevy/prelude/struct.Transform.html#method.rotate">Transform::rotate</a> 来旋转箭头。对于旋转，我们使用 <code>Speed::multiplier</code>，如果箭头的速度更快，就会旋转地更快。下面是所有这些效果组合在一起的样子：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_arrows_spinning.mp4">视频资源</a></p>
</blockquote>
<p>太酷了！再次强调，你可以随时即兴发挥，添加其他逻辑，让它更加酷炫。游戏有一半的乐趣来自于制作你喜欢的花哨特效！</p>
<h2><a class="header" href="#着色器背景" id="着色器背景">着色器背景</a></h2>
<p>接下来我们要做的是替换灰色背景。选择之一是使用 <code>ClearColor</code> 资源，以静态颜色作为背景。<a href="https://github.com/bevyengine/bevy/blob/v0.4.0/examples/window/clear_color.rs">这里</a>是一个使用示例。这种方式很简单，我们只需要在 <code>main</code> 函数中加上 <code>.add_resource(ClearColor(Color::rgb(0.5, 0.5, 0.9)))</code>，缺点是只能将背景改为一个平面颜色，我们希望看到更加生动的内容。着色器可以帮助我们！</p>
<p>我们将在所有元素下面制作一个窗口大小的精灵，我们将添加着色器材料。这样我们会有一个背景，也就是设置一个着色器作为背景。</p>
<p>当我们用着色器添加一些其他东西时，我们创建一个名为 <code>shaders</code> 的文件夹，用于存放相关文件。我们先打开 <code>shaders/mod.rs</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::{
    prelude::*,
    reflect::TypeUuid,
    render::{
        pipeline::{PipelineDescriptor, RenderPipeline},
        render_graph::{base, RenderGraph},
        renderer::RenderResources,
        shader::{ShaderStage, ShaderStages},
    },
    window::WindowResized,
};

mod background;
use background::*;
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们只添加了一些导入，声明了 <code>background</code> 模块，接下来就创建这个模块：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::*;

pub struct Background;
pub fn setup_background(
    commands: &amp;mut Commands,
    mut pipelines: ResMut&lt;Assets&lt;PipelineDescriptor&gt;&gt;,
    mut shaders: ResMut&lt;Assets&lt;Shader&gt;&gt;,
    window: Res&lt;WindowDescriptor&gt;,
) {
    // 创建一个新的着色器管道
    let pipeline_handle = pipelines.add(PipelineDescriptor::default_config(ShaderStages {
        vertex: shaders.add(Shader::from_glsl(
            ShaderStage::Vertex,
            include_str!(&quot;background.vert&quot;),
        )),
        fragment: Some(shaders.add(Shader::from_glsl(
            ShaderStage::Fragment,
            include_str!(&quot;background.frag&quot;),
        ))),
    }));

    commands
        .spawn(SpriteBundle {
            render_pipelines: RenderPipelines::from_pipelines(vec![RenderPipeline::new(
                pipeline_handle,
            )]),
            transform: Transform::from_scale(Vec3::new(
                window.width + 10.,
                window.height + 10.,
                1.,
            )),
            ..Default::default()
        })
        .with(Background);
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个文件中，我们添加了一个“启动系统”，它首先创建了 <code>PipelineDescriptor</code>，其中包含顶点和 fragment 着色器。这些都是用 <code>include_str</code> 宏从文件中添加进来的。然后我们会创建一个带有 <code>RenderPipelines</code> 组件的 <code>SpriteBundle</code>，并将我们创建的管道描述符传入。最后，我们添加了一个 <code>Background</code> 标记组件。</p>
<p>我们正在使用 <code>WindowDescriptor</code> 资源来得到屏幕宽度和高度，这样就可以进行正确的转换。如果玩家将窗口变大，会出现一个小问题，因为我们的背景大小不变，导致后面的灰色背景被显示出来！为了解决这个问题，我们添加另一个“系统”：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 当窗口大小变化时，背景大小跟着改变
pub fn update_background_size(
    mut event_reader: Local&lt;EventReader&lt;WindowResized&gt;&gt;,
    events: Res&lt;Events&lt;WindowResized&gt;&gt;,
    mut background: Query&lt;(&amp;mut Transform, &amp;Background)&gt;,
) {
    for event in event_reader.iter(&amp;events) {
        for (mut transform, _) in background.iter_mut() {
            transform.scale = Vec3::new(event.width, event.height, 1.);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它监听 <a href="https://docs.rs/bevy/0.4.0/bevy/window/struct.WindowResized.html">WindowResized</a> 事件，该事件在每次调整窗口大小时会提供新的窗口宽高。</p>
<p>正如你注意到的，在 Bevy 中有一种易于使用且优雅的模式。事件也不例外。要使用一个事件，我们需要添加一个 <code>Event&lt;T&gt;</code> 资源和一个 <code>Local&lt;EventReader&lt;T&gt;&gt;</code> 作为参数。然后我们就可以通过事件资源来使用 <code>EventReader::iter</code>，该事件资源将给我们提供需要处理的事件。</p>
<p>实际使用着色器时是使用 Rust 的 <code>include_str</code> 宏添加的，它将以字符串的形式添加文件内容。首先，我们创建 <code>background.vert</code>：</p>
<pre><code>#version 450

layout(location = 0) in vec3 Vertex_Position;
layout(location = 1) in vec3 Vertex_Normal;
layout(location = 2) in vec2 Vertex_Uv;

layout(location = 1) out vec2 v_Uv;

layout(set = 0, binding = 0) uniform Camera {
    mat4 ViewProj;
};
layout(set = 1, binding = 0) uniform Transform {
    mat4 Model;
};

void main() {
    v_Uv = Vertex_Uv;
    gl_Position = ViewProj * Model * vec4(Vertex_Position, 1.0);
}
</code></pre>
<p>我们在这里只需做一件特殊的事是添加 <code>v_Uv</code>（纹理的 uv 坐标）作为输出，这样，我们就可以在 fragment 着色器中使用它，现在我们在 <code>background.frag</code> 中创建它：</p>
<pre><code>// shaders/background.frag
#version 450

layout(location = 0) in vec4 v_Position;
layout(location = 1) in vec2 v_Uv;

layout(location = 0) out vec4 o_Target;

void main() {
    o_Target = vec4(v_Uv, 0.1, 1.0);
}
</code></pre>
<p>在这个着色器中，我们只返回基于背景的 uv 坐标的简单颜色。</p>
<p>我们现在需要注册这些创建的“系统”。我们在 <code>shaders/mod.rs</code> 中添加 <code>ShaderPlugin</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shaders/mod.rs
pub struct ShadersPlugin;
impl Plugin for ShadersPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.add_startup_system(setup_background.system())
            .add_system(update_background_size.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们可以在 <code>main.rs</code> 中导入它：</p>
<pre><pre class="playground"><code class="language-rust">mod shaders;
use shaders::ShadersPlugin;

fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .init_resource::&lt;ScoreResource&gt;()
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin)
        .add_plugin(UIPlugin)
        .add_plugin(AudioPlugin)
        .add_plugin(ShadersPlugin) // &lt;--- New
        .run();
}
</code></pre></pre>
<p>运行游戏你可以看到下方链接视频中展示的效果：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_simple_background.mp4">视频资源</a></p>
</blockquote>
<h2><a class="header" href="#使用时间着色器" id="使用时间着色器">使用时间着色器</a></h2>
<p>继续，我们会有一些奇特的场景，酷！理想情况下，我们希望游戏背景随着时间有一些变化。</p>
<p>Bevy 没有（至少现在没有）添加时间和分辨率到着色器中作为输入，所以我们将不得不手动添加它们。希望这点能在 Bevy 中尽快得到改善。</p>
<p>我们再次打开 <code>shaders/mod.rs</code>文件，并增加以下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(RenderResources, Default, TypeUuid)]
#[uuid = &quot;0320b9b8-b3a3-4baa-8bfa-c94008177b17&quot;]
/// 将资源传递给着色器
pub struct ShaderInputs {
    time: f32,
    resolution: Vec2,
}

/// 在每一帧中，更新 ShaderInputs 中的时间
fn update_time(time: Res&lt;Time&gt;, mut nodes: Query&lt;&amp;mut ShaderInputs&gt;) {
    let time = time.seconds_since_startup();
    for mut node in nodes.iter_mut() {
        node.time = time as f32;
    }
}

/// 如果窗口大小发生改变，更新 ShaderInputs 的分辨率
fn update_resolution(
    mut event_reader: Local&lt;EventReader&lt;WindowResized&gt;&gt;,
    events: Res&lt;Events&lt;WindowResized&gt;&gt;,
    mut background: Query&lt;&amp;mut ShaderInputs&gt;,
) {
    for event in event_reader.iter(&amp;events) {
        for mut node in background.iter_mut() {
            node.resolution = Vec2::new(event.width / event.height, 1.);
        }
    }
}

/// 在渲染图形时，添加 ShaderInputs 作为一个 edge
fn setup_render_graph(mut render_graph: ResMut&lt;RenderGraph&gt;) {
    render_graph.add_system_node(&quot;inputs&quot;, RenderResourcesNode::&lt;ShaderInputs&gt;::new(true));
    render_graph
        .add_node_edge(&quot;inputs&quot;, base::node::MAIN_PASS)
        .unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>我们正在创建一个新的 <code>ShaderInputs</code> 结构体，将其作为渲染图形边添加到 <code>setup_render_graph</code> 中，并将其加到“启动系统”中。<code>update_time</code> 和 <code>update_resolution</code> 是两个负责更新 <code>ShaderInputs</code> 组件值的系统。注意在 <code>update_resolution</code> 中我们是通过监听 <code>WindowResized</code> 事件来实现，而非更新每一帧。</p>
<p>现在，用以下代码替换 <code>ShaderPlugin</code> 中的实现，添加所有系统和资源：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ShadersPlugin;
impl Plugin for ShadersPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.add_asset::&lt;ShaderInputs&gt;() // &lt;--- 新代码
            .add_startup_system(setup_render_graph.system()) // &lt;--- 新代码
            .add_system(update_time.system()) // &lt;--- 新代码
            .add_system(update_resolution.system()) // &lt;--- 新代码
            .add_startup_system(setup_background.system())
            .add_system(update_background_size.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们现在要向之前创建的背景实体添加 <code>ShaderInputs</code> 组件，提供初始值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shaders/background.rs
pub fn setup_background(
    commands: &amp;mut Commands,
    mut pipelines: ResMut&lt;Assets&lt;PipelineDescriptor&gt;&gt;,
    mut shaders: ResMut&lt;Assets&lt;Shader&gt;&gt;,
    window: Res&lt;WindowDescriptor&gt;,
) {
    // 创建新的着色器管道
    let pipeline_handle = pipelines.add(PipelineDescriptor::default_config(ShaderStages {
        vertex: shaders.add(Shader::from_glsl(
            ShaderStage::Vertex,
            include_str!(&quot;background.vert&quot;),
        )),
        fragment: Some(shaders.add(Shader::from_glsl(
            ShaderStage::Fragment,
            include_str!(&quot;background.frag&quot;),
        ))),
    }));

    commands
        .spawn(SpriteBundle {
            render_pipelines: RenderPipelines::from_pipelines(vec![RenderPipeline::new(
                pipeline_handle,
            )]),
            transform: Transform::from_scale(Vec3::new(
                window.width + 10.,
                window.height + 10.,
                1.,
            )),
            ..Default::default()
        })
        .with(Background)
        // New
        .with(ShaderInputs {
            time: 0.,
            resolution: Vec2::new(window.width / window.height, 1.),
        });
}
<span class="boring">}
</span></code></pre></pre>
<p>这些值在添加一些东西后，现在可以在着色器上使用了：</p>
<pre><code>// shaders/background.frag
#version 450

layout(location = 0) in vec4 v_Position;
layout(location = 1) in vec2 v_Uv;

layout(location = 0) out vec4 o_Target;

// New
layout(set = 2, binding = 0) uniform ShaderInputs_time {
    float time;
};
// New
layout(set = 2, binding = 1) uniform ShaderInputs_resolution {
    vec2 resolution;
};

void main() {
    o_Target = vec4(v_Uv, abs(sin(time)), 1.0);
}
</code></pre>
<p>基本上，我们必须对 <code>ShaderInputs</code> 的每个字段增加 uniform，它包含 <code>binding</code> 对应增加的值，以及形如 <code>ShaderInputs_$name</code> 的名字，其中的 <code>$name</code> 是字段名。现在我们可以使用着色器内部的变量了！</p>
<p>现在看起来应该如下方链接视频所示：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_background_with_time.mp4">视频资源</a></p>
</blockquote>
<p>就个人而言，我选择了以下配置的着色器作为背景：</p>
<pre><code>#version 450

#define TWO_PI 6.28318530718

layout(location = 0) in vec4 v_Position;
layout(location = 1) in vec2 v_Uv;
layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) uniform ShaderInputs_time {
    float time;
};
layout(set = 2, binding = 1) uniform ShaderInputs_resolution {
    vec2 resolution;
};

vec3 hsb2rgb(in vec3 c){
    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                             6.0)-3.0)-1.0,
                     0.0,
                     1.0 );
    rgb = rgb*rgb*(3.0-2.0*rgb);
    return c.z * mix( vec3(1.0), rgb, c.y);
}

float wave_sin(in float x) {
    float amplitude = 0.5;
    float frequency = 1.0;
    float y = sin(x * frequency);
    float t = 0.01*(-time*50.0);
    y += sin(x * frequency * 2.1 + t)*4.5;
    y += sin(x * frequency * 1.72 + t*1.121)*4.0;
    y += sin(x * frequency * 2.221 + t*0.437)*5.0;
    y += sin(x * frequency * 3.1122+ t*4.269)*2.5;
    y *= amplitude*0.06;
    return y;
}
float wave_cos(in float x) {
    float amplitude = 0.5;
    float frequency = 2.0;
    float y = cos(x * frequency);
    float t = 0.01*(-time*30.0);
    y += cos(x * frequency * 2.1 + t)*4.5;
    y += cos(x * frequency * 1.72 + t*1.121)*4.0;
    y += cos(x * frequency * 2.221 + t*0.437)*5.0;
    y += cos(x * frequency * 3.1122+ t*4.269)*2.5;
    y *= amplitude*0.06;
    return y;
}
vec2 wave(in vec2 v) {
    return vec2(wave_sin(v.x), wave_cos(v.y));
}

void main() {
    vec2 uv = wave(v_Uv);
    vec3 color = hsb2rgb(vec3(uv.x + sin(uv.y), 0.7, 1.0));

    o_Target = vec4(color,1.0);
}
</code></pre>
<p>它移动周围的颜色，产生好看的波浪，效果如下方链接视频所示：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_fancy_background.mp4">视频资源</a></p>
</blockquote>
<p>现在轮到你玩它了，找到你喜欢的东西。如果你不太理解着色器，你可以尝试对上面的着色器做一些小修改，你也可以去 <a href="https://www.shadertoy.com/">Shadertoy</a> 查找一些资料。例如，下面是一个 <a href="https://www.shadertoy.com/view/XsXXDn">shader</a> 配置，它由 Danilo Guanabara 转换自 Shadertoy：</p>
<pre><code>// shaders/background.frag
#version 450

// Creation, by Silexars (Danilo Guanabara)
// From https://www.shadertoy.com/view/XsXXDn

layout(location = 0) in vec4 v_Position;
layout(location = 1) in vec2 v_Uv;
layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) uniform ShaderInputs_time {
    float time;
};
layout(set = 2, binding = 1) uniform ShaderInputs_resolution {
    vec2 resolution;
};

void main() {
    vec3 c;
    vec2 r = resolution;
    float l,z=time;
    for(int i=0;i&lt;3;i++) {
        vec2 uv,p = v_Uv; // / r;
        uv = p;
        p -= 0.5;
        p.x *= r.x/r.y;
        z += 0.07;
        l = length(p);
        uv += p/l*(sin(z)+1.)*abs(sin(l*9.0-z*2.0));
        c[i] = (0.01)/length(abs(mod(uv,1.0)-0.5));
    }
    o_Target = vec4(c/l,time);
}
</code></pre>
<p>效果如下方链接视频所示：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_creation_background.mp4">视频资源</a></p>
</blockquote>
<h2><a class="header" href="#美化点击动画" id="美化点击动画">美化点击动画</a></h2>
<p>我们之前已经为失败的箭头添加了有趣动画，但当成功命中箭头时，我们啥也没做。它就这样消失了，这有点让人失望。我们将这一点进行改进。</p>
<p>我们将有四个不同的“精灵”，每个精灵在每个目标区域箭头下都有一个着色器。然后，每当正确命中箭头时，相应的精灵下的着色器就会启动动画，动画持续一段时间后，再消失。</p>
<p>注意：这个如果用技术实现会比较复杂，但这样可以展示很多东西。实现这一点有个捷径是在每次正确点击箭头时创建一个精灵，然后几秒钟后删除掉。</p>
<p>打开 <code>shaders/target_arrows.rs</code> 文件。我们为这些精灵添加一个组件（我把它叫做“普通目标箭头”），它只是指示目标箭头的方向和位置：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TargetArrowSparkle {
    direction: Directions,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们再添加另一条边到渲染图中，并将另一个结构体作为参数传递给着色器。这将保留最近一次正确命中箭头的时间，以及对应得分：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shaders/target_arrows.rs
#[derive(RenderResources, TypeUuid)]
#[uuid = &quot;c9400817-b3a3-4baa-8bfa-0320b9b87b17&quot;]
pub struct TimeSinceLastCorrect {
    last_time: f32,
    points: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>请注意，当我们向目标箭头添加 <code>TimeSinceLastCorrect</code> 组件时，每个组件都有自己的值，这些值是不共享的，所以我们需要单独设定它们。</p>
<p>现在，我们添加一个“启动系统”用于创建精灵：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shaders/target_arrows.rs
use super::*;
use crate::consts::*;
use crate::types::Directions::{self, *};

pub fn setup_target_arrows(
    commands: &amp;mut Commands,
    mut pipelines: ResMut&lt;Assets&lt;PipelineDescriptor&gt;&gt;,
    mut shaders: ResMut&lt;Assets&lt;Shader&gt;&gt;,
    mut render_graph: ResMut&lt;RenderGraph&gt;,
    window: Res&lt;WindowDescriptor&gt;,
) {
    // 创建一个新的着色器管道
    let pipeline_handle = pipelines.add(PipelineDescriptor::default_config(ShaderStages {
        vertex: shaders.add(Shader::from_glsl(
            ShaderStage::Vertex,
            include_str!(&quot;target_arrows.vert&quot;),
        )),
        fragment: Some(shaders.add(Shader::from_glsl(
            ShaderStage::Fragment,
            include_str!(&quot;target_arrows.frag&quot;),
        ))),
    }));

    // 把 TimeSinceLastCorrect 加到渲染图中
    render_graph.add_system_node(
        &quot;last_time&quot;,
        RenderResourcesNode::&lt;TimeSinceLastCorrect&gt;::new(true),
    );
    render_graph
        .add_node_edge(&quot;last_time&quot;, base::node::MAIN_PASS)
        .unwrap();

    let directions = [Up, Down, Left, Right];
    for direction in directions.iter() {
        // z 值不同，所以它们不会重叠
        let z = match direction {
            Up =&gt; 0.3,
            Down =&gt; 0.4,
            Left =&gt; 0.5,
            Right =&gt; 0.6,
        };

        let mut transform =
            Transform::from_translation(Vec3::new(TARGET_POSITION, direction.y(), z));
        transform.scale = Vec3::new(300., 300., 1.);
        commands
            .spawn(SpriteBundle {
                render_pipelines: RenderPipelines::from_pipelines(vec![RenderPipeline::new(
                    pipeline_handle.clone(),
                )]),
                transform,
                visible: Visible {
                    is_transparent: true,
                    ..Default::default()
                },
                ..Default::default()
            })
            .with(TargetArrowSparkle {
                direction: *direction,
            })
            .with(TimeSinceLastCorrect {
                last_time: 3.,
                points: 0.5,
            })
            .with(ShaderInputs {
                time: 0.,
                resolution: Vec2::new(window.width / window.height, 1.),
            });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个系统就像是 <code>setup_target_arrows</code>，<code>setup_render_graph</code> 和 <code>setup_background</code> 的混合体。我们首先创建一个 <code>PipelineDescriptor</code>，然后添加 <code>TimeSinceLastCorrect</code> 作为渲染图的边，最后我们创建一个存放所有方向的数组，然后迭代它，创建 4 个精灵组，并添加 <code>TargetArrowSparkle</code>，<code>TimeSinceLastCorrect</code> 和 <code>ShaderInputs</code> 组件。</p>
<p>我们把 <code>last_time</code> 设为 3 秒进行测试。这样，当时间达到三秒时，动画就开始了。当我们设置好所有内容后，我们会将其更改为负值，因为我们希望箭头在被正确点击时触发。</p>
<p>我们还需要为这个着色器创建新文件：</p>
<pre><code>#version 450

layout(location = 0) in vec3 Vertex_Position;
layout(location = 1) in vec3 Vertex_Normal;
layout(location = 2) in vec2 Vertex_Uv;

layout(location = 1) out vec2 v_Uv;

layout(set = 0, binding = 0) uniform Camera {
    mat4 ViewProj;
};
layout(set = 1, binding = 0) uniform Transform {
    mat4 Model;
};

void main() {
    v_Uv = Vertex_Uv;
    gl_Position = ViewProj * Model * vec4(Vertex_Position, 1.0);
}
</code></pre>
<p>vertex 着色器的实现基本上和 <code>shaders/background.vert</code> 一样。更有趣的是 <code>shaders/target_arrows.frag</code>：</p>
<pre><code># shaders/target_arrows.frag
#version 450

#define TWO_PI 6.28318530718

layout(location = 0) in vec4 v_Position;
layout(location = 1) in vec2 v_Uv;
layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) uniform ShaderInputs_time {
    float time;
};
layout(set = 2, binding = 1) uniform ShaderInputs_resolution {
    vec2 resolution;
};
layout(set = 3, binding = 0) uniform TimeSinceLastCorrect_last_time {
    float last_time;
};
layout(set = 3, binding = 1) uniform TimeSinceLastCorrect_points {
    float points;
};

float interval(in float a, in float b, in float val) {
    return step(a, val) * smoothstep(1.0 - b - 0.1, 1.0 - b, 1. - val);
}

float circle(in vec2 uv, in float _radius){
    vec2 dist = uv - vec2(0.5);
    return 1.0 - smoothstep(_radius - (_radius * 0.01),
                            _radius + (_radius * 0.01),
                            dot(dist, dist) * 4.0);
}

float smoothcircle(in vec2 _st, in float s){
    vec2 dist = _st-vec2(0.5);
    return 4. * dot(dist,dist) / (s);
}

void main() {
    // 0. when the circle shouldn't be shown
    float alpha = interval(last_time, last_time + 0.6, time);

    // Circle radius
    float radius = time - last_time;
    // 0. for not in circle, 1. for circle
    // float circle = circle(v_Uv, radius) * (1. - circle(v_Uv, radius - 0.1));
    float circle = smoothcircle(v_Uv, radius) * smoothcircle(v_Uv, radius) * circle(v_Uv, radius);

    // rgb(92, 175, 29);
    vec3 colorMin = vec3(0.36078431373,0.6862745098,0.1137254902);
    // rgb(255, 255, 6);
    vec3 colorMax = vec3(1.,1.,0.02352941176);

    // Get color according to points
    vec3 color = mix(colorMin, colorMax, points);

    o_Target = vec4(color * circle, circle * alpha);
}
</code></pre>
<p>这个着色器有点复杂，但简而言之，它的作用是创建一个半径随时间增加的圆。圆圈在 <code>last_time</code> 后存在 <code>0.6</code> 秒。我们把值设为 3 来添加 <code>TimeSinceLastCorrect</code>，并且和 <code>ShaderInputs</code> 一样，每个字段的绑定值都会增加。圆形的颜色根据点的不同而有所变化。</p>
<p>我们还需要把 <code>setup_target_arrows</code> 加到 <code>ShaderPlugin</code> 中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shaders/mod.rs
mod target_arrows;
use target_arrows::*;

pub struct ShadersPlugin;
impl Plugin for ShadersPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.add_asset::&lt;ShaderInputs&gt;()
            .add_asset::&lt;TimeSinceLastCorrect&gt;()
            .add_startup_system(setup_render_graph.system())
            .add_system(update_time.system())
            .add_system(update_resolution.system())
            .add_startup_system(setup_background.system())
            .add_system(update_background_size.system())
            .add_startup_system(setup_target_arrows.system()); // &lt;--- New
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在运行游戏，将看到如下面链接视频所展示的效果：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_half_done_fancy_clicking.mp4">视频资源</a></p>
</blockquote>
<p>如你所看到的，就在歌曲开始后，第 3 秒时，所有的圆圈开始变大，约过半秒后它们就消失了。太好了，这意味这着色器和定时器都正常工作了！我们仍然缺少一些东西来更新一些值，所以我们添加一个“系统”，用于当箭头被正确的按下时，更新 <code>last_time</code> 值。在此之前，我们使其默认值为负的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shaders/target_arrows.rs
.with(TimeSinceLastCorrect {
    last_time: -10.,
    points: 0.,
})
<span class="boring">}
</span></code></pre></pre>
<p>现在如果你运行这个游戏，圆圈就不会出现了。</p>
<p>之前，我们已经看到了如何侦听事件，但我们仍然没有看到硬币的另一面。我们现在就准备探索一下。我们将创建一个正确点击箭头时发生的事件。我们在 <code>arrows.rs</code> 文件中的 <code>despawn_arrows</code> 中产生这个事件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// arrows.rs
/// 事件结构体
pub struct CorrectArrowEvent {
    pub direction: Directions,
    pub points: usize,
}

/// 当他们到达目标区域时，正确点击按钮，箭头就会消失
fn despawn_arrows(
    commands: &amp;mut Commands,
    query: Query&lt;(Entity, &amp;Transform, &amp;Arrow)&gt;,
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut score: ResMut&lt;ScoreResource&gt;,
    mut correct_arrow_events: ResMut&lt;Events&lt;CorrectArrowEvent&gt;&gt;,
) {
    for (entity, transform, arrow) in query.iter() {
        let pos = transform.translation.x;

        // Check if arrow is inside clicking threshold
        if (TARGET_POSITION - THRESHOLD..=TARGET_POSITION + THRESHOLD).contains(&amp;pos)
            &amp;&amp; arrow.direction.key_just_pressed(&amp;keyboard_input)
        {
            commands.despawn(entity);

            let points = score.increase_correct(TARGET_POSITION - pos);

            // 新代码
            
            // 发送事件
            correct_arrow_events.send(CorrectArrowEvent {
                direction: arrow.direction,
                points,
            });
        }

        // 当箭头离开屏幕时消除它们
        if pos &gt;= 2. * TARGET_POSITION {
            commands.despawn(entity);
            score.increase_fails();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们首先要做的是创建一个新的 <code>CorrectArrowEvent</code> 结构体，它用来表示我们的事件。对于 <code>despawn_arrows</code>，我们添加了 <code>ResMut&lt;Events&lt;CorrectArrowEvent&gt;&gt;</code> 参数，这样我们就能通过 <code>send</code> 方法发送事件。为了发送一个事件，我们需要传入一个 <code>CorrectArrowEvent</code> 结构体，它携带箭头的方向以及玩家的得分。</p>
<p>现在我们需要把 <code>.init_resource::&lt;Events&lt;CorrectArrowEvent&gt;&gt;()</code> 添加到 <code>ArrowsPlugin</code>，我们已经准备好了。很简单，对吧？</p>
<p>现在我们要在 <code>shaders/target_arrows.rs</code> 中添加一个“系统”，它负责更新“目标区域箭头”中的 <code>last_time</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shaders/target_arrows.rs
pub fn correct_arrow_event_listener(
    time: Res&lt;Time&gt;,
    mut correct_event_reader: Local&lt;EventReader&lt;CorrectArrowEvent&gt;&gt;,
    correct_events: Res&lt;Events&lt;CorrectArrowEvent&gt;&gt;,
    mut query: Query&lt;(&amp;TargetArrowSparkle, &amp;mut TimeSinceLastCorrect)&gt;,
) {
    for event in correct_event_reader.iter(&amp;correct_events) {
        for (arrow, mut last_correct) in query.iter_mut() {
            if arrow.direction == event.direction {
                last_correct.last_time = time.seconds_since_startup() as f32;
                last_correct.points = event.points as f32 / 100.;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>它通过监听事件，寻找与目标方向相关的箭头精灵，并更新其中的 <code>last_time</code> 和 <code>points</code> 值。</p>
<p>把最后一个“系统”加到 <code>ShaderPlugin</code>，<code>.add_system(correct_arrow_event_listener.system())</code>。现在如果你运行游戏，当你正确点击箭头时，就会看到圆圈效果：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_target_arrow_circles.mp4">视频资源</a></p>
</blockquote>
<p>这就是这个游戏中我们要做的所有着色工作。和以往一样，你可以随便修改代码，添加更多效果，进行实验！</p>
<h2><a class="header" href="#增加状态" id="增加状态">增加状态</a></h2>
<p>在下一节，我们将制作一个非常简单的歌曲选择菜单。为此，我们将在一些状态值上下手，这就需要修改一些地方。为了创建一个状态，我们需要新建一个新的枚举，并将其包装成 <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.State.html">State</a> 的资源加到游戏代码中。然后，我们可以使用 <code>on_state_update</code>，<code>on_state_enter</code> 和 <code>on_state_exit</code> 等方法为每个系统分配特定的状态。</p>
<p>我们开始吧。首先，打开 <code>consts.rs</code>，添加 state 枚举：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Stage for our systems
pub const APP_STATE_STAGE: &amp;str = &quot;app_state_stage&quot;;

/// States
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum AppState {
    Menu,
    Game,
    MakeMap,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>AppState</code> 将代表我们游戏的三个模式：歌曲选择菜单，游戏和（尚未实现的）地图制作模式。</p>
<p>我们，还添加了一个字符串用于表示我们的系统的阶段。现在我们进入 <code>main.rs</code> 中，添加 <code>State</code> 以及更新后的新阶段两个资源：</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
use crate::consts::*;

fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_resource(State::new(AppState::Menu)) // &lt;--- 新代码
        .add_stage_after( // &lt;--- 新代码
            stage::UPDATE,
            APP_STATE_STAGE,
            StateStage::&lt;AppState&gt;::default(),
        )
        .init_resource::&lt;ScoreResource&gt;()
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin)
        .add_plugin(UIPlugin)
        .add_plugin(AudioPlugin)
        .add_plugin(ShadersPlugin)
        .run();
}
</code></pre></pre>
<p>现在游戏不会有任何变化，因为我们的“系统”仍然以普通的方式加入。为了改变这一点，我们将从修改 <code>arrows.rs</code> 中的 <code>ArrowsPlugin</code> 入手：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// arrows.rs
pub struct ArrowsPlugin;
impl Plugin for ArrowsPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.init_resource::&lt;ArrowMaterialResource&gt;()
            .init_resource::&lt;Events&lt;CorrectArrowEvent&gt;&gt;()
            .on_state_enter(
                APP_STATE_STAGE,
                AppState::Game,
                setup_target_arrows.system(),
            )
            .on_state_update(APP_STATE_STAGE, AppState::Game, spawn_arrows.system())
            .on_state_update(APP_STATE_STAGE, AppState::Game, move_arrows.system())
            .on_state_update(APP_STATE_STAGE, AppState::Game, despawn_arrows.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们必须把 <code>add_startup_system</code>替换为 <code>on_stage_enter</code>，将 <code>add_system</code> 替换为 <code>on_stage_update</code>。对于这些函数，我们必须传入“系统”运行的阶段和状态。因为我们想要所有这些运行在 <code>Game</code> 状态，就是我们使用的那个。</p>
<p>现在我们看看 <code>ui.rs</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ui.rs
use crate::consts::*;

pub struct UIPlugin;
impl Plugin for UIPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.on_state_enter(APP_STATE_STAGE, AppState::Game, setup_ui.system())
            .on_state_update(APP_STATE_STAGE, AppState::Game, update_time_text.system())
            .on_state_update(APP_STATE_STAGE, AppState::Game, update_score_text.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>audio.rs</code> 中的代码:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// audio.rs
use crate::consts::*;

pub struct AudioPlugin;
impl Plugin for AudioPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.on_state_update(APP_STATE_STAGE, AppState::Game, start_song.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们已经修改了所有与 <code>Game</code> 状态相关的“系统”，所以如果你现在运行游戏，除了看到动画背景外，什么也不会发生，因为我们要从 <code>Menu</code> 开始，但是我们还没有相关的“系统”。</p>
<h2><a class="header" href="#添加基础菜单" id="添加基础菜单">添加基础菜单</a></h2>
<p>我们现在将制作一个带有按钮的菜单，它可以让我们选择一首歌曲或进入游戏地图制作模式。我们将它保存在一个新的文件 <code>menu.rs</code> 中。我们新建一个资源来保存对应的素材：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::consts::*;
use bevy::prelude::*;

struct ButtonMaterials {
    none: Handle&lt;ColorMaterial&gt;,
    normal: Handle&lt;ColorMaterial&gt;,
    hovered: Handle&lt;ColorMaterial&gt;,
    pressed: Handle&lt;ColorMaterial&gt;,
    font: Handle&lt;Font&gt;,
}

impl FromResources for ButtonMaterials {
    fn from_resources(resources: &amp;Resources) -&gt; Self {
        let mut materials = resources.get_mut::&lt;Assets&lt;ColorMaterial&gt;&gt;().unwrap();
        let asset_server = resources.get_mut::&lt;AssetServer&gt;().unwrap();

        ButtonMaterials {
            none: materials.add(Color::NONE.into()),
            normal: materials.add(Color::rgb(0.15, 0.15, 0.15).into()),
            hovered: materials.add(Color::rgb(0.25, 0.25, 0.25).into()),
            pressed: materials.add(Color::rgb(0.35, 0.75, 0.35).into()),
            font: asset_server.load(&quot;fonts/FiraSans-Bold.ttf&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这看起来很标准。接下来，我们将创建一个“系统”来构建菜单元素。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
struct MenuUI;
fn setup_menu(commands: &amp;mut Commands, button_materials: Res&lt;ButtonMaterials&gt;) {
    commands
        .spawn(NodeBundle {
            style: Style {
                size: Size::new(Val::Percent(100.), Val::Percent(100.)),
                display: Display::Flex,
                flex_direction: FlexDirection::Column,
                align_items: AlignItems::FlexStart,
                justify_content: JustifyContent::FlexStart,
                ..Default::default()
            },
            material: button_materials.none.clone(),
            ..Default::default()
        })
        .with(MenuUI)
        .with_children(|parent| {
            // 生成新按钮
            parent
                .spawn(ButtonBundle {
                    style: Style {
                        size: Size::new(Val::Px(350.0), Val::Px(65.0)),
                        margin: Rect::all(Val::Auto),
                        justify_content: JustifyContent::Center,
                        align_items: AlignItems::Center,
                        ..Default::default()
                    },
                    material: button_materials.normal.clone(),
                    ..Default::default()
                })
                .with_children(|parent| {
                    parent.spawn(TextBundle {
                        text: Text {
                            value: &quot;Play&quot;.to_string(),
                            font: button_materials.font.clone(),
                            style: TextStyle {
                                font_size: 20.0,
                                color: Color::rgb(0.9, 0.9, 0.9),
                                ..Default::default()
                            },
                        },
                        ..Default::default()
                    });
                });
        });
}
<span class="boring">}
</span></code></pre></pre>
<p>这看起来非常类似于 <code>ui.rs</code> 中的 <code>setup_ui</code>。但结构类似于 <code>NodeBundle &gt; ButtonBundle &gt; TextBundle</code>。</p>
<p>我们还要创建一个删除所有按钮的系统，这样我们就可以在离开菜单时运行它。如果不这样做，菜单按钮会一直停留在游戏屏幕上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
fn despawn_menu(commands: &amp;mut Commands, query: Query&lt;(Entity, &amp;MenuUI)&gt;) {
    for (entity, _) in query.iter() {
        commands.despawn_recursive(entity);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>给这个系统实现插件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
pub struct MenuPlugin;
impl Plugin for MenuPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.init_resource::&lt;ButtonMaterials&gt;()
            .on_state_enter(APP_STATE_STAGE, AppState::Menu, setup_menu.system())
            .on_state_exit(APP_STATE_STAGE, AppState::Menu, despawn_menu.system());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>把它添加到 <code>main.rs</code> 中，导入它并在 <code>main</code> 函数中增加 <code>.add_plugin(MenuPlugin)</code> 调用：</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
mod menu;
use menu::MenuPlugin;

fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_resource(State::new(AppState::Menu))
        .add_stage_after(
            stage::UPDATE,
            APP_STATE_STAGE,
            StateStage::&lt;AppState&gt;::default(),
        )
        .init_resource::&lt;ScoreResource&gt;()
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin)
        .add_plugin(UIPlugin)
        .add_plugin(AudioPlugin)
        .add_plugin(ShadersPlugin)
        .add_plugin(MenuPlugin) // &lt;--- 新代码
        .run();
}


fn setup(commands: &amp;mut Commands) {
    commands
        .spawn(Camera2dBundle::default())
        .spawn(CameraUiBundle::default());
}
</code></pre></pre>
<p>我们还要更改 <code>setup</code>，不再是 <code>SongConfig</code> 资源，因为我们会在玩家点击按钮选择歌曲时添加它。</p>
<p>现在运行游戏会显示下面这样的按钮：</p>
<p><img src="https://caballerocoll.com/images/rhythm_basic_menu.png" alt="" /></p>
<p>目前，单击按钮并将鼠标悬停在按钮上会发现按钮什么也没有干，所以我们需要让菜单能根据需要有所反应。首先，我们将添加一个系统，根据按钮的交互改变颜色：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
fn button_color_system(
    button_materials: Res&lt;ButtonMaterials&gt;,
    mut query: Query&lt;
        (&amp;Interaction, &amp;mut Handle&lt;ColorMaterial&gt;),
        (Mutated&lt;Interaction&gt;, With&lt;Button&gt;),
    &gt;,
) {
    for (interaction, mut material) in query.iter_mut() {
        match *interaction {
            Interaction::Clicked =&gt; {
                *material = button_materials.pressed.clone();
            }
            Interaction::Hovered =&gt; {
                *material = button_materials.hovered.clone();
            }
            Interaction::None =&gt; {
                *material = button_materials.normal.clone();
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里我们使用的是 <code>Interaction</code> 组件，它和 <code>ButtonBundle</code> 一起。它有三个不同的变体，<code>Clicked</code>，<code>Hovered</code> 和 <code>None</code>。分别表示：单机按钮，悬停在按钮上，不做任何事。我们将匹配按钮的所有可能的值，从而做出不同的反应。将 <code>MenuPlugin</code> 加到游戏中，运行游戏，观察鼠标悬停、点击或移开时按钮的颜色是如何变化的。</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_button_interactions.mp4">视频资源</a></p>
</blockquote>
<h2><a class="header" href="#优化菜单" id="优化菜单">优化菜单</a></h2>
<p>我们还需要两个东西：在文件夹中显示歌曲列表菜单，以及正式开始游戏的按钮。我们从第一点开始，在 <code>menu.rs</code> 中增加一个方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
use std::fs::read_dir;

pub fn get_songs() -&gt; Vec&lt;String&gt; {
    let paths = read_dir(&quot;assets/songs&quot;).unwrap();

    let mut vec = vec![];
    for path in paths {
        let path = path.unwrap().path();

        if &quot;toml&quot; == path.as_path().extension().unwrap() {
            vec.push(
                path.as_path()
                    .file_stem()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_string(),
            );
        }
    }
    vec
}
<span class="boring">}
</span></code></pre></pre>
<p>这个函数使用 <a href="https://doc.rust-lang.org/std/fs/fn.read_dir.html"><code>read_dir</code></a> 获取 <code>songs</code> 目录中的文件，并将 <code>.toml</code> 后缀文件路径追加到数组中。</p>
<p>现在我们可以从 <code>setup_menu</code> 内部调用这个函数，来为 <code>get_songs</code> 得到的每个文件增加按钮。首先，我们创建一个枚举组件加到按钮中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
enum MenuButton {
    MakeMap,
    PlaySong(String),
}
impl MenuButton {
    fn name(&amp;self) -&gt; String {
        match self {
            Self::MakeMap =&gt; &quot;Make map&quot;.to_string(),
            Self::PlaySong(song) =&gt; format!(&quot;Play song: {}&quot;, song),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>枚举的第一个变体 <code>MakeMap</code> 用于进入地图制作模式（如果实现了）。另一个变体 <code>PlaySong</code> 用于开始特定的歌曲游戏。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
fn setup_menu(commands: &amp;mut Commands, button_materials: Res&lt;ButtonMaterials&gt;) {
    // 制作按钮列表
    let mut buttons: Vec&lt;MenuButton&gt; = get_songs()
        .iter()
        .map(|name| MenuButton::PlaySong(name.clone()))
        .collect();
    buttons.push(MenuButton::MakeMap);

    commands
        .spawn(NodeBundle {
            style: Style {
                size: Size::new(Val::Percent(100.), Val::Percent(100.)),
                display: Display::Flex,
                flex_direction: FlexDirection::Column,
                align_items: AlignItems::FlexStart,
                justify_content: JustifyContent::FlexStart,
                ..Default::default()
            },
            material: button_materials.none.clone(),
            ..Default::default()
        })
        .with(MenuUI)
        .with_children(|parent| {
            // 将所有按钮以子按钮的方式加入
            for button in buttons {
                // 生成新按钮
                parent
                    .spawn(ButtonBundle {
                        style: Style {
                            size: Size::new(Val::Px(350.0), Val::Px(65.0)),
                            margin: Rect::all(Val::Auto),
                            justify_content: JustifyContent::Center,
                            align_items: AlignItems::Center,
                            ..Default::default()
                        },
                        material: button_materials.normal.clone(),
                        ..Default::default()
                    })
                    .with_children(|parent| {
                        parent.spawn(TextBundle {
                            text: Text {
                                value: button.name(),
                                font: button_materials.font.clone(),
                                style: TextStyle {
                                    font_size: 20.0,
                                    color: Color::rgb(0.9, 0.9, 0.9),
                                    ..Default::default()
                                },
                            },
                            ..Default::default()
                        });
                    })
                    .with(button);
            }
        });
}
<span class="boring">}
</span></code></pre></pre>
<p>我们已替换了 <code>with_children</code> 的内容，来循环遍历按钮列表，从而创建按钮。</p>
<p>注意：我们设置按钮的方式有点菜，所以如果你有很多按钮显示的话，它会看起来很奇怪！添加一个滚动条或者其他改善方式就留给读者作为练习了。</p>
<p>效果如下图所示：</p>
<p><img src="https://caballerocoll.com/images/rhythm_menu_with_correct_buttons.png" alt="" /></p>
<p>现在我们要让按钮可用。为此，我们添加另一个“系统”来监听点击事件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
use crate::types::load_config;

fn button_press_system(
    commands: &amp;mut Commands,
    asset_server: Res&lt;AssetServer&gt;,
    query: Query&lt;(&amp;Interaction, &amp;MenuButton), (Mutated&lt;Interaction&gt;, With&lt;Button&gt;)&gt;,
    mut state: ResMut&lt;State&lt;AppState&gt;&gt;,
) {
    for (interaction, button) in query.iter() {
        // 在这一帧中检测按钮是否被点击
        if *interaction == Interaction::Clicked {
            match button {
                // 如果地图制作按钮被点击，改变模式
                MenuButton::MakeMap =&gt; state
                    .set_next(AppState::MakeMap)
                    .expect(&quot;Couldn't switch state to MakeMap&quot;),
                // 如果它是一个播放歌曲按钮，加载对应配置，插入资源，然后改变态模式
                MenuButton::PlaySong(song) =&gt; {
                    let config = load_config(&amp;*format!(&quot;{}.toml&quot;, song), &amp;asset_server);
                    commands.insert_resource(config);
                    state
                        .set_next(AppState::Game)
                        .expect(&quot;Couldn't switch state to Game&quot;)
                }
            };
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个系统中，我们循环遍历每个按钮，并检查它们是否处于点击状态。如果是，我们会匹配按钮的类型，执行相应的逻辑。对于 <code>MakeMap</code>，我们只需使用 <code>set_next</code> 改变状态。对于 <code>PlaySong</code>，用我们创建的 <code>SongConfig</code> 函数来加载选定歌曲的 <code>SongConfig</code>，在将状态更改为 <code>Game</code> 之前，我们使用 <code>insert_resource</code> 添加歌曲。</p>
<p>最后，我们应该把这个系统添加到 <code>MenuPlugin</code>，设置成 <code>Menu</code> 状态更新时运行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// menu.rs
pub struct MenuPlugin;
impl Plugin for MenuPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.init_resource::&lt;ButtonMaterials&gt;()
            .on_state_enter(APP_STATE_STAGE, AppState::Menu, setup_menu.system())
            .on_state_update(
                APP_STATE_STAGE,
                AppState::Menu,
                button_color_system.system(),
            )
            .on_state_update(
                APP_STATE_STAGE,
                AppState::Menu,
                button_press_system.system(),
            )
            .on_state_exit(APP_STATE_STAGE, AppState::Menu, despawn_menu.system());
    
}
<span class="boring">}
</span></code></pre></pre>
<p>现在运行游戏，我们会看到按钮正常工作，开始游戏：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_menu_changing_state.mp4">视频资源</a></p>
</blockquote>
<p>但有个大问题！当我们开始游戏时，时间在跑了，箭头却没有显示！因为我们使用 <code>time_since_startup</code> 来检查何时生成箭头，当我们进入 <code>Game</code> 状态时，值已经过了第一个箭头的生成时间，所以不会出现，其它箭头也不会出现。为了解决这个问题，我们将在后面制作一个包装器，这样我们就可以在进入 <code>Game</code> 模式时重置它。</p>
<h2><a class="header" href="#时间系统封装" id="时间系统封装">时间系统封装</a></h2>
<p>我们的时间包装器非常类似于 Bevy 的时间资源实现，不同的是它需要在我们进入 <code>Game</code> 和 <code>MakeMap</code> 状态时重置时间系统。复制所有代码只是为了改善一些糟糕的东西，但这会让我们在未来做其他工作时带来方便，比如暂停。这也是一个了解 Bevy 源码的好机会。</p>
<p>此外，通过同时拥有一个正常的时间资源和我们自己包装的版本，可以让我们使用正常的时间资源，以及其他需要控制时间的场景。例如，我们要继续为游戏背景使用正常时间，因为我们希望它在所有状态下都能工作。</p>
<p>打开一个新文件， <code>time.rs</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::consts::*;
use bevy::{
    prelude::*,
    utils::{Duration, Instant},
};

pub struct ControlledTime {
    delta: Duration,
    last_update: Option&lt;Instant&gt;,
    delta_seconds_f64: f64,
    delta_seconds: f32,
    seconds_since_startup: f64,
    startup: Instant,
}
impl Default for ControlledTime {
    fn default() -&gt; Self {
        Self {
            delta: Duration::from_secs(0),
            last_update: None,
            startup: Instant::now(),
            delta_seconds_f64: 0.0,
            seconds_since_startup: 0.0,
            delta_seconds: 0.0,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里我们添加了一个与 Bevy 的 time 相同的结构体，使用相同的 <code>Default</code> 实现，我们将其称为 <code>ControlledTime</code>。</p>
<p>现在，添加我们想要的方法，它来自于<a href="https://github.com/bevyengine/bevy/blob/3b2c6ce49b3b9ea8bc5cb68f8d350a80ff928af6/crates/bevy_core/src/time/time.rs">这个资源</a>，此外我们还会添加一个 <code>reset_time</code> 函数，它将时间设置为 0：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// time.rs
impl ControlledTime {
    pub fn reset_time(&amp;mut self) {
        self.startup = Instant::now();
        self.seconds_since_startup = 0.0;
    }

    pub fn update(&amp;mut self) {
        let now = Instant::now();
        self.update_with_instant(now);
    }

    pub fn update_with_instant(&amp;mut self, instant: Instant) {
        if let Some(last_update) = self.last_update {
            self.delta = instant - last_update;
            self.delta_seconds_f64 = self.delta.as_secs_f64();
            self.delta_seconds = self.delta.as_secs_f32();
        }

        let duration_since_startup = instant - self.startup;
        self.seconds_since_startup = duration_since_startup.as_secs_f64();
        self.last_update = Some(instant);
    }

    /// 当前标记和最后一次标记的时间差是 [`f32`] 秒
    #[inline]
    pub fn delta_seconds(&amp;self) -&gt; f32 {
        self.delta_seconds
    }

    /// 当前标记和最后一次标记的时间差是 [`f64`] 秒
    #[inline]
    pub fn delta_seconds_f64(&amp;self) -&gt; f64 {
        self.delta_seconds_f64
    }

    /// 启动后的时间，以秒为单位
    #[inline]
    pub fn seconds_since_startup(&amp;self) -&gt; f64 {
        self.seconds_since_startup
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>考虑到这一点，我们需要一个能够更新时间的“系统”：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// time.rs
pub fn update_time(mut time: ResMut&lt;ControlledTime&gt;) {
    time.update();
}
<span class="boring">}
</span></code></pre></pre>
<p>并且有一个系统对时间进行重置</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// time.rs
pub fn reset_time_when_entering_game(mut time: ResMut&lt;ControlledTime&gt;) {
    time.reset_time();
}
<span class="boring">}
</span></code></pre></pre>
<p>我们还会添加一个插件来把它们放在一起：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// time.rs
pub struct TimePlugin;
impl Plugin for TimePlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.init_resource::&lt;ControlledTime&gt;()
            .on_state_update(APP_STATE_STAGE, AppState::Game, update_time.system())
            .on_state_update(APP_STATE_STAGE, AppState::MakeMap, update_time.system())
            .on_state_enter(
                APP_STATE_STAGE,
                AppState::Game,
                reset_time_when_entering_game.system(),
            )
            .on_state_enter(
                APP_STATE_STAGE,
                AppState::MakeMap,
                reset_time_when_entering_game.system(),
            );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们在 <code>Game</code> 和 <code>MapMaker</code> 执行期间设置了 <code>update_time</code>，并且 <code>reset_time_when_entering_game</code> 在这两种模式下都会执行。</p>
<p>跟其它插件一样，我们在 <code>main.rs</code> 中添加：</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
mod time;
use time::TimePlugin;

fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_resource(State::new(AppState::Menu))
        .add_stage_after(
            stage::UPDATE,
            APP_STATE_STAGE,
            StateStage::&lt;AppState&gt;::default(),
        )
        .init_resource::&lt;ScoreResource&gt;()
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin)
        .add_plugin(UIPlugin)
        .add_plugin(AudioPlugin)
        .add_plugin(ShadersPlugin)
        .add_plugin(MenuPlugin)
        .add_plugin(TimePlugin) // &lt;--- New
        .run();
}
</code></pre></pre>
<p>我们需要做的最后一件事就是用 <code>ControlledTime</code> 代替 <code>Time</code>。</p>
<p>首先是 <code>ui.rs</code>，我们只需改变 <code>update_time_text</code> 中的 <code>time</code> 参数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ui.rs
use crate::time::ControlledTime;

fn update_time_text(time: Res&lt;ControlledTime&gt;, mut query: Query&lt;(&amp;mut Text, &amp;TimeText)&gt;) {
    [...]
}
<span class="boring">}
</span></code></pre></pre>
<p><code>audio.rs</code> 文件也一样，将 <code>Time</code> 替换为 <code>ControlledTime</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// audio.rs
use crate::time::ControlledTime;

fn start_song(audio: Res&lt;Audio&gt;, time: Res&lt;ControlledTime&gt;, config: Res&lt;SongConfig&gt;) {
    [...]
}
<span class="boring">}
</span></code></pre></pre>
<p>最后是 <code>arrows.rs</code> 文件，要修改的地方多一些：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs
use crate::time::ControlledTime;

/// Spawns arrows
fn spawn_arrows(
    commands: &amp;mut Commands,
    mut song_config: ResMut&lt;SongConfig&gt;,
    materials: Res&lt;ArrowMaterialResource&gt;,
    time: Res&lt;ControlledTime&gt;,
) {
    [...]
}

/// Moves the arrows forward
fn move_arrows(time: Res&lt;ControlledTime&gt;, mut query: Query&lt;(&amp;mut Transform, &amp;Arrow)&gt;) {
    [...]
}
<span class="boring">}
</span></code></pre></pre>
<p>现在运行游戏，可以看到菜单和游戏正常工作了：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_working_menu_and_game.mp4">视频资源</a></p>
</blockquote>
<p>太棒了！</p>
<h2><a class="header" href="#添加简单的地图制作模式" id="添加简单的地图制作模式">添加简单的地图制作模式</a></h2>
<p>在本节中，我们添加一个场景模式来帮助我们给歌曲创建地图。我们想要的是当歌曲播放时，我们何时按下按键，并将它们保存到一个文件中。</p>
<p>我们打开一个新文件 <code>map_maker.rs</code>，我们从添加资源和“系统”开始：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::time::ControlledTime;
use crate::consts::*;
use crate::types::{
    ArrowTimeToml,
    Directions::{self, *},
    Speed,
};
use bevy::{
    app::AppExit,
    input::{keyboard::KeyCode, Input},
    prelude::*,
};
use serde_derive::Serialize;
use std::fs::File;
use std::io::prelude::*;

#[derive(Serialize, Debug, Default)]
/// 跟踪按键被按下的时间
struct Presses {
    arrows: Vec&lt;ArrowTimeToml&gt;,
}

/// 保存被按下的键
fn save_key_presses(
    time: Res&lt;ControlledTime&gt;,
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut presses: ResMut&lt;Presses&gt;,
) {
    let directions = [Up, Down, Left, Right];
    for direction in directions.iter() {
        if direction.key_just_pressed(&amp;keyboard_input) {
            presses.arrows.push(ArrowTimeToml {
                click_time: time.seconds_since_startup(),
                speed: Speed::Slow,
                direction: *direction,
            });
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们大量添加需要增加的东西，我们创建 <code>Presses</code> 资源，它保存了一个 <code>ArrowTimeToml</code> 列表，以及一个当方向键被按下时添加到该列表的“系统”，并循环所有方向的按键。</p>
<p>我们还需要一个系统来监听 <code>AppExit</code> 事件，并将 <code>ArrowTimeToml</code> 列表保存到文件中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// map_maker.rs
fn save_to_file_on_exit(
    mut event_reader: Local&lt;EventReader&lt;AppExit&gt;&gt;,
    events: Res&lt;Events&lt;AppExit&gt;&gt;,
    presses: Res&lt;Presses&gt;,
) {
    for _event in event_reader.iter(&amp;events) {
        let text = toml::to_string(&amp;*presses).expect(&quot;Couldn't convert to toml text&quot;);

        let mut file = File::create(&quot;map.toml&quot;).expect(&quot;Couldn't open map.toml&quot;);
        file.write_all(text.as_bytes())
            .expect(&quot;Couldn't write to map.toml&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们得做点什么来提高这个模式的易用性。当玩家按下一个按键时，相应的方向会有箭头出现在屏幕上。我们将添加两个系统，一个生成箭头，一个切换箭头的可见性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// map_maker.rs
struct MapMakerArrow(Directions);

/// Creates map maker arrows
fn setup_map_maker_arrows(
    commands: &amp;mut Commands,
    mut materials: ResMut&lt;Assets&lt;ColorMaterial&gt;&gt;,
    asset_server: ResMut&lt;AssetServer&gt;,
) {
    let border_handle = materials.add(asset_server.load(&quot;images/arrow_border.png&quot;).into());

    let directions = [Up, Down, Left, Right];
    for direction in directions.iter() {
        let y = match direction {
            Up =&gt; 150.,
            Down =&gt; 50.,
            Left =&gt; -50.,
            Right =&gt; -150.,
        };

        let mut transform = Transform::from_translation(Vec3::new(0., y, 1.));
        transform.rotate(Quat::from_rotation_z(direction.rotation()));
        commands
            .spawn(SpriteBundle {
                material: border_handle.clone(),
                sprite: Sprite::new(Vec2::new(140., 140.)),
                transform,
                ..Default::default()
            })
            .with(MapMakerArrow(*direction));
    }
}

/// 根据是否按下对应的键来切换可见性
fn toggle_map_maker_arrows(
    mut query: Query&lt;(&amp;mut Visible, &amp;MapMakerArrow)&gt;,
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    for (mut visible, arrow) in query.iter_mut() {
        visible.is_visible = arrow.0.key_pressed(&amp;keyboard_input);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>第一个“系统”非常类似于 <code>spawn_target_arrows</code>，它只是创建精灵，并添加我们刚刚声明的 <code>MapMakerArrow</code> 组件。第二个系统是 <code>toggle_map_maker_arrows</code>，根据箭头对应的方向键是否被按下来设置箭头的可见性。我们通过设置精灵的 <code>Visible</code> 中的 <code>is_visible</code> 字段来做到这一点。</p>
<p>这里有一个问题，我们目前给 <code>Directions</code> 声明的 <code>key_just_pressed</code> 方法使用了 <code>just_pressed</code>，这只会在按键被按下的第一帧时才会生效。我们希望玩家按下按键，箭头就立即显示，所以我们添加了另一种 <code>pressed</code> 方法，它可以实现我们想要的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// types.rs
impl Directions {
    [Other methods...]

    /// 检查是否按下与当前方向相同的方向键
    pub fn key_pressed(&amp;self, input: &amp;Input&lt;KeyCode&gt;) -&gt; bool {
        let keys = match self {
            Directions::Up =&gt; [KeyCode::Up, KeyCode::D],
            Directions::Down =&gt; [KeyCode::Down, KeyCode::F],
            Directions::Left =&gt; [KeyCode::Left, KeyCode::J],
            Directions::Right =&gt; [KeyCode::Right, KeyCode::K],
        };

        keys.iter().any(|code| input.pressed(*code))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样，我们的 <code>toggle_map_maker_arrows</code> 系统就可以正常工作了！我们还要给所有的歌曲地图实现一个插件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// map_maker.rs
pub struct MapMakerPlugin;
impl Plugin for MapMakerPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.init_resource::&lt;Presses&gt;()
            .on_state_enter(
                APP_STATE_STAGE,
                AppState::MakeMap,
                setup_map_maker_arrows.system(),
            )
            .on_state_update(
                APP_STATE_STAGE,
                AppState::MakeMap,
                toggle_map_maker_arrows.system(),
            )
            .on_state_update(
                APP_STATE_STAGE,
                AppState::MakeMap,
                save_key_presses.system(),
            )
            .on_state_update(
                APP_STATE_STAGE,
                AppState::MakeMap,
                save_to_file_on_exit.system(),
            );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>要想让它运行起来，我们还需要在 <code>main.rs</code> 中加上“系统”的调用代码：</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
mod map_maker;
use map_maker::MapMakerPlugin;

fn main() {
    App::build()
        // Set antialiasing to use 4 samples
        .add_resource(Msaa { samples: 4 })
        // Set WindowDescriptor Resource to change title and size
        .add_resource(WindowDescriptor {
            title: &quot;Rhythm!&quot;.to_string(),
            width: 800.,
            height: 600.,
            ..Default::default()
        })
        .add_resource(State::new(AppState::Menu))
        .add_stage_after(
            stage::UPDATE,
            APP_STATE_STAGE,
            StateStage::&lt;AppState&gt;::default(),
        )
        .init_resource::&lt;ScoreResource&gt;()
        .add_startup_system(setup.system())
        .add_system(exit_on_esc_system.system())
        .add_plugins(DefaultPlugins)
        .add_plugin(ArrowsPlugin)
        .add_plugin(UIPlugin)
        .add_plugin(AudioPlugin)
        .add_plugin(ShadersPlugin)
        .add_plugin(MenuPlugin)
        .add_plugin(TimePlugin)
        .add_plugin(MapMakerPlugin) // &lt;--- 新增代码
        .run();
}
</code></pre></pre>
<p>现在，我们可以运行游戏来看看地图制作模式是否能正常工作：</p>
<blockquote>
<p><a href="https://caballerocoll.com/images/rhythm/rhythm_map_maker_mode.mp4">视频资源</a></p>
</blockquote>
<p>请记住，在游戏终端中使用 ESC 键退出，而不是 <code>Ctrl+C</code> 键，这样才能保存文件成功。</p>
<p>这是我们得到的一个文件示例：</p>
<pre><code class="language-map.toml">[[arrows]]
click_time = 1.04939044
speed = &quot;Slow&quot;
direction = &quot;Up&quot;

[[arrows]]
click_time = 1.658164574
speed = &quot;Slow&quot;
direction = &quot;Down&quot;

[[arrows]]
click_time = 2.191576505
speed = &quot;Slow&quot;
direction = &quot;Up&quot;

[[arrows]]
click_time = 2.558483463
speed = &quot;Slow&quot;
direction = &quot;Up&quot;

[[arrows]]
click_time = 2.858588189
speed = &quot;Slow&quot;
direction = &quot;Left&quot;

[[arrows]]
click_time = 3.4904190330000002
speed = &quot;Slow&quot;
direction = &quot;Up&quot;

[[arrows]]
click_time = 3.9252477949999998
speed = &quot;Slow&quot;
direction = &quot;Up&quot;

[[arrows]]
click_time = 4.240984206
speed = &quot;Slow&quot;
direction = &quot;Left&quot;

[[arrows]]
click_time = 4.62353972
speed = &quot;Slow&quot;
direction = &quot;Up&quot;

[[arrows]]
click_time = 4.97381796
speed = &quot;Slow&quot;
direction = &quot;Up&quot;

[[arrows]]
click_time = 5.308837329
speed = &quot;Slow&quot;
direction = &quot;Left&quot;
</code></pre>
<p>现在我们可以将它添加到 <code>assets/songs</code> 目录下，添加 <code>name</code> 和 <code>filename</code> 字段，这样就有了歌曲的工作地图！</p>
<p>我们需要做的最后一件事是在地图制作模式下播放歌曲，否则它就显得有点鸡肋。我们简单实现一下，并且给使用的歌曲路径硬编码，这样可以让教程简短一些（如果还算短的话）。我们将使用路径 <code>assets/map_maker_song.mp3</code> 中的歌曲。玩家必须在地图制作器中修改文件路径来更换歌曲。每个人都可以实现一些自己的“系统”，以更容易地选择地图制作器中使用的歌曲。</p>
<h2><a class="header" href="#在地图制作器中播放歌曲" id="在地图制作器中播放歌曲">在地图制作器中播放歌曲</a></h2>
<p>为了让音乐进入地图制作器，我们先要添加一个资源来保存 <code>Handle&lt;AudioSource&gt;</code>。我们要为该资源实现 <code>FromResources</code>，这样可以在开始时就加载它，当把它加载到地图制作器中时，它就准备好可以玩了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MapMakerAudio(Handle&lt;AudioSource&gt;);
impl FromResources for MapMakerAudio {
    fn from_resources(resources: &amp;Resources) -&gt; Self {
        let asset_server = resources.get_mut::&lt;AssetServer&gt;().unwrap();
        let audio = asset_server.load(&quot;map_maker_song.mp3&quot;);
        Self(audio)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这一次我决定使用一个元组结构体来处理资源，因为我们只有一个字段。<code>FromResources</code> 实现了静态资源服务器，它可以加载音频资源。</p>
<p>在那之后，我们要创建一个新“系统”来进行播放音频，我们将把它设置为进入 <code>MakeMap</code> 的状态时执行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// map_maker.rs
fn start_song(audio: Res&lt;Audio&gt;, map_maker_audio: Res&lt;MapMakerAudio&gt;) {
    audio.play(map_maker_audio.0.clone());
}
<span class="boring">}
</span></code></pre></pre>
<p>我们要做的最后一件事是将这两个资源加到插件中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// map_maker.rs
pub struct MapMakerPlugin;
impl Plugin for MapMakerPlugin {
    fn build(&amp;self, app: &amp;mut AppBuilder) {
        app.init_resource::&lt;Presses&gt;()
            .init_resource::&lt;MapMakerAudio&gt;() // &lt;--- 新代码
            .on_state_enter(APP_STATE_STAGE, AppState::MakeMap, start_song.system()) // &lt;--- 新代码
            .on_state_enter(
                APP_STATE_STAGE,
                AppState::MakeMap,
                setup_map_maker_arrows.system(),
            )
            .on_state_update(
                APP_STATE_STAGE,
                AppState::MakeMap,
                toggle_map_maker_arrows.system(),
            )
            .on_state_update(
                APP_STATE_STAGE,
                AppState::MakeMap,
                save_key_presses.system(),
            )
            .on_state_update(
                APP_STATE_STAGE,
                AppState::MakeMap,
                save_to_file_on_exit.system(),
            );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>找一个音频文件，并将其放到 <code>assets/map_maker_song.mp3</code> 中，如果你运行游戏，进入地图制作模式时，应该可以听到音频播放了！</p>
<p>至此，我们的游戏教程就结束了。和往常一样，你可以随意尝试，修改一些东西，让它成为你的东西！如果你有任何的改进，请在 <a href="https://twitter.com/guimcaballero">Twitter</a> 标记我，这样我就能看到了！</p>
<h2><a class="header" href="#下一步" id="下一步">下一步</a></h2>
<p>如果你还没想好要做什么样的二次开发，以下提供一些可以尝试的想法：</p>
<ul>
<li>1.添加必须在特定的时间内保持状态的箭头。</li>
<li>2.改进地图制作器，增加选择歌曲的功能。</li>
<li>3.给游戏增加一个游戏结束画面。</li>
<li>4.增加一种歌曲播放完后，回到菜单的方式</li>
<li>5.创建一个可以改变点击阈值的“系统”，可以让玩家在困难模式时选择简单模式，玩家很轻松则切换到困难模式。</li>
</ul>
<h1><a class="header" href="#译arenas-in-rust" id="译arenas-in-rust">「译」Arenas in Rust</a></h1>
<p>译者：<a href="https://github.com/MATRIXKOO">MATRIXKOO</a> / 后期编辑：张汉东</p>
<blockquote>
<p>原文: <a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/">Arenas in Rust</a></p>
</blockquote>
<hr />
<h1><a class="header" href="#rust-中的-arenas-内存池" id="rust-中的-arenas-内存池">Rust 中的 Arenas 内存池</a></h1>
<p>最近有一些关于 Rust 中 <code>Arenas</code> 的讨论，我想我应该写一篇关于这个文章。</p>
<p>在 Rust 中，<code>Arenas</code> 并不是那种 &quot;典型的&quot; 问题，所以很少有人了解它们。只会在各种用例的应用程序中有看到它们。一般来说，你只需要调包就行了，没必要为它使用 <code>unsafe</code> 。因此无需专门去学会写它，但这些知识也不是无用的，尤其是对有使用 <code>Arenas</code> 的人来说更是如此 。</p>
<p>此外，我在实现自引用（self-referential）的 <code>Arenas</code> 时会涉及到一系列非常<em>酷</em>的 <code>lifetime</code>操作 ，我以前完全没写过。</p>
<p>我主要是为了写一些<em>很酷</em>的生命周期效应而写的，但是我认为有必要写一篇针对所有 <code>Rustaceans</code> 的介绍。如果你已经知道什么是 <code>Arenas</code>，并且想看到一些很炫酷的 <code>lifetime</code> 技巧，则可以直接跳到<a href="https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/#implementing-a-self-referential-arena">这里</a>阅读。</p>
<h2><a class="header" href="#什么是-arena-" id="什么是-arena-">什么是 arena ?</a></h2>
<p><code>Arenas</code> 本质上是一种将预期生命周期相同的内存进行分组的模式。比如说有时需要在某个生命周期内分配一堆对象，之后这些对象将被全部销毁。每次都调用系统分配器效率低下，更可取的是为对象预分配一堆内存，并在完成处理后立即将其全部清理干净。
&gt;译者注: 没错就是 cache</p>
<p>从广义上讲，使用 <code>Arenas</code>  有以下两个原因：</p>
<p>首先，如上所述，使用它主要目标可能是减轻内存消耗。例如，在游戏或应用程序中，可能存在大量需要逐帧分配，使用完立即销毁的情况。特别是在游戏开发中，这非常普遍，而内存压力是游戏开发人员比较关心的事情。使用  <code>Arenas</code>，可以轻松地分配一个 <code>Arena</code>，在每个帧中将其填满，并在帧结束后将其清空。缓存局部性还能其他好处：可以确保大多数每帧对象在帧期间（可能比其他对象使用得更多）位于缓存中，因为它们是相邻分配的。</p>
<p>另一个原因可能是用于编写自引用的数据，例如带有环的复杂图，使用此方法数据可以一次全部清除。例如，在编写编译器时，<code>type</code>信息可能将需要引用其他类型或者其他数据，从而导致复杂的，可能是 <code>type</code> 的有环图。一旦推导出类型，就不需要专门销毁它了，因此可以使用一个 <code>Arenas</code> 来存储所有计算出的类型信息，当类型信息无关紧要时，就可以直接将他们一次性清楚。使用这种模式可以让代码不必担心自引用位是否会 “提前” 释放，它可以保证，如果存在一个 <code>Ty</code> ，则它的寿命与其他所有 <code>Ty</code> 一样长，并且可以直接引用它们。</p>
<blockquote>
<p>译者注: 不会导致空引用</p>
</blockquote>
<p>这两个目标不一定是相互联系的：可以使用一个 <code>Arenas</code>来同时实现两个目标。但是，也可以拥有一个禁止使用自引用类型的 <code>Arenas</code>（有得有失，你能得到一些好处）。在本文的稍后部分，我将实现一个允许自引用类型但对减轻内存分配压力影响不大的  <code>Arenas</code>，主要是为了易于实现。<em>通常</em>，如果要为编写用于自引用类型 的 <code>Arenas</code>，则可以使其同时减少分配器压力，但可能会有所取舍。 </p>
<h2><a class="header" href="#在-rust-中如何使用-arena-" id="在-rust-中如何使用-arena-">在 Rust 中如何使用 arena ?</a></h2>
<p>一般来说，要使用 arena ，只需要调包。 我简单的搜索一下现有的 <code>Arenas</code> 实现，在<a href="https://crates.io/search?q=arena">这里</a>。下面我会介绍两个我已经了解的库，但我只是挂 &quot;二&quot; 漏万。</p>
<p>要指出的是，如果只需要环结构，而不必使用 <code>arenas</code> ，那么出色的 <a href="https://docs.rs/petgraph/">petgraph</a> 通常就足够了。 <a href="https://docs.rs/slotmap/">slotmap</a> 也很不错； 它是类似地图的数据结构，可用于基于分代索引的自引用数据。 </p>
<h3><a class="header" href="#bumpalo" id="bumpalo">Bumpalo</a></h3>
<p><code>Bumpalo</code> 是一种快速的 <code>bump allocator[1]</code>，它允许异构的内容，并且仅在不关心析构函数运行的情况下才允许循环。</p>
<blockquote>
<p>参见: [1]https://blog.codingnow.com/2013/11/bump_pointer_allocator.html</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bumpalo::Bump;

// (example slightly modified from `bumpalo` docs)

// Create a new arena to bump allocate into.
let bump = Bump::new();

// Allocate values into the arena.
let scooter = bump.alloc(Doggo {
    cuteness: u64::max_value(),
    age: 8,
    scritches_required: true,
});

// Happy birthday, Scooter!
scooter.age += 1;
<span class="boring">}
</span></code></pre></pre>
<p>每次对 <code>Bump::alloc()</code> 的调用都会返回对已分配对象的可变引用。 这可以分配不同的对象，它们甚至可以相互引用 (不用环的话,借用检查就会强制这样做) 。 默认情况下，它不会在其内容上调用析构函数。 但是，可以使用 <code>bumpalo::boxed</code>（或Nightly上的自定义分配器）来实现这个效果。 可以类似地使用 <code>bumpalo::collections</code>来获取 <code>bumpalo</code> 支持的向量和字符串。<code> bumpalo::boxed</code> 将不允许自引用。 
x</p>
<h3><a class="header" href="#typed-arena" id="typed-arena">typed-arena</a></h3>
<p>［typed-arena](https://docs.rs/typed-arena/)是一个 <code>areana</code> 分配器，它只能存储单一类型的对象，但是就可以循环引用： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example from typed-arena docs

use std::cell::Cell;
use typed_arena::Arena;

struct CycleParticipant&lt;'a&gt; {
    other: Cell&lt;Option&lt;&amp;'a CycleParticipant&lt;'a&gt;&gt;&gt;,
}

let arena = Arena::new();

let a = arena.alloc(CycleParticipant { other: Cell::new(None) });
let b = arena.alloc(CycleParticipant { other: Cell::new(None) });

// mutate them after the fact to set up a cycle
a.other.set(Some(b));
b.other.set(Some(a));
<span class="boring">}
</span></code></pre></pre>
<p>和 <code>bumpalo</code> 不同的是，<code>typed-arena</code> 当 <code>arena</code> 本身超出范围时，就会使用析构函数
&gt;你或许想知道，析构函数在引用数据上的安全性–毕竟，无论哪一个变量被第二次销毁，析构函数都会读到悬挂的引用。 我们将在文章的后面对此进行介绍，但这与 <code>drop</code> 检查有关，特别是如果尝试自引用时，则 arena 元素 本身允许的唯一显式析构函数将是带有适当标记类型的析构函数。 </p>
<h2><a class="header" href="#实现一个支持自引用的-arena" id="实现一个支持自引用的-arena">实现一个支持自引用的 arena</a></h2>
<p>写自引用代码是很有趣的，因为 Rust 非常警惕自引用数据。 但是 <code>areana</code> 可以让你清楚地将“我不在乎此对象”和“可以删除此对象”阶段分开，以允许自引用和循环类型出现。</p>
<blockquote>
<p>人们很少需要实现自己的 arena，Bumpalo和Typedarena涵盖了大多数使用场景，实在没办法的话不妨先在 crates.io上 找一下。 但是，如果你的确需要直接实现的话，或者对具体的生命周期细节感兴趣，那么本节适合你。 </p>
</blockquote>
<p>在以下规则中实现输入条目为Entry的竞技场Arena的关键：</p>
<ul>
<li><code>Arena</code> 和 <code>Entry</code> 都应具有生命周期参数：<code>Arena &lt;'arena&gt;</code> 和 <code>Entry &lt;'arena&gt;</code></li>
<li><code>Arena</code> 方法都应将 <code>Arena &lt;'arena&gt;</code> 接收为 <code>＆'arena</code> 自身，即其自身类型为<code>＆'arena Arena &lt;'arena&gt;</code></li>
<li><code>Entry</code>几乎应该始终以 <code>＆'arena Entry &lt;'arena&gt;</code> 的形式传递（为此创建别名非常有用）</li>
<li>使用内部可变性； <code>Arena</code>上的 <code>＆mut self</code> 将使所有代码停止编译。 如果使用 <code>unsafe</code>的可变性，请确保 <code>RefCell &lt;Entry &lt;'arena &gt;&gt;</code>  具有 <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a> 。</li>
</ul>
<p>从生命周期的角度来看基本上就是这样，剩下的全部就是确定所需的 API 。 掌握了以上规则，只要确保定义区域与所需的保证一起使用，就不必了解底层生命周期的状况。</p>
<p>让我们看一个 实现，然后剖析其工作原理。 </p>
<p>###　实现
我的库 <a href="https://docs.rs/elsa">elsa</a> 在其中一个示例中使用 100％ <code>safe</code> 的代码实现了一个 <code>arena</code> 。由于 <code>elsa :: FrozenVec</code> 要求其内容位于间接引用之后，因此该 <code>arena</code> 无法节省分配，并且它不是通用的，但这是一种合理的方式来说明生命周期的工作方式，而无需陷入 使用 <code>unsafe</code> 带来的麻烦之中。</p>
<p>该示例实现了 <code>Person &lt;'arena&gt;</code> 类型的 <code>Arena</code> ，<code>Arena &lt;'arena&gt;</code> 。目标是实现某种可能有环的有向社交图。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use elsa::FrozenVec;

struct Arena&lt;'arena&gt; {
    people: FrozenVec&lt;Box&lt;Person&lt;'arena&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/elsa/1.4.0/elsa/vec/struct.FrozenVec.html">elsa::FrozenVec</a>是类似于 <code>Vec</code> 的仅支持追加内容的抽象，可让你调用<code>push</code> 而不需要传入可变的引用，这是只使用 <code>safe</code> 的一个实现。</p>
<p>每个 <code>Person &lt;'arena&gt;</code> 都有一个他们关注的人的列表，但也跟踪他们关注的人： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person&lt;'arena&gt; {
    pub follows: FrozenVec&lt;PersonRef&lt;'arena&gt;&gt;,
    pub reverse_follows: FrozenVec&lt;PersonRef&lt;'arena&gt;&gt;,
    pub name: &amp;'static str,
}

// following the rule above about references to entry types
type PersonRef&lt;'arena&gt; = &amp;'arena Person&lt;'arena&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这个生命周期 <code>arena</code>  其实是 “arena本身的生命周期”。 从这开始事情就变得奇怪起来了：通常，如果一个有生命周期参数，则调用者可以选择其中的内容。 不必只是说“这是对象本身的生命周期”，调用者通常可以根据需要实例化 <code>arena &lt;'static&gt;</code> 或为某个 <code>'a</code> 实例化 <code>Arena &lt;'a&gt;</code> 。 但是在这里，我们声明 “<code> 'arena</code> 是 <code>arena</code> 自身的生命周期&quot; ； 很明显，一定有东西不太对。</p>
<p>这是我们实际实现的地方： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;'arena&gt; Arena&lt;'arena&gt; {
    fn new() -&gt; Arena&lt;'arena&gt; {
        Arena {
            people: FrozenVec::new(),
        }
    }
    
    fn add_person(&amp;'arena self, name: &amp;'static str,
                  follows: Vec&lt;PersonRef&lt;'arena&gt;&gt;) -&gt; PersonRef&lt;'arena&gt; {
        let idx = self.people.len();
        self.people.push(Box::new(Person {
            name,
            follows: follows.into(),
            reverse_follows: Default::default(),
        }));
        let me = &amp;self.people[idx];
        for friend in &amp;me.follows {
            // We're mutating existing arena entries to add references,
            // potentially creating cycles!
            // 把每一个元素都加上了 引用 , 很有可能导致循环引用
            friend.reverse_follows.push(me)
        }
        me
    }

    fn dump(&amp;'arena self) {
        // code to print out every Person, their followers, and the people who follow them
        // 打印出 `Person` ,他们的关注者 ,和关注的人
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>注意 <code>add_person中的&amp;'arena self</code>。</p>
<p>此处的很好的实现了,“如果A 关注了 B，然后B又关注A” 这种通常需要分开处理的情况，但这仅是示例。</p>
<p>最后，我们可以像这样使用 <code>arena</code> ： </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arena = Arena::new();
    let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
    let best_friend = arena.add_person(&quot;best friend&quot;, vec![lonely]);
    let threes_a_crowd = arena.add_person(&quot;threes a crowd&quot;, vec![lonely, best_friend]);
    let rando = arena.add_person(&quot;rando&quot;, vec![]);
    let _everyone = arena.add_person(&quot;follows everyone&quot;, vec![rando, threes_a_crowd, lonely, best_friend]);
    arena.dump();
}
</code></pre></pre>
<p>在这种情况下，所有 “可变性” 都发生在 <code>arena</code> 本身的实现中，但是此代码可能会将元素直接添加到 <code>follows/reverse_follows</code> 列表中，或者 <code>Person</code> 可能具有用于其他类型链接的 <code>RefCells</code> 。</p>
<h3><a class="header" href="#生命周期是如何工作的" id="生命周期是如何工作的">生命周期是如何工作的</a></h3>
<p>那么这是如何工作的呢？ 如前所述，在 Rust 中使用这样的抽象，调用者通常可以自由地根据其处理方式来设置生存期。 例如，如果 <code>HashMap&lt;K，&amp;'a str&gt;</code>，则 <code>'a</code> 将根据你尝试插入的内容的生存期进行调整。</p>
<p>当构造 <code>Arena</code> 时，其生命周期确实仍然不受限制，我们可以通过检查以下强制约束生命周期的代码来进行测试。 (依然是能过编译的)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena: Arena&lt;'static&gt; = Arena::new();
<span class="boring">}
</span></code></pre></pre>
<p>当你想做点什么的时候,就会停止工作:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena: Arena&lt;'static&gt; = Arena::new();
let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">error[E0597]: `arena` does not live long enough
  --&gt; examples/mutable_arena.rs:5:18
   |
4  |     let arena: Arena&lt;'static&gt; = Arena::new();
   |                -------------- type annotation requires that `arena` is borrowed for `'static`
5  |     let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
   |                  ^^^^^ borrowed value does not live long enough
...
11 | }
   | - `arena` dropped here while still borrowed
</code></pre>
<p><code>add_person</code> 方法以某种方式强制将 <code>Arena</code> 的 <code>arena</code> 参数设置为自己的生命周期，从而对其进行约束（并且无法用类型注释将其强制约束为其他任何值）。 这是与 <code>add_person</code> 的<code>＆'arena</code> 自签名（即 self 是 <code>＆'arena Arena &lt;'self&gt;</code> ）的巧妙互动，以及<code>'Arena in Arena &lt;'arena&gt;</code> 是<a href="https://doc.rust-lang.org/nomicon/subtyping.html#variance">不变的生命周期</a>。 </p>
<p>通常，在 Rust 程序中，生命周期具有&quot;伸缩性&quot;。 以下代码可以通过编译：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ask for two strings *with the same lifetime*
// 要求具有相同 生命周期的 string 
fn take_strings&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) {}

// string literal with lifetime 'static
// 要求具有 `'static' 生命周期的 ` string literal`  
let lives_forever = &quot;foo&quot;;
// owned string with shorter, local lifetime
// 要求具有 `local` 生命周期
let short_lived = String::from(&quot;bar&quot;);

// still works!
// 能跑通
take_strings(lives_forever, &amp;*short_lived);
<span class="boring">}
</span></code></pre></pre>
<p>在这段代码中，Rust 很高兴地注意到，虽然 <code>live_forever</code> 和 <code>&amp;* short_lived</code> 具有不同的生命周期，但假装 <code>life_forever</code> 在 <code>take_strings</code> 函数的有效期内具有较短的生命周期是完全可以接受的。这只是引用，使用生命周期长的引用也适用于生命周期短的情况。</p>
<p>事实是，这种伸缩性并非对所用的生命周期都一样！<a href="https://doc.rust-lang.org/nomicon/subtyping.html">nomicon chapter on subtyping and variance</a> 一章详细说明了为什么会这样，但一般的经验法则是，大多数生命周期都是“紧缩的” (更专业的说法是 <code>协变的</code> )，就像上面的<code>&amp;a str</code> 中的一样，但是如果涉及某种形式的可变性，它们是不可变的，也称为“不变式”。如果使用的是函数类型，则具有 <code>弹性的</code> 生命周期 (即抗变的)，但是这种情况很少见。 </p>
<p>我们的 <code>Arena &lt;'arena&gt;</code> 使用内部可变性（通过 <code>FrozenVec</code>）使' <code>arena</code>不变。 让我们再次看一下两行代码。当编译器看到下面代码的第一行时，便会构建 <code>arena</code>，我们将其生命周期称为“ a”。此时 Arena 类型是 <code>Arena &lt;'？&gt;</code> ，其中的'？由表示形式表示，但生命周期不受限制。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena = Arena::new(); 
let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<p>让我们把生命周期写清楚一点</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arena = Arena::new(); // type Arena&lt;'?&gt;, lives for 'a

// explicitly write the `self` that gets constructed when you call add_person
// 显式写出 在调用 add_person 时的构建函数
let ref_to_arena = &amp;arena; // type &amp;'a Arena&lt;'?&gt;
let lonely = Arena::add_person(ref_to_arena, &quot;lonely&quot;, vec![]);
<span class="boring">}
</span></code></pre></pre>
<p>还记得我之前列出的第二条规则吗？</p>
<ul>
<li>Arena方法都应将Arena &lt;'arena&gt;接收为＆'arena自身，即其自身类型为＆'arena Arena &lt;'arena&gt; 我们遵循这条规则； </li>
</ul>
<p><code>add_person</code> 的签名是 <code>fn add_person(&amp;'arena self)</code>。这意味着 <code>ref_to_arena</code> 的生存期必须与 <code>&amp;'arena Arena &lt;'arena&gt;</code> 模式匹配。目前，它的生命周期是<code>&amp;'a Arena &lt;'?&gt;</code>，表示<code> '？</code>强制与'a相同，即 <code>arena</code> 变量本身的生存期。如果生命周期是可变的，则编译器可以压缩其他生存期来适配它，但它是不变的，并且不受限制的生存期被强制转变成一个确切的生命周期。</p>
<p>通过这个巧妙的技巧，我们可以强制编译器将 <code>Arena &lt;'arena&gt;</code> 的生存期参数设置为其实例的生存期。 </p>
<p>在此之后，其余的工作就非常简单了。 <code>Arena &lt;'arena&gt;</code> 拥有类型为 <code>Person &lt;'arena&gt;</code>的元素，也就是说：“<code>Person</code> 被允许引用具有 <code>'arena</code> 生命周期的元素, 例如 <code>Arena</code> &quot;。</p>
<p><code>type PersonRef &lt;'arena&gt; =&amp;'arena Person &lt;'arena&gt;</code>是“引用在 <code>Arena</code> 中并允许从其中引用对象 <code>Person</code> 的引用的便捷缩写。</p>
<h3><a class="header" href="#析构器如何工作" id="析构器如何工作">析构器如何工作</a></h3>
<p>到目前为止，我还没有讨论存在析构函数的情况下如何保证安全。 如果 <code>Arena</code> 具 有循环引用，并且编写了一个析构函数读取去这些循环引用，那么在销毁的过程中就会导致悬垂引用。 </p>
<p>这是 rust 十分模糊的地方。 除了“明确析构器巧妙地改变借用检查行为”，你没有什么需要必须去了解的。 但是了解这里的机制对建立一个更好的心智模型更有帮助。 </p>
<p>如果将以下代码添加到 <code>arena</code> 示例中： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'arena&gt; Drop for Person&lt;'arena&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;goodbye {:?}&quot;, self.name);
        for friend in &amp;self.reverse_follows {
            // potentially dangling!
            println!(&quot;\t\t{}&quot;, friend.name);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>报错:</p>
<pre><code class="language-shell">error[E0597]: `arena` does not live long enough
  --&gt; examples/mutable_arena.rs:5:18
   |
5  |     let lonely = arena.add_person(&quot;lonely&quot;, vec![]);
   |                  ^^^^^ borrowed value does not live long enough
...
11 | }
   | -
   | |
   | `arena` dropped here while still borrowed
   | borrow might be used here, when `arena` is dropped and runs the destructor for type `Arena&lt;'_&gt;`
</code></pre>
<p>析构函数的存在在自引用数据的生命周期内巧妙地更改了借用检查器的行为。准确的规则是十分 <code>tricky</code>的，并在 <a href="https://doc.rust-lang.org/nomicon/dropck.html">nomicon</a>中进行了解释，但实际上发生的是，在Person &lt;'arena&gt;上存在自定义析构函数后，<code>'person arena</code>（因为是Arena）的 '<code>'arena</code>变成了一个“在销毁时观测到的的生命周期&quot;。然后在借用检查期间将其考虑在内---知道作用域末尾隐式调用<code>drop()</code>能够读取<code>'arena</code>的数据，Rust 做出了适当的结论，由于销毁本身是可变的操作，在销毁之后，调用<code>drop()</code> 读取内容是可行的 。 </p>
<p>当然，需要问的一个合理问题是，如果析构函数不允许用 <code>'arena</code> '“包装”数据，应该如何在 <code>arena</code> 中存储例如 <code>Box</code> 或者 <code>FrozenVec</code>之类的东西呢? </p>
<p>原因是 Rust 知道 <code>Box::Drop </code>由于不清楚 <code>Person</code> 是什么,也不会去试图知道,而无法检查 <code>Person.follows</code>的内容。</p>
<p>当然凡事都有例外,由于析构器可以调用指定的 <code>trait</code> 方法(或者特化的方法)来告诉如何读取<code>Person</code>的内容,如果有一个随机的泛型类型提供了这种方法,就可以再次巧妙地更改借用检查器的行为。<code> stdlib</code> 类型和其他自定义数据结构通过转义填充<code>＃[may_dangle]</code>（也称为“ eyepatch” 毕竟析构器 &quot;看不到&quot; 生命周期）来实现这种目的，声明不会从生命周期或通用参数中读取自定义析构函数。 </p>
<p>这也适用于诸如  <a href="https://docs.rs/typed-arena/">typed-arena </a>之类的库；如果需要创建循环引用，则将无法在为放置在 <code>arena</code>  上的类型上编写自定义析构函数。但是只要避免创建循环引用就可以使用 <code>typed-arena</code> 编写自定义析构函数了；因此将无法使用内部可变性来使一个 <code>arena</code> 指向另一个 <code>arena</code>。 </p>
<p>感谢 <a href="https://mpc.sh/">Mark Cohen</a> 和 <a href="https://twitter.com/kneecaw/">Nika Layzell</a> 审阅了这篇文章的草稿。 </p>
<h1><a class="header" href="#译用rust编写llvm的玩具编译器" id="译用rust编写llvm的玩具编译器">「译」用Rust编写LLVM的玩具编译器</a></h1>
<p>译者：<a href="https://github.com/iamazy">iamazy</a> / 后期编辑：张汉东</p>
<blockquote>
<p>原文：<a href="https://blog.ulysse.io/post/a-toy-front-end-for-llvm-written-in-rust/">A Toy Front-End for LLVM, written in Rust</a></p>
</blockquote>
<hr />
<h2><a class="header" href="#正文-2" id="正文-2">正文</a></h2>
<blockquote>
<p>我目前的副业是用 Rust 编写一个可以将代码转换成 LLVM IR 的编译器。LLVM 的 API 对于新手来说有点令人生畏，而且没有很多有关的教程（有限的教程大多数还是基于 C++ 的，如何使用 Rust 做同样的事并不总是那么明确）。我希望当我准备做一件事情时，有人可以手把手的教我，这也是我要写这篇文章的原因。</p>
</blockquote>
<p>对于 Rust，与 LLVM 的接口交互的最佳选择是使用 <code>llvm-sys</code>。互联网上的一些热心朋友在<a href="http://rustdoc.taricorp.net/llvm-sys/llvm_sys/">这里</a>托管了一些关于 <code>llvm-sys</code> 的文档。当然，你还应该去查看 LLVM 的<a href="http://llvm.org/docs/tutorial/LangImpl01.html">官方指南</a>，因为它可以帮助你理解 LLVM 是如何“思考”的。这篇文章基本上是 LLVM 官方指南的 Rust 翻译。</p>
<p>你可以从这里获取最终的<a href="https://github.com/ucarion/llvm-rust-getting-started">代码</a>。</p>
<h2><a class="header" href="#搭建开发环境" id="搭建开发环境">搭建开发环境</a></h2>
<p>对于新手，使用 LLVM 开发有一个可以复用的方式：</p>
<pre><code class="language-shell"># `curl` is just so we can next install Rust
sudo apt-get -y install clang curl llvm-3.8-dev
curl https://sh.rustup.rs -sSf | sh

# The `llvm-sys` crate expects something called `llvm-config` on your PATH.
sudo ln -s /usr/bin/llvm-config-3.8 /usr/bin/llvm-config
</code></pre>
<p>如果你是在 Ubuntu 上执行上面的语句（你可能需要执行 <code>apt-get update</code> ），则没有任何问题。如果不是，你需要使用下面的 <code>Vagrantfile</code> 文件在 Vagrant Box 中运行上述语句。</p>
<pre><code class="language-shell">Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;bento/ubuntu-16.04&quot;
end
</code></pre>
<p>你可以从执行 <code>cargo init llvm-example --bin</code> 开始，并将下面（从 llvm-sys 中拷贝）的代码写入 <code>src/main.rs</code> 中：</p>
<pre><pre class="playground"><code class="language-rust">//! Construct a function that does nothing in LLVM IR.

extern crate llvm_sys as llvm;

use std::ptr;

fn main() {
    unsafe {
        // Set up a context, module and builder in that context.
        let context = llvm::core::LLVMContextCreate();
        let module = llvm::core::LLVMModuleCreateWithName(b&quot;nop\0&quot;.as_ptr() as *const _);
        let builder = llvm::core::LLVMCreateBuilderInContext(context);

        // Get the type signature for void nop(void);
        // Then create it in our module.
        let void = llvm::core::LLVMVoidTypeInContext(context);
        let function_type = llvm::core::LLVMFunctionType(void, ptr::null_mut(), 0, 0);
        let function = llvm::core::LLVMAddFunction(module, b&quot;nop\0&quot;.as_ptr() as *const _, function_type);

        // Create a basic block in the function and set our builder to generate
        // code in it.
        let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function,b&quot;entry\0&quot;.as_ptr() as *const _);
        llvm::core::LLVMPositionBuilderAtEnd(builder, bb);

        // Emit a `ret void` into the function
        llvm::core::LLVMBuildRetVoid(builder);

        // Dump the module as IR to stdout.
        llvm::core::LLVMDumpModule(module);

        // Clean up. Values created in the context mostly get cleaned up there.
        llvm::core::LLVMDisposeBuilder(builder);
        llvm::core::LLVMDisposeModule(module);
        llvm::core::LLVMContextDispose(context);
    }
}
</code></pre></pre>
<p>并在你的 <code>Cargo.toml</code> 文件中：</p>
<pre><code class="language-toml">[package]
name = &quot;llvm-example&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Ulysse Carion &lt;ulysse@ulysse.io&gt;&quot;]

[[bin]]
name = &quot;main&quot;

[dependencies]
llvm-sys = &quot;0.2&quot;
</code></pre>
<p>你可以获得：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cargo run
   Compiling llvm-example v0.1.0 (file:///vagrant)
     Running `target/debug/main`
; ModuleID = 'nop'

define void @nop() {
entry:
  ret void
}
</code></pre>
<p>完美！现在我们可以开始编写自己的东西了。</p>
<h2><a class="header" href="#一段不太平凡的程序" id="一段不太平凡的程序">一段不太平凡的程序</a></h2>
<p>首先，让我们编译一个程序，该程序通过从 main 函数中返回一个整数来简单的设置一个返回码。</p>
<p>下面是我使用的方式（我们有时候需要使用一个解析器，所以我先添加了 <code>peg</code> 库）：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(plugin)]
#![plugin(peg_syntax_ext)]

extern crate llvm_sys as llvm;

use std::ffi::CString;
use std::fs::File;
use std::io::Read;
use std::ptr;

fn main() {
    let mut input = String::new();
    let mut f = File::open(&quot;in.ex&quot;).unwrap();
    f.read_to_string(&amp;mut input).unwrap();

    let parsed_input = parser::program(&amp;input).unwrap();

    unsafe {
        codegen(parsed_input);
    }
}

peg! parser(r#&quot;
    #[pub]
    program -&gt; String
        = i:int_literal &quot;\n&quot; { i }

    int_literal -&gt; String
        = [0-9]+ { match_str.to_owned() }
&quot;#);

unsafe fn codegen(input: String) {
    let context = llvm::core::LLVMContextCreate();
    let module = llvm::core::LLVMModuleCreateWithName(b&quot;example_module\0&quot;.as_ptr() as *const _);
    let builder = llvm::core::LLVMCreateBuilderInContext(context);

    // In LLVM, you get your types from functions.
    let int_type = llvm::core::LLVMInt64TypeInContext(context);
    let function_type = llvm::core::LLVMFunctionType(int_type, ptr::null_mut(), 0, 0);
    let function = llvm::core::LLVMAddFunction(module, b&quot;main\0&quot;.as_ptr() as *const _, function_type);

    let entry_name = CString::new(&quot;entry&quot;).unwrap();
    let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function, entry_name.as_ptr());
    llvm::core::LLVMPositionBuilderAtEnd(builder, bb);

    // The juicy part: construct a `LLVMValue` from a Rust value:
    let int_value: u64 = input.parse().unwrap();
    let int_value = llvm::core::LLVMConstInt(int_type, int_value, 0);

    llvm::core::LLVMBuildRet(builder, int_value);

    // Instead of dumping to stdout, let's write out the IR to `out.ll`
    let out_file = CString::new(&quot;out.ll&quot;).unwrap();
    llvm::core::LLVMPrintModuleToFile(module, out_file.as_ptr(), ptr::null_mut());

    llvm::core::LLVMDisposeBuilder(builder);
    llvm::core::LLVMDisposeModule(module);
    llvm::core::LLVMContextDispose(context);
}
</code></pre></pre>
<p>它起作用了！测试一下：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cat in.ex
42
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ lli-3.8 out.ll ; echo $?
42
</code></pre>
<p>有点酷哦！顺便提一下，下面是 <code>out.ll</code> 文件的内容：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  ret i64 42
}
</code></pre>
<h2><a class="header" href="#算术" id="算术">算术</a></h2>
<p>让我们添加对数字的加减乘除操作的支持。为了实现这个，我们需要扩展我们的语法。我们引入一个枚举来代表 AST（抽象语法树）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Literal(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>并扩展语法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `product` and `sum` are that way to get operator precedence
peg! parser(r#&quot;
    use super::Expr;

    #[pub]
    program -&gt; Expr
        = e:expression &quot;\n&quot; { e }

    expression -&gt; Expr
        = sum

    sum -&gt; Expr
        = a:product _ &quot;+&quot; _ b:sum { Expr::Add(Box::new(a), Box::new(b)) }
        / a:product _ &quot;-&quot; _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) }
        / product

    product -&gt; Expr
        = a:int_literal _ &quot;*&quot; _ b:product { Expr::Mul(Box::new(a), Box::new(b)) }
        / a:int_literal _ &quot;/&quot; _ b:product { Expr::Div(Box::new(a), Box::new(b)) }
        / int_literal

    int_literal -&gt; Expr
        = [0-9]+ { Expr::Literal(match_str.to_owned()) }

    _ = &quot; &quot;*
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<p>接下来，可以提交代码。你可以指定诸如 “addtmp” 的字符串，这些字符串将被用作 IR 中对应“寄存器”名称的一部分。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When you write out instructions in LLVM, you get back `LLVMValueRef`s. You
// can then use these references in other instructions.
unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        Expr::Literal(int_literal) =&gt; {
            let int_type = llvm::core::LLVMInt64TypeInContext(context);
            llvm::core::LLVMConstInt(int_type, int_literal.parse().unwrap(), 0)
        },

        Expr::Add(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;addtmp&quot;).unwrap();
            llvm::core::LLVMBuildAdd(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Sub(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;subtmp&quot;).unwrap();
            llvm::core::LLVMBuildSub(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Mul(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;multmp&quot;).unwrap();
            llvm::core::LLVMBuildMul(builder, lhs, rhs, name.as_ptr())
        },

        Expr::Div(lhs, rhs) =&gt; {
            let lhs = codegen_expr(context, builder, *lhs);
            let rhs = codegen_expr(context, builder, *rhs);

            let name = CString::new(&quot;divtmp&quot;).unwrap();
            llvm::core::LLVMBuildUDiv(builder, lhs, rhs, name.as_ptr())
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，你可以执行 <code>10 * 4 + 20/2 - 8</code> 之类的程序！如果你问我，那可真是太酷了。</p>
<h2><a class="header" href="#变量" id="变量">变量</a></h2>
<p>我们将采用简单的方式并假设程序不会执行任何烦人的操作，如引用未定义的变量等。我们只将变量存储在寄存器中，并将它们存在 <code>HashMap&lt;String, LLVMValueRef&gt;</code> 中，之所以有用是因为运行该程序只有这一种方式。</p>
<p>我们扩展语言和解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Literal(String),
    Ref(String),
    Assign(String, Box&lt;Expr&gt;),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
}

peg! parser(r#&quot;
    use super::Expr;

    #[pub]
    program -&gt; Vec&lt;Expr&gt;
        = e:(expression ** &quot;\n&quot;) &quot;\n&quot; { e }

    expression -&gt; Expr
        = i:identifier _ &quot;=&quot; _ s:sum { Expr::Assign(i, Box::new(s)) }
        / sum

    sum -&gt; Expr
        = a:product _ &quot;+&quot; _ b:sum { Expr::Add(Box::new(a), Box::new(b)) }
        / a:product _ &quot;-&quot; _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) }
        / product

    product -&gt; Expr
        = a:ref_or_literal _ &quot;*&quot; _ b:product { Expr::Mul(Box::new(a), Box::new(b)) }
        / a:ref_or_literal _ &quot;/&quot; _ b:product { Expr::Div(Box::new(a), Box::new(b)) }
        / ref_or_literal

    ref_or_literal -&gt; Expr
        = i:identifier { Expr::Ref(i) }
        / int_literal

    identifier -&gt; String
        = [a-zA-Z]+ { match_str.to_owned() }

    int_literal -&gt; Expr
        = [0-9]+ { Expr::Literal(match_str.to_owned()) }

    _ = &quot; &quot;*
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<p>然后为这两个新的表达式添加支持：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, names: &amp;mut HashMap&lt;String, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        // ...

        Expr::Ref(name) =&gt; {
            *names.get(&amp;name).unwrap()
        },

        Expr::Assign(name, expr) =&gt; {
            let new_value = codegen_expr(context, builder, names, *expr);
            names.insert(name, new_value);
            new_value
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>并迅速的在 <code>codegen</code> 函数中更新：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zero = llvm::core::LLVMConstInt(int_type, 0, 0);

let mut names = HashMap::new();
let mut return_value = zero; // return value on empty program
for expr in input {
    return_value = codegen_expr(context, builder, &amp;mut names, expr);
}
llvm::core::LLVMBuildRet(builder, return_value);
<span class="boring">}
</span></code></pre></pre>
<p>现在让我们来一探究竟：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>vagrant@vagrant:/vagrant$ cat in.ex
a = 3
b = 76
a + b
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ cat out.ll
; ModuleID = 'example_module'

define i64 @main() {
entry:
  ret i64 79
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#if" id="if">If</a></h2>
<p>在使用 <code>if</code> 关键字的时候遇到一些麻烦。让 <code>if</code> 起作用的最简单的方式就是将所有的变量存储在堆栈上。并让 LLVM 做一些优化。在 LLVM 中，你可以通过 <code>alloca</code> 指令创建一个栈变量，并使用 <code>load/store</code> 进行读写。</p>
<p>为了实现这个，我们通过添加新的解析规则再一次扩展了语言和语法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>expression -&gt; Expr
    = if_expression
    / i:identifier _ &quot;=&quot; _ s:expression { Expr::Assign(i, Box::new(s)) }
    / sum

if_expression -&gt; Expr
    = &quot;if&quot; _ e:expression _ &quot;{\n&quot; _ then_body:statements _ &quot;}&quot; _ &quot;else&quot; _ &quot;{\n&quot; _ else_body:statements _ &quot;}&quot; {
        Expr::If(Box::new(e), then_body, else_body)
    }
<span class="boring">}
</span></code></pre></pre>
<p>并在 AST 节点上添加了一个新的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Literal(String),
    Ref(String),
    Assign(String, Box&lt;Expr&gt;),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Mul(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Div(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    If(Box&lt;Expr&gt;, Vec&lt;Expr&gt;, Vec&lt;Expr&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，完成关于 <code>if</code> 表达式的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, func: LLVMValueRef, names: &amp;mut HashMap&lt;String, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef {
    match expr {
        // ...

        Expr::If(condition, then_body, else_body) =&gt; {
            let condition_value = codegen_expr(context, builder, func, names, *condition);
            let int_type = llvm::core::LLVMInt64TypeInContext(context);
            let zero = llvm::core::LLVMConstInt(int_type, 0, 0);

            // `is_nonzero` is a 1-bit integer
            let name = CString::new(&quot;is_nonzero&quot;).unwrap();
            let is_nonzero = llvm::core::LLVMBuildICmp(builder, llvm::LLVMIntPredicate::LLVMIntNE, condition_value, zero, name.as_ptr());

            // It's fine to create blocks first, and then fill them in later.
            let entry_name = CString::new(&quot;entry&quot;).unwrap();
            let then_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());
            let else_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());
            let merge_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr());

            llvm::core::LLVMBuildCondBr(builder, is_nonzero, then_block, else_block);

            llvm::core::LLVMPositionBuilderAtEnd(builder, then_block);
            let mut then_return = zero;
            for expr in then_body {
                then_return = codegen_expr(context, builder, func, names, expr);
            }
            llvm::core::LLVMBuildBr(builder, merge_block);

            llvm::core::LLVMPositionBuilderAtEnd(builder, else_block);
            let mut else_return = zero;
            for expr in else_body {
                else_return = codegen_expr(context, builder, func, names, expr);
            }
            llvm::core::LLVMBuildBr(builder, merge_block);

            // Position the builder so that it's ready to work on the next
            // expression.
            llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block);
            zero
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>代码有点多，但是完成了你所期待的事情。现在，你可以像这样来运行程序：</p>
<pre><code class="language-groovy">a = 1
if a {
    a = 42
} else {
    a = 13
}
a
</code></pre>
<p>上述代码对应的 IR 如下所示：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  %a = alloca i64
  store i64 1, i64* %a
  %a1 = load i64, i64* %a
  %is_nonzero = icmp ne i64 %a1, 0
  br i1 %is_nonzero, label %entry2, label %entry3

entry2:                                           ; preds = %entry
  store i64 42, i64* %a
  br label %entry4

entry3:                                           ; preds = %entry
  store i64 13, i64* %a
  br label %entry4

entry4:                                           ; preds = %entry3, %entry2
  %a5 = load i64, i64* %a
  ret i64 %a5
}
</code></pre>
<p>然而，我们还没有结束。目前，我们的 “if” 表达式的返回结果始终为 zero（见上述 <code>codegen_expr</code> 函数中 If 分支的返回值）。而我们想要的正好与其相反，如果我们执行了 “then” 路径，则 if 的求值结果应该为 then_return，否则返回 else_return。</p>
<p>你如何使用 LLVM 跟踪它执行了哪个分支？通过使用 “phi” 节点。你给 phi 指令一个 (block, value) 对，该 phi 节点将会返回与先前执行的块相对应的值。</p>
<p>我们可以这样结束 if。注意，我们必须更新 then_block 和 else_block，因为这是我们在 “then/else” 分支中需要的最后一个块，并且前面的 then_block 是 “then/else” 的第一个块。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is mostly the same code as before, just note the new calls to
// `LLVMGetInsertBlock`.

llvm::core::LLVMPositionBuilderAtEnd(builder, then_block);
let mut then_return = zero;
for expr in then_body {
    then_return = codegen_expr(context, builder, func, names, expr);
}
llvm::core::LLVMBuildBr(builder, merge_block);
let then_block = llvm::core::LLVMGetInsertBlock(builder);

llvm::core::LLVMPositionBuilderAtEnd(builder, else_block);
let mut else_return = zero;
for expr in else_body {
    else_return = codegen_expr(context, builder, func, names, expr);
}
llvm::core::LLVMBuildBr(builder, merge_block);
let else_block = llvm::core::LLVMGetInsertBlock(builder);

// Insert the phi node
llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block);
let phi_name = CString::new(&quot;iftmp&quot;).unwrap();
let phi = llvm::core::LLVMBuildPhi(builder, int_type, phi_name.as_ptr());

let mut values = vec![then_return, else_return];
let mut blocks = vec![then_block, else_block];

llvm::core::LLVMAddIncoming(phi, values.as_mut_ptr(), blocks.as_mut_ptr(), 2);
phi
<span class="boring">}
</span></code></pre></pre>
<p>然后，你就得到了一个令人惊叹的编译器：</p>
<pre><code class="language-shell">vagrant@vagrant:/vagrant$ cat in.ex
a = 1
b = 0
c = if a {
    if b {
        11
    } else {
        40
    }
} else {
    if b {
        10
    } else {
        20
    }
}
c + 2
vagrant@vagrant:/vagrant$ cargo run
     Running `target/debug/main`
vagrant@vagrant:/vagrant$ lli-3.8 out.ll ; echo $?
42
</code></pre>
<p>太酷了！下面是我们提供的示例输入程序的 IR：</p>
<pre><code class="language-s">; ModuleID = 'example_module'

define i64 @main() {
entry:
  %a = alloca i64
  %b = alloca i64
  %c = alloca i64
  store i64 1, i64* %a
  store i64 0, i64* %b
  %a1 = load i64, i64* %a
  %is_nonzero = icmp ne i64 %a1, 0
  br i1 %is_nonzero, label %entry2, label %entry3

entry2:                                           ; preds = %entry
  %b5 = load i64, i64* %b
  %is_nonzero6 = icmp ne i64 %b5, 0
  br i1 %is_nonzero6, label %entry7, label %entry8

entry3:                                           ; preds = %entry
  %b10 = load i64, i64* %b
  %is_nonzero11 = icmp ne i64 %b10, 0
  br i1 %is_nonzero11, label %entry12, label %entry13

entry4:                                           ; preds = %entry14, %entry9
  %iftmp16 = phi i64 [ %iftmp, %entry9 ], [ %iftmp15, %entry14 ]
  store i64 %iftmp16, i64* %c
  %c17 = load i64, i64* %c
  %addtmp = add i64 %c17, 2
  ret i64 %addtmp

entry7:                                           ; preds = %entry2
  br label %entry9

entry8:                                           ; preds = %entry2
  br label %entry9

entry9:                                           ; preds = %entry8, %entry7
  %iftmp = phi i64 [ 11, %entry7 ], [ 40, %entry8 ]
  br label %entry4

entry12:                                          ; preds = %entry3
  br label %entry14

entry13:                                          ; preds = %entry3
  br label %entry14

entry14:                                          ; preds = %entry13, %entry12
  %iftmp15 = phi i64 [ 10, %entry12 ], [ 20, %entry13 ]
  br label %entry4
}

</code></pre>
<p>请注意：这些块具有以下的模式：不包含第一个条目，它们三个为一组，第一个是 “then” 分支，然后是 “else” 分支，最后是 “merge” 块（带有可识别的 phi 指令）。每一次我们遇到 “if” 表达式时都会在 main 后面附加三个新块。因为要在 AST 中递归查询三元组，所以块的三元组是有序的。</p>
<p>这就是我想要分享的全部内容！希望在这一点上你可以有足够的实力来决定你的命运。</p>
<h2><a class="header" href="#透过-rust-探索系统的本原并发篇" id="透过-rust-探索系统的本原并发篇">透过 Rust 探索系统的本原：并发篇</a></h2>
<p>作者：陈天 / 后期编辑：<a href="https://github.com/NiZerin">NiZerin</a></p>
<blockquote>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/9g0wVT-5PpmXRoKJZo-skA">https://mp.weixin.qq.com/s/9g0wVT-5PpmXRoKJZo-skA</a></p>
</blockquote>
<hr />
<p>rust 是一门非常优秀的语言，我虽然没有特别正式介绍过 rust 本身，但其实已经写了好多篇跟 rust 相关的文章：</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828208&amp;idx=1&amp;sn=1599b7cbc3bcc2c050c2689b9e46acbd&amp;chksm=8704a96cb073207a890c0056332ede6ac01eda5f5bcc02ec016b466b0fb6b6c91c3637fee1c1&amp;scene=21#wechat_redirect">沅有芷兮：类型系统的数学之美</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828386&amp;idx=1&amp;sn=555e16a024e027f6cde350a0a09d3af4&amp;chksm=8704ae3eb0732728040c309dbd4200c93483f6f40b1ac86dc7d8810f53290d870657b89ea5ce&amp;scene=21#wechat_redirect">Noise 协议的应用</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828413&amp;idx=1&amp;sn=2eadc24e7fe82581c70f78c186d0e678&amp;chksm=8704ae21b0732737f456bc372e8317edd532edeb63ee60a3a92efd748e2c5a9b5a9ec6e3caf8&amp;scene=21#wechat_redirect">用 noise 协议的思路来点对点加密文件？</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828397&amp;idx=1&amp;sn=37978455a88361c65663bc7e73fa63f3&amp;chksm=8704ae31b0732727ea88c86b95b551307b2a2d55834d3ee2a9d731165bce96289fe4a12cec0e&amp;scene=21#wechat_redirect">如何安全地保存密码？</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828863&amp;idx=1&amp;sn=5ff0ccb8b286e9ba86e2c944f244ce6d&amp;chksm=8704afe3b07326f50e903b975d655248b0136dff262a776291cf662d7c7a0f30889648570b9f&amp;scene=21#wechat_redirect">从微秒到纳秒：关于性能的奇妙旅程</a></li>
</ul>
<p>我打算写一个系列，讲讲如果透过 rust 来更好地探索系统的本原。我不知道我能写多少，也许就这一篇，也许很多篇，不管怎样，每篇都会介绍独立的概念。这个系列并不会介绍大量的 rust 代码，因此其内容对非 rust 程序员也有好处。</p>
<p>这一篇我们讲并发。几年前我曾经写过一篇介绍并发概念的文章：<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=401691172&amp;idx=1&amp;sn=b4b3a8fe51eb4250ff82e9153580f1dd&amp;chksm=0d04d0383a73592ea5f61767d2c6ee7f1ee364153fc6a3ff4d4d8253a6a17afe71c693e941e8&amp;scene=21#wechat_redirect">concurrency</a>，大家感兴趣可以看看。这篇我们从更加务实的角度，以一个简单的字典服务器程序的迭代为引子，把并发中涉及的概念和解决方法串起来。</p>
<h2><a class="header" href="#v1循环处理" id="v1循环处理">v1：循环处理</a></h2>
<p>我们的字典服务器监听 8888 端口，在服务器端维护一个 KV db（使用 hash map）。客户端可以插入（更新）一个 key 和相关的 value，也可以查询一个 key，获得对应的 value。嗯，就像 redis 服务器一样，只不过比 redis 简单十万八千倍。</p>
<p>这个需求很简单，我们马上可以想到：</p>
<ol>
<li>监听 8888 端口</li>
<li>写一个死循环，不断 <code>accept</code> socket，然后对 socket 里收到的数据进行处理。</li>
</ol>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-concurrent/1.webp" alt="" /></p>
<p>但这样是串行服务，我们只有处理完上一个 socket 的数据，才有机会处理下一个 socket，吞吐量非常有限。显然，我们需要改进。</p>
<h2><a class="header" href="#v2多线程处理" id="v2多线程处理">v2：多线程处理</a></h2>
<p>接下来我们需要解决串行服务的瓶颈。一个方法是 <code>accept</code> 之后，将新的 socket 放入一个线程里执行，于是主线程不会被阻塞住，可以继续 <code>accept</code> 后续的 socket。这样，每个 client 过来的请求都可以独立地处理。</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-concurrent/2.png" alt="" /></p>
<p>可是，这带来了一个显而易见的问题：我们的 KV db 成为了一个共享状态，它在多个线程之间共享数据。这是并发处理的第一种范式：共享状态的并发（Shared-State Concurrency）。</p>
<p>既然引入了共享状态，那么我们需要在访问它的时候做妥善的保护 —— 这个访问和操作共享状态的代码区域叫临界区（Critical Section）。如果你还记得操作系统课程的内容，你会知道，最基本的操作是使用互斥量（Mutex）来保护临界区。</p>
<p>互斥量本质是一种二元锁。当线程获得锁之后，便拥有了对共享状态的独占访问；反之，如果无法获得锁，那么将会在访问锁的位置阻塞，直到能够获得锁。在完成对共享状态的访问后（临界区的出口），我们需要释放锁，这样，其它访问者才有机会退出阻塞状态。一旦忘记释放锁，或者使用多把锁的过程中造成了死锁，那么程序就无法响应或者崩溃。rust 的内存安全模型能够避免忘记释放锁，这让开发变得非常轻松，并且最大程度上解决了（不同函数间）死锁问题。</p>
<p>但任何语言的任何保护都无法避免逻辑上的死锁，比如下面这个显而易见的例子：</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
   let data = Mutex::new(0);
   let _d1 = data.lock();
   let _d2 = data.lock(); // deadlock now
}
</code></pre></pre>
<p>互斥锁往往锁的粒度太大，在很多场景下效率太低。于是我们在此基础上分离了读写的操作，产生了读写锁（RwLock），它同一时刻允许任意数量的共享读者或者一个写者。读写锁的一个优化是顺序锁（SeqLock），它提高了读锁和写锁的独立性 —— 写锁不会被读锁阻塞，读锁也不会被写锁阻塞。，但写锁会被写锁阻塞。</p>
<p>读写锁适用于读者数量远大于写者，或者读多写少的场景。在我们这个场景下，读写的比例差别可能并不是特别明显，从 Mutex 换到 RwLock 的收益需要在生产环境中具体测试一下才能有结论。</p>
<h2><a class="header" href="#v3锁的优化" id="v3锁的优化">v3：锁的优化</a></h2>
<p>但即使我们无法通过使用不同实现的锁来优化对共享状态访问的效率，我们还是有很多方法来优化锁。无论何种方法，其核心思想是：<strong>尽可能减少锁的粒度</strong>。比如，对数据库而言，我们可以对整个数据库管理系统加锁，也可以对单个数据库的访问加锁，还可以对数据表的访问加锁，甚至对数据表中的一行或者一列加锁。对于我们的 KV db 而言，我们可以创建 N 个 hashmap（模拟多个数据库），然后把 Key 分散到这 N 个 hashmap 中，这样，不管使用什么锁，其粒度都变成之前的 1/N 了。</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-concurrent/3.webp" alt="" /></p>
<p>新的 KV db 的定义，以及添加 / 访问数据的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{hash_map::DefaultHasher, HashMap};
use std::hash::{Hash, Hasher};
use std::sync::{Arc, RwLock};

struct KvDb(Arc&lt;Vec&lt;RwLock&lt;HashMap&lt;String, Vec&lt;u8&gt;&gt;&gt;&gt;&gt;);

impl KvDb {
    pub fn new(len: usize) -&gt; Self {
        let mut dbs: Vec&lt;RwLock&lt;HashMap&lt;String, Vec&lt;u8&gt;&gt;&gt;&gt; = Vec::with_capacity(len);
        for _i in 0..len {
            dbs.push(RwLock::new(HashMap::new()))
        }
        Self(Arc::new(dbs))
    }

    pub fn insert(&amp;self, k: &amp;str, v: Vec&lt;u8&gt;) {
        let dbs = self.0.clone();
        let mut writer = dbs[(self.hash(k) % dbs.len()) as usize].write().unwrap();
        writer.insert(k.into(), v);
    }

    pub fn get(&amp;self, k: &amp;str) -&gt; Vec&lt;u8&gt; {
        let dbs = self.0.clone();
        let reader = dbs[(self.hash(k) % dbs.len()) as usize].read().unwrap();
        reader.get(k).unwrap().to_owned()
    }

    fn hash(&amp;self, k: &amp;str) -&gt; usize {
        let mut hasher = DefaultHasher::new();
        k.to_owned().hash(&amp;mut hasher);
        hasher.finish() as usize
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>rust 里面的 dashmap 提供了一个类似思路的高并发访问的 hashmap。</p>
<h2><a class="header" href="#v4share-memory-by-communicating" id="v4share-memory-by-communicating">v4：share memory by communicating</a></h2>
<p>前面的迭代不管怎么优化都跳脱不出同一种思路：Shared-state concurrency，或者说：communicate by share memory。这种方法限制很少，非常灵活，适用于任何并发场景，因而它是所有并发方案的基石。然而，灵活度带来的问题就是容易出错，需要额外的约定和限制来避免一些问题的产生。</p>
<p>那么，有没有办法把并发的需求抽象出来，设计一些更高级的数据结构和使用方法，把锁的使用隐藏起来？</p>
<p>当然有。</p>
<p>其中最有效最优雅的方法是消息传递（message passing）。我们把问题的两端分别定义成生产者和消费者。KvDb 的客户端是生产者，它们提交请求（update / get），而 KvDb 的服务器是消费者，它接受请求，返回处理的结果。连接两端的是一个消息通道（channel）。我们可以根据消息通道的两端的使用情况，将其进一步细分成几种访问模型：</p>
<ul>
<li>
<p>spsc：单生产者单消费者（Single producer single consumer）。这是最简单的访问模型，它可以用锁（RwLock）来实现并发，也可以通过一个 ring buffer 实现无锁（lock-free）并发。rust 的标准库没有 spsc 的实现，但第三方库，如 tokio，提供了 <code>oneshot</code> channel。当然我们也可以封装 <code>VecDeque</code> 来模拟 spsc。</p>
</li>
<li>
<p>mpsc：多生产者单消费者（ Multiple producer single consumer）。这是最典型的并发使用模型，大部分的客户端/服务器实现都能用 mpsc 模型来处理。rust 标准库里有 <code>std::mpsc::channel</code> 来处理 mpsc 模型。</p>
</li>
<li>
<p>spmc：单生产者多消费者（Single producer multiple consumer）。这可能是使用最少的消息模型。rust 标准库里没有对应的实现，也鲜有第三方库单独实现它。Jonhoo 做了一个 crate <code>bus</code> ，是 spmc broadcast channel，它是单个生产者对所有消费者的广播。</p>
</li>
<li>
<p>mpmc：多生产者多消费者（ Multiple producer Multiple consumer）。mpmc 是最复杂的情况，可以用来实现之前的几种模式。但因为 spsc / mpsc 有很多使用场景，所以一般我们不会用 mpmc 来模拟。rust 标准库里没有 mpmc 的实现，但 <code>crossbeam</code> 实现了高效的 mpmc channel。</p>
</li>
</ul>
<p>使用消息通道的思路，我们可以进一步迭代我们的 KvDb —— 在处理 socket 的线程和处理 state 的线程之间建立一个 mpsc channel：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-concurrent/4.png" alt="" /></p>
<p>这种方式是否更高效？不见得。但从并发处理的角度来看，它结构上更清晰，不容易出错。</p>
<p>使用消息传递来处理并发的思路是如此重要，以至于两门非常有影响力的语言将其内置在语言的运行时里，成为语言的一部分：</p>
<p>golang 内建了 channel，使用 goroutine 和 channel 来处理并发。其语言的核心思想是：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>而 erlang 内建了 actor model，让 <code>send</code>，<code>receive</code> 成为其最基本的六个函数之一。两个 actor（process）之间唯一的交流方式就是找到对方的 pid，然后发送消息。</p>
<h2><a class="header" href="#v5协程asyncawait-or-异步处理" id="v5协程asyncawait-or-异步处理">v5：协程（async/await or 异步处理）</a></h2>
<p>我们在使用多线程做并发处理时，使用的是操作系统的调度能力。这样的好处是，我们无需自己再做一个调度器，进行复杂的调度处理；坏处是，操作系统处理线程的调度需要复杂的上下文切换，其中包括用户态和内核态的切换，所以它的效率不够高，尤其是如果我们需要大量的随用随抛的「线程」时。</p>
<p>然而，「现代」的应用程序因为复杂程度越来越高，所以其并发程度也越来越高，大量的操作都涉及随用随抛的「线程」。如果我们用操作系统线程来实现这些「线程」，会大大拖累系统的整体效率，甚至会触及操作系统的限制（<code>/proc/sys/kernel/threads-max</code>）。</p>
<p>因而，「现代」的编程语言都有协程的支持 —— 在 golang 里是 goroutine，在 erlang 里是 process，在 python 里是 coroutine，在 rust 里是 future。它们可以以一个更小的粒度在用户态进行并发处理，代价是用户态需要一个调度器。golang / erlang 在语言层面的运行时提供了这个调度器，而 rust 需要引入相关的库。这些语言的用户态调度器的实现都大同小异：</p>
<ul>
<li>
<p>使用 N 个操作系统线程（一般来说 N= 硬件线程的数量）</p>
</li>
<li>
<p>每个线程上维护若干个队列，保存不同状态下的异步任务。当 ready 队列有任务时，执行该任务，直到其再度挂起或者执行完毕。所以每个异步任务本身要避免没有 IO 或系统调用的大量纯计算工作（computation intensive），如果有这样的工作，那么要主动 yield。</p>
</li>
<li>
<p>如果某个线程上没有待执行的任务，它可以去其它线程上「偷」任务（work stealing scheduler）。</p>
</li>
<li>
<p>如果某个线程上正在运行的任务被阻塞（比如执行 syscall），那么一般而言调度器会把队列里的其它任务交给没有阻塞的线程（golang），或者把阻塞操作交给其它专门的线程处理。</p>
</li>
</ul>
<p>无论从 v3 还是 v4 版本，我们都很容易把一个多线程的实现变成多协程的实现。对于 rust 而言，就是引入 async / await：</p>
<ul>
<li>
<p>把相应的函数变成 async 函数，这样函数的返回值会变成一个 <code>Future</code>。</p>
</li>
<li>
<p>在调用 async 函数的地方，添加 <code>.await</code> 来处理 async 的状态机。</p>
</li>
<li>
<p>在使用 <code>spawn</code> 的地方，使用 <code>tokio</code> 或者 <code>async_std</code> 对应的 <code>spawn</code>，来创建一个协程。</p>
</li>
<li>
<p>在入口函数，引入 <code>executor</code>，比如使用宏 <code>#[tokio::main]</code>。</p>
</li>
</ul>
<p>对于我们的 kv server，因为协程处理的流程图和线程处理类似（内部机制大不一样），所以这里我就不附图了。</p>
<h2><a class="header" href="#one-more-thing线程和协程间的同步" id="one-more-thing线程和协程间的同步">One more thing：线程和协程间的同步</a></h2>
<p>在一个复杂的系统里，线程和协程可能会同时出现。我们用线程做计算密集的事情，而用协程做 IO 密集的事情，这样系统可以达到最好的吞吐能力。遗憾的是，很多以协程为卖点的语言，如 erlang 和 golang，你所面临的环境是受控的（某种意义上说，这也是优势 - don't make me think），只能创建协程，而不能创建线程。所以无法做这样的优化。而另一些语言，如 Python，Scala，虽然同时支持线程和协程，两者混合使用要么效率不高，要么没有很好的库，用起来很别扭（我并没有 scala 经验，关于 akka 和 thread 混用的别扭只是道听途说）。</p>
<p>而 Rust 处理得很优雅 — <code>tokio::sync</code> 提供了在同步和异步线程之间使用 channel 同步的工具。你甚至感觉不到你的数据在不同的 runtime 间穿梭。其实站在操作系统的角度想想也能释然：管它是线程和协程，在操作系统层面都是线程，只不过协程是运行在某些线程上的受那些线程独立调度的数据结构而已。所以，线程和协程间的同步，归根结底，还是线程之间的同步问题。而线程间同步的手段，我们都可以使用，只不过在这种场景下，channel 是最好（最舒服）的选择。</p>
<p>所以，我们可以在系统启动时（或者服务器启动时），在普通的线程和 tokio 管理的线程（Runtime）间创建好一个 channel，然后在各自的上下文中处理流入流出 channel 的数据，如下图所示：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-concurrent/5.webp" alt="" /></p>
<p>本文中我们提到的这个 KV store 的例子太简单，并不涉及同步线程和异步线程之间的同步，我举个其它例子。上篇文章《<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828863&amp;idx=1&amp;sn=5ff0ccb8b286e9ba86e2c944f244ce6d&amp;chksm=8704afe3b07326f50e903b975d655248b0136dff262a776291cf662d7c7a0f30889648570b9f&amp;scene=21#wechat_redirect">从微秒到纳秒</a>》讲了如何使用多线程来处理不同 repo 下的事件的写入。下图是之前文章里的主流程：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-concurrent/6.webp" alt="" /></p>
<p>在这个流程的基础上，我们需要添加一个新的功能：当日志文件 rotate 时，我们发一个消息出去，由一组 uploader 线程负责把刚刚关闭封存的日志文件传输到 S3。</p>
<p>Rust 下和 S3 打交道的库是 Rusoto，Rusoto 是全异步的处理，因而我们需要一个 Tokio runtime 来处理异步的任务。我们可以在 <code>Server.start</code> 接口来处理 Runtime 的创建，然后创建 channel，把 rx 交给 Tokio runtime 下运行的一个死循环的异步任务，这个任务从 rx 里取数据，然后 spawn 新的异步任务将 file 上传到 S3 对应 bucket 的 key 下。而 channel 的 tx 端则传给每个 repo 的 <code>LoggerWriter</code>，这样，<code>LoggerWriter</code> 在做 rotation 的时候，就可以通过 tx 发送要上传给 S3 的本地文件名 file，以及上传到 S3 的对象的 key。如下图所示：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-concurrent/7.webp" alt="" /></p>
<p>整个流程同样看上去不容易实现，但最终添加的也就是二十行代码而已（不计入 S3 具体上传的代码）。</p>
<h2><a class="header" href="#透过-rust-探索系统的本原安全篇" id="透过-rust-探索系统的本原安全篇">透过 Rust 探索系统的本原：安全篇</a></h2>
<p>作者：陈天 / 后期编辑：<a href="https://github.com/NiZerin">NiZerin</a></p>
<blockquote>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/HCHYr5sWnEG_qOGE3hfNnQ">https://mp.weixin.qq.com/s/HCHYr5sWnEG_qOGE3hfNnQ</a></p>
</blockquote>
<hr />
<p>安全是我的老本行，隔一段时间不拉出来谈一谈就不舒服。我个人觉得：做应用不谈安全都是在耍流氓。</p>
<p>按照 CISSP[1] 的定义，安全有八大领域：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/1.webp" alt="" /></p>
<p>本文只关注 Communication and Network Security 中 TCP/IP 范畴下的 Session Layer Security，也就是 TCP/UDP 层之上的安全方案：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/2.webp" alt="" /></p>
<p>目前业界首选的方案是 TLS[2]。在所有流行的应用层解决方案中，都离不开 TLS。</p>
<p>在 p2p 领域，TLS 并不那么受待见，大家似乎更喜欢和 TLS 提供了同等安全水平，但更加去中心化（不需要 CA[3]）的 noise protocol[4]。我去年写过一篇关于 Noise protocol 的文章：<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828386&amp;idx=1&amp;sn=555e16a024e027f6cde350a0a09d3af4&amp;chksm=8704ae3eb0732728040c309dbd4200c93483f6f40b1ac86dc7d8810f53290d870657b89ea5ce&amp;scene=21#wechat_redirect">Noise 框架：构建安全协议的蓝图</a>。</p>
<p>本文围绕 TLS 和 Noise protocol，以及它们在 Rust 下的使用场景，谈谈我们如何做安全的系统和应用。</p>
<h2><a class="header" href="#安全的本质" id="安全的本质">安全的本质</a></h2>
<p>很多人谈到安全，首先想到的是加密解密。加解密只解决了安全范畴的机密性（confidentialilty）的问题，但它没有触及另外两个重要的范畴：完整性（integrity）和可用性（availability）。我们简单讲一下这三个概念：</p>
<ul>
<li>
<p>机密性：信息在使用和传输的过程中以密文保存，只有授权的用户才可以获取到明文。</p>
</li>
<li>
<p>完整性：信息在使用和传输的过程中，不会被非法授权和破坏。</p>
</li>
<li>
<p>可用性：合法用户对信息的访问不会被拒绝。</p>
</li>
</ul>
<p>为了保证可用性，我们会提供服务的高可用性（防止 DoS 以及服务故障），做数据冗余和灾备处理（防止数据丢失），监控，故障转移等等。</p>
<p>为了保证完整性，我们会使用哈希算法，数字签名来保证数据的一致性。</p>
<p>为了保证机密性，我们会使用对称和非对称加密来保证在传输途中，以及在数据载体上的机密性。机密性往往需要完整性作为先决条件；而完整性不一定需要机密性作为先决条件。</p>
<p>下图阐述了安全领域涉及机密性和完整性的主要算法：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/3.webp" alt="" /></p>
<p>注意，这里的一些算法是泛称，而非具体某种算法。比如：sha3 算法族下面除了 keccak 以外，还有 blake2，blake3 等其他算法；而 ECC 算法下面，属于签名算法的有 Ed25519，Ed448 等，属于非对称加密的有 x25519，x448 等。</p>
<p>如果你看了我前几周的文章，大概对我介绍的《<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828843&amp;idx=1&amp;sn=f60193eba1debfdbab4d9ea48ddf8203&amp;chksm=8704aff7b07326e1c265b21c1617c436e2ab4b4f8911c9b7b64cc8b9f5d34e993aa875090e87&amp;scene=21#wechat_redirect">胖客户端，廋服务器</a>》有些印象。文章中我提到了服务端把用户端的事件写入到事件日志中，客户端可以 clone / pull 这些事件日志，在本地生成相应的状态。那么问题来了，客户端怎么知道 clone 下来的事件日志是未经第三方篡改的事件日志呢？很简单，我们只需对日志文件做个 hash，然后用服务器的私钥对这个 hash 做一个签名，把签名附带在文件头上。这样客户端收到文件后，用服务器的公钥验证这个签名即可。这样，只要服务器的私钥不泄露，这个签名就可以验证文件的完整性。在比特币的世界里，每个区块的完整性都由打包该区块的矿工的签名来保证，而整个链的完整性则由哈希链和中本聪共识（最长链）保证。</p>
<p>进一步的，如果我们用户的私有 repo 下的所有事件日志都只有用户自己才能访问，其他人（包括服务端应用）都无法访问，那么我们可以用用户的公钥来加密 repo 的所有事件日志。</p>
<h2><a class="header" href="#dh-算法互联网安全的基石" id="dh-算法互联网安全的基石">DH 算法：互联网安全的基石</a></h2>
<p>当我们需要保证存储在媒介上的信息的安全性时，一切都简单而直观；但当我们需要保证在网络传输中的实时信息的安全性时，我们就面临着巨大的挑战。</p>
<p>这其中第一个挑战就是：每个连接使用什么密钥来加密数据？</p>
<p>我们知道，在网络传输中，非对称加密的效率不高，不适合大量数据的加密，而对称加密则需要双方共享密钥，才能正常通讯。因此，我们需要一种手段，在不安全的网络信道中，只传输部分信息，通过这部分信息 + 本地的私有信息，协商出来双方一致的共享密钥。第三方即便获得明文传输的信息，也无法推导出密钥。如果这样的手段行得通，那么，我们就可以在网络通讯的握手过程，生成每个 session 独立的共享密钥（session key），后续的通讯都通过这个（这对）密钥来加密完成。这个协商的过程就是 DH 算法（Diffie-Hellman Key Exchange Algorithm）[5]（对算法细节感兴趣的可以去看 wikipedia）：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/4.webp" alt="" /></p>
<p>DH 算法是 TLS 以及 Noise protocol 的基石。如果没有它，我们就不会有目前这样一个繁荣且安全的互联网世界。</p>
<p>在 Rust 下，如果你需要直接使用 DH 算法，可以使用 dalek 出品的 <code>x25519-dalek</code>[6]。它是使用 curve25519 [7] 的 ECDH（Elliptic Curve Diffie-Hellman） 的实现。代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand_core::OsRng;
use x25519_dalek::{EphemeralSecret, PublicKey};
let alice_secret = EphemeralSecret::new(OsRng);
let alice_public = PublicKey::from(&amp;alice_secret);
let bob_secret = EphemeralSecret::new(OsRng);
let bob_public = PublicKey::from(&amp;bob_secret);
let alice_shared_secret = alice_secret.diffie_hellman(&amp;bob_public);
let bob_shared_secret = bob_secret.diffie_hellman(&amp;alice_public);
assert_eq!(alice_shared_secret.as_bytes(), bob_shared_secret.as_bytes());
<span class="boring">}
</span></code></pre></pre>
<p>你也许会问：我又不去实现 TLS 或者类似的加密协议，而我自己的网络传输都靠 TLS 保护着呢，DH 对我来说有什么用呢？</p>
<p>我能想到的一个场景是文件加密。在本文开头，我说：</p>
<blockquote>
<p>进一步的，如果我们用户的私有 repo 下的所有事件日志都只有用户自己才能访问，其他人（包括服务端应用）都无法访问，那么我们可以用用户的公钥来加密 repo 的所有事件日志。</p>
</blockquote>
<p>这个方案的缺点是效率太低 — 如果需要加密的文件有几个 G，非对称加密显然不好。但我们又没法用对称加密：毕竟我们不能跟每个人都预先共享一组密钥（共享密钥本身又存在安全风险）。这时，我们可以用 DH 算法生成一个只对这个文件有效的密钥，加密文件，然后在文件头提供必要的信息即可：</p>
<ol>
<li>
<p>生成一个临时公钥对</p>
</li>
<li>
<p>用私钥和用户的公钥算 DH key</p>
</li>
<li>
<p>用 DH key 作为 AES[8] 或者 ChachaPoly[9] 的密钥，加密文件</p>
</li>
<li>
<p>在文件头添加临时生成的公钥</p>
</li>
</ol>
<p>这样，在解密端，用户可以用自己的私钥和文件中携带的公钥算出 DH key，然后解密之。</p>
<p>如果大家对这个思路感兴趣，可以参考我用 Noise protocol 做的类似的解决方案：tyrchen/conceal[10]。</p>
<p>除了 x25519-dalek 外，ristretto255-dh[11] 也值得一试，它是 zcash 实现的 Ristretto255[12] DH 算法。</p>
<h2><a class="header" href="#tls不仅仅是-http-的安全防线" id="tls不仅仅是-http-的安全防线">TLS：不仅仅是 HTTP 的安全防线</a></h2>
<p>作为 HTTPS 的安全协议的唯一选择，相信大家对 TLS（以及它的前身 SSL）有一定的了解 — 起码知道：</p>
<ul>
<li>
<p>服务端需要安装经过合法 CA 签署的证书（certificate）。如果你配过 nginx，你还会知道，证书和证书的私钥一般都是 PEM [13] 格式存储在文件系统的。一般来说，除了配置自己的证书外，还需要配置整个服务器证书链以便客户端验证。</p>
</li>
<li>
<p>客户端在连接服务器时，会获取服务器证书，然后通过操作系统受信的根证书来验证服务器的证书以及签署该证书的 CA，以及签署该 CA 的上一级 CA 等形成的整个证书链可以由某个根证书验证。</p>
</li>
<li>
<p>客户端验证了服务器的证书后，会跟服务器交互建立一个安全信道，保证之后的传输的安全。这个过程是 TLS 握手。</p>
</li>
<li>
<p>之后整个 HTTP 协议交互的过程，都被这个安全信道保护起来（说人话就是加密了），第三方无法嗅探到内部的交互，也无法破坏其完整性。</p>
</li>
</ul>
<p>如果你经常调试（或者逆向工程）HTTPS，你大概还知道：</p>
<ul>
<li>
<p>通过 Charles Proxy 这样的工具，可以做 Man-In-The-Middle[14]，来截获加密的数据。使用 Charles Proxy 时，需要在操作系统级「信任」其根证书，这是证书验证的流程所决定的。一旦某个根证书被系统信任，那么它可以签署任何域名的证书，这样第三方就可以伪装成目标服务器，terminate 客户端到服务器的任何 TLS 流量，然后再伪装成客户端，向实际服务器发送数据。所以，不要轻易信任来路不明的根证书。</p>
</li>
<li>
<p>如果要避免 Charles Proxy 等工具做 Man-In-The-Middle，你可以使用 certificate pinning。</p>
</li>
</ul>
<p>你大概率不知道：</p>
<ul>
<li>
<p>TLS 支持 client certificate - 也就是说不光客户端可以验证服务器是否是我要连的服务器；服务器也可以验证客户端是否是我（的 CA）签署的客户端。</p>
</li>
<li>
<p>客户端验证服务器时，除了可以通过系统的根证书验证，也可以预置一个 CA 证书来验证服务器的证书是否由该 CA 签署。</p>
</li>
</ul>
<h3><a class="header" href="#证书是个什么鬼" id="证书是个什么鬼">证书是个什么鬼？</a></h3>
<p>我们这里所说的证书，是 PKI 体系下的 X.509 证书[16]。X.509 证书用于证明一个公钥的身份。我说我是 domain.com 的合法服务器，何以见得？我生成一对私钥和公钥，通过其签署一个 CSR（Certificate Signing Request [17]），里面通过 CN（Common Name）声索我对 <code>*.domain.com</code> 的占有。一般一个 CSR 包含这些信息：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/5.webp" alt="" /></p>
<p>随后我把 CSR 提交给一个由某个根证书签署的 CA，由其签名并发回给我。这样，任何应用通过 HTTPS 连接 domain.com 时就可以正常通讯。</p>
<p>在 letsencrypt[18] 成为主流之前，证书是个几乎相当于特许经营的好生意。像 godaddy 这样的家伙，一个证书可以卖上百美金一年，简直如同抢钱。证书作为一门生意，极大地破坏了互联网的安全性，很多小的玩家不想支付每年的证书费用，干脆就避免使用 HTTPS。letsencrypt 的出现，几乎摧毁了各大吃相难看的 CA 的生意。Letsencrypt 自动化了证书的申请流程，只要你能把某个域名指向你的服务器，让 letsencrypt 验证到你请求的域名就是你拥有的域名，可以立即签署一个有效期是 3 个月的免费证书。至于证书的有效期为啥不能更长，这个，根本不是技术原因，我猜是来自做垂死挣扎的既得利益者们的压力。</p>
<h3><a class="header" href="#能不能自己做-ca" id="能不能自己做-ca">能不能自己做 CA？</a></h3>
<p>CA 机构是 internet 的不可或缺，却相对脆弱的一环。Letsencrypt 只是解决了证书收费的问题，不过没有解决 CA 机构本身的脆弱性 — 任何一个中心化的，可以签署证书，被数亿设备信任的机构都是有安全风险的，因为黑客随时盯着这些机构的漏洞。一旦一个CA 被攻陷，黑客们可以伪造出成千上万的域名的服务器证书。</p>
<p>有没有可能一个应用的客户端和服务器使用自己的 CA，绕过任何 CA 机构？</p>
<p>当然可以。你可以生成自己的 CA cert（自签名），然后用 CA key 签名 Server cert。你的客户端在启动 TLS 连接时，信任你自己的 CA cert 即可。你甚至还可以通过你的 CA 给每个客户端签名，让服务器也同时验证客户端是你信任的客户端。如下图所示：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/6.webp" alt="" /></p>
<p>一个新的客户端在注册新用户/登录时，服务器会从 CA 获取证书，连同用户登录获得的 token 一同返回给客户端。之后，客户端访问任何服务端的 API（除 auth 之外），都需要提供 client cert 供服务器验证，这样，额外增加安全性，并且，可以杜绝 Charles Proxy 这样的中间人。</p>
<p>当然这样的手段只适合客户端代码由你自己控制（比如 iOS/android/OSX/Linux/Windows app）。你无法让你的服务器证书通过浏览器的安全验证（因为证书不在系统根证书的信任列表中），因而，任何使用浏览器访问你的服务器的用户将无法使用你的服务。</p>
<p>如果你对这样的方案感兴趣，可以看看我的 crate: tyrchen/cellar[19]。它借鉴比特币分层钱包[20]的设计，可以从一个 passphrase 衍生出确定的分层密码/密钥/证书。生成的证书可以被应用在 TLS 应用中，比如：tyrchen/mobc-tonic[21]（我做的一个 grpc client connection pool）。</p>
<p>下面是我通过 celllar 生成的 CA 证书（注意 <code>CA: TRUE</code>）：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/7.webp" alt="" /></p>
<p>以及该 CA 签署的服务器证书（注意 <code>CA: FALSE</code> 和 <code>TLS Web Server Authentication</code>）：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/8.webp" alt="" /></p>
<p>以及该 CA 签署的客户端证书（注意 <code>CA: FALSE</code> 以及 <code>TLS Web Client Authentication</code>）：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/9.webp" alt="" /></p>
<p>将 TLS 应用在 HTTP 之外</p>
<p>TLS 可以保护我们的 HTTP 应用，其中包括 REST/GraphQL/Websocket API，以及 gRPC API。虽然目前 HTTP 是几乎绝大多数互联网应用使用的协议，但还有大量的其它基于 TCP 层的协议。如果你要保证这些协议的安全性，使用 TLS 是一个简单直接的选择。</p>
<p>然而，理解和使用好 OpenSSL 库不是一件容易的事情。十多年前，我曾经用 C 语言和老旧的 OpenSSL （0.9.x）打过交道，那体验<strong>相当</strong>不好。Python / Erlang 有不错的 OpenSSL 的封装，在应用中使用 TLS 比较舒服自然。如果你熟悉的语言没有很好的库去包装 OpenSSL，那么，在应用中使用 TLS 就不那么容易。</p>
<p>在 Rust 里，除了 OpenSSL 的封装，我们还有 Rustls[22]。它是一个经过了 security auditing[23] 的 TLS 安全裤，性能比 OpenSSL 更好，且理论上更加安全（没有遗留的历史问题，没有 TLS1.1 及以下的不安全代码，没有遗留的不安全的加密算法，比如 RC4，3DES）。</p>
<p>Rustls 虽然比 OpenSSL 容易使用，但成功建立起 TLS 连接，还需要更多对 TLS 细节的理解。为此，我做了一个 crate：tokio-tls-helper[24]，可以让你通过简单的配置，创建 TLS connector (client) 和 acceptor (server)。</p>
<p>比如客户端使用自定义的 CA cert 以及通过自定义 CA 签署的 client cert：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>domain = &quot;localhost&quot;

[cert]
pem = &quot;&quot;&quot;-----BEGIN CERTIFICATE-----
MIIBeTCCASugAwIBAgIBKjAFBgMrZXAwNzELMAkGA1UEBgwCVVMxFDASBgNVBAoM
C0RvbWFpbiBJbmMuMRIwEAYDVQQDDAlEb21haW4gQ0EwHhcNMjEwMzE0MTg0NTU2
WhcNMzEwMzEyMTg0NTU2WjA3MQswCQYDVQQGDAJVUzEUMBIGA1UECgwLRG9tYWlu
IEluYy4xEjAQBgNVBAMMCURvbWFpbiBDQTAqMAUGAytlcAMhAAzhorM9IPsXjBTx
ZxykGl5xZrsj3X2XqKjaAVutnf7po1wwWjAUBgNVHREEDTALgglsb2NhbGhvc3Qw
HQYDVR0OBBYEFD+NqChBZDOs5FMgefHJSIWiRTHXMBIGA1UdEwEB/wQIMAYBAf8C
ARAwDwYDVR0PAQH/BAUDAwcGADAFBgMrZXADQQA9sligQcYGaBqTxR1+JadSelMK
Wp35+yhVVuu4PTL18kWdU819w3cVlRe/GHt+jjlbk1i22TvfO5AaNmdxySkO
-----END CERTIFICATE-----&quot;&quot;&quot;

[identity]
key = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----
MFMCAQEwBQYDK2VwBCIEIArjJtHm3xb4aX3fsGHpuB8dD3yzcLxWcPCqy7AGtTG5
oSMDIQD/38MZBnYuyitIGU3ltOGwwDwtB6KYag4rL1zsSGTzYg==
-----END PRIVATE KEY-----&quot;&quot;&quot;

[identity.cert]
pem = &quot;&quot;&quot;-----BEGIN CERTIFICATE-----
MIIBZDCCARagAwIBAgIBKjAFBgMrZXAwNzELMAkGA1UEBgwCVVMxFDASBgNVBAoM
C0RvbWFpbiBJbmMuMRIwEAYDVQQDDAlEb21haW4gQ0EwHhcNMjEwMzE0MTg0NTU2
WhcNMjEwOTEwMTg0NTU2WjAyMQswCQYDVQQGDAJVUzEQMA4GA1UECgwHYW5kcm9p
ZDERMA8GA1UEAwwIYWJjZDEyMzQwKjAFBgMrZXADIQD/38MZBnYuyitIGU3ltOGw
wDwtB6KYag4rL1zsSGTzYqNMMEowFAYDVR0RBA0wC4IJbG9jYWxob3N0MBMGA1Ud
JQQMMAoGCCsGAQUFBwMCMAwGA1UdEwQFMAMBAQAwDwYDVR0PAQH/BAUDAwfgADAF
BgMrZXADQQCKhph1Z3g6E+EULUi5yIROSXmMxWjzi+L1OmqNh9ANJlrQwlcfwq0G
8JbfGVwq1sotEI83mv42mWkSSX98uysO
-----END CERTIFICATE-----&quot;&quot;&quot;
<span class="boring">}
</span></code></pre></pre>
<p>有了这个配置，客户端可以生成 <code>ClientTlsConfig</code>，然后生成 <code>connector</code>，在建立好 TCP stream 后，直接调用 <code>connector.connect(stream)</code> 就可以将 TCP 连接升级为 TLS 连接，之后可以在其之上进行应用层的协议：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let msg = b&quot;Hello world\n&quot;;
let mut buf = [0; 12];

let config: ClientTlsConfig = toml::from_str(config_file).unwrap();
let connector = config.tls_connector(Uri::from_static(&quot;localhost&quot;)).unwrap();

let stream = TcpStream::connect(addr).await.unwrap();
let mut stream = connector.connect(stream).await.unwrap();
info!(&quot;client: TLS conn established&quot;);

stream.write_all(msg).await.unwrap();

info!(&quot;client: send data&quot;);

let (mut reader, _writer) = split(stream);

reader.read_exact(buf).await.unwrap();

info!(&quot;client: read echoed data&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>服务端的使用也很简单：配置相同的 CA cert，以及服务器的 server/key：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[identity]
key = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----
MFMCAQEwBQYDK2VwBCIEII0kozd0PJsbNfNUS/oqI/Q/enDiLwmdw+JUnTLpR9xs
oSMDIQAtkhJiFdF9SYBIMcLikWPRIgca/Rz9ngIgd6HuG6HI3g==
-----END PRIVATE KEY-----&quot;&quot;&quot;

[identity.cert]
pem = &quot;&quot;&quot;-----BEGIN CERTIFICATE-----
MIIBazCCAR2gAwIBAgIBKjAFBgMrZXAwNzELMAkGA1UEBgwCVVMxFDASBgNVBAoM
C0RvbWFpbiBJbmMuMRIwEAYDVQQDDAlEb21haW4gQ0EwHhcNMjEwMzE0MTg0NTU2
WhcNMjIwMzE0MTg0NTU2WjA5MQswCQYDVQQGDAJVUzEUMBIGA1UECgwLRG9tYWlu
IEluYy4xFDASBgNVBAMMC0dSUEMgU2VydmVyMCowBQYDK2VwAyEALZISYhXRfUmA
SDHC4pFj0SIHGv0c/Z4CIHeh7huhyN6jTDBKMBQGA1UdEQQNMAuCCWxvY2FsaG9z
dDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMEBTADAQEAMA8GA1UdDwEB/wQF
AwMH4AAwBQYDK2VwA0EAy7EOIZp73XtcqaSopqDGWU7Umi4DVvIgjmY6qbJZP0sj
ExGdaVq/7MOlZl1I+vY7G0NSZWZIUilX0CoOkrn0DA==
-----END CERTIFICATE-----&quot;&quot;&quot;


[client_ca_root]
pem = &quot;&quot;&quot;-----BEGIN CERTIFICATE-----
MIIBeTCCASugAwIBAgIBKjAFBgMrZXAwNzELMAkGA1UEBgwCVVMxFDASBgNVBAoM
C0RvbWFpbiBJbmMuMRIwEAYDVQQDDAlEb21haW4gQ0EwHhcNMjEwMzE0MTg0NTU2
WhcNMzEwMzEyMTg0NTU2WjA3MQswCQYDVQQGDAJVUzEUMBIGA1UECgwLRG9tYWlu
IEluYy4xEjAQBgNVBAMMCURvbWFpbiBDQTAqMAUGAytlcAMhAAzhorM9IPsXjBTx
ZxykGl5xZrsj3X2XqKjaAVutnf7po1wwWjAUBgNVHREEDTALgglsb2NhbGhvc3Qw
HQYDVR0OBBYEFD+NqChBZDOs5FMgefHJSIWiRTHXMBIGA1UdEwEB/wQIMAYBAf8C
ARAwDwYDVR0PAQH/BAUDAwcGADAFBgMrZXADQQA9sligQcYGaBqTxR1+JadSelMK
Wp35+yhVVuu4PTL18kWdU819w3cVlRe/GHt+jjlbk1i22TvfO5AaNmdxySkO
-----END CERTIFICATE-----&quot;&quot;&quot;
<span class="boring">}
</span></code></pre></pre>
<p>服务端同样可以通过配置生成 <code>ServerTlsConfig</code>，然后生成 <code>acceptor</code>，之后正常使用 TCP listener accept 一个 TCP stream 后，就可以通过 <code>acceptor.accept(stream)</code> 把 TCP 连接升级为 TLS。这个过程配合客户端的 <code>connector.connect(stream)</code>，共同完成前面所说的 DH 过程，协商出来 session key，然后开始加密/解密应用层的数据：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config: ServerTlsConfig = toml::from_str(config_file).unwrap();
let acceptor = config.tls_acceptor().unwrap();
let listener = TcpListener::bind(addr).await.unwrap();
tokio::spawn(async move {
    loop {
        let (stream, peer_addr) = listener.accept().await.unwrap();
        let stream = acceptor.accept(stream).await.unwrap();
        info!(&quot;server: Accepted client conn with TLS&quot;);

        let fut = async move {
            let (mut reader, mut writer) = split(stream);
            let n = copy(&amp;mut reader, &amp;mut writer).await?;
            writer.flush().await?;
            debug!(&quot;Echo: {} - {}&quot;, peer_addr, n);
        }

        tokio::spawn(async move {
            if let Err(err) = fut.await {
                error!(&quot;{:?}&quot;, err);
            }
        });
    }
});
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#noise-protocol狂野西部的守护者" id="noise-protocol狂野西部的守护者">Noise Protocol：狂野西部的守护者</a></h2>
<p>如果你没看过我之前的文章，大概率 Noise Protocol 对你来说是个陌生的名字。如果你搭过各种各样的梯子，你也许使用过 Wireguard[25]，那么恭喜你，你已经在不知不觉中使用 Noise Protocol 了 — 因为 Wireguard 在安全层使用了 Noise Protocol。我曾经写过一篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=2649828356&amp;idx=1&amp;sn=0cfcf0de0a6a3c1fe9d1fc8d9e7df5f1&amp;chksm=8704ae18b073270e2e7ced09f29846ebc38affed8cb023410f995ee829ceedaddaa7b80cadbe&amp;scene=21#wechat_redirect">Wireguard：简约之美</a>，介绍了 Wireguard 这个非常牛逼的 VPN 工具。</p>
<p>因为之前的关于 Wireguard 和 Noise protocol 的文章对 Noise Protocol 本身已经有足够丰富的介绍，这里我就不再赘述 Noise Protocol 的细节。</p>
<p>如果说 TLS 是出身高贵的正规军，那么 Noise Protocol 就是出身草根的土八路。但二者其实互相借鉴，互相学习。TLS 1.3 和 Noise Protocol 的主要区别有两个：</p>
<ol>
<li>
<p>在身份验证方面二者走上了不同的道路（TLS 1.3 使用证书，而 Noise Protocol 完全不使用）</p>
</li>
<li>
<p>通讯过程中使用的算法一个走协商（TLS）一个走预配置（Noise）</p>
</li>
</ol>
<p>走协商还是走配置这跟协议的使用场景有关。TLS 关注的是大量不同版本的标准客户端（比如 Firefox）和服务器之间的交互，两端支持的算法族可能有不小的出入，协商出双方都能接受的算法是最优的选择，这样可以支持尽可能广的应用场景；而 Noise Protocol 关注的是定制的客户端和服务器之间的交互，因而两端可以通过预配置来确定使用的算法。比如 WireGuard 使用 <code>Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s</code>，那么客户端和服务端都需要：</p>
<ul>
<li>
<p>Curve 25519 做 ECDH</p>
</li>
<li>
<p>CharChaPoly 做加密</p>
</li>
<li>
<p>Blake2s 做哈希</p>
</li>
<li>
<p>两端使用 pre-shared key 进一步保证安全性</p>
</li>
</ul>
<p>因为避免使用证书这样天然具有中心化的东西，Noise Protocol 在 p2p 领域走出了新的天地。从最简单的 NN（双方都没有固定公钥）KK（双方都知道对方的固定公钥），到最复杂的 XX（双方都有固定公钥，通过网络加密传输给对方），Noise Protocol 定义了 12 种协商模式，再辅以不同的哈希和加密算法，可以组合出上百种安全方案，总有一种适合你：</p>
<p><img src="https://oss.iacblog.com/rust/rust-to-system-essence-safety/10.webp" alt="" /></p>
<p>在 Rust 下，snow[26] 是 Noise Protocol 的非常成熟的实现，而 libp2p 则使用了 snow 来实现 libp2p 协议的安全层。</p>
<p>下面是使用 snow 在 TCP 协议之上建立加密信道的实例。我们可以看到，仅需额外的几行代码就可以将你的网络应用打造得非常安全：</p>
<ul>
<li>
<p>创建 snow Builder</p>
</li>
<li>
<p>在建立连接后发送和接收不超过 3 个 Noise protocol 协议报文</p>
</li>
<li>
<p>协议握手完成后，使用 <code>noise.into_transport_mode()</code> 将 snow 状态机切换到传输模式</p>
</li>
<li>
<p>之后收到报文后调用 <code>noise.read_message()</code> 解密，发送报文前调用 <code>noise.write_message()</code> 加密即可。</p>
</li>
</ul>
<p>服务器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let params: NoiseParams = &quot;Noise_XX_25519_ChaChaPoly_BLAKE2s&quot;.parse().unwrap();
let builder: Builder&lt;'_&gt; = Builder::new(params.clone());
let static_key = builder.generate_keypair().unwrap().private;
let mut noise = builder
    .local_private_key(&amp;static_key)
    .build_responder()
    .unwrap();

// wait on client's arrival
println!(&quot;Listening on 0.0.0.0:9999&quot;);
let (mut stream, _) = TcpListener::bind(&quot;0.0.0.0:9999&quot;).unwrap().accept().unwrap();

// &lt;- e
noise
    .read_message(&amp;recv(&amp;mut stream).unwrap(), &amp;mut buf)
    .unwrap();

// -&gt; e, ee, s, es
let len = noise.write_message(&amp;[0u8; 0], &amp;mut buf).unwrap();
send(&amp;mut stream, &amp;buf[..len]);

// &lt;- s, se
noise
    .read_message(&amp;recv(&amp;mut stream).unwrap(), &amp;mut buf)
    .unwrap();

// transition the state machine to transport mode sinc handshake is complete.
let mut noise = noise.into_transport_mode().unwrap();
while let Ok(msg) = recv(&amp;mut stream) {
    let len = noise.read_message(&amp;msg, &amp;mut buf).unwrap();
    println!(&quot;client said: {}&quot;, String::from_utf8_lossy(&amp;buf[..len]));
}

println!(&quot;connection closed&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>客户端：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let params: NoiseParams = &quot;Noise_XX_25519_ChaChaPoly_BLAKE2s&quot;.parse().unwrap();
let builder: Builder&lt;'_&gt; = Builder::new(params.clone());
let static_key = builder.generate_keypair().unwrap().private;
let mut noise = builder
    .local_private_key(&amp;static_key)
    .build_initiator()
    .unwrap();

// connect to server
let mut stream = TcpStream::connect(&quot;127.0.0.1:9999&quot;).unwrap();
println!(&quot;connected!&quot;);

// -&gt; e
let len = noise.write_message(&amp;[], &amp;mut buf).unwrap();
send(&amp;mut stream, &amp;buf[..len]);

// &lt;- e, ee, s, es
noise
    .read_message(&amp;recv(&amp;mut stream).unwrap(), &amp;mut buf)
    .unwrap();

// -&gt; s, se
let len = noise.write_message(&amp;[], &amp;mut buf).unwrap();
send(&amp;mut stream, &amp;buf[..len]);

let mut noise = noise.into_transport_mode().unwrap();
println!(&quot;Session established...&quot;);

// send secure data
for _ in 0..10 {
    let len = noise.write_message(b&quot;HACK THE PLANET&quot;, &amp;mut buf).unwrap();
    send(&amp;mut stream, &amp;buf[..len]);
}
<span class="boring">}
</span></code></pre></pre>
<p>因为 snow 的所有操作都直接操作内存的 buffer，所有的 IO 都是由你创建的 TCP stream 完成，所以 snow 可以很好地在同步或者异步模式下工作。</p>
<h2><a class="header" href="#贤者时刻" id="贤者时刻">贤者时刻</a></h2>
<blockquote>
<p>连接千万条，安全第一条。网络不加密，亲人两行泪。- 鲁迅：不是我说的</p>
</blockquote>
<h1><a class="header" href="#如何为-rust-语言做贡献--part-2" id="如何为-rust-语言做贡献--part-2">如何为 Rust 语言做贡献 | Part 2</a></h1>
<p>作者：CrLF0710（野喵）/ 后期编辑：张汉东</p>
<hr />
<p>大家好，上次讲了如何利用空闲时间参与Rust Project，做一些技术上的参与。这一次呢，我要讲的是如何更加系统的参与Rust Project，相应的，这里讲的内容也需要参与者相应的投入更多的时间、以及更高的门槛。</p>
<p>在开始正式参与之前，我们有必要了解一下Rust Project的组织架构，也就是Rust Team。</p>
<h1><a class="header" href="#rust-官方团队" id="rust-官方团队">Rust 官方团队</a></h1>
<p>Rust Team 由十个Team 构成。每个Team习惯上称为T-XYZ，比如权限最高的Team是核心团队，习惯上写成T-Core。</p>
<p>十个Team(除T-Core外排名不分先后)分别是T-Core, T-Lang, T-Libs, T-Compiler, T-Devtools, T-Crates<span>.io</span>, T-Infra, T-Release, T-Community 和 T-Moderation。所有团队的成员是常驻人员，其实也都是志愿者，成员的选拔主要来自于同一团队其他已有成员的认同。接下来让我们来逐一对各个团队做个介绍。</p>
<p>首先是核心团队T-Core，它的职责是管理Rust Project的总体方向，管理各个Team的领导职责，管理跨团队事务。它是一个没有团队负责人的团队，而且讨论频道是不对外部公众公开的。它出现最多的地方就是，大家会看到那些刊发重大决策的博文都是以核心团队的名义发表的。它的成员往往是其他团队的团队负责人等。</p>
<p>接下来我想首先介绍的是语言设计团队T-Lang，它的职责是设计Rust这门语言。在<a href="https://github.com/rust-lang/rfcs">Rust RFCs</a>被接受的RFC中，语言设计类的RFC到目前为止是占绝对多数的。他们的职责就是讨论语言的未来更改，并且帮忙参与一部分语言特性的实现（参见稍后提到的“项目组”）。平时大家笑谈的“语言律师”就是这些人——对于你的一个设计想法，他们可以飞快地在脑中与语言其他已有特性进行交叉验证，指出你的设计不足……在我的经验里，多多围观他们的讨论对你更深地理解Rust是非常有好处的。</p>
<p>然后是库设计团队T-Libs，它的职责是设计维护Rust的内置库。要注意内置库不止是标准库std，还有core, alloc, test等等。库设计团队的成员们往往都是一些知名rust库的作者，他们在设计API上都是非常有经验的，关注的是接口的易用性等等。实际上Rust的内置库其实从整体上是已经趋于“收敛”了，很难看到较大块的增加，一般都是在一些已有的类型上增加一些小的接口和辅助函数等等。这些接口的稳定化就是由T-Libs来把关的。</p>
<p>接下来是编译器维护团队T-Compiler，它的职责是维护编译器的主体代码。T-Compiler是所有团队中人员最多的团队，以T-Compiler的名义提交的代码占的比重也是最大的。所有已经实现的语言特性相关的代码都是移交给他们来维护的，而对编译器的各种bug的修复、各种诊断帮助信息的用户体验逻辑维护、对编译器的性能优化等等，都是由T-Compiler来进行。这里的任务从简单的“调整一个内部判断条件”，到困难的“实现一个下一代的借用检查器和特质查询系统”，能做的事情有很多很多。</p>
<p>接下来是开发工具团队T-Devtools，它其实是由一堆小团队组成，职责是负责维护cargo、rustdoc、rustfmt、rustup等各种小的程序。每个程序的维护团队其实是相互独立的。这里其实有非常多的贡献机会。</p>
<p>然后是Crates.io团队T-Crates<span>.io</span>，它负责开发维护crates.io网站的前后端，大家上传的开源Rust包都可以集中放到这个网站里。</p>
<p>接下来是运维团队T-Infra，它负责维护Rust的各个网站、crater、CI、域名解析、CDN连接等等的正常运转。</p>
<p>然后是版本发布团队T-Release。与任务导向的T-Compiler不同，T-Release负责按照Rust的发布周期对各个发布版本执行回归测试，定位回归测试中发现的问题、联系T-Compiler进行评估修复。</p>
<p>然后是社区团队T-Community。负责组织Rust相关的活动和会议、管理网站内容、进行社区投票等等。它基本上就可以看作是最近新成立的 Rust 基金会的前身，区别在于新成立的Rust基金会在原来的基础上增加了财务和法务等等的新的责任。</p>
<p>最后是风纪管理T-Moderation。主要负责维持各种交流频道的秩序，维护《行为准则》，管理必要的账号封禁事项等等。</p>
<h1><a class="header" href="#rust-官方团队里的非正式成员" id="rust-官方团队里的非正式成员">Rust 官方团队里的非正式成员</a></h1>
<p>虽然听起来团队成员数量还不少，但是实际上要推动rust的健康发展，人员力量很容易捉襟见肘。Rust的策略是吸纳更多的非正式成员进来完成工作。其中活跃的人在某种意义上也可以看作是正式成员的候补。</p>
<p>对非正式成员的组织有三种形式：项目组，工作组和社区组。这个划分是之前讨论的，还在试行阶段没有变成正式决策。</p>
<p>项目组(project group)是临时的。例如某个团队想要完成一个新功能的设计与实现，那么就会由该团队的一个成员发起一个项目组，由这个正式成员来带队。这个正式成员负责组织人手和会议，对相关的功能进行推进。</p>
<p>工作组(working group)是较长期的。例如某个团队决定需要一群人来固定推进一些事情，那么同样也会由该团队的一个成员发起一个工作组。这个正式成员负责组织人手和会议，完成既定的任务。</p>
<p>社区组(community group)之前叫做领域工作组，曾经也是工作组概念里的一部分。领域工作组是2017~2018年左右官方推进的一个概念，希望针对一些比较有前景的领域，各自集合一些人来定期讨论，做一些事情，比如写一些代码之类的。第一批成立了四个：网络、嵌入式、WebAssembly、命令行界面。后来又成立了第五个：游戏开发。实践证明，社区工作组这个想法执行起来并不太好，甚至导致了官方和社区的一些矛盾和摩擦。网络领域工作组解散后，官方的态度倾向于将这些领域工作组改编为社区组，不再属于官方团队的一部分。目前是在向这个方向行动，还没有完成。</p>
<p>在这里我们主要关注项目组和工作组。一般来说门槛都是相当低的，一般只需要你在相应小组的频道里简单自我介绍一下，然后按时去参加会议就可以了。但是由于时区的缘故，例会时间往往在北京时间午夜之后，会议语言也一般都是英语。如果你是比较技术导向的，比如希望推进rust的某个特性工作的进展，不妨找到感兴趣的项目组报名参与一下。</p>
<h1><a class="header" href="#rust-官方工作交流平台" id="rust-官方工作交流平台">Rust 官方工作交流平台</a></h1>
<p>Rust官方交流平台是用一个叫Zulip的软件，网址是<a href="chapter_3/rust-lang.zulipchat.com">rust-lang.zulipchat.com</a>。可以用github登录。这东西有点介于IM与论坛之间，登录之后它有一些频道（称为Stream）。各个团队一般都至少有一个。很多团队也根据需要会为下面的工作组、领域建多个频道。在每个频道里面，任何人都可以建主题，有点像论坛发帖的感觉，然后大家在感兴趣的主题下讨论。它也有手机端app，但是目前还不是很好用；推荐使用网页版或者桌面App。Stream需要订阅才会显示，刚登录的时候显示不全，记得去所有频道面板中订阅自己想关注的频道。</p>
<p>有的团队喜欢开视频会议，它们一般会选Zoom。如果需要协同编辑，往往用Dropbox Papers或者HackMD。大部分都是可以公开访问的，个别的需要申请权限。</p>
<p>在交流时要稍微注意一点的是，关于称呼。欧美有很多人对性别平权、少数群体之类的比较在意。稍微注意下He/She两个词的使用千万不要用错，如果不确定，就用They就好了。</p>
<p>话说，官方 Zulip 里有一个中文频道 <code>t-community/l10n/zh</code>，不过蛮冷清的。大家感兴趣的话可以来聊关于翻译的话题啊。</p>
<h1><a class="header" href="#四月刊" id="四月刊">四月刊</a></h1>
<p><img src="chapter_4/../image/rust_magazine3.png" alt="logo" /></p>
<h2><a class="header" href="#发刊通告-3" id="发刊通告-3">发刊通告</a></h2>
<ul>
<li><a href="chapter_4/./announce.html">发刊通告</a></li>
</ul>
<h2><a class="header" href="#rust-资讯" id="rust-资讯">Rust 资讯</a></h2>
<ul>
<li><a href="chapter_4/./info.html">Rust 资讯来源汇总</a></li>
<li><a href="chapter_4/./lang.html">官方动态</a></li>
<li><a href="chapter_4/./hots.html">社区热点</a></li>
<li><a href="chapter_4/./events.html">活动回顾</a></li>
<li><a href="chapter_4/./jobs.html">本月招聘</a></li>
</ul>
<h2><a class="header" href="#rust-与-学术" id="rust-与-学术">Rust 与 学术</a></h2>
<ul>
<li><a href="chapter_4/./safe_system.html">论文鉴赏 | 使用 Rust 进行安全系统编程</a></li>
<li><a href="chapter_4/./safe_drop.html">论文鉴赏 | SafeDrop：通过静态数据流分析检测Rust程序的内存释放错误</a></li>
<li><a href="chapter_4/./event_os_design.html">学界动态</a></li>
</ul>
<h2><a class="header" href="#rust-in-production-3" id="rust-in-production-3">Rust in Production</a></h2>
<ul>
<li><a href="chapter_4/./hw_stratovirt.html">华为 | StratoVirt 地址空间管理-基于Rust的实现与优化</a></li>
<li><a href="chapter_4/./hw_bin_opt.html">华为 | Rust 编译后二进制大小和常用优化方式</a></li>
<li><a href="chapter_4/./ant_trait.html">蚂蚁集团 | Trait 使用及实现分析</a></li>
<li><a href="chapter_4/./ant_async_os_opt.html">蚂蚁集团 | 异步化OS：我们如何利用Rustasyncawait提升10x性能-Rust</a></li>
<li><a href="chapter_4/./zhihu_simd_rucene.html">知乎 | 基于 SIMD 指令优化 Rucene</a></li>
<li><a href="chapter_4/./datenlord_io_uring.html">Datenlord | Rust 异步实现 io_uring </a></li>
<li><a href="chapter_4/./rust_ffi.html">PingCAP | 使用 Rust FFI 心得</a></li>
<li><a href="chapter_4/./libp2p_ipfs.html">Netwarp | 从 libp2p-rs 到 IPFS </a></li>
<li><a href="chapter_4/./google_android_rust.html">Google | 在 Android 平台使用 Rust</a></li>
<li><a href="chapter_4/./meili_search.html">MeiliSearch | 开源搜索引擎</a></li>
</ul>
<h2><a class="header" href="#学习园地-3" id="学习园地-3">学习园地</a></h2>
<h3><a class="header" href="#新手入门" id="新手入门">新手入门</a></h3>
<ul>
<li><a href="chapter_4/./learn.html">学习资源</a></li>
<li><a href="chapter_4/./a-primer-on-rusts-result-type.html">【译】Rust 的 Result 类型基础</a></li>
</ul>
<h3><a class="header" href="#语言特性与技巧" id="语言特性与技巧">语言特性与技巧</a></h3>
<ul>
<li><a href="chapter_4/./faq.html">常见问题汇总</a></li>
<li><a href="chapter_4/./tips.html">语言技巧</a></li>
<li><a href="chapter_4/./try_trait_v2.html">RFC 介绍 | try-trait v2</a></li>
<li><a href="chapter_4/./2021_edition_preview.html">【官宣】Rust 2021 Edition 计划</a></li>
<li><a href="chapter_4/./rustc_edit_distance_and_typo_checker.html">用 rustc 源码实现拼写错误候选词建议</a></li>
<li><a href="chapter_4/./nom_url.html">使用 nom 解析 url</a></li>
</ul>
<h3><a class="header" href="#rust-与-设计模式" id="rust-与-设计模式">Rust 与 设计模式</a></h3>
<ul>
<li><a href="chapter_4/./facade.html">真实世界的设计模式 | 外观模式（Facade Pattern）</a></li>
</ul>
<h3><a class="header" href="#主题专栏rust-探索系统本原" id="主题专栏rust-探索系统本原">【主题专栏】Rust 探索系统本原</a></h3>
<ul>
<li><a href="chapter_4/./rust-to-system-essence-raii.html">Rust 探索系统本原 | RAII </a></li>
<li><a href="chapter_4/./rust-to-system-essence-lang.html">Rust 探索系统本原 | 编程语言 </a></li>
<li><a href="chapter_4/./rust-to-system-essence-memory.html">Rust 探索系统本原 | 内存管理 </a></li>
<li><a href="chapter_4/./rust-to-system-essence-network.html">Rust 探索系统本原 | 网络 </a></li>
</ul>
<h3><a class="header" href="#主题专栏如何为-rust-做贡献" id="主题专栏如何为-rust-做贡献">【主题专栏】如何为 Rust 做贡献</a></h3>
<ul>
<li><a href="chapter_4/./contribute_to_the_rust_part3.html">如何为 Rust 语言做贡献 | Part 3 </a></li>
<li><a href="chapter_4/./improve-std-slice-binary-search.html">优化 Rust 标准库的 binary_search</a></li>
</ul>
<h2><a class="header" href="#开源项目巡礼" id="开源项目巡礼">开源项目巡礼</a></h2>
<ul>
<li><a href="chapter_4/./github_trending.html">GitHub 趋势榜</a></li>
<li><a href="chapter_4/./tool_libs.html">推荐项目 ｜ 基础工具库</a></li>
<li><a href="chapter_4/./frameworks.html">推荐项目 |  框架引擎</a></li>
<li><a href="chapter_4/./tensorbase.html">开源产品 | TensorBase，基于Rust的现代化开源数据仓库</a></li>
<li><a href="chapter_4/./zenoh.html">开源产品 | eclipse zenoh 助力雾计算和边缘计算</a></li>
</ul>
<h2><a class="header" href="#rust-vs-security" id="rust-vs-security">Rust vs Security</a></h2>
<ul>
<li><a href="chapter_4/./unsafe_rust_tips.html">Unsafe Rust 编码技巧 | Part 1</a></li>
</ul>
<h1><a class="header" href="#发刊通告-4" id="发刊通告-4">发刊通告</a></h1>
<p>编辑：张汉东</p>
<h3><a class="header" href="#四发刊通告" id="四发刊通告">四发刊通告</a></h3>
<p>五一到了，祝大家劳动节快乐！《 RustMagazine 中文精选 》2021 年第四期发布了! </p>
<p>第四期的内容组织结构进行了初次改版，希望可以形成一个固定的结构，容纳更多内容，更加方便协作。</p>
<p>每次发布月刊，都会体会到时光流逝的无情。当月刊发布的时候，也意味着一个月已经过去了。</p>
<p>无论如何，加油吧！</p>
<h3><a class="header" href="#本刊动态" id="本刊动态">本刊动态</a></h3>
<p><strong>（GitHub Page）现在已经支持 Rss 订阅</strong></p>
<ol>
<li>
<p>订阅地址：<a href="https://rustmagazine.github.io/rust_magazine_2021/rss.xml">https://rustmagazine.github.io/rust_magazine_2021/rss.xml</a></p>
</li>
<li>
<p>复制订阅地址到你最喜欢的订阅工具开始订阅。</p>
</li>
</ol>
<p>语雀平台自动支持邮件订阅。</p>
<h3><a class="header" href="#上期三月刊访问数据统计小结" id="上期三月刊访问数据统计小结">上期（三月刊）访问数据统计小结</a></h3>
<p><strong>用户数</strong></p>
<ul>
<li>新用户新增 2162</li>
</ul>
<p><strong>浏览量：</strong></p>
<ul>
<li>网页浏览量 ： 10,334</li>
</ul>
<p><strong>读者分布地区排名：</strong></p>
<ul>
<li>亚洲，新用户增加 1,535</li>
<li>美国，新用户增加 134</li>
<li>欧洲，新用户增加 13</li>
</ul>
<p><strong>三月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li>《华为 | 基于 Rust 的下一代虚拟化平台 StratoVirt》</li>
<li>《华为 ｜ 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型》</li>
<li>《透过 Rust 探索系统本原 : 并发篇》</li>
<li>《蚂蚁集团 | Rust CPU Affinity 初探》</li>
<li>《Rust 中使用 MySql》</li>
</ul>
<p><strong>二月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<p>注： 一月刊的 《图解 Rust 所有权》文章依旧最受欢迎，作者：肖猛 </p>
<ul>
<li>《 前端入门 ｜ Rust 和 WebAssembly》，作者: 陈鑫(lencx)</li>
<li>《 实践案例 | 使用 Bevy 游戏引擎制作炸弹人》，作者：Cupnfish</li>
<li>《 蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考 》， 作者：evenyag</li>
<li>《 华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景》，作者：俞一峻等三位</li>
<li>《 DatenLord ｜ Linux 全新异步接口 io_uring 的 Rust 生态盘点》，作者：施继成</li>
</ul>
<p>后续也期待大家投稿。欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！</p>
<h1><a class="header" href="#rust-资讯来源汇总" id="rust-资讯来源汇总">Rust 资讯来源汇总</a></h1>
<p>编辑：张汉东</p>
<hr />
<p>大家一定好奇 Rust 资讯从哪里可以获取呢？那么本文就对 Rust 资讯信息来源做一次汇总。欢迎补充！</p>
<h2><a class="header" href="#国外" id="国外">国外</a></h2>
<ul>
<li><a href="https://this-week-in-rust.org/">Rust Weekly</a>，每周三更新一次，汇总了 Rust 生态圈的一些动态，还包括了一些知名开源项目的 Issues 信息等。</li>
<li><a href="https://www.reddit.com/r/rust/">Reddit Rust 频道</a>，每天都会有 Rust 新项目、技术讨论等帖子，可以每天关注。</li>
<li><a href="https://rust.libhunt.com/newsletter/archive">Awesome Rust Weekly</a>，和 Rust Weekly 类似，也是每周发一次信息聚合，但风格有点差别，都可以关注下。</li>
<li><a href="https://readrust.net/">Read Rust</a>，不定时更新一些 Rust 信息，并且对这些信息做了分类。</li>
<li><a href="https://github.com/trending/rust?since=daily">GitHub Rust Trending</a>，GitHub Rust 趋势榜。</li>
<li><a href="https://twitter.com/search?q=rustlang&amp;src=typed_query">Twitter rustlang tag</a>，在 Twitter 里搜索 <code>rustlang</code> 就可以看到很多 Rust 相关动态。</li>
</ul>
<h2><a class="header" href="#国内" id="国内">国内</a></h2>
<ul>
<li><a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust 日报</a>，每天收集汇总当天的 Rust 动态。</li>
<li><a href="https://t.me/rust_daily_news">Rust 视界</a>，Rust 日报前身，是一个 telegram channel ，现在不定时分享一些Rust 动态。</li>
<li><a href="https://blog.budshome.com/budshome/rust-guan-fang-zhou-bao-386-qi-(2021-04-14)">芽之家</a>，Rust Weekly 翻译，也有其他的一些Rust 动态翻译。如果想参与翻译贡献的，也可以去这里贡献：<a href="https://github.com/zzy/this-week-in-rust-zh-cn">https://github.com/zzy/this-week-in-rust-zh-cn</a></li>
<li><a href="https://www.zhihu.com/topic/19674381/hot">知乎</a>， 知乎上也有很多 Rust 讨论和文章，可以搜索。</li>
</ul>
<h1><a class="header" href="#rust官方动态-1" id="rust官方动态-1">Rust官方动态</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#rust-2021-edition-发布计划" id="rust-2021-edition-发布计划">Rust 2021 Edition 发布计划</a></h2>
<p><a href="chapter_4/./2021_edition_preview.html">【官宣】Rust 2021 Edition 计划</a></p>
<h2><a class="header" href="#rust-基金会-董事成员概要介绍" id="rust-基金会-董事成员概要介绍">Rust 基金会 董事成员概要介绍</a></h2>
<p>从 2021.03.18 到 2021.04.22 ，Rust 基金会官网依次介绍了十位董事（目前一共11位）会成员，这里依次列出简要介绍：</p>
<p><a href="https://foundation.rust-lang.org/board/">Rust Foundation Board</a></p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-03-18-introducing-bobby-holleybobby-holleya" id="a-hrefhttpsfoundationrust-langorgposts2021-03-18-introducing-bobby-holleybobby-holleya"><a href="https://foundation.rust-lang.org/posts/2021-03-18-introducing-bobby-holley/">Bobby Holley</a></a></h3>
<p>供职于 Mozillian Firefox CTO 办公室，从事技术战略和协调工作。在 Rust 基金会担任 会员董事 (Member Director)。</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-03-18-introducing-tyler-mandrytyler-mandrya" id="a-hrefhttpsfoundationrust-langorgposts2021-03-18-introducing-tyler-mandrytyler-mandrya"><a href="https://foundation.rust-lang.org/posts/2021-03-18-introducing-tyler-mandry/">Tyler Mandry</a></a></h3>
<p>供职于 Google Fuchsia操作系统。于2020年初开始领导Rust on Fuchsia团队。为 Rust 贡献了很多， 例如 async/await 编译器优化，指导工作（如基于源代码的代码覆盖率）并领导异步基金会工作组。在 Rust 基金会担任 项目董事（Project Director），负责工程质量相关。</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-03-25-introducing-mark-rousskovmark-rousskova" id="a-hrefhttpsfoundationrust-langorgposts2021-03-25-introducing-mark-rousskovmark-rousskova"><a href="https://foundation.rust-lang.org/posts/2021-03-25-introducing-mark-rousskov/">Mark Rousskov</a></a></h3>
<p>在 Rust 基金会担任 项目董事（Project Director），Rust Core 团队代表。 Mark 认为 Rust 基金会的意义在于：定义Rust的价值观和目标：开发可持续，有效的模型在全球范围内进行开放式合作，在众多社区之间建立桥梁。</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-03-25-introducing-nell-shamrell-harringtonnell-shamrell-harringtona" id="a-hrefhttpsfoundationrust-langorgposts2021-03-25-introducing-nell-shamrell-harringtonnell-shamrell-harringtona"><a href="https://foundation.rust-lang.org/posts/2021-03-25-introducing-nell-shamrell-harrington/">Nell Shamrell-Harrington</a></a></h3>
<p>供职于 微软，Rust Async Foundations 工作组成员，现在是 Rust 基金会 会员董事（Member Director）。Nell 曾经是 Mozilla Rust团队的一员。在2020年8月裁员之后，有机会加入了 微软，成为开源计划办公室的首席软件工程师。</p>
<p>他说，</p>
<p>“微软对待开源的态度真正发生了转变。微软理解开源软件对于其作为企业的成功以及对我们客户的成功至关重要。此外，微软还了解到，为了使我们所依赖的项目获得成功，我们必须以身作则的开源公民的身份行事，并与开源社区进行有意义的互动。这包括作为Rust基金会的赞助者捐款。它还包括致力于Rust项目的工程工作，以使其不仅对Microsoft更好，而且对全世界所有Rustaceans也更好。微软很高兴有机会与社区互动并回馈社区，并期望与Rust的维护者在编译器，核心工具，文档等方面紧密合作”。</p>
<p>“在 Rust 基金会部分职责是代表Microsoft对Rust社区的利益，但对我来说，代表和维护Rust的维护者和社区对Microsoft的利益对我来说更为重要。理解和平衡这些需求并找到共同点并不总是容易的，但这是Rustaceans在RFC流程中每天都会做的事情。我们有很多机会相互学习，相互构建，设计以前从未考虑过的解决方案。”</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-04-08-introducing-florian-gilcherflorian-gilchera" id="a-hrefhttpsfoundationrust-langorgposts2021-04-08-introducing-florian-gilcherflorian-gilchera"><a href="https://foundation.rust-lang.org/posts/2021-04-08-introducing-florian-gilcher/">Florian Gilcher</a></a></h3>
<p>在 Rust 基金会担任 项目董事（Project Director），Rust Core 团队代表。Rust Berlin，RustFest和OxidizeConf 会议的创始人之一。曾经他还是一名活跃的 Ruby 开发者，领导开发 Padrino 框架。第一次写 Rust 代码是 2013 年。2015年以来，专业地教授 Rust 并共同维护开源培训材料。2018年，我全力以赴并共同创立了 Ferrous Systems，这家公司致力于通过传播知识，实践并改善 Rust 本身来帮助行业采用 Rust。</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-04-08-introducing-peixin-hou侯培新a" id="a-hrefhttpsfoundationrust-langorgposts2021-04-08-introducing-peixin-hou侯培新a"><a href="https://foundation.rust-lang.org/posts/2021-04-08-introducing-peixin-hou/">侯培新</a></a></h3>
<p>供职于 华为。在 Rust 基金会中担任 会员董事（Member Director）。华为选择 Rust 语言是因为 Rust 语言默认内存安全，并且应用范围匹配 C/Cpp 领域。华为作为 ICT 基础设施供应商，性能和安全性基本上是Rust的两个基本基准，所以希望投资 Rust 语言并在产品中得到广泛使用。华为作为唯一战略赞助。</p>
<p>他说到：</p>
<p>“对于华为，我们将在社区中投资的领域包括数值计算，机器人技术，虚拟化等项目。作为迄今为止中国唯一的铂金创始成员，我们还希望与所有合作伙伴一起推广 Rust，这可能包括建立本地基础架构，例如 crates.io 和本地 CI，以实现更好的访问和可用性，将更多文档翻译成中文并推广更多活动。最后但并非最不重要的一点是，我们渴望在欧盟，北美拥有更多的Rust人才加入我们的行列。”</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-04-15-introducing-jane-lusbyjane-lusbya" id="a-hrefhttpsfoundationrust-langorgposts2021-04-15-introducing-jane-lusbyjane-lusbya"><a href="https://foundation.rust-lang.org/posts/2021-04-15-introducing-jane-lusby/">Jane Lusby</a></a></h3>
<p>Jane 是 Rust 错误处理项目组的负责人，以及 Clippy 和 wg-traits 团队成员。她在 Rust 基金会中担任 项目董事（Project Director），负责项目协作。</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-04-15-introducing-shane-millershane-millera" id="a-hrefhttpsfoundationrust-langorgposts2021-04-15-introducing-shane-millershane-millera"><a href="https://foundation.rust-lang.org/posts/2021-04-15-introducing-shane-miller/">Shane Miller</a></a></h3>
<p>Shane 目前领导 AWS 的 Rust平台团队。大约 30年以来，她一直在创造自己独特的职业道路。她曾经是一名高中辍学生，Smalltalk首席工程师，大学数学系，零售业务所有者，政治顾问，工程经理以及 AWS 的首席技术项目经理和高级工程经理。</p>
<p>她在 基金会担任 会员董事 （Member Director）。</p>
<p>她说到：</p>
<p>“
作为基金会董事会的一名董事，我设想基金会将成为一个为Rust项目维护者提供我自己的AWS团队支持的组织。当我们消除计算，存储和生产力工具的维护人员的自付费用时，我们将使Rust真正可访问。我们还可以提供对资源的访问，例如领导力和沟通培训，这些资源可以帮助Rust的维护者发展自己和团队。</p>
<p>我对基金会感到兴奋的是，它为我提供了一种以不同方式为我们的社区做出贡献的机制。我有大量交付大规模软件的经验。在回到工程经理职位之前，我是AWS的首席技术项目经理。我启动了涵盖组织和地区的服务。我知道将复杂性和规模相结合要取得成功是多么困难，并且我期待着帮助我们的社区简化其中的一些复杂性。</p>
<p>用塞思·戈德温（Seth Godwin）的话说：“我们为谋生做什么？我们要做的是尝试改变一切。 我们试图找到一种现状，即困扰我们的事情，需要改进的事情，需要改变的渴望的事情，然后我们进行更改。我们试图做出重大的永久性重要改变。”</p>
<p>让我们建立社区和技术，使我们所有人永存。
”</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-04-22-introducing-josh-stonejosh-stonea" id="a-hrefhttpsfoundationrust-langorgposts2021-04-22-introducing-josh-stonejosh-stonea"><a href="https://foundation.rust-lang.org/posts/2021-04-22-introducing-josh-stone/">Josh Stone</a></a></h3>
<p>在 基金会中担任 项目董事（Project Director），负责可靠性领域。他目前是 Rust 发布团队，同时也是安全响应工作组和编译器团队贡献者的成员，重点是LLVM工作组。</p>
<p>他说到：
“
我希望这些角色为我做好了担任可靠性项目主管的准备。我们一直希望Rust能够“正常运行”，因此您可以自由更新到最新版本，而不必担心性能下降。我们的跟踪记录很好，但是当然并不完美，我将寻找跟踪和改进它的方法。诸如crates.io和docs.rs之类的服务也很重要，不仅在正常运行时间上而且在广泛的可访问性上也是如此。我在这种基础架构方面的经验较少，但是我绝对愿意提出建议。
”</p>
<h3><a class="header" href="#a-hrefhttpsfoundationrust-langorgposts2021-04-22-introducing-lars-bergstromlars-bergstroma" id="a-hrefhttpsfoundationrust-langorgposts2021-04-22-introducing-lars-bergstromlars-bergstroma"><a href="https://foundation.rust-lang.org/posts/2021-04-22-introducing-lars-bergstrom/">Lars Bergstrom</a></a></h3>
<p>供职于 Goolge ，是 Android 平台编程语言的工程总监，他的团队目前在使用 Cpp/Java/Kotlin/Rust。在性能最敏感的代码中提高内存安全性，对Android至关重要，既要确保用户安全，又要减少紧急安全更新的次数。目前在基金会担任 会员董事（Member Director）。</p>
<p>在加入 Goolge 之前，一直在 Mozilla 工作（2013年开始），从事 Servo 浏览器引擎开发。</p>
<p>他说到：</p>
<p>“
希望基金会能够帮助Rust围绕许多个人和公司正在开展的活动发展新的合作关系，从而使整个社区受益。例如，大多数公司在内部对每个 Crate 的导入/更新进行附加的安全性检查，许可证/代码验证和性能分析，但如今这些信息并未在外部共享。此外，虽然理想的是用Rust编写新项目，但对于我们大多数人来说，我们需要将Rust集成到现有系统中-许多系统都是C++，并且每个系统都使用一组独特的功能，这些功能对与Rust进行有效集成提出了挑战。跨公司合作，我们可以构建适用于整个行业的解决方案。最后，对于许多关键系统（例如设备驱动程序）来说，Rust开发人员可以访问的正式验证还可以帮助我们消除软件系统中除内存安全性之外的更多问题。
”</p>
<h2><a class="header" href="#facebook-加入了-rust-基金会" id="facebook-加入了-rust-基金会">Facebook 加入了 Rust 基金会</a></h2>
<p>其他基金会成员一样，Facebook致力于维持和发展Rust开源生态系统和社区。</p>
<p>Facebook的开源生态系统负责人，现任Rust Foundation的董事会主席Joel Marcey说：“ Facebook自2016年以来就接受了Rust，并在开发的各个方面都使用了Rust，从源代码控制到编译器。” “我们正在加入Rust基金会，以帮助贡献，改进和发展这种语言，这对我们和全球开发人员都变得如此宝贵。我们期待与其他基金会成员和Rust社区一起参与，使Rust成为系统编程及其他领域的主流选择语言。”</p>
<p>Facebook将于2021年加强对Rust的内部开发人员支持。除了公司内各个团队编写Rust代码外，现在还有一个专门的Rust团队，主要负责公司内部Rust开发的发展，包括开源贡献。加入Rust和基于Rust的项目，并与Rust社区互动。</p>
<p><a href="https://developers.facebook.com/blog/post/2021/04/29/facebook-joins-rust-foundation/">https://developers.facebook.com/blog/post/2021/04/29/facebook-joins-rust-foundation/</a></p>
<h2><a class="header" href="#rust-基金会新增四个银牌会员" id="rust-基金会新增四个银牌会员">Rust 基金会新增四个银牌会员</a></h2>
<ul>
<li><a href="https://zama.ai/">zama</a>，为数据科学和AI构建开源同态加密解决方案。 从加密库到机器学习框架，他们始终使用Rust。</li>
<li><a href="https://ferrous-systems.com/">Ferrous Systems</a>，通过提供培训和服务来改善Rust的生态系统，并雇用Rust编译器的维护者。 它还通过为嵌入式空间提供重要的生态系统工具（例如knurling ）和共维护库（例如nrf-hal）来启用Rust on Embedded。 他们目前的标志性项目是二茂铁，以在安全关键型空间中启用Rust。</li>
<li><a href="https://www.tag1consulting.com/">Tag1Consulting</a>，是一家全球技术咨询公司，是支持他们依赖的开源项目的热心倡导者。 他们依靠Rust进行一些项目，例如goose.rs，这是一个高度可扩展的负载测试工具，其灵感来自基于Python的Locust Framework。</li>
<li><a href="https://www.clever-cloud.com/en/">CleverClound</a>，是一个自Rust成立以来就一直存在于Rust社区中的IT自动化平台。 他们自豪地为许多Rust开源项目做出了贡献，例如nom，sozu和许多其他项目。</li>
</ul>
<p><a href="https://foundation.rust-lang.org/posts/2021-04-29-membership-update/">https://foundation.rust-lang.org/posts/2021-04-29-membership-update/</a></p>
<h2><a class="header" href="#rust-编译器compiler团队-4-月份计划" id="rust-编译器compiler团队-4-月份计划">Rust 编译器（Compiler）团队 4 月份计划</a></h2>
<p>2021 年 4 月 15 日， Felix Klock on 代表 Rust 编译器团队发表了博文 Rust Compiler April Steering Cycle，对于 Rust 编译器的 4 月份研讨会议，进行日程安排。</p>
<p>以下是原文内容：</p>
<ul>
<li>2021 年 4 月 9 日，4 月第 2 个星期五，Rust 编译器团队召开了关于编译器方向周期（steering cycle）的 4 月份计划会议。</li>
<li>每到第 4 个星期五，Rust 编译器团队就将决定：在未来的三个星期五，如何使用预定的指导和设计会议时间。</li>
<li>2021 年 4 月 23 日，星期五，我们将举行一次会议，讨论的主题是：为编译器贡献者提出一套指导原则。</li>
<li>2021 年 4 月 30 日，星期五，我们将召开一次会议，讨论每周的编译器性能分类过程。</li>
</ul>
<p>此两个会议，将在格林尼治标准时间下午 2-3 点举行，直播地址为 T-compiler/meetings zulip stream。</p>
<h2><a class="header" href="#niko-退出-rust-核心团队将专注于-rust-语言设计" id="niko-退出-rust-核心团队将专注于-rust-语言设计">Niko 退出 Rust 核心团队，将专注于 Rust 语言设计</a></h2>
<p>Niko Matsakis 正在逐步退出 Rust 核心团队，他将集中精力带领 Rust 语言团队。多年来，Niko Matsakis 为 Rust 项目做了大量工作。从一开始，Niko 就是核心团队的一员，并在 Rust 的治理过程中，发挥了关键作用。关于 Niko 将为专注的新焦点带来什么特性，Rust 团队都很期待！</p>
<p>Niko 在其博客说到：</p>
<p>“
我计划将所有精力都集中在作为语言设计团队负责人和AWS Rust Platform团队技术负责人的角色上。</p>
<p>我希望能做更多的产品计划，例如异步愿景文档，以帮助Rust为其未来建立一致的愿景。我还希望继续研究扩展lang团队，改进RFC流程并帮助团队正常运作的方法。
”</p>
<p><a href="https://smallcultfollowing.com/babysteps/blog/2021/04/02/my-shiny-future/">https://smallcultfollowing.com/babysteps/blog/2021/04/02/my-shiny-future/</a></p>
<h2><a class="header" href="#rust-gat-离稳定又进了一步" id="rust-gat-离稳定又进了一步">Rust GAT 离稳定又进了一步</a></h2>
<p>#81823 Bug 已被修复，目前阻碍 GAT 只剩下 三个 Bug 了。</p>
<p><a href="https://github.com/rust-lang/rust/issues/44265">https://github.com/rust-lang/rust/issues/44265</a></p>
<h2><a class="header" href="#头脑风暴进行中async-rust-的未来熠熠生辉" id="头脑风暴进行中async-rust-的未来熠熠生辉">头脑风暴进行中：Async Rust 的未来熠熠生辉</a></h2>
<p>Niko Matsakis 代表 Async 基金会工作组，于 2021 年 4 月 14 日发布文章 Brainstorming Async Rust’s Shiny Future</p>
<p>3 月 18 日，我们宣布开始为 Async Rust 构建共享的愿景文档的过程。从那时起，我们已经接收到了 24 个“现状”故事。在开启状态的 PR（open PRs）中，还有 4 个故事；在过去的几周里，Ryan Levick 和我还主持了 10 多个协作写作会议。</p>
<p>阅读：</p>
<ul>
<li><a href="https://blog.rust-lang.org/2021/03/18/async-vision-doc.html">原文</a></li>
<li><a href="https://blog.budshome.com/budshome/wei-async-rust-gou-jian-gong-xiang-de-yuan-jing-wen-dang------rust-she-qu-de-jiang-gu-shi-,ke-huo-jiang">译文</a></li>
</ul>
<h2><a class="header" href="#rustc_codegen_cranelift-进展报告" id="rustc_codegen_cranelift-进展报告">rustc_codegen_cranelift 进展报告</a></h2>
<ul>
<li>删除了对旧式Cranelift后端的支持</li>
<li>原子操作是使用本机原子指令实现的，而不是使用全局锁来模拟的</li>
<li>使用MinGW交叉编译到Windows</li>
<li>在CI上运行rustc测试套件</li>
</ul>
<p>后面的挑战：</p>
<ol>
<li>Windows对MSVC工具链的支持</li>
</ol>
<p>Cranelift尚不支持COFF / PE目标文件的TLS。 这意味着与使用pthread密钥实现TLS的MinGW不同，当前无法为MSVC进行编译。</p>
<ol start="2">
<li>SIMD</li>
</ol>
<p>很多平台指令支持仍未实现。</p>
<p><a href="https://bjorn3.github.io/2021/04/13/progress-report-april-2021.html">https://bjorn3.github.io/2021/04/13/progress-report-april-2021.html</a></p>
<h2><a class="header" href="#miri-现支持运行-doctests" id="miri-现支持运行-doctests">Miri 现支持运行 doctests</a></h2>
<p>Miri 是一个实验性的 Rust MIR 解释器。它可以运行 Rust 二进制文件，对其进行测试，可以检查出某些未定义的行为 ref。</p>
<p>支持 doctests 之后，cargo miri test 执行的测试与 cargo test 执行的测试就保持一致了。</p>
<p><a href="https://github.com/rust-lang/miri/pull/1757">https://github.com/rust-lang/miri/pull/1757</a></p>
<h2><a class="header" href="#编译器团队迎来新成员-aaron-hill" id="编译器团队迎来新成员-aaron-hill">编译器团队迎来新成员 Aaron Hill</a></h2>
<p>自2017年创立以来，Aaron Hill（@ Aaron1011）一直在为编译器的许多不同部分做出贡献。最近，Aaron一直致力于发现和修复增量系统中的错误和正确性问题，清理以及对宏扩展和卫生的改进， 以及其他错误修复。 除编译器外，Aaron还实现了对Miri中展开，生成自动特征文档以及将来在Cargo中不兼容报告的支持。</p>
<p><a href="https://blog.rust-lang.org/inside-rust/2021/04/26/aaron-hill-compiler-team.html">https://blog.rust-lang.org/inside-rust/2021/04/26/aaron-hill-compiler-team.html</a></p>
<h2><a class="header" href="#rustup-1241-发布" id="rustup-1241-发布">Rustup 1.24.1 发布</a></h2>
<p>Rustup 1.24.0 发布之后，发现了因为代码疏漏导致<code>cargo fmt</code>无法使用，从而回滚到 1.23.1 。现在 1.24.1 修复了这个 Bug 。</p>
<p><a href="https://blog.rust-lang.org/2021/04/29/Rustup-1.24.1.html">https://blog.rust-lang.org/2021/04/29/Rustup-1.24.1.html</a></p>
<h2><a class="header" href="#介绍-turbowish" id="介绍-turbowish">介绍 TurboWish</a></h2>
<p>TurboWish 是编译器团队Leader Pnkfelix 及其领导的 Amazon Web Services团队 计划中的一套工具的总称，用于了解Rust程序的动态行为。 他们希望这些工具特别专注于洞察有关程序性能特征。</p>
<p>目标描述：</p>
<ul>
<li>
<p>Profile Production Code：合并TurboWish框架的开销很低：可以将其合并到生产代码中，而不会产生过多的维护负担，也不会产生显着的性能开销。</p>
</li>
<li>
<p>Domain-specific Feedback：框架和应用程序可以为专用度量提供数据，这些度量特定于其内部体系结构。</p>
</li>
<li>
<p>Understand Hidden Costs and Connections：tokio之类的框架使编写异步代码变得容易，因为它们在抽象后隐藏了许多细节（例如Rust编译器生成的生成器代码，或tokio运行时管理的任务队列）。 TurboWish公开了那些隐藏的细节，使开发人员可以将它们与其他程序事件相关联。它还暴露了人类通常必须手工重建的联系（例如，从未来到资源再到可能产生僵局的未来链），从而使人们可以直接从Rust的所有权模型中查看对象图中资源的持有方式。</p>
</li>
<li>
<p>Framework Agnostic：Rust的许多用户都使用tokio，但并非全部。 async-std和fuschia_async是用于异步编程的其他框架。 TurboWish可以为任何此类框架提供价值（尽管在担保时也可以提供特定于框架的功能）。对于我们的初始发行版，我们可以只专注于tokio，但是如果tokio证明是成功的，则期望与其他人集成。</p>
</li>
<li>
<p>EC2 Instance Type Agnostic：如果我们使用任何特定于OS的功能（例如dtrace探针），则无论实例类型如何，它们将在所有EC2 AL2实例上可用。 （特别是，我们不能要求访问CPU性能计数器。）</p>
</li>
<li>
<p>Part 1: <a href="http://blog.pnkfx.org/blog/2021/04/26/road-to-turbowish-part-1-goals/">http://blog.pnkfx.org/blog/2021/04/26/road-to-turbowish-part-1-goals/</a></p>
</li>
<li>
<p>Part 2: <a href="http://blog.pnkfx.org/blog/2021/04/27/road-to-turbowish-part-2-stories/">http://blog.pnkfx.org/blog/2021/04/27/road-to-turbowish-part-2-stories/</a></p>
</li>
</ul>
<h1><a class="header" href="#社区热点-1" id="社区热点-1">社区热点</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#rfcrust--linux-内核的第二语言" id="rfcrust--linux-内核的第二语言">【RFC】Rust : Linux 内核的第二语言</a></h2>
<p>以下是 RFC 的一些摘要：</p>
<p>We believe that, even today, the advantages of using Rust outweighs the cost.</p>
<p>内核中支持 Rust 去编写驱动和一些类似 “叶子” 模块，而不打算用 Rust 重写内核核心和内核子系统。</p>
<h3><a class="header" href="#在-linux-内核中对-使用-rust--的期望" id="在-linux-内核中对-使用-rust--的期望">在 Linux 内核中对 使用 Rust  的期望：</a></h3>
<ol>
<li>用 Rust 新编写的代码能降低内存安全/ 数据竞争 / 逻辑 Bug 的风险</li>
<li>维护人员对 重构和 接受模块补丁 更有信心</li>
<li>新的驱动程序和模块变得更容易编写</li>
<li>使用新的现代的语言，吸引更多的人参与内核开发</li>
<li>通过利用Rust工具，建立的文档指南。 例如，要求记录所有公共API，安全前提条件，“Unsafe”块和类型不变式。</li>
</ol>
<h3><a class="header" href="#rust与c相比也有缺点" id="rust与c相比也有缺点">Rust与C相比也有缺点：</a></h3>
<ul>
<li>围绕内核开发的 C 语言工具有很多年的积累，但是，如果内核 Rust 使用量上来，也会有相应工具。</li>
<li>Rust 基于 LLVM 的单一实现。目前通过第三方的努力来改善这种情况，比如 GCC 前端，基于 Cranelift 的 rust 后端，以及减少 bootstrapping chain 的 mrustc。</li>
<li>未标准化。虽然尚不清楚标准化是否会对内核有利，但在任何情况下都有几点可以最小化此问题：Rust稳定性承诺，广泛的文档，WIP参考，详细的RFC等。</li>
<li>编译速度太慢。</li>
<li>目前需要一些 nightly 功能，目标是一年内帮助 rustc 稳定这些功能，或者是，找到替代的稳定的功能。在这里维护相关报告：https://github.com/Rust-for-Linux/linux/issues/2</li>
<li>其他。</li>
</ul>
<p>「 我们认为Rust很可能会就像C一样，成为系统编程的重要组成部分」 </p>
<h3><a class="header" href="#关键设计选择" id="关键设计选择">关键设计选择</a></h3>
<ol>
<li>Rust内核模块需要一些共享代码，即
通过配置选项（<code>CONFIG_RUST</code>）启用。这使得
单个模块更小。此支持包括：
<ul>
<li>Rust 标准库。当前包含了 alloc 和 core，未来可能仅有 core 的子集。</li>
</ul>
</li>
</ol>
<ul>
<li>包装内核API  的 安全抽象 API，目的是为了让 Rust 编写的模块中尽可能减少 Unsafe 代码的数量。</li>
<li>其他。 例如“模块！”过程宏，编译器内置函数，生成的绑定和帮助程序等。</li>
</ul>
<ol start="2">
<li>
<p>用Rust编写的模块永远不要直接使用C内核API。在内核中使用Rust的全部要点是，我们开发了安全的抽象，因此模块更易于推理，因此更易于查看，重构等  。此外，通过“ bindgen”（正式的Rust工具）即时生成与内核C端的绑定。使用它可以避免在Rust方面更新绑定。</p>
</li>
<li>
<p>在Rust代码库中，大多数文档都是在Markdown中与源代码一起编写的。我们遵循此约定，因此尽管在<code>Documentation / rust /</code>中有一些常规文档，但大多数实际文档都在源代码本身中。</p>
</li>
</ol>
<p>强制执行自动代码格式，使用 clippy/ fmt 等。例如，这意味着4个空格用于缩进，而不是制表符。我们认为重要的是保持格式自动化。</p>
<ol start="4">
<li>为避免将GPL符号公开为非GPL（甚至间接），将内核中的所有Rust支持符号导出为GPL。</li>
</ol>
<h3><a class="header" href="#目前状态" id="目前状态">目前状态</a></h3>
<p>目前提供的 Rust 支持是实验性的，因为还有很多细节需要完善，比如内核API需要安全抽象等。但是，现在可以编写一些模块等原型了。</p>
<p>目前支持 Clang 构建内核，支持 x86_64，arm64和<code>ppc64le</code>等衍生架构，以及 RISC-V等。</p>
<h3><a class="header" href="#上游计划" id="上游计划">上游计划</a></h3>
<p>与往常一样，尽早进入主线是解决所有遗漏细节的最佳方法，但是，我们何时提交它们取决于我们收到的有关此RFC的反馈以及高层维护者的总体看法。</p>
<p>我们希望得到反馈的另一个主题是 kernel crate： https://rust-for-linux.github.io/docs/kernel/</p>
<h3><a class="header" href="#相关链接-1" id="相关链接-1">相关链接</a></h3>
<p>https://lkml.org/lkml/2021/4/14/1023</p>
<p>仓库地址：https://github.com/Rust-for-Linux/linux</p>
<h2><a class="header" href="#linus-对-rust-进内核给出了珍贵的指导意见" id="linus-对-rust-进内核给出了珍贵的指导意见">Linus 对 Rust 进内核给出了珍贵的指导意见</a></h2>
<pre><code class="language-text">
So I replied with my reactions to a couple of the individual patches, but on the whole I don't hate it.

HOWEVER.

I do think that the &quot;run-time failure panic&quot; is a fundamental issue.

I may not understand the ramifications of when it can happen, so maybe it's less of an issue than I think it is, but very fundamentally I think that if some Rust allocation can cause a panic, this is simply fundamentally not acceptable.

Allocation failures in a driver or non-core code  and that is by definition all of any new Rust code can never EVER validly cause panics. Same goes for &quot;oh, some case I didn't test used 128-bit integers or floating point&quot;.

So if the Rust compiler causes hidden allocations that cannot be caught and returned as errors, then I seriously think that this whole approach needs to be entirely NAK'ed, and the Rust infrastructure - whether at the compiler level or in the kernel wrappers - needs more work.

So if the panic was just some placeholder for things that _can_ be caught, then I think that catching code absolutely needs to be written, and not left as a to-do.

And if the panic situation is some fundamental &quot;this is what the Rust compiler does for internal allocation failures&quot;, then I think it needs more than just kernel wrapper work - it needs the Rust compiler to be *fixed*.

Because kernel code is different from random user-space system   tools. Running out of memory simply MUST NOT cause an abort.  It needs to just result in an error return.

I don't know enough about how the out-of-memory situations would be triggered and caught to actually know whether this is a fundamental problem or not, so my reaction comes from ignorance, but basically the rule has to be that there are absolutely zero run-time &quot;panic()&quot; calls. Unsafe code has to either be caught at compile time, or it has to be handled dynamically as just a regular error.

With the main point of Rust being safety, there is no way I will ever accept &quot;panic dynamically&quot; (whether due to out-of-memory or due to anything else - I also reacted to the &quot;floating point use causes dynamic panics&quot;) as a feature in the Rust model.

           Linus

</code></pre>
<p>详细：<a href="https://lkml.org/lkml/2021/4/14/1099">https://lkml.org/lkml/2021/4/14/1099</a></p>
<h2><a class="header" href="#google-linux-内核中使用-rust" id="google-linux-内核中使用-rust">Google: Linux 内核中使用 Rust</a></h2>
<p>Google 发布的这篇博文中宣布支持 Rust ，并且还给出一个驱动开发示例来对比 Rust 和 C 。</p>
<p><a href="https://security.googleblog.com/2021/04/rust-in-linux-kernel.html">https://security.googleblog.com/2021/04/rust-in-linux-kernel.html</a></p>
<h2><a class="header" href="#字节码联盟成为非营利组织并且迎来新成员" id="字节码联盟成为非营利组织并且迎来新成员">字节码联盟成为非营利组织并且迎来新成员</a></h2>
<p>字节码联盟（Bytecode Alliance）成为了 501(c)(6) 非营利组织，并且有新成员加入 Arm, DFINITY Foundation, Embark Studios, Google, Shopify, 和 University of California at San Diego 。</p>
<p><strong>一直以来的工作：</strong></p>
<ol>
<li>推动 nanoprocess 并推动标准化，包括 WASI/ Interface Types/Module Linking等。</li>
<li>Cranelift WebAssembly编译器创建了一个新的代码生成后端，重点关注性能和安全性。这个新的后端是由Fastly，Mozilla，Intel和Arm之间紧密合作创建的，现在是Wasmtime和Lucet的默认后端，并且Fastly最近对该技术进行了全面的安全评估，并为 Compute @ Edge 切换到了这个新后端。</li>
<li>改进了协作流程；例如，引入了RFC流程来提高可见性，并能够集中讨论我们核心项目的重大变化</li>
</ol>
<p><strong>未来社区治理</strong></p>
<p>我们欢迎新成员加入字节码联盟。 在加入新成员的同时，在接下来的几个月中，我们将为技术指导委员会（TSC）和董事会全面定义章程，作为引导阶段的一部分。 在此期间结束时，我们将组织理事会和TSC选举，以全面建立Bytecode Alliance的开放治理模型。 更多细节将在不久的将来出现。</p>
<p><a href="https://bytecodealliance.org/articles/bytecode-alliance-update">https://bytecodealliance.org/articles/bytecode-alliance-update</a></p>
<h2><a class="header" href="#rust-在过去一年中是增长最快的语言之一" id="rust-在过去一年中是增长最快的语言之一">Rust 在过去一年中是增长最快的语言之一</a></h2>
<p>SlashData指出，Rust和Lua是过去12个月中增长最快的两个编程语言社区，尽管其基础比Python低。</p>
<p>Rust并未得到广泛使用，但今年它的社区走出了Mozilla的阴影，并创建了自己的Rust Foundation，该基金会得到了Amazon Web Services，Microsoft Azure，Google和Mozilla的支持。</p>
<p>Google力求Rust成为Linux内核的第二种语言，并使用它为Android操作系统编写新代码，因为它的内存安全性保证有助于避免内存错误。 开发人员还赞赏Rust的Crates软件包管理系统。</p>
<p><a href="https://www.zdnet.com/article/programming-languages-javascript-has-most-developers-but-rust-is-the-fastest-growing/">https://www.zdnet.com/article/programming-languages-javascript-has-most-developers-but-rust-is-the-fastest-growing/</a></p>
<h2><a class="header" href="#整理了一下-rust-尾调用优化的状态" id="整理了一下-rust-尾调用优化的状态">整理了一下 Rust 尾调用优化的状态</a></h2>
<p><img src="chapter_4/image/others/rust_tco.png" alt="tco" /></p>
<p>起因是 reddit 上面看到一篇帖子，作者说他看到 Clang 加了一个<code> [[clang::musttail]]</code> 属性，可以保证编译器对尾调用的优化，意味着 LLVM后端 目前应该也支持了尾调用优化的保证，那 Rust  是不是就离支持 尾调用优化不远了呢？</p>
<p><a href="https://www.reddit.com/r/rust/comments/my6k5i/are_we_finally_about_to_gain_guaranteed_tail/">https://www.reddit.com/r/rust/comments/my6k5i/are_we_finally_about_to_gain_guaranteed_tail/</a></p>
<p>参考：</p>
<p><a href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html">https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html</a></p>
<p><a href="https://dev.to/seanchen1991/the-story-of-tail-call-optimizations-in-rust-35hf">https://dev.to/seanchen1991/the-story-of-tail-call-optimizations-in-rust-35hf</a></p>
<h2><a class="header" href="#rust-osdev-发布-2021-年-3-月简讯" id="rust-osdev-发布-2021-年-3-月简讯">Rust OSDev 发布 2021 年 3 月简讯</a></h2>
<p>Rust OSDev 组织是 Blog OS 系列文章作者创建，维护着一些 OS 相关项目。</p>
<ul>
<li><a href="https://rust-osdev.com/this-month/2021-03/">https://rust-osdev.com/this-month/2021-03/</a></li>
<li><a href="https://github.com/rust-osdev/about">https://github.com/rust-osdev/about</a></li>
</ul>
<h2><a class="header" href="#gcc-rust-发布第四期月报" id="gcc-rust-发布第四期月报">GCC Rust 发布第四期月报</a></h2>
<p>GCC Rust成为了 Google Summer of Code 2021 指导组织的一员，吸引了来自世界各地的一些对编译器开发感兴趣的学生。</p>
<p>此编译器的长期目标是前端可以与GCC分离，并成为自己的项目（同时保持GCC版权分配），这就是为什么我们使用rust-gcc.cc分支的原因 go-gcc.cc通用抽象。</p>
<p>更多：</p>
<ul>
<li><a href="https://github.com/Rust-GCC/gccrs/wiki/Google-Summer-of-Code">https://github.com/Rust-GCC/gccrs/wiki/Google-Summer-of-Code</a></li>
<li><a href="https://thephilbert.io/2021/04/02/gcc-rust-monthly-report-4-march-2021/">https://thephilbert.io/2021/04/02/gcc-rust-monthly-report-4-march-2021/</a></li>
</ul>
<h2><a class="header" href="#mrustc-支持-rust-1390" id="mrustc-支持-rust-1390">mrustc 支持 Rust 1.39.0</a></h2>
<ol>
<li>mrustc 是一个 基于 Cpp 的 Rust 编译器的替代实现，最终目标是成为一个单独的重新实现。</li>
<li>目前官方 rustc 版本为 1.51.0 。</li>
</ol>
<p><a href="https://github.com/thepowersgang/mrustc/">https://github.com/thepowersgang/mrustc/</a></p>
<h2><a class="header" href="#flott-月报发布" id="flott-月报发布">Flott 月报发布</a></h2>
<p>Flott 是基于 Rust 实现的运动控制软件的工具包。</p>
<p>Flott的目的是通过提供库来简化运动控制软件的开发，这些库可以抽象出通常用于运动控制的硬件，例如电动机，编码器以及其他传感器和执行器。</p>
<p>上个月看到了通用步进电机接口步进器（Stepper）的新版本。 还发布了Stepper Terminal，这是一个基于Stepper的新应用程序，用于从计算机上的命令行控制步进电机。</p>
<ul>
<li><a href="https://flott-motion.org/news/last-month-in-flott-april-2021/">https://flott-motion.org/news/last-month-in-flott-april-2021/</a></li>
<li><a href="https://github.com/flott-motion">https://github.com/flott-motion</a></li>
</ul>
<h2><a class="header" href="#社区雄文rust-是为专业程序员准备的" id="社区雄文rust-是为专业程序员准备的">社区雄文：Rust 是为专业程序员准备的</a></h2>
<p>专业的程序员通过创作和维护可解决问题的软件来创造价值。 （专业程序员还有其他重要的方式可以交付价值，但是本文是关于编程的。）</p>
<p>程序员依靠各种工具来编写软件。 可以说，最重要和最重要的工具选择是编程语言。</p>
<p>在这篇文章中，作者将阐明为什么他相信Rust对于软件专业人员来说是一种非常引人注目的编程语言选择。 简而言之，他希望说服你学习和部署Rust。</p>
<p><a href="https://gregoryszorc.com/blog/2021/04/13/rust-is-for-professionals/">https://gregoryszorc.com/blog/2021/04/13/rust-is-for-professionals/</a></p>
<h2><a class="header" href="#tokio-发布-io_uring-设计方案" id="tokio-发布-io_uring-设计方案">Tokio 发布 io_uring 设计方案</a></h2>
<p>该 RFC 提出了一个新的异步Rust运行时，它由<code>io-uring</code>作为新的 Crate 支持：<a href="https://github.com/tokio-rs/tokio-uring">tokio-uring</a>。 该API的目的是尽可能接近惯用的Tokio，但在必要时会有所偏离，以提供对io-uring功能的完全访问权限。 它还将与现有的Tokio库兼容。 运行时将使用隔离的每核线程模型，并且许多类型将是<code>!Send</code>。</p>
<p><a href="https://github.com/tokio-rs/tokio-uring/pull/1">https://github.com/tokio-rs/tokio-uring/pull/1</a></p>
<h2><a class="header" href="#starlark----facebook-用-rust-重新实现了-starlark-这门编程语言" id="starlark----facebook-用-rust-重新实现了-starlark-这门编程语言">Starlark -- Facebook 用 Rust 重新实现了 Starlark 这门编程语言</a></h2>
<p>Starlark 是 Google 开发的类似于 Python3 的一门编程语言，主要用在 Google 自己的构建工具 Bazel 和 Facebook 的构建工具 Buck 中。Starlark 目前有三种实现，一种是 Go，一种是 Java，另外一种就是现在这个项目，使用 Rust 实现。Rust 的初版是 Google 实现的，现在给了 Facebook。Rust 实现包括了完整的 parser，evaluator，linter 和 debugger。对编程语言感兴趣的朋友可以看看。</p>
<ul>
<li><a href="https://developers.facebook.com/blog/post/2021/04/08/rust-starlark-library/">https://developers.facebook.com/blog/post/2021/04/08/rust-starlark-library/</a></li>
<li><a href="https://github.com/facebookexperimental/starlark-rust">https://github.com/facebookexperimental/starlark-rust</a></li>
</ul>
<h2><a class="header" href="#enso-编程语言发布-20" id="enso-编程语言发布-20">enso 编程语言发布 2.0</a></h2>
<p>enso 是一种可视化编程语言，同时也支持支持 Java、Python、R、JavaScript。使用 Rust 和 Java 编写。</p>
<p><a href="https://github.com/enso-org/enso">https://github.com/enso-org/enso</a></p>
<h2><a class="header" href="#42-个在生产环境使用-rust-的公司" id="42-个在生产环境使用-rust-的公司">42 个在生产环境使用 Rust 的公司</a></h2>
<p><a href="https://kerkour.com/blog/rust-in-production-2021/">https://kerkour.com/blog/rust-in-production-2021/</a></p>
<h2><a class="header" href="#google-提供资金isrg-联合-rustls-作者和-googleoss-对-rustls-进行改进" id="google-提供资金isrg-联合-rustls-作者和-googleoss-对-rustls-进行改进">Google 提供资金，ISRG 联合 Rustls 作者和 GoogleOSS 对 Rustls 进行改进</a></h2>
<p>改进包括：</p>
<ol>
<li>强制执行免恐慌（no-panic policy）策略，以消除在C语言边界上使用Rustls时出现未定义行为的可能性。</li>
<li>改进C API，以便Rustls可以更轻松地集成到现有的基于C的应用程序中。将C API合并到主要的Rustls存储库中。</li>
<li>添加对验证主题备用名称扩展中包含IP地址的证书的支持。</li>
<li>使基于客户端输入来配置服务器端连接成为可能。</li>
</ol>
<p>目前已经完成了curl和Apache httpd 中集成 rustls，未来希望在 Let's Encrypt 中 用 Rustls 取代 OpenSSL 和其他不安全的TLS库</p>
<p><a href="https://www.abetterinternet.org/post/preparing-rustls-for-wider-adoption/">https://www.abetterinternet.org/post/preparing-rustls-for-wider-adoption/</a></p>
<h2><a class="header" href="#寻找-rust--工作是一种痛" id="寻找-rust--工作是一种痛">寻找 Rust  工作是一种痛</a></h2>
<p>Reddit 上面有人发帖问，有没有区块链之外的Rust工作？ </p>
<p>看来 Rust  工作不好找，不只是 国内的问题。</p>
<p>评论区有人回复摘录：</p>
<blockquote>
<p>70%的 Rust 职位是很区块链相关的，他之前找过一个 非区块链 Rust 后端工作，但是不久之后就变成 Go 了。。。</p>
</blockquote>
<blockquote>
<p>如果每个人都只是寻找Rust工作，而不是将现有公司代码转换为Rust，那么就不会有Rust工作。</p>
</blockquote>
<blockquote>
<p>还有人直接在评论区招聘，视频流/webrtc 相关职位</p>
</blockquote>
<blockquote>
<p>有人一直在寻找 Rust 工作，并为此付出一些代价。比如专门去寻找适合 一个人开发的 工作，这样就有机会选择 Rust ，最终让他找到了工作机会，一家视频游戏公司，围绕unity开发一些工具，最终目标是从他们的工作流中干掉unity</p>
</blockquote>
<blockquote>
<p>也有一个电力行业的人说他们会在今年夏天发布一些 Rust 职位</p>
</blockquote>
<blockquote>
<p>还有一家 科学仪器设计和生产商在使用 Rust ，其中一种仪器在每个实验中收集了几Tb的图像数据，这些数据使用rust编写的代码进行处理和分析。</p>
</blockquote>
<blockquote>
<p>如果您对计算机视觉/零售结帐感兴趣，请访问https://standard.ai。在过去的几年中，很大一部分生产堆栈已从python / cython迁移到rust。 尽管一些后端和研究团队将长期使用python，但目前它在很大程度上是使用 Rust 的。</p>
</blockquote>
<blockquote>
<p>有人直接发了 JD ，是完全远程的工作，国内也可以看看。 https://www.showseeker.com/backend-developer </p>
</blockquote>
<p>如有任何问题，请联系官方发贴电</p>
<p>相比国外，国内 Rust 岗位虽然不多，但也是有的。</p>
<p><a href="https://www.reddit.com/r/rust/comments/n05zhh/looking_for_a_rust_job_is_pain/">https://www.reddit.com/r/rust/comments/n05zhh/looking_for_a_rust_job_is_pain/</a></p>
<h2><a class="header" href="#用rust重写tensorbord部分组件带来了100x到400x的速度提升" id="用rust重写tensorbord部分组件带来了100x到400x的速度提升">用Rust重写Tensorbord部分组件带来了100x到400x的速度提升</a></h2>
<p>相比原先Python和C++混合，使用大量的锁和跨语言交互的数据读取器， 在使用了Rust编写的专用进程进行数据读取后，性能提升了100x到400x。</p>
<ul>
<li>相关 Issue: <a href="https://github.com/tensorflow/tensorboard/issues/4784">https://github.com/tensorflow/tensorboard/issues/4784</a></li>
<li>阅读更多：<a href="https://www.reddit.com/r/rust/comments/mzlg5s/parts_of_tensorboard_are_being_rewritten_in_rust/">https://www.reddit.com/r/rust/comments/mzlg5s/parts_of_tensorboard_are_being_rewritten_in_rust/</a></li>
</ul>
<h2><a class="header" href="#rust-生态贡献者-排名" id="rust-生态贡献者-排名">Rust 生态贡献者 排名</a></h2>
<p><a href="https://www.johndbeatty.com/rustaceanrank.html">https://www.johndbeatty.com/rustaceanrank.html</a></p>
<h1><a class="header" href="#活动回顾" id="活动回顾">活动回顾</a></h1>
<p>后期编辑：张汉东</p>
<blockquote>
<p>编者按：</p>
<p>总结了本月的活动，包括线上和线下。</p>
<p>线上： 《Rust 唠嗑室》和 《RustFriday 飞书群线上沙龙》</p>
</blockquote>
<hr />
<h1><a class="header" href="#活动预告20210515-北京线下-webassembly-meetup-" id="活动预告20210515-北京线下-webassembly-meetup-">【活动预告】2021.05.15 北京线下 WebAssembly Meetup **</a></h1>
<p>现在征集议题 ：  <a href="https://mp.weixin.qq.com/s/5MFN1x8XQBeE3Zs7oqBtsQ">议题申请</a></p>
<hr />
<h1><a class="header" href="#线上rust-唠嗑室本月汇总" id="线上rust-唠嗑室本月汇总">【线上】Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598/video">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
<li>后期编辑：高宪凤</li>
</ul>
<h3><a class="header" href="#rust-唠嗑室第-21-期---local-native-分布式应用开发" id="rust-唠嗑室第-21-期---local-native-分布式应用开发">《Rust 唠嗑室》第 21 期 - Local Native 分布式应用开发</a></h3>
<p><strong>时间</strong>: 2021/03/30 20:30-21:30</p>
<p><strong>主讲人</strong>：Yi Wang</p>
<p><strong>内容</strong>：详解 Rust 实现的跨平台去中心的应用 Local Native</p>
<ul>
<li>demo 网络书签信息管理工具 Local Native</li>
<li>技术讲解</li>
<li>未来的目标</li>
<li>demo 姐妹项目 Fastxt</li>
<li>Q&amp;A</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1wi4y1N7Ez">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<ul>
<li>官方网站 <a href="https://yilab.com/">https://yilab.com/</a></li>
</ul>
<hr />
<h3><a class="header" href="#rust-唠嗑室第-22-期---关于-rust-io_uring-异步接口实现的思考" id="rust-唠嗑室第-22-期---关于-rust-io_uring-异步接口实现的思考">《Rust 唠嗑室》第 22 期 - 关于 Rust io_uring 异步接口实现的思考</a></h3>
<p><strong>时间</strong>: 2021/04/13 20:30-21:30</p>
<p><strong>主讲人</strong>：施继成</p>
<p><strong>内容</strong>：关于 Rust io_uring 异步接口实现的思考</p>
<p>io_uring 接口在 Linux 中被用于高效的异步 I/O 操作，但是使用 liburing 的简单封装十分不友好，我们探索了一种实现方法，一方面能够简化接口的使用，另外一方面避免不必要的内存拷贝保证效率。借此机会和大家分享一下实现过程中的思考，也聆听大家的建议，不断改进优化实现方法。</p>
<p><a href="https://www.bilibili.com/video/BV1VA411L7tt">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<ul>
<li>Liburing 库的简单封装 <a href="https://github.com/ringbahn/uring-sys">https://github.com/ringbahn/uring-sys</a></li>
<li>队列、注册器等数据结构抽象 <a href="https://github.com/datenlord/ring-io">https://github.com/datenlord/ring-io</a></li>
<li>基于 Rust 重写 io_uring 接口 <a href="https://github.com/tokio-rs/io-uring">https://github.com/tokio-rs/io-uring</a></li>
</ul>
<hr />
<h3><a class="header" href="#rust-唠嗑室第-23-期---rust-from-a-haskellers-view" id="rust-唠嗑室第-23-期---rust-from-a-haskellers-view">《Rust 唠嗑室》第 23 期 - Rust From A Haskeller's View</a></h3>
<p><strong>时间</strong>: 2021/04/27 20:30-21:30</p>
<p><strong>主讲人</strong>：火锅 boy 大冬冬</p>
<p><strong>内容</strong>：Rust From A Haskller's view</p>
<p>从资深 Haskell 程序员的视角，试图了解 Rust 这门年轻的语言，除了从技术的角度和 Haskell 进行对比之外，也分享了关于两个语言社区发展的思考和展望</p>
<p><a href="https://www.bilibili.com/video/BV18h411m7Gf">查看回放</a></p>
<hr />
<h1><a class="header" href="#线上rustfriday-飞书群线上沙龙" id="线上rustfriday-飞书群线上沙龙">【线上】RustFriday 飞书群线上沙龙</a></h1>
<p>每周五晚八点，限定两个主题：语言特性和开源项目，在线讨论。</p>
<p>Rust 中文社群 飞书群 邀请你加入：</p>
<p>对话群： https://applink.feishu.cn/TeLAcbDR 
话题群：https://applink.feishu.cn/TeLD868w</p>
<h2><a class="header" href="#第三期讨论主题-rust-语言中级中间语言-mir-的功用" id="第三期讨论主题-rust-语言中级中间语言-mir-的功用">第三期讨论主题： Rust 语言中级中间语言 MIR 的功用</a></h2>
<ol>
<li>介绍 MIR 与 MIRI</li>
<li>和论文的两位第一作者共同阅读2021年新出炉的论文：《 SafeDrop：通过静态数据流分析检测 Rust 程序中的内存释放错误》</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://rustc-dev-guide.rust-lang.org/mir/dataflow.html</li>
<li>https://github.com/rust-lang/miri</li>
<li>https://arxiv.org/pdf/2103.15420</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1nU4y1h7NN/">查看回放</a></p>
<h2><a class="header" href="#第四期-讨论主题" id="第四期-讨论主题">第四期 讨论主题：</a></h2>
<ol>
<li>Rust 今天新合并的 RFC : try-trait</li>
<li>Lunatic： 一个类似于 Erlang 的 容错 WASM 运行时</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1xy4y147Ve/">查看回放</a></p>
<h2><a class="header" href="#第五期-讨论主题" id="第五期-讨论主题">第五期 讨论主题：</a></h2>
<ol>
<li>语言特性： 《Rust 标准库 trait 之旅》</li>
<li>领域项目：通过WebSocket实时共享应用程序状态框架 Aper</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md</li>
<li>https://github.com/aper-dev/aper</li>
<li>https://aper.dev/guide/</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1f5411c7qg/">查看回放</a></p>
<hr />
<center> 🔥🔥🔥🔥 <strong>Rust MeetUp</strong> 🔥🔥🔥🔥 </center>
<h1><a class="header" href="#线下rust-meetup-本月汇总" id="线下rust-meetup-本月汇总">【线下】Rust MeetUp 本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598/video">Rust 活动</a></li>
<li>上传者：MikeTang</li>
<li>后期编辑：高宪凤</li>
</ul>
<hr />
<h3><a class="header" href="#rust-meetup-北京站" id="rust-meetup-北京站">Rust Meetup 北京站</a></h3>
<p><strong>时间</strong>: 2021/04/10</p>
<p><strong>地点</strong>：北京中关村创业大街</p>
<h4><a class="header" href="#p1-构建安全高性能的网络应用" id="p1-构建安全高性能的网络应用">【P1】 构建安全高性能的网络应用</a></h4>
<p><strong>嘉宾</strong>：陈天</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1b7qo?p=1">查看回放</a></p>
<h4><a class="header" href="#p2-异步化-os--使用-asyncawait-提升-10-倍性能" id="p2-异步化-os--使用-asyncawait-提升-10-倍性能">【P2】 异步化 OS : 使用 async/await 提升 10 倍性能</a></h4>
<p><strong>嘉宾</strong>：蚂蚁集团 田洪亮</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1b7qo?p=2">查看回放</a></p>
<h4><a class="header" href="#p3-rust和高性能隐私计算" id="p3-rust和高性能隐私计算">【P3】 Rust和高性能隐私计算</a></h4>
<p><strong>嘉宾</strong>：数牍科技</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1b7qo?p=3">查看回放</a></p>
<h4><a class="header" href="#p4-用rust实现rdma编程" id="p4-用rust实现rdma编程">【P4】 用Rust实现RDMA编程</a></h4>
<p><strong>嘉宾</strong>：王璞 @ Datenlord</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1b7qo?p=4">查看回放</a></p>
<h4><a class="header" href="#p5-统一相似的异步和同步代码" id="p5-统一相似的异步和同步代码">【P5】 统一相似的异步和同步代码</a></h4>
<p><strong>嘉宾</strong>：吕国立</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1b7qo?p=5">查看回放</a></p>
<h4><a class="header" href="#p6-unicode标识符简介" id="p6-unicode标识符简介">【P6】 Unicode标识符简介</a></h4>
<p><strong>嘉宾</strong>：CRLF0710</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1b7qo?p=6">查看回放</a></p>
<h4><a class="header" href="#p7-线性类型映射世界" id="p7-线性类型映射世界">【P7】 线性类型映射世界</a></h4>
<p><strong>嘉宾</strong>：jolestar</p>
<p><a href="https://www.bilibili.com/video/BV1R54y1b7qo?p=7">查看回放</a></p>
<hr />
<h3><a class="header" href="#rust-meetup-成都站" id="rust-meetup-成都站">Rust Meetup 成都站</a></h3>
<p><strong>时间</strong>: 2021/04/27</p>
<p><strong>地点</strong>：成都天府软件园</p>
<h4><a class="header" href="#p1-the-future-of-embedded-system-programming" id="p1-the-future-of-embedded-system-programming">【P1】 The Future of Embedded System Programming</a></h4>
<p><strong>嘉宾</strong>：张奕</p>
<p><a href="https://www.bilibili.com/video/BV1Y54y1j7za?p=1">查看回放</a></p>
<h4><a class="header" href="#p2-亚马逊教你轻松开发安全隔离的虚拟机" id="p2-亚马逊教你轻松开发安全隔离的虚拟机">【P2】 亚马逊教你轻松开发安全隔离的虚拟机</a></h4>
<p><strong>嘉宾</strong>：孙华</p>
<p><a href="https://www.bilibili.com/video/BV1Y54y1j7za?p=2">查看回放</a></p>
<h4><a class="header" href="#p3-从rust在金融系统的应用到通用事件门溯源模型" id="p3-从rust在金融系统的应用到通用事件门溯源模型">【P3】 从Rust在金融系统的应用到通用事件门溯源模型</a></h4>
<p><strong>嘉宾</strong>：张宇</p>
<p><a href="https://www.bilibili.com/video/BV1Y54y1j7za?p=3">查看回放</a></p>
<h4><a class="header" href="#p4-md5-编码器-live-coding" id="p4-md5-编码器-live-coding">【P4】 md5 编码器 live coding</a></h4>
<p><strong>嘉宾</strong>：吴翱翔</p>
<p><a href="https://www.bilibili.com/video/BV1Y54y1j7za?p=4">查看回放</a></p>
<h1><a class="header" href="#本月招聘" id="本月招聘">本月招聘</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#知乎搜索后端研发工程师" id="知乎搜索后端研发工程师">知乎：搜索后端研发工程师</a></h2>
<p><strong>岗位职责</strong></p>
<ol>
<li>负责知乎搜索业务的后端开发工作</li>
<li>负责知乎搜索服务在线系统架构建设，优化系统稳定性、性能和吞吐量</li>
<li>负责对应数据的索引建设及更新，优化索引数据的一致性及更新效率</li>
</ol>
<p><strong>任职要求</strong></p>
<ol>
<li>有扎实的编程能力，有良好的数据结构和算法基础</li>
<li>良好的团队合作精神，较强的沟通能力</li>
<li>熟悉 Linux 开发环境，熟悉 Go 语言，熟悉网络编程、多线程编程</li>
<li>熟悉搜索引擎，对 Elasticsearch、Kubernetes 有使用经验者优先</li>
<li>有高可靠分布式系统架构设计经验者优先</li>
<li>熟悉 Rust 语言优先</li>
</ol>
<p><strong>联系方式</strong></p>
<p>zl @ zhihu.com</p>
<hr />
<h2><a class="header" href="#蚂蚁集团" id="蚂蚁集团">蚂蚁集团：</a></h2>
<h3><a class="header" href="#蚂蚁集团系统安全开发工程师社招校招实习生均可" id="蚂蚁集团系统安全开发工程师社招校招实习生均可">蚂蚁集团：系统/安全开发工程师（社招/校招/实习生均可）</a></h3>
<p>蚂蚁集团安全计算团队致力于基于TEE、内核、虚拟化等技术为蚂蚁数据和业务打造安全计算环境。</p>
<p><strong>职位亮点</strong></p>
<ol>
<li>这里有领先业界的技术等你探索，也有业界少有的技术难题等你攻克；</li>
<li>这里有一帮技术大牛（知名开源项目创始人、顶级会议论文作者）等你来碰撞智慧的火花；</li>
<li>这是一个让技术梦想变成现实、用技术改变世界、让技术人快速成长的平台！</li>
</ol>
<p><strong>职位描述</strong></p>
<p>负责云环境下的高安全、高可靠的底层支撑软件和产品研发。本岗位P6/P7/P8/P9都有需求。</p>
<p><strong>职位要求</strong></p>
<ol>
<li>大学本科或以上学历，计算机及相关专业，三年以上相关工作经验；</li>
<li>对底层系统技术有比较深入的理解，有底层软件的开发经验；</li>
<li>熟悉C或C++编程，有Rust语言的经验优先；</li>
<li>对底层软件或安全技术有浓厚的兴趣，并具备快速学习的能力。</li>
</ol>
<p><strong>联系方式</strong></p>
<p>闫守孟，shoumeng.ysm@antgroup.com</p>
<h3><a class="header" href="#时序数据库研发工程师" id="时序数据库研发工程师">时序数据库研发工程师</a></h3>
<p><strong>岗位职责</strong></p>
<p>CeresDB 作为高性能、低成本并具有实时分析能力的新一代分布式时序数据库，已经应用在蚂蚁内部诸多场景中。我们面临着海量数据存储、访问和分析的技术挑战，急需对此方向感兴趣的朋友加入。</p>
<p>您将参与时序数据库 CeresDB 存储引擎的研发，包括但不限于：</p>
<ol>
<li>核心存储引擎的研发</li>
<li>存储与计算分离架构的研发</li>
<li>引擎层面对于实时计算和分析框架的研发</li>
<li>软硬件结合技术的探索和应用</li>
</ol>
<p><strong>任职要求</strong></p>
<ol>
<li>扎实的计算机基础，有良好的数据结构和算法基础。</li>
<li>掌握 C/C++/Rust/Go 语言中的至少一门，并有意愿学习和使用 Rust 语言。</li>
<li>熟悉 Linux 系统编程，有良好的编码习惯，追求卓越的工程实践，易于沟通，并具有持续学习的能力。</li>
<li>良好的团队合作精神，较强的沟通能力。</li>
<li>熟悉 Rust 语言优先，有过时序数据库研发经验优先。</li>
</ol>
<p><strong>联系方式</strong></p>
<p>jiachun.fjc@antgroup.com</p>
<hr />
<h2><a class="header" href="#飞书团队" id="飞书团队">飞书团队：</a></h2>
<h3><a class="header" href="#rust-开发工程师" id="rust-开发工程师">Rust 开发工程师</a></h3>
<p><strong>职位描述</strong></p>
<p>1、开发跨平台高性能native客户端核心组件；
2、负责沟通及创作工具的系统设计, 实现, 优化和演进； 
3、研究分析主流 IM，优化实现方案，改进产品功能； 
4、负责设计和优化 IM 协议、弱网通信、推送、存储、网络并发、并行计算、加密以及安全等； 
5、保证工程质量和开发效率。</p>
<p><strong>职位要求</strong></p>
<p>1、计算机相关专业，有较为扎实的计算机基础知识，深入理解数据结构、算法、网络和操作系统知识；
2、熟悉 C/C++，一年以上 Rust 开发经验，有实际 Rust 项目经验或 Rust 相关开源项目贡献经验优先；
3、对代码规范、性能和效率追求极致，乐于探索底层细节和实现原理；
4、认真负责，沟通高效，有良好的团队合作意识；
5、较强的学习能力，熟练阅读英文技术文档优先；</p>
<p><strong>联系方式</strong></p>
<p>wx: <code>newpants629</code>，或者直接在内推链接投递简历：<a href="https://job.toutiao.com/s/eB1j29f">https://job.toutiao.com/s/eB1j29f</a>。</p>
<hr />
<h2><a class="header" href="#pingcap" id="pingcap">PingCAP:</a></h2>
<h3><a class="header" href="#sql-引擎自动调优算法工程师" id="sql-引擎自动调优算法工程师">SQL 引擎自动调优算法工程师</a></h3>
<p><strong>工作职责</strong></p>
<ol>
<li>负责 TiDB 自动调优，提升 TiDB 在各种运行环境和工作负载下的使用体验，包括但不限于：优化器代价模型、执行引擎并发和资源管理、存储引擎缓存配置、事务隔离级别等的自动调优；</li>
<li>根据业务负载，给出业务优化建议，如增删索引、收集统计信息、调整集群拓扑等。</li>
</ol>
<p><strong>任职资格</strong></p>
<ol>
<li>具备数据库的设计与开发经验；</li>
<li>掌握常用算法和数据结构；</li>
<li>掌握至少一门编程语言，如：C/C++/Java/Go/Rust；</li>
<li>良好的分析与解决问题能力；</li>
<li>良好的沟通与协作能力；</li>
<li>良好的英文书面能力，能流畅阅读英文论文，用英文编写技术文档。</li>
</ol>
<p>加分项：</p>
<ol>
<li>具备云原生数据库自动调优经验；</li>
<li>有良好的英文口语能力，能流畅沟通交流。</li>
</ol>
<p><a href="https://careers.pingcap.com/apply/pingcap/39950/#/job/cbebd61d-0434-4fe4-9f9e-51fb3a446859">职位申请</a></p>
<p><strong>Infra研发工程师</strong></p>
<p>工作职责数据库存储了大量核心的商业数据，对正确性、可靠性要求非常高。开发一款数据库难，测试一款数据库也非常有挑战。TiDB 有大量的测试用例。如何管理、高效运行这些测试用例，对提升测试效率意义重大。</p>
<p>我们希望构建一套强大的测试平台和工具包，能高效利用资源自动化跑完测试，并反馈测试结果。同时为测试同事提供一套简单易用的开发包，帮助他们降低测试自动化的难度，提高测试效率。</p>
<p><strong>工作职责</strong></p>
<p>1.开发 TiDB 的测试基础设施，包括测试用例管理系统，测试用例运行系统以及测试资源管理系统，帮助测试同事管理、运行测试用例，并返回测试结果；
2.开发 TiDB 的系统测试平台，包括负载管理、资源隔离、错误检测、测试记录管理等功能；
3.开发和维护云上的测试基础设施，降低云上测试的复杂度，节约成本；
4.负责 DBaaS 业务的 API 测试、K8s operator 测试以及压力和稳定性测试；
5.分解上述平台软件需求，完成技术选型和技术设计，发布高质量的工具产品。</p>
<p><strong>任职资格</strong></p>
<p>1.热爱编程，希望自动化一切低效的工作；
2.掌握一门后端语言，理解该语言特性，golang、rust 更佳；
3.熟悉并实践过常用的数据结构、算法、协议；
4.有一定软件架构能力，了解微服务拆分，分布式架构设计及常用中间件；
5.具有良好的工程素养和较强的学习能力，认真负责，有较强的问题定位和推动能力；
6.熟悉 K8s 加分，深入理解分布式技术加分，对测试、软件质量有较高热情加分。</p>
<p><a href="https://careers.pingcap.com/apply/pingcap/39950/#/job/3728986e-918a-468a-a3f9-0b3fa98b9956">职位申请</a></p>
<hr />
<h2><a class="header" href="#octopus-network--rust工程师" id="octopus-network--rust工程师">Octopus Network ： Rust工程师</a></h2>
<p>Octopus Network 致力于将 Web3.0 分布式应用落地化，积极探索 Web3.0 与 Web2.0 的结合，带给用户与当前互联网同样或相似的使用体验。公司已获得数百万美元的VC投资。网址：https://oct.network。</p>
<p><strong>职责：</strong></p>
<ul>
<li>使用 Rust 构建一整套 Web3.0 技术栈</li>
<li>完善现有的开发框架</li>
<li>解决一些细节技术问题</li>
</ul>
<p><strong>要求：</strong></p>
<ul>
<li>有相当程度的 Rust 经验（1~3年经验）</li>
<li>对 Rust 的 crates 依赖机制、cargo 工具、编译选项等使用相当熟悉</li>
<li>对 Rust 的 no_std 编程有过研究</li>
<li>有网络编程、存储系统、密码学背景知识</li>
</ul>
<p><strong>加分项：</strong></p>
<ul>
<li>对 WebAssembly 的原理和实践有经验者优先</li>
<li>对 Blockchain 的原理和实践有经验者优先</li>
<li>英语听说写能力好者优先</li>
<li>对社区建设有经验，在Rust社区中有过贡献者优先</li>
<li>对知名 Rust 开源项目（包括但不仅限于密码学、p2p通信、blockchain、分布式存储等项目）有过贡献者优先</li>
<li>有加密领域实践经验者优先</li>
</ul>
<p><strong>工作形式：</strong></p>
<ul>
<li>全远程</li>
</ul>
<p><strong>待遇：</strong></p>
<p>同行业上等水平，100K$-150K$ total package, tax free。优质待遇诚邀优秀人才。</p>
<p><strong>联系：</strong></p>
<ul>
<li>Email：mike@oct.network</li>
<li>vx：daogangtang</li>
</ul>
<hr />
<h2><a class="header" href="#北京数牍科技" id="北京数牍科技">北京数牍科技：</a></h2>
<p><strong>Rust研发工程师</strong></p>
<p>北京 | 1- 5年</p>
<p>工作职责：
1、负责多方计算平台PaaS平台的设计、开发、测试和优化。
2、负责系统架构设计、优化，提升系统性能和开发效率。
3、负责技术预研和技术难点攻关，保障系统可用性、稳定性和可扩展性。
任职要求：
1、计算机相关专业本科及以上学历，具有两年以上Rust/C++开发经验。
2、严密的思维逻辑性，体系性的思考方式，良好的语言表达能力。
3、有从事分布式计算或存储的开发经验。</p>
<p><strong>Rust 算法工程师</strong>
北京 | 1- 5年
工作职责：
1、负责实现安全多方计算算法的实现。
2、负责实现多方机器学习算法的实现。
3、理解分布式架构下的多方安全计算场景，对算法进行分布式改造。
4、对现有算法进行持续的迭代、优化。
任职要求：
1、计算机相关专业本科及以上学历，具有两年以上Rust/C++开发经验。
2、严密的思维逻辑性，体系性的思考方式，良好的语言表达能力。
加分项：
3、具有机器学习算法的相关背景，特别是federated learning。
4、熟悉常见机器学习框架中的一种，例如scikit-learn、tensorflow。
5、有一定密码学算法基础，例如同态加密、不经意传输等。
6、有一定的英文阅读能力。</p>
<p>**联系方式 **</p>
<p>zhangkm @ sudoprivacy.com</p>
<hr />
<h2><a class="header" href="#上海吉利集团-数字科技板块招聘" id="上海吉利集团-数字科技板块招聘">【上海】吉利集团-数字科技板块招聘</a></h2>
<p>Base上海，工程师25-40k 架构师35-50k</p>
<p><strong>岗位职责：</strong></p>
<p>1.负责吸收海外先进的区块链原创技术，进行本地化改造及优化落地；</p>
<p>2.负责与国内合作伙伴进行区块链技术合作，支持区块链应用的场景落地；</p>
<p>3.负责区块链底层架构设计及关键技术选型、关键技术实现；</p>
<p>4.从事区块链及产品的设计和研发工作，研究区块链的协议，运行机制和底层实现以及核心代码开发；</p>
<p>5.搭建基于区块链的底层架构，能实现公链、侧链、私有链及多种逻辑，供应用层调度使用，直至提供云服务输出；</p>
<p>6.组织制定和实施技术决策和技术方案，组织架构设计与升级优化；</p>
<p>7.能够对虚拟机引擎(wasm、EVM、V8等)进行性能优化和改造</p>
<p><strong>任职要求：</strong></p>
<p>1.本科及以上学历，计算机、软件工程、数学或信息技术相关专业；3年以上工作经验；</p>
<p>2.精通Rust/C++/Haskell等开发语言中的一种或多种，具有良好的编程能力和编程习惯；</p>
<p>3.熟悉各种数据结构和算法，对密码学、安全协议和加密算法、数字签名、数字证书有研究；</p>
<p>4.熟悉Hyperledger Fabric、Ethereum、IPFS等相关开源项目中的一种或多种，有研究和贡献经验优先；</p>
<p>5.熟悉Linux、分布式、智能合约、共识机制和算法，有大型分布式系统研发经验，具备高性能、高可用、可扩展系统的体系化建设能力；</p>
<p>6.精通一种或几种主流数据库的原理与使用，包括传统关系型数据库和NoSQL等；</p>
<p>7.熟练应用软件工程和系统设计的能力，对计算机系统、网络通信、信息安全和应用系统架构等有全面的认识；</p>
<p>8.优秀的跨团队沟通能力和协作能力</p>
<p><strong>联系方式</strong></p>
<p>简历发送 Song.Shang@geely.com</p>
<p>微信: shangsongwww</p>
<hr />
<h3><a class="header" href="#上海息未信息科技-rust开发工程师" id="上海息未信息科技-rust开发工程师">上海息未信息科技： Rust开发工程师</a></h3>
<p>10-15K·13薪</p>
<p><strong>职位描述</strong></p>
<p>1、参与公司硬件终端业务系统开发工作，编写设计技术文档，核心代码开发，保证代码质量；
2、根据开发进度和任务分配，能够独立处理和完成任务；
3、分析并解决系统开发及运行维护过程中的问题，对系统性能进行调优；
4、参与业务需求讨论，参与技术方案的制定。参与系统架构设计与技术调研，并给出合理方案；</p>
<p><strong>岗位要求：</strong></p>
<p>1、计算机、软件、电子信息、通信等相关专业本科及以上学历，一年以上研发相关工作经验;
2、熟悉c++、rust开发经验优先;
3、能熟练使用设计模式，在工作中深刻理解和使用单元测试及重构的能力，
4、能独立完成中小型项目的系统分析、设计、架构，并主导完成详细设计和编码的任务，确保项目的进度和质量；
5、具备良好的沟通表达能力和学习能力、逻辑分析能力和问题解决能力，具有团队协作精神和追求卓越的精神。</p>
<p><strong>公司介绍</strong></p>
<p>上海息未信息科技有限公司专注于航天及航空训练装备的研发生产，是由国内顶级基金投资的科技企业，主要服务于中国航天、军队以及航空公司。员工数量在20人左右，同时具备机械结构设计、单片机开发、虚拟现实开发的能力。企业正处于高速上升期，具有非常好的成长空间。</p>
<ul>
<li><a href="https://www.zhipin.com/job_detail/db294e87806c4d8e1nZ43NS6FlBZ.html?ka=comp_joblist_4">Boss 直聘申请</a></li>
</ul>
<h1><a class="header" href="#论文鉴赏--使用-rust-进行安全系统编程" id="论文鉴赏--使用-rust-进行安全系统编程">论文鉴赏 | 使用 Rust 进行安全系统编程</a></h1>
<p>译者： <a href="https://github.com/MATRIXKOO">MATRIXKOO</a> / 编辑：张汉东</p>
<blockquote>
<p>论文原文： https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext#FNA</p>
</blockquote>
<blockquote>
<p>编者按：</p>
<p>该文章发布于 ACM通讯，2021年4月。</p>
<p>作者是 德国马克斯·普朗克软件系统研究所（Max Planck institute for sofetware system）的 Ralf Jung 等。Ralf Jung 同时也是 Rust 官方团队致力于改进 Miri 以提供 Unsafe Rust 中 UB 检查。同时 Rust 安全模型形式验证项目 Rust Belt 的发起者。</p>
</blockquote>
<hr />
<blockquote>
<p>关键观点</p>
</blockquote>
<ul>
<li>
<p>Rust 是第一个受行业支持的在高级语言带来的安全性和由较低级别的 <code>系统编程 (system programming)</code> 语言提供的资源管控之间做出长远平衡的语言。 </p>
</li>
<li>
<p>它以强大的类型系统解决了这一挑战，这种基于所有权和原则的类型系统静态地防止了共享状态的改变。这种方法使许多常见的系统编程的漏洞在编译时被检测到。 </p>
</li>
<li>
<p>有许多数据类型的实现从根本上取决于处于共享的可变状态，因此不能依靠 Rust 的严格要求进行类型检查所有权。为了支持这样的数据类型，Rust  明智的拥抱 <code>unsafe</code>,  使用 <code>safe</code> 的 API 封装在其中的 <code>unsafe</code> 代码。 </p>
</li>
<li>
<p>作为<code>RustBelt project</code> 的一部分， 健壮的 <code>semantic type</code> 证明技术，以及先进的 <code>separation logic</code> 和机器证明技术使得我们能够为 Rust 建立严格可靠的基础。</p>
</li>
</ul>
<blockquote>
<p>译者注: <code>RustBelt project</code>: https://plv.mpi-sws.org/rustbelt/#project</p>
<p>一个致力于用形式化证明来保证 Rust 安全性的项目</p>
</blockquote>
<hr />
<p>编程语言设计在两个看似不可调和的愿望之间长期存在着矛盾对立。</p>
<p>编程语言设计在两个看似不可调和的愿望之间长期存在着矛盾对立。</p>
<ul>
<li>安全 ( safe )。 我们想要强类型系统来排除静态地消除大量错误。 我们要自动内存管理。我们想要数据封装， 这样我们就可以对私有变量执行不变的对象的表示形式，并确保它们将不会被不受信任的代码破坏。 </li>
<li>控制 (control )。 至少对于 Web浏览器，操作系统，或游戏引擎这样的 <code>系统编程 (system programming)</code> 程序，约束它们性能或资源是一个重要的问题，我们想了解数据的字节级表示。 我们想要用<code>底层语言 (low-level programming)</code> 的编程技术优化我们程序的时间和空间的使用。 我们希望在需要时使用 <code>裸机</code> 。</li>
</ul>
<p>然而，按照传统的看法，鱼和熊掌不能兼得。 Java 之类的语言使我们极大的安全保证，但代价是牺牲对底层的控制。结果，对于许多系统编程应用程序，唯一现实的选择是使用一种像 C 或 C++ 提供细粒度的语言控制资源管理。 但是，获得这种控制需要很高的成本。例如，微软最近报告说，他们修复的 70％ 安全漏洞都归因于内存安全违规行为 <a href="chapter_4/safe_system.html#33">33</a>，并且都是能被强类型系统排除的问题。同样，Mozilla 报告指出，绝大多数关键 他们在Firefox中发现的错误是内存有关的<a href="chapter_4/safe_system.html#16">16 </a>。如果可以以某种方式两全其美: 安全系统编程的同时对底层有控制权...</p>
<p>键入 <strong>Rust</strong> 。由Mozilla赞助，并在过去十年中由众多不同的贡献者社区积极开发，Rust 支持许多从现代 C ++ 派生的常见的底层编程习惯用法和 API 。 但是，与C ++不同，Rust 通过强大的静态类型系统来强制安全地使用这些 API 。 </p>
<p>特别的，像 Java 一样，Rust 可以保护程序员免受内存安全性问题的侵害（例如，<code>use-after-free</code>的错误）。 但是 Rust 更进一步地捍卫程序员免受其他主流语言无法阻止的其他更隐蔽的异常现象的影响。 例如，考虑<em>数据竞争</em>：对共享内存的不同步访问（至少其中之一是写操作）。 即使数据争用有效地构成了并发代码的未定义（或弱定义）行为，大多数<code>安全</code>语言（例如 Java 和 Go ）都允许它们的存在，并且它们是并发错误的可靠来源<a href="chapter_4/safe_system.html#35">35</a>。与之不同的是，Rust 的类型系统在编译时就能探测到数据竞争。</p>
<p>Rust 一直在稳步普及，以至于现在许多主要的工业软件供应商（例如 Dropbox ，Facebook ，Amazon和 <code>Cloudflare</code> ）都在内部使用 Rust，并且 Rust 在 过去五年的 Stack Overflow 的 <code>最受欢迎的</code> 编程语言列表中排名第一。 微软的安全响应中心团队最近宣布，它正在积极探索对 Microsoft 使用 Rust 可能性，以减少系统软件中的安全漏洞。 <a href="chapter_4/safe_system.html#8">8</a>,<a href="chapter_4/safe_system.html#25">25</a></p>
<p>Rust 的设计深深地吸取了关于安全系统编程的学术研究的精髓。特别是，与其他主流语言相比，Rust 设计的最大特色在于采用了<em>所有权类型系统</em>（在学术文献中通常称为<em>仿射</em>或<em>子结构</em>类型系统<a href="chapter_4/safe_system.html#36">36</a>）。所有权类型系统通过限制对象的应用， 可用于在程序执行的任何给定点进行变异来帮助程序员实施较低级编程的安全模式。 但是，Rust 至少用两种新颖而令人兴奋的方式超越了先前工作的所有权类型系统：</p>
<ol>
<li>Rust采用了<code>借用 (borrowing)</code>和<code>生命周期(lifetime)</code>的机制，这使得表达常见的C ++风格的习惯用法变得容易得多，并确保了它们的安全使用。 </li>
<li>Rust还提供了丰富的 API 集（例如，用于并发抽象，高效的数据结构和内存管理），它们通过支持比 Rust 的核心类型系统更灵活的别名和突变组合，从根本上扩展了语言的功能。相应地，这些 API 不能在 Rust 的安全片段内实现：相反，它们在内部使用了该语言潜在的 <code>unsafe</code> C 风格的特性，是以一种声称不会干扰 Rust 的语言级别安全性保证的方式进行安全封装。 </li>
</ol>
<p>Rust 的设计的这些方面不仅对其成功至关重要，它们还提出了有关其语义和安全性保证的基本研究问题，从而使编程语言社区才刚刚开始探索。 在本文中，我们首先为读者提供了Rust 编程语言的鸟瞰图，重点介绍了 Rust 的一些基本功能，这些功能使它与同时代产品脱颖而出。其次，我们描述了 <code>RustBelt</code>初步进展，该项目是由欧洲研究委员会（ERC）资助的正在进行中的项目，其目的是为 Rust 的安全性主张提供第一个正式的（并经过机器检查的）基础。通过这个项目，我们希望激发计算机科学研究领域的其他成员开始更加关注 Rust ，并为这种突破性语言的发展做出贡献。 </p>
<h2><a class="header" href="#动机-c-中的无效指针" id="动机-c-中的无效指针">动机: C++ 中的无效指针</a></h2>
<p>为了演示在系统编程语言中常见的那种内存安全问题，让我们考虑一下</p>
<p><img src="https://dl.acm.org/cms/attachment/1f582f38-4371-4a65-af48-ac767ff53686/f1.jpg" alt="" /></p>
<p><strong>Figure 1. Use-after-free bug in C++ and how the bug is prevented in Rust.</strong></p>
<p>在第一行中，该程序创建一个整数的 <code>std::vector</code>（可增长数组）。 <code>v</code> 的初始内容（两个元素<code>10</code>和<code>11</code>）存储在内存中的缓冲区中。在第二行中，我们创建一个指向该缓冲区的指针 <code>vptr</code>。具体来说，它指向第二个元素（当前值为 <code>11</code> ）的存储位置。现在，<code>v</code> 和  <code>vptr</code> 都指向同一个缓冲区（重叠的部分）。我们说这两个指针是 <code>混叠</code> 的。在第三行中，我们将新元素 <code>push</code> 到 <code>v</code> 的末尾。在缓冲区<code>v</code>中，将元素<code>12</code> 添加到<code>11</code>之后。如果没有更多空间可容纳其他元素，将分配一个新的缓冲区，并将所有现有元素移到上方。让我们假设这就是这里发生的情况。为什么这种情况很有趣？因为<code>vptr</code>仍然指向旧缓冲区。换句话说，在<code>v</code>中添加一个新元素已经将<code>vptr</code>变成了悬空的指针。这是可能的，因为两个指针都是引用：通过指针（<code>v</code>）进行的操作通常也会影响其所有引用（<code>vptr</code>）。 [图1]可视化了整个情况。</p>
<p><code>vptr</code> 现在是一个悬空指针，在第四行中存在一个问题。在这里，我们从<code>vptr</code> 解引用，并且由于它是一个悬空指针，所以这是一个 <code>use-after-free</code> 错误。 </p>
<p>实际上，这种问题很普遍，以至于它的一个实例拥有自己的名称：<em>迭代器无效</em>，这是指迭代器（通常在内部用指针实现）无效的情况，因为迭代所遍历的数据结构是可变的在迭代过程中。最常见的情况是在一个循环中遍历某个容器数据结构，然后间接但偶然地调用一个使数据结构发生突变的操作。注意，实际上，对改变数据结构的操作的调用（在我们的示例的第3行中为<code> push_back</code>）可能深深地嵌套在几层抽象的后面。特别是当重构代码或添加新功能时，通常几乎无法确定是否推送到某个 <code>vector</code>是否会使程序中其他位置的指针失效，不存在 <code>use-after-free</code>。 </p>
<p>**与垃圾回收语言进行比较。**诸如Java ，Go 和 OCaml 之类的语言可避免使用垃圾回收的使用后释放的错误：仅当程序无法使用内存时才释放内存。因此，不能有悬空的指针，也不没有<code>use-after-free</code>。 垃圾回收存在的问题是，为了提高效率，此类语言通常不允许<em>内部</em> 指针（即，指针放入数据结构）。例如，Java中的数组<code> int []</code> 的表示方式类似于 C++ 中的 <code>std::vector &lt;int&gt;</code>（Java中的数组不能增长）。但是，与C ++不同，一个Java数组只能<code>获取</code>和 <code>设置</code>元素，而不能对其进行<code>引用</code>。为了使元素本身可寻址，它们必须是单独的对象，然后可以将对它们的引用存储在数组中--也就是说，需要将元素<code>装箱</code>。为了安全，牺牲了性能和对存储器布局的控制。 最重要的是，垃圾回收甚至不能正确解决迭代器无效的问题。在Java中遍历集合时对其进行改变不会导致指针悬空，但可能会导致在运行时抛出 <code>ConcurrentModificationException</code> 。类似地，尽管 Java 确实防止了由于空指针滥用引起的安全漏洞，但它通过引发 <code>空指针异常 (NullPointerException)</code> 的运行时检查来做到这一点。在这两种情况下，其结果显然都比 C++程序的相应未定义行为更好。这仍然有很多不足之处：我们希望从一开始(编译期)就防止错误发生，而不是交付不正确的代码然后在运行时才检测到问题。 </p>
<p><strong>Rust解决指针无效的方法</strong>。在 Rust 中，编译器会静态检测到迭代器无效和空指针滥用等问题，它们会导致编译时错误，而不是运行时异常。为了解释它是如何工作的，请在[图1]底部参考我们C ++示例的 Rust转换。 像在 C++ 版本中一样，内存中有一个缓冲区，而 <code>vptr</code> 指向该缓冲区的中间（导致引用）； <code>push</code>可能会重新分配缓冲区，这导致 <code>vptr</code> 变成悬空的指针，并导致第4行中的 use-after-free。 </p>
<p>但是这一切都没有发生。相反，编译器显示错误：<code>一次不能多次借用 (borrowing) 可变的变量v</code> 我们将很快回到<code>借用 (borrowing)</code>，但是关键思想（Rust 通过这种机制在存在指向数据结构的指针的情况下实现内存安全的机制）已经在这里变得显而易见：类型系统强制执行该规则（我们将在以后介绍）不会有多个可变引用。在并发的上下文中，这个原理听起来应该很熟悉，并且 Rust 确实使用这个方法来确保不存在数据竞争。但是，正如我们被 Rust 编译器拒绝的示例所示，引用和可变性的不受限制的组合即使对于顺序程序也是造成灾难的原因：在第3行中，<code>vptr</code>和<code>v</code>引用（<code>v</code>被认为是指向它的所有内容，与<code>vptr</code> 重叠），我们正在使用一个可变引用，这将导致第4行出现的内存访问错误。 </p>
<h2><a class="header" href="#所有权和借用-borrowing" id="所有权和借用-borrowing">所有权和借用 (borrowing)</a></h2>
<p>Rust防止不可控制的引用的核心机制是<em>所有权</em>。 Rust 中的内存始终具有唯一的所有者，如示例2中所示。 </p>
<p><img src="https://dl.acm.org/cms/attachment/4d8b8636-fbe9-4742-a47b-e29c462cf6d0/f2.jpg" alt="" /></p>
<p><strong>Figure 2. Rust example: Moving ownership.</strong></p>
<p>在这里，我们构造与第一个示例类似的 <code>v</code> ，然后将其传递给<code> consume</code>。在操作上，就像在C ++中一样，参数是按值传递的，但是副本是浅复制的—指针被复制，但它们的指针不会重复。这意味着<code> v</code>和<code> w</code>指向内存中的相同缓冲区。 </p>
<p>如果程序同时使用 <code>v</code> 和 <code>w</code> 两者就会出现这个问题，但是在第6行尝试这样做的时候会导致编译时错误。这是因为 Rust 认为  <code>v</code> 的所有权作为调用的一部分已经移动到 <code>consume</code> 上，这意味着 <code>consume</code> 可以用 <code>w</code> 来做任何想要的事情，并且调用者可能不再访问这个 <code>Vec</code> 的内存。 </p>
<p><strong>资源管理。</strong> Rust的所有权不仅可以防止内存错误，而且还构成了 Rust 的内存管理方法（更广泛地说，是资源管理的核心。当拥有内存的变量（例如，Vector 的内存中的缓冲区的 <code>Vec &lt;T&gt;</code>类型的变量）超出作用域的时候，我们可以确定不再需要该内存了，因此编译器可以在那时自动释放内存。为此，就像在C++中一样，编译器透明地插入<em>destructor</em> 调用。例如，在 <code>consume </code>函数中，实际上没有必要显式调用析构函数方法（<code>drop</code>）。我们可以将该函数的主体保留为空，并且它将自身自动释放<code> w</code>。 </p>
<p>因此，Rust程序员几乎不必担心内存管理：尽管缺少垃圾收集器，但它基本上是自动的。此外，内存管理也是 <code>静态的</code>（在编译时确定）这一事实产生了极大的好处：它不仅有助于降低最大的内存消耗，而且还可以在反应式系统中(例如 web 服务器 )提供良好的 <code>最坏情况</code> 的 <code>latency</code> 。最重要的是，Rust 的方法超出了内存管理的范围：文件描述符，套接字，锁，句柄等其他资源都使用相同的机制处理，因此Rust程序员不必担心关闭文件或释放锁。C++以 RAII（资源获取即初始化）的形式为使用析构函数进行自动资源管理的方式开了先河； <a href="chapter_4/safe_system.html#31">31</a> Rust 中的主要区别在于类型系统可以静态地确保资源在销毁后不再使用。 </p>
<hr />
<p>**可变的引用。**严格的所有权准则既令人愉悦又简单，但是使用起来并不方便。通常，人们想 <em>暂时</em> 地向某个函数提供数据，在函数允许之后后将其返回。例如，我们希望<code>v.push（12）</code> 赋予 <code>push</code> 来使 <code>v</code>改变的特权，但是我们不希望它<code>consume</code> vector <code>v</code>。 </p>
<p>在Rust 中，这是通过 <em>借用 (borrowing)</em> 实现的，它从 <em>region types</em> 的先前工作中获得了很多启发。<a href="chapter_4/safe_system.html#13">13</a>,<a href="chapter_4/safe_system.html#34">34</a></p>
<p>函数<code>add_ something</code>接受类型为 <code>＆mut Vec&lt;i32&gt;</code>的参数，该参数表示对<code>Vec&lt;i32&gt;</code>的 <code>可变引用</code> 。在操作上，这就像C ++中的引用一样，即 <code>Vec</code>通过引用传递。 在类型系统中，这被解释为向自调用者的<code>Vec</code>的<code>add_something</code> <em>借用 (borrowing)</em> 所有权。 </p>
<p><a href="https://dl.acm.org/cms/attachment/8f380ed9-5373-457c-ad22-ca28804ed776/f3.jpg"><img src="https://dl.acm.org/cms/attachment/8f380ed9-5373-457c-ad22-ca28804ed776/f3.jpg" alt="f3.jpg" /></a></p>
<p><strong>Figure 3. Rust example: Mutable references.</strong></p>
<p>函数 <code> add_something</code> 展示了格式化过的借用 (borrowing)看起来是什么样子。 为了搞清楚为什么编译器在拒绝前面的指针无效示例，而这段代码却可以通过，我们必须引入另一个概念：<em>lifetimes</em>。 就像在现实生活中一样，借用 (borrowing)某物时，可以通过事先就可以借用 (borrowing)多久达成共识，来防止误解。 因此，当创建引用时，会为其分配一个生存期，并以完整的引用类型形式记录下来：<code>＆'a mut T</code>表示生存期<code> 'a</code>。编译器会确保引用（<code> v</code>， 在我们的示例中）仅在该生命周期内被使用，并且直到生命周期结束，引用对象才被再次使用。</p>
<p>在我们的例子中，生存期（全部由编译器推断）分别持续到 <code>add_something</code> 和 <code>Vec::push</code> 结束。 在之前借用 (borrowing)的生命周期尚未结束之前，<code>v</code>不会被使用。</p>
<p>相比之下，[图4] 显示了从[图1]推断出的上一个示例的生命周期。<code>vptr</code> 借用 (borrowing)生命周期的<code>'a</code> 从第2行开始，一直持续到第4行。<code>vptr</code> 因为在第4行中被使用了，因此不能变得更短了。这意味着在第3行中，<code>v</code>  使用了借出的 ，这是错误的。 </p>
<p><img src="https://dl.acm.org/cms/attachment/e1a6ee8d-bc5e-458f-8b3d-7ade88032266/f4.jpg" alt="f4.jpg" /></p>
<p><strong>Figure 4. Use-after-free example with inferred reference lifetime.</strong></p>
<p>总结一下：每当通过值传递某些东西时（如在 <code>consume</code> 中），Rust 会将其解释为所有权转移。 当某些变量引用传递时（如在 <code>add_something</code> 中），Rust 将此解释为在特定生命周期内借用 (borrowing)。</p>
<hr />
<p>**共享引用 (shared reference)。**遵循我们可以可变引用不可共享的原则，可变引用是 <code>unique pointers</code>：它们不允许引用。 为了完善这种规则，Rust 提供了第二种引用，称为 <code>共享引用 (shared reference)</code> ，写为<code>&amp;Vec&lt;i32&gt;</code>或 <code>＆'a Vec &lt;i32&gt;</code> ，允许多个引用但不能改变。 共享引用 (shared reference)的一种主要用例是在多个线程之间共享只读数据，如图5所示。</p>
<p><img src="https://dl.acm.org/cms/attachment/7d2a2da7-ce35-4321-a112-3d4eb716939e/f5.jpg" alt="f5.jpg" /></p>
<p><strong>Figure 5. Rust example: Shared references.</strong></p>
<p>在这里，我们创建一个共享引用 (shared reference) <code>vptr</code> ，指向（并借用 (borrowing)）<code> v [1]</code>。此处的竖线表示不带任何参数的 <em>closure</em>（有时也称为匿名函数或 <code> lambda</code> ）。这些闭包被传递给 <code>join</code> ，这是 Rust 版本的 <code>并行组合</code>( <code>parallel composition</code> )：它需要两个闭包，并行地运行两个闭包，等待两个闭包完成，然后返回两个结果。当<code>join</code>返回时，借用 (borrowing)结束，因此我们可以再次对<code>v</code> 进行修改。 </p>
<p>就像可变引用一样，共享引用 (shared reference)也存在着生命周期。深入代码背后，Rust 的编译器使用生命周期来跟踪两个线程之间临时共享 <code> v</code> 的时间。在生存期结束后（第5行），<code>v</code>的原始所有者重新获得了完全控制权。此处的主要区别在于，允许多个共享引用 (shared reference)在同一生存期内共存，只要它们仅用于 <code>读取</code>  而不是用于 <code>写入</code> 即可。将示例中的两个线程之一更改为<code>||v.push(12)</code>，就可以看到这条规则的实现: 编译器会给出一条错误，告诉我们不能同时具有可变引用和对 <code>Vec</code> 的共享引用 (shared reference)。的确，该程序在读取线程和<code> v.push(12)</code> 的线程之间存在致命的数据争用，因此，编译器能静态的检测到此类情况是很重要的。 </p>
<p>共享引用 (shared reference)在顺序执行的代码中也很有用；例如，在对 <code>vec</code> 用 <code>shared iterator</code> 进行遍历时，我们仍然可以传一个 <code>vec</code> 共享引用 (shared reference)到其他函数里。但是在本文中，我们将重点讨论为实现并发而使用共享引用 (shared reference)。 </p>
<hr />
<p>**总结。**为了获得安全性，Rust 类型系统强制执行以下原则：共享不可变，可变不共享。拥有 <code>T</code> 类型的值意味着变量完全 <code>拥有</code> 它。可以用可变引用（<code>&amp;mut T</code>）或共享引用 (shared reference)（<code>&amp;T</code>) 去对 <code>T</code> 进行引用。 </p>
<h2><a class="header" href="#用-safe-api-放宽-rust-的严格所有权规则" id="用-safe-api-放宽-rust-的严格所有权规则">用 <code>safe</code> API 放宽 Rust 的严格所有权规则</a></h2>
<p>Rust的核心所有权原则具有足够的灵活性，可以解决许多底层编程的习惯用法。但是对于实现某些数据结构而言，它可能过于严格。例如，引用态无法被更改，就不可能实现双向链接列表，因为每个节点都被其下一个和上一个节点引用 。</p>
<p>Rust 对这个问题采取了一种不寻常的方法。比起允许其类型系统复杂化以解决不遵守该数据类型的数据结构实现，或者引入动态检查来在运行时强制执行安全检查，Rust 允许通过开发 <em><code>safe</code> 的API</em> 来放宽其所有权准则-API通过安全地控制引用的可变状态的使用来扩展语言的表达能力。尽管这些 API 的实现不遵循 Rust 严格的所有权原则（我们将在后面再讲），但 API 本身却严格利用了 Rust 的所有权和借用 (borrowing)机制以确保它们整体上保持 Rust 一致的的安全性。现在让我们看几个例子。 </p>
<hr />
<p><strong>共享可变状态</strong>  Rust 的共享引用 (shared reference)允许多个线程同时读取共享数据。 但是仅 <em>读取</em> 数据的线程只是事情的一半，接下来我们将看到 <code>Mutex</code> API 如何是实现跨线程安全地共享可变 <code>mutable</code> 状态。 乍一看，这似乎与我们到目前为止对 Rust 的安全性所说的一切相矛盾：Rust 的所有权准则要点不是要 <code>防止</code> 共享状态的改变吗？ 的确，但是我们将看到如何使用<code>Mutex</code> 充分限制这种改变，以免破坏内存或线程安全。 现在来看图6。</p>
<p><img src="https://dl.acm.org/cms/attachment/a2dd9c19-b0b2-400b-bf41-0f73aa941100/f6.jpg" alt="f6.jpg" /></p>
<p><strong>Figure 6. Rust example: Shared mutable state.</strong></p>
<p>我们再次使用结构化并发和共享引用 (shared reference)，但是现在将 <code>vec</code> 包装在 <code>Mutex</code> 中：变量 <code>mutex_v</code> 的类型为<code> Mutex&lt;Vec&lt;i32&gt;&gt;</code>。<code> Mutex</code> 的的关键操作是<code> lock</code>。它将一直阻塞直到获得独占锁为止。当变量超出范围时，锁将由 <code>v</code> 的析构函数隐式释放。最终，如果第一个线程设法先获取锁，则该程序将打印<code> [10,11,12]</code>，如果第二个线程则获取到了， 就会打印<code> [10，11]</code>。 </p>
<p>为了弄清楚示例程序的类型检查方式，让我们仔细研究一下<code>lock</code>。它（差不多（实际类型是 被<code>LockResult&lt;…&gt;</code> 包装起来的类型，这也是为什么使用了  <code>unwrap</code> ）的类型为 <code>fn（&amp;'a Mutex &lt;T&gt;)-&gt; MutexGuard &lt;'a，T&gt;</code> 可以使用对互斥锁的共享引用 (shared reference)来调用，这就是 Rust 允许我们在两个线程上调用锁定的原因：两个闭包都捕获<code>&amp;Mutex&lt;Vec&lt;i32&gt;&gt;</code>，并与<code>&amp;i32</code>类型的 <code>vptr</code> 一样，在我们的第一个并发示例中，两个线程可以同时使用该引用。实际上，<code>lock</code> 获取一个共享而不是可变的引用是至关重要的；否则，两个线程将无法尝试同时获取该锁，并且一开始就不需要锁。 </p>
<p><code>lock</code> 的返回类型，即 <code>MutexGuard &lt;'a，T&gt;</code>，基本上与<code>＆'a mut T'</code> 相同：它给予对存储在锁中的<code>T</code> 的独占访问权限。此外，当超出范围时，它会自动释放锁（在 C++世界中被称为RAII <a href="chapter_4/safe_system.html#33">33</a>）。 </p>
<p>在我们的示例中，这意味着两个线程 <em>临时</em> 都具有对该 <code>vec</code>  的独占访问权，并且它们都有可变引用，这说明了一个事实-由于锁正确地实现了互斥，因此它们永远不会同时具有可变引用，因此保持了可变引用的唯一性。换句话说，<code>Mutex</code> 可以安全地提供引用状态的改变，因为它实现了运行时检查，确保不会在改变时产生可变引用。</p>
<hr />
<p><strong>可变计数</strong> 我们已经看到，共享引用 (shared reference)提供了一种在程序中不同部分方之间共享数据的方法。但是，共享引用 (shared reference)具有 <code>静态确定</code> 的生存期，并且当该生存期结束时，数据将再次被唯一拥有。这与结构化并行机制（如上一示例中的 <code> join</code> ）配合得很好，但不适用于 <code>非结构化</code> 的并行机制，在这种情况下，会产生独立运行于父进程的进程。 </p>
<p>在 Rust 中，在这种情况下共享数据的典型方法是使用 <code>原子引用计数</code> 指针：<code> Arc&lt;T&gt;</code> 是指向 <code>T</code> 的指针，它会计算存在多少指向<code>T</code> 的指针，并当最后一个指针销毁时 (引用计数归零) 释放 <code>T</code>（并释放其相关资源）。（这可以看作是轻量级实现垃圾回收的一种形式）由于数据是共享的，因此我们无法从<code>Arc&lt;T&gt;</code>中获取<code>&amp;mut T</code>，但是我们可以获得<code>&amp;T</code>。 （在这种情况下，编译器确保在引用生存期内不会破坏 <code>Arc&lt;T&gt;</code>）</p>
<p><img src="https://dl.acm.org/cms/attachment/be6b6fee-b9f0-40b3-af33-55264c275aae/f7.jpg" alt="f7.jpg" /></p>
<p><strong>Figure 7. Rust example: Reference counting.</strong></p>
<p>我们首先创建一个指向我们通常 <code>vec</code> 的 <code> Arc</code> 。 <code>arc_v2</code>是通过<code>clone arc_v1</code>获得的，这意味着引用计数增加了一个，但是数据本身不会增加。 然后我们起一个使用 <code>arc_v2</code> 的线程； 即使我们在此编写的函数返回后，这个线程仍在后台运行。 因为这是非结构化的并行，所以我们必须显式地将<code> arc_v2</code> 移动（即转移其所有权）到另一个线程中运行的闭包中。 <code> Arc</code> 是一个 <code>智能指针</code>（类似于C ++中的<code> shared_ptr</code>），因此我们可以像使用<code>&amp;Vec&lt;i32&gt;</code> 一样使用它。尤其是在第3行和第4行中，我们可以打印出索引为1 的元素的值。当 <code>arc_v1</code> 和<code>arc_v2</code> 超出作用域时，它们的析构函数将被隐式调用，最后 <code>Arc</code> 会销毁 <code>vec</code> 。 </p>
<hr />
<p><strong>线程安全</strong> </p>
<p>在这个关于 Rust 的简短介绍中 ，<code>Rc &lt;T&gt;</code> 是我们最后一个要谈论的类型。 <code>Rc &lt;T&gt;</code> 是一个引用计数类型，它与 <code>Arc &lt;T&gt;</code> 非常相似，但是关键区别在于<code>Arc &lt; T&gt;</code> 使用原子 （获取和添加指令）来更新引用计数，而 <code>Rc &lt;T&gt;</code> 使用非原子操作。结果，<code>Rc &lt;T&gt;</code>可能更快，但不是线程安全的。 <code> Rc&lt;T&gt;</code> 类型在复杂的顺序执行的代码中很有用，在这种情况下，共享引用 (shared reference)的强制执行的静态作用域不够灵活，或者无法静态预测对对象的最后一个引用被销毁的时间，对象无法在应该被回收时被销毁。 </p>
<p>由于<code>Rc&lt;T&gt;</code>不是线程安全的，因此我们需要确保程序员在应该使用 <code>Arc&lt;T&gt;</code> 时不要混用使用<code>Rc&lt;T&gt;</code>。这很重要：如果我们采用我们前面的 <code>Arc</code> 示例，并用 <code>Rc</code> 替换了所有<code>Arc</code>，这样程序就会产生数据竞争，可能会过早分配内存或根本不分配内存。但是，非常值得注意的是，Rust 编译器依然能够捕获这种错误。 Rust 使用了一种叫做<code>Send</code> 的 trait ：这是一种类型的属性，只有当类型 <code>T</code> 的元素可以安全地发送到另一个线程时，类型 <code>T</code> 才能使用它。类型<code>Arc &lt;T&gt;</code>是 <code>Send</code> 的，但是<code>Rc&lt;T&gt;</code> 不是。 <code>join</code> 和<code>spawn</code>都要求它们运行的闭包捕获的所有内容都具有 <code>Send</code> ，因此，如果我们在闭包中捕获非<code>Send</code> 类型的 <code>Rc &lt;T&gt;</code> 的变量，将导致编译失败。 </p>
<p>Rust对 <code>Send</code> 的使用证明了强静态类型的限制有时会有更强大的表现力。与 C++ 的智能引用计数指针 <code>std::shared_ptr</code> 更是如此，因为 <code>std::shared_ptr</code> 使用了原子指令。（更准确地说，在Linux上，如果程序使用 <code>pthreads</code>，它使用的任何代码可能产生线程，就会使用原子指令。 ），因为具有更有效的非线程安全变体（如<code>Rc</code> ）被认为过于冒险。相比之下，Rust的<code>send</code> 允许人们 <code>无畏编码</code> ： <a href="chapter_4/safe_system.html#26">26</a>），Rust 是一种将线程安全的数据结构（例如 <code>Arc</code>）和非线程安全的数据结构（例如<code>Rc</code>）同时包含在中的语言，同时以模块化的方式确保不会错误地使用两者。 </p>
<h2><a class="header" href="#安全封装-unsafe" id="安全封装-unsafe">安全封装 <code>unsafe</code></a></h2>
<p>我们已经看到了诸如 <code>Arc</code> 和 <code>Mutex</code> 这样的类型如何使 Rust 程序 安全地使用诸如引用计数和共享引用 (shared reference)之类。但是，这有一个问题：这些类型实际上不能在 Rust 中实现。或更确切地说，它们不能在 <em><code>safe Rust </code></em> 中实现：编译器会因为可能违反引用规则而拒绝执行 <code>Arc</code> 。实际上，它甚至会拒绝使用 <code>Vec</code> 来访问可能未初始化的内存。出于效率原因，<code>Vec</code> 手动管理底层缓冲区并跟踪其初始化部分。当然，<code> Arc</code> 的实现实际上并没有违反引用规则，而 <code>Vec</code> 实际上并没有访问未初始化的内存，但是这些推断对于编译器来说太过于细微了。</p>
<p>为了解决这个问题，Rust 提供了一个 <code>后门</code> ：Rust 不仅包含我们到目前为止讨论的安 <code> Safe Rust</code>，而且还提供了一些 <code>unsafe</code> 功能，例如 C 风格的非受限指针。编译器不能保证这些功能的安全性（内存安全性和/或线程安全性），因此它们仅在标记有 <code>unsafe</code> 关键字的语法块内可用。这样，可以确保不会 <em>偶然</em> 离开 <code>Safe Rust</code>。</p>
<blockquote>
<p><em>我们希望激发计算机科学研究领域的其他成员开始更加关注Rust，并为这种突破性语言的发展做出贡献。</em> </p>
</blockquote>
<hr />
<p>例如，<code>Arc</code> 的实现使用 <code>unsafe</code> 来实现在 <code>Safe Rust</code> 中无法表达的模式：没有明确所有者的共享引用 (shared reference)，由线程安全引用计数进行管理。 对<code>弱(weak)引用</code>的支持使情况更加复杂：<code>弱引用</code> 不能使引用对象保持存活，但可以通过原子方式检查其有效性，并升级为完整的<code>Arc</code> 。 Rust编译器根本无法静态验证当引用计数达到零时释放内存实际上是安全的。 </p>
<hr />
<p><strong><code>unsafe</code> 块的替代品</strong> 可以将 <code>Arc</code> 或<code>Vec</code> 之类的东西转换到语言层面。例如，Python 和 Swift 具有内置的引用计数，Python 具有与 <code>Vec</code> 等效的内置的 <code>list</code>。但是，这些语言功能是在 C 或 C++中实现的，因此它们实际上没有比 <code>unsafe Rust</code> 实现更安全。除此之外，将不安全的操作限制为语言内置的实现还严重限制了灵活性。例如，Firefox 使用 Rust 库实现了 <code>Arc</code> 的变体，但不支持弱引用，从而提高了代码的空间使用率和性能。语言是否应该为任何内置类型的设计空间中的每个可能的位置提供原语？ </p>
<p>避免 <code>unsafe</code> 另一种选择是使类型系统具有足够的表达力，以实际能够验证诸如 <code> Arc</code> 之类的类型的安全性。但是，由于此类数据结构的安全性的可能性很小（实际上是 <code> Arc</code> 和简化的变体，其中一些已被用作最近几份正式验证论文中的主要案例研究<a href="chapter_4/safe_system.html#9">9</a>,[12],(#12)，<a href="chapter_4/safe_system.html#18">18</a>，但这基本上只能被有形式的通用定理证明经历和具有足够背景知识的研究人员使用。开发者和种定理证明社区还有很大的距离。</p>
<hr />
<p><strong>安全抽象</strong> 相反，Rust选择允许程序员在必要时灵活地编写不安全的代码，尽管期望它应该被  <code>safe</code> 的 API 封装。安全封装意味着，无论使用诸如 <code>Arc</code> 或 <code>Vec</code>  之类的 Rust API 都是通过 <code>unsafe</code> 代码实现的，这些 API 的用户都不会受到影响：只要用户在 <code>safe</code> 片段中编写类型正确的代码，由于 Rust 在 API 的实现中使用了不安全的代码，他们永远都观察不到异常行为。这与 C++ 形成鲜明对比，C++的弱类型系统缺乏甚至无法强制 <code>安全使用</code> API 的能力。结果，像<code>shared_ptr</code> 或 <code>vector</code> 之类的 C++ API 容易被滥用，导致引用计数错误和迭代器无效，这些错误在Rust中都不会出现。 </p>
<p>编写不安全代码的能力就像 Rust 程序员用来使类型系统更有用而又不会将其变成定理证明器的杠杆一样，我们确信这是 Rust 成功的关键。 Rust 社区正在开发一个有着安全可用的高性能库的生态系统，让程序员可以在它们之上构建安全而高效的应用程序。 </p>
<p>但是，当然天下没有免费的午餐：Rust 库的作者必须以某种方式确保，他们会非常谨慎，在使用 <code>unsafe</code> 的时候不会破坏 Rust 的安全保证。一方面，这比C/C++ 要好得多，因为绝大多数 Rust代码 是用该语言的 <code>safe</code> 编写的，因此 Rust 的 <code>攻击面</code> 要小得多。另一方面，当 <code>unsafe</code>  变得不可或缺的时候，程序员知道自己是否足够 <code>谨慎</code> 远非显而易见。</p>
<p>因此，为了保持对 Rust 生态系统安全性的信心，我们真心希望有一种形式化的方法，可以正式的验证使用安全地封装在安全API 的 <code>unsafe</code> 的背后的行为。 这正是<code> RustBelt</code> 项目的目标。</p>
<h3><a class="header" href="#rustbelt-rust-基础设施的保卫者" id="rustbelt-rust-基础设施的保卫者">RustBelt: Rust 基础设施的保卫者</a></h3>
<p>验证 Rust 的安全性的主要挑战是考虑 <code>safe</code> 与 <code>unsafe</code> 之间的相互作用。 要了解为什么这具有挑战性，让我们简要地看一下验证编程语言安全性的标准技术，即所谓的<em>syntactic approach</em> 。<a href="chapter_4/safe_system.html#14">14</a>，<a href="chapter_4/safe_system.html#37">37</a> 使用该技术，安全性是由基于大量数学推导给出正式结构的类型检查器的  <em>syntactic typing judgment</em> 来表示的。 </p>
<hr />
<p><strong>Theorem 1</strong>*( <em>Syntactic type soundness</em> ) 如果程序 e 在 <em>syntactic typing judgment</em> 后是 <code>well-typed</code> 的，则 e 是安全的。 </p>
<blockquote>
<p>well-typed 参见 <a href="https://en.wikipedia.org/wiki/Type_safety">Type safety</a></p>
</blockquote>
<p>不幸的是，这个定理对于我们的目的来说太弱了，因为它仅在语法上谈论安全程序，从而排除了使用 <code>不安全</code>代码的程序。 例如，<code>if true {e} else {crash（）}</code> 在语法上不是 <code>well-typed</code>，但由于从未执行<code>crash（）</code>，所以它仍然是安全的。 </p>
<hr />
<p><strong>解决方案: <em>Semantic type soundness</em>.</strong></p>
<blockquote>
<p><a href="https://blog.sigplan.org/tag/semantic-type-soundness/">Semantic type soundness</a> </p>
</blockquote>
<p>为了说明 <code>safe</code> 与 <code>unsafe</code> 之间的相互作用，我们改用称为 <em>Semantic type soundness</em> 的技术，该技术根据程序的<code>行为</code>来表示安全性，而不是使用固定的推理规则集。 <em>Semantic type soundness</em> 的关键要素是 <em>logical relation(逻辑关系)</em>，该逻辑关系为每个 API 分配了 <em>safety contract</em>   。 它表示如果API 中每个方法的输入均符合其指定的类型，则输出也是如此。使用形式验证中的技术，可以证明 API 的实现满足指定的 <em>safety contract</em> ，如[图8]。</p>
<p><img src="https://dl.acm.org/cms/attachment/2c46d078-5266-431c-96b0-80fd8eee1c18/f8.jpg" alt="f8.jpg" /></p>
<p><strong>Figure 8. Semantic type soundness.</strong></p>
<p>对于 <code>safe</code> 与 <code>unsafe</code> 组合的程序进行推理， <em>Semantic type soundness</em> 是理想的选择。 对于任何使用 <code>unsafe</code> 代码块的库（例如<code> Arc Mutex Rc 和 Vec</code>），都必须手动证明该实现满足 <em>safety contract</em> 。 例如： </p>
<p><strong>Theorem 2.</strong> <em>Arc satisfies its safety contract</em>.</p>
<p>对于程序的 <code>safe</code> 代码块，验证是自动的。 以下定理表达了这一点，该定理说，如果将组件写入 Rust 的 <code>safe</code> 代码块中，则它通过构造满足其 <em>safety contract</em>。 </p>
<p><strong>Theorem 3</strong> (Fundamental theorem). <em>如果 组件 e 在语法上是 <code>well-typed</code>的 ，则 e 满足 safety contract</em>。</p>
<p>综上所述，如果“<code>unsafe</code> 的只出现是在经过手动验证可以满足 <em>safety contract</em> 的库中，则这表示 Rust 程序是安全的。 </p>
<p>**使用 <a href="https://iris-project.org/">Iris logic</a> 来解码 <em>safety contract</em>  ** <em>Semantic type soundness</em> 是一种古老的技术，至少可以追溯到米尔纳（1978年）关于类型健全性的开创性论文，<a href="chapter_4/safe_system.html#28">28</a>，但将其扩展到像 Rust 这样的工业现代语言被证明是一个艰巨的挑战。实际上，在开发“<code>&quot;step-indexed Kripke logical relations</code>”（SKLR）模型<a href="chapter_4/safe_system.html#3">3</a>,<a href="chapter_4/safe_system.html#5">5</a> 之前，将其扩展到具有可变状态和高阶函数的语言仍然是一个悬而未决的问题。<a href="chapter_4/safe_system.html#2">2</a>,<a href="chapter_4/safe_system.html#4">4</a>，作为基础证明代码项目的一部分。即便如此，使用 SKLR 模型直接编码的<em>safety contract</em>  的验证仍然是非常繁琐，低级且难以维护的。 </p>
<p>在 <code>RustBelt</code> 项目中，我们以 Iris 的最新工作为基础<a href="chapter_4/safe_system.html#19">19</a>,<a href="chapter_4/safe_system.html#20">20</a>,<a href="chapter_4/safe_system.html#21">21</a>,<a href="chapter_4/safe_system.html#23">23</a>，(一个证明框架，用于更高阶，并发，命令式程序，使用 Coq proof assistant实现)。<a href="chapter_4/safe_system.html#1">1</a> Iris提供了一种更高级的语言来编码和使用 SKLR 模型，从而使我们能够扩展此类模型，以处理Rust等复杂的语言。特别是基于<em>separation logic</em>，<a href="chapter_4/safe_system.html#29">29</a>, <a href="chapter_4/safe_system.html#30">30</a>, Hoare逻辑的扩展<a href="chapter_4/safe_system.html#15">15</a> 专门针对指针操作程序的模块化推理，并以所有权概念为中心。这为我们提供了一种理想的语言，可用于在Rust中建模所有权类型的语义。 </p>
<p>Iris扩展了传统的 <em>separation logic</em>，并增加了一些对 Rust 至关重要的附加功能： </p>
<ul>
<li>
<p>Iris 支持<em>用户定义的 ghost state</em>：定义自定义逻辑资源的能力，这些逻辑资源对于证明程序的正确性十分有用，但并不直接对应于其物理状态下(译者注: 指内存)的任何内容。 Iris 用户定义的 <em>ghost state</em> 使我们能够验证诸如 <code>Arc</code> 之类的库的健全性，这些库的所有权并不对应于物理所有权（例如，两个单独拥有的 <code>Arc&lt;T&gt;</code> 可能在同一款内存下）-- 一种称为 <code> fictional separation</code> 的现象。<a href="chapter_4/safe_system.html#10">10</a>，<a href="chapter_4/safe_system.html#11">11</a> </p>
<p>通过（在Iris内）派生了一个新的，特定于领域的<code>lifetime logic</code>，它还使我们能够以更高的抽象水平来思考 Rust 的借用 (borrowing)和生命周期。 </p>
</li>
<li>
<p>Iris支持 <em>impredicative invariants</em> ：程序状态上的不变式，可能会循环引用其他不变式的存在。<a href="chapter_4/safe_system.html#32">32 </a><em>impredicative invariants</em> 构建核心类型系统（例如递归类型和闭包）中起着至关重要的作用。 </p>
</li>
</ul>
<p>Rust 的复杂性要求我们对语义的健全性证明进行<em>machine-checked</em>, 因为这太繁琐且容易出错，无法手动进行证明。 幸运的是，Iris带有丰富的 <em>separation-logic tactics</em> ，这些策略是根据标准 Coq 策略制定的，因此可以让 Coq用户 经过 <code> time-tested</code> 的方式熟悉的开发 <em>machine-checked</em> 的语义完整性证明。 <a href="chapter_4/safe_system.html#22">22</a>,<a href="chapter_4/safe_system.html#24">24</a></p>
<h3><a class="header" href="#结论和展望" id="结论和展望">结论和展望</a></h3>
<p>在本文中，我们给出了 Rust 的鸟瞰图，展示了 Rust 的核心概念，例如借用 (borrowing)，生存期以及封装在 <code>safe</code> API 中的 <code>unsafe</code> 代码。这些功能帮助 Rust 第一个受行业支持的在高级语言带来的安全性和由较低级别的<code>系统编程</code>语言提供的资源管控之间做出长远平衡的语言。 </p>
<p>为了研究 <code>Rust </code> 的安全声明，我们描述了语义类型健全性的证明技术，这使我们能够开始在 <code>RustBelt</code> 项目中为 Rust 构建严格的基础。有关Rust 和 <code>RustBelt</code> 的更多详细信息，请向感兴趣的读者可以去阅读我们的POPL'18论文<a href="chapter_4/safe_system.html#18">18</a> 和第一作者的博士学位论文。<a href="chapter_4/safe_system.html#17">17</a> </p>
<p>我们还有很多工作要做。尽管 <code>RustBelt</code> 最近为Rust 考虑 从C++继承来的宽松内存并发模型( relaxed-memory concurrency model )<a href="chapter_4/safe_system.html#9">9</a>，当还没有涵盖许多其他 Rust 功能和 API，例如其 <code>trait</code> 系统，该系统非常复杂以至于会出现很多微妙的 bug 。 <a href="chapter_4/safe_system.html#7">7</a>，尽管验证<code>unsafe rust</code> 库的健全性目前需要形式语义的深厚背景，但我们希望最终开发出可以直接交给程序员的形式化方法。 </p>
<p>最后，尽管 <code>RustBelt</code> 专注于为 Rust 本身打好安全基础，但我们很高兴看到其他研究项目（特别是 <code>Prusti</code> <a href="chapter_4/safe_system.html#6">6</a> 和 <code>RustHorn</code> <a href="chapter_4/safe_system.html#27">27</a>）正开始探索一个令人激动的正交方向：即Rust 的强类型系统有可能用作简化系统代码形式验证的有力工具。 </p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<p><span id="1"></span> 1.The Coq proof assistant, 2019; https://coq.inria.fr/.</p>
<p><span id="2"></span> 2. Ahmed, A., Appel, A.W., Richards, C.D., Swadi,  K.N., Tan, G. and Wang, D.C. Semantic foundations for typed assembly  languages. <em>TOPLAS 32</em>, 3 (2010).</p>
<p><span id="3"></span>3. Ahmed, A.J. Semantics of types for mutable state. Ph.D. thesis, Princeton University, 2004.</p>
<p><span id="4"></span>4. Appel, A.W. Foundational proof-carrying code. <em>LICS</em>, 2001.</p>
<p><span id="5"></span>5. Appel, A.W. and McAllester, D. An indexed model of recursive types for foundational proof-carrying code. <em>TOPLAS 23</em>, 5 (2001).</p>
<p><span id="6"></span>6. Astrauskas, V., Müller, P., Poli, F. and Summers, A.J. Leveraging Rust types for modular specification and verification. <em>PACMPL 3 (OOPSLA)</em>, 2019.</p>
<p><span id="7"></span>7. Ben-Yehuda, A. Coherence can be bypassed by an indirect impl for a trait object, 2019; https://github.com/rust-lang/rustissues/57893.</p>
<p><span id="8"></span>8. Burch, A. Using Rust in Windows. Blog post, 2019; https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/.</p>
<p><span id="9"></span>9. Dang, H.-H., Jourdan, J.-H., Kaiser, J.-O. and Dreyer, D. RustBelt meets relaxed memory. <em>PACMPL 4 (POPL)</em>, 2020.</p>
<p><span id="10"></span>10. Dinsdale-Young, T., Dodds, M., Gardner, P., Parkinson, M.J. and Vafeiadis, V. Concurrent abstract predicates. <em>ECOOP</em>, 2010.</p>
<p><span id="11"></span>11. Dinsdale-Young, T., Gardner, P. and Wheelhouse, M.J. Abstraction and refinement for local reasoning. <em>VSTTE</em>, 2010.</p>
<p><span id="12"></span>12. Doko, M. and Vafeiadis, V. Tackling real-life relaxed concurrency with FSL++. <em>ESOP 10201, LNCS</em>, 2017.</p>
<p><span id="13"></span>13. Grossman, D., Morrisett, G., Jim, T., Hicks, M., Wang, Y. and Cheney, J. Region-based memory management in Cyclone. <em>PLDI</em>, 2002.</p>
<p><span id="14"></span>14. Harper, R. <em>Practical Foundations for Programming Languages</em> (2nd Ed.). Cambridge University Press, 2016.</p>
<p><span id="15"></span>15. Hoare, C.A.R. An axiomatic basis for computer programming. <em>Commun. ACM 12</em>, 10 (1969).</p>
<p><span id="16"></span>16. Hosfelt, D. Implications of rewriting a browser component in Rust. Blog post, 2019; https://hacks.mozilla.org/2019/02/rewriting-a-browser-component-in-rust/.</p>
<p><span id="17"></span>17. Jung, R. Understanding and Evolving the Rust Programming Language. Ph.D. thesis, Universität des Saarlandes, 2020; https://people.mpi-sws,org/~jung/thesis.html.</p>
<p><span id="18"></span>18. Jung, R., Jourdan, J.-H., Krebbers, R. and Dreyer, D. RustBelt: Securing the foundations of the Rust programming language. <em>PACMPL 2 (POPL)</em>, 2018.</p>
<p><span id="19"></span>19. Jung, R., Krebbers, R., Birkedal, L. and Dreyer, D. Higher-order ghost state. <em>ICFP</em>, 2016.</p>
<p><span id="20"></span>20. Jung, R., Krebbers, R., Jourdan, J.-H., Bizjak, A., Birkedal, L. and Dreyer, D. Iris from the ground up: A modular  foundation for higher- order concurrent separation logic. <em>JFP 28</em> (2018).</p>
<p><span id="21"></span>21. Jung, R., Swasey, D., Sieczkowski, F.,  Svendsen, K., Turon, A., Birkedal, L. and Dreyer, D. Iris: Monoids and  invariants as an orthogonal basis for concurrent reasoning. <em>POPL</em>, 2015.</p>
<p><span id="22"></span>22. Krebbers, R., Jourdan, J.-H., Jung, R.,  Tassarotti, J., Kaiser, J.-O, Timany, A., Charguéraud, A. and Dreyer, D. MoSeL: A general, extensible modal framework for interactive proofs in  separation logic. <em>PACMPL 2 (ICFP)</em>, 2018.</p>
<p><span id="23"></span>23. Krebbers, R., Jung, R., Bizjak, A., Jourdan,  J., Dreyer, D. and Birkedal, L. The essence of higher-order concurrent  separation logic. <em>ESOP</em>, 2017.</p>
<p><span id="24"></span>24. Krebbers, R., Timany, A. and Birkedal, L. Interactive proofs in higher-order concurrent separation logic. <em>POPL</em>, 2017.</p>
<p><span id="25"></span>25. Levick, R. Why Rust for safe systems programming. Blog post, 2019; https://msrc-blog.microsoft.com/2019/07/22/why-rust-for-safe-systems-programming/.</p>
<p><span id="26"></span>26. Matsakis, N. and Turon, A. Rust in 2016, 2015. Blog post; https://blog.rust-lang.org/2015/08/14/Next-year.html.</p>
<p><span id="27"></span>27. Matsushita, Y., Tsukada, T. and Kobayashi, N. RustHorn: CHC-based verification for Rust programs. <em>ESOP</em>, 2020.</p>
<p><span id="28"></span>28. Milner, R. A theory of type polymorphism in programming. <em>J. Computer and System Sciences 17</em>, 3 (1978).</p>
<p><span id="29"></span>29. O'Hearn, P.W., Reynolds, J.C. and Yang, H. Local reasoning about programs that alter data structures. <em>CSL</em>, 2001.</p>
<p><span id="30"></span>30. O'Hearn, P.W. Resources, concurrency, and local reasoning. <em>Theoretical Computer Science 375</em>, 1–3 (2007).</p>
<p><span id="31"></span>31. Stroustrup, B. <em>The C++ Programming Language</em>. Addison-Wesley, 2013.</p>
<p><span id="32"></span>32. Svendsen, K. and Birkedal, L. Impredicative concurrent abstract predicates. <em>ESOP</em>, 2014.</p>
<p><span id="33"></span>33. Thomas, G. A proactive approach to more secure code. Blog post, 2019; https://msrc-blog.microsoft.com/2019/07/16/a-proactive-approach-to-more-secure-code/.</p>
<p><span id="34"></span>34. Tofte, M. and Talpin, J. Region-based memory management. Information and Computation 132, 2 (1997).</p>
<p><span id="35"></span>35. Tu, T., Liu, X., Song, L. and Zhang, Y. Understanding real-world concurrency bugs in Go. <em>ASPLOS</em>, 2019.</p>
<p><span id="36"></span>36. Walker, D. Substructural type systems. <em>Advanced Topics in Types and Programming Languages</em>. B.C. Pierce, Ed. MIT Press, Cambridge, MA, 2005.</p>
<p><span id="37"></span>37. Wright, A.K. and Felleisen, M. A syntactic approach to type soundness. <em>Information and Computation 115</em>, 1 (1994).</p>
<h1><a class="header" href="#论文鉴赏--safedrop通过静态数据流分析检测rust程序的内存释放错误" id="论文鉴赏--safedrop通过静态数据流分析检测rust程序的内存释放错误">论文鉴赏 | SafeDrop：通过静态数据流分析检测Rust程序的内存释放错误</a></h1>
<p>编辑： 张汉东</p>
<blockquote>
<p>论文原文：<a href="https://arxiv.org/abs/2103.15420">https://arxiv.org/abs/2103.15420</a></p>
</blockquote>
<blockquote>
<p>编者按：</p>
<p>该论文是由复旦大学四位同学共同编写，其中两位共同第一作者 崔莫寒 和 陈澄钧 也参与了 4 月 9 号 RustFriday 飞书群线上沙龙 第三期的活动。回放地址：<a href="https://www.bilibili.com/video/BV1nU4y1h7NN/">https://www.bilibili.com/video/BV1nU4y1h7NN/</a></p>
<p>Rust 中文社群 飞书群 邀请你加入：<a href="https://applink.feishu.cn/TeLAcbDR">https://applink.feishu.cn/TeLAcbDR </a></p>
<p>论文中提到的 SafeDrop 工具还未开源，等工具得到进一步完善就会开源。</p>
<p>本文也不是全文翻译，只是摘录关键部分。欢迎观看沙龙视频回放。</p>
</blockquote>
<hr />
<h2><a class="header" href="#介绍-4" id="介绍-4">介绍</a></h2>
<p>Rust是一种新兴的编程语言，旨在防止内存安全错误。但是，Rust的当前设计还会带来副作用，这可能会增加内存安全问题的风险。特别是，它采用OBRM（基于所有权的资源管理），并在没有垃圾收集器的情况下自动执行未使用资源的自动重新分配。因此，它可能错误地处理已回收的内存并导致使用后释放或两次释放的问题。在本文中，我们研究了无效的内存分配问题，并提出了SafeDrop，一种静态的路径敏感型数据流分析方法来检测此类错误。</p>
<p>我们的方法通过遍历控制流图并提取每个数据流的所有别名，来迭代地分析 Rust Crate的每个API。为了保证精度和可伸缩性，我们利用改进的Tarjan算法来实现可伸缩的路径敏感分析，以及基于缓存的策略，以实现高效的过程间分析。我们的实验结果表明，我们的方法可以成功地检测出所有此类问题的现有CVE，而误报的数量有限。与原始编译时间相比，分析开销从1.0％到110.7％不等。我们进一步将工具应用于多个真实的Rust Crate，并发现8个涉及无效内存释放问题的Rust Crate。</p>
<p>OBRM（基于所有权的资源管理）模型假定在创建所有者时应分配资源，并在其所有者超出有效范围后进行释放。理想情况下，即使程序遇到异常，该模型也应能够防止指针悬空和内存泄漏。</p>
<p>但是，我们观察到，现实中Rust Crate的许多关键错误都与这种自动释放方案相关，例如，它可能会错误地丢弃一些仍在使用的缓冲区并招致 <code>use-after-free</code> 的错误（例如CVE-2019-16140），或者可能会错误地丢弃<code>dangling pointers</code>并导致 <code>double free</code>（例如CVE-2019-16144）。</p>
<p>通常，内存释放错误是由 Unsafe Rust 代码触发的。在Rust中， Unsafe Rust 的API是必需的，以提供对实现细节的底层控制和抽象。但是，滥用 Unsafe Rust 的API可能会使基于所有权的资源管理系统的健全性失效，并可能导致不确定的行为。例如， Unsafe Rust 的API可能导致共享别名的内存回收，而删除一个实例将导致其余别名的指针悬空。此外，Rust中的内部 Unsafe Rust 允许仅在内部具有不安全代码的函数可以被称为安全函数，内部可能存在内存安全问题。当前的Rust编译器对 Unsafe Rust 代码的内存安全风险一无所知，只是假设开发人员应负责使用它们。内存安全性是Rust提倡的最重要的功能，如果可能的话，降低这种风险非常重要。</p>
<p>针对此问题，本文提出了 SafeDrop，这是一种静态路径敏感的数据流分析方法，用于自动检测内存安全性错误释放机制。 Safe-Drop反复分析Rust Crate的每个API，并仔细检查Rust MIR（中级中间表示）中的每个drop语句是否可以安全启动。由于别名分析的潜在问题是可以决定的，因此它很难解决，因此我们采用了几种设计来提高我们方法的可扩展性，同时又不牺牲太多精度。我们的方法采用路径相遇（MOP）方法，并基于改进的Tarjan算法提取每个函数的所有有价值的路径，这对于消除具有相同别名关系的循环中的冗余路径是有效的。对于每个路径，我们以对流量敏感的方式提取所有别名的集合，并相应地分析每个dropstatement的安全性。当遇到函数调用时，我们在被调用者上递归执行SafeDrop，并分析参数与返回值之间的别名关系。为了避免重复分析，我们缓存并重用每个函数获得的别名结果。</p>
<h2><a class="header" href="#mir-介绍" id="mir-介绍">MIR 介绍</a></h2>
<p>因为 SafeDrop 是基于 MIR 来分析，所以先了解下 MRI 相关。</p>
<p>Rust 的编译过程中会产生 MIR (中级中间语言)，MIR 语法格式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>BasicBlock := {Statement} Terminator
Statement := LValue = RValue | StorageLive(Value)
    | StorageDead(Value) | ...
LValue := LValue | LValue.f | *LValue | ...
RValue := LValue | move LValue
    | &amp; LValue | &amp; mut LValue
    | * LValue | * mut LValue
    | ...
Terminator := Goto(BB) | Panic(BB)
    | Return | Resume | Abort
    | If(Value, BB0, BB1)
    | LVALUE = (FnCall, BB0, BB1)
    | Drop(Value, BB0, BB1)
    | SwitchInt(Value, BB0, BB1, BB2, ...)
    | ...
<span class="boring">}
</span></code></pre></pre>
<p>MIR是基于控制流图（Control Flow Graph，CFG）的有向无环图，主要包含了上面所说的几个语法元素：</p>
<ul>
<li>BasicBlock，由基本语句和终止符组成。</li>
<li>Statement，基本语句，就是每一行 Rust 代码转译为 MIR 的对应代码</li>
<li>LValue &amp;&amp; RValue， 分别对应位置表达式和值表达式。</li>
<li>Terminator，终止符，BasicBlock 的出口，包含各种形式的跳转，比如 Return/Resume/Abort/IF/Drop等等</li>
</ul>
<h2><a class="header" href="#safedrop-基于-mir-分析" id="safedrop-基于-mir-分析">SafeDrop 基于 MIR 分析</a></h2>
<p><img src="chapter_4/./image/safedrop/1.png" alt="1" /></p>
<p>如图所示。左侧为代码，右侧为该代码生成的 MIR。</p>
<p>SafeDrop 会依赖 MIR 进行静态路径分析。代码左边从 字符串 S 得到了指向堆的指针 <code>ptr</code>，然后通过<code>Vec::from_raw_parts</code>又创建了一个新的对该堆内存有所有权的变量，相当于现在同一片堆内存，有了两个指针。然后注释了 <code>mem::forget(s)</code>，代码就会发生 <code>double free</code> 的问题。但是解开<code>mem::forget(s)</code>的注释，又会发生<code>use-after-free</code>的问题。</p>
<p>这段代码比较简单，其实用 Miri 也可以检测出来这两种 UB。但是 SafeDrop 检测机制和 Miri 还是有所区别的。</p>
<p>SafeDrop 检测 MIR 中的 调用路径，会发现 <code>drop(_0)</code> 和 <code>drop(_1)</code>调用了两次，就会发现问题所在。同样，如果把 <code>mem::forget(s)</code>注释打开，也会检测到 <code>drop</code> 后又使用的情况，让 UB 无所遁形。</p>
<h2><a class="header" href="#形式化定义问题" id="形式化定义问题">形式化定义问题</a></h2>
<p>经过一些实验，SafeDrop 团队将 Unsafe Rust 中的遇到的一些常见问题做了形式化定义：</p>
<ul>
<li>
<p>使用中释放缓存区(Dropping buffers in use)</p>
<p>如果该算法错误地释放了一些缓冲区，这些缓冲区将在以后访问，则它将导致容易受到内存安全问题（包括释放后使用和双重释放）的指针的困扰。</p>
</li>
<li>
<p>释放无效指针（Dropping invalid pointers）。
如果无效指针悬空，则丢弃指针将导致double free；否则，指针将丢失。 如果无效指针指向包含指针类型的未初始化内存，则删除该指针可能会递归删除其嵌套指针，并导致无效的内存访问。</p>
</li>
</ul>
<h2><a class="header" href="#safedrop-中检测无效内存位置的典型模式" id="safedrop-中检测无效内存位置的典型模式">SafeDrop 中检测无效内存位置的典型模式</a></h2>
<ul>
<li>UAF: use after free; </li>
<li>DF: double free;</li>
<li>IMA: invalid memory access</li>
</ul>
<p>SafeDrop 检测无效内存位置遵循下面 7 种模式：</p>
<ul>
<li>Pattern 1: <code>GetPtr() -&gt; UnsafeConstruct() -&gt; Drop() -&gt; Use()  =&gt; UAF</code></li>
<li>Pattern 2: <code>GetPtr() -&gt; UnsafeConstruct() -&gt; Drop() -&gt; Drop() =&gt; DF</code></li>
<li>Pattern 3: <code>GetPtr() -&gt; Drop() -&gt; UnsafeConstruct() -&gt; Use()  =&gt; UAF</code></li>
<li>Pattern 4: <code>GetPtr() -&gt; Drop() -&gt; UnsafeConstruct() -&gt; Drop() =&gt; DF</code></li>
<li>Pattern 5: <code>GetPtr() -&gt; Drop() -&gt; Use() =&gt; UAF</code></li>
<li>Pattern 6: <code>Uninitialized() -&gt; Use()  =&gt; IMA</code></li>
<li>Pattern 7: <code>Uninitialized() -&gt; Drop() =&gt; IMA</code></li>
</ul>
<h2><a class="header" href="#检测方法" id="检测方法">检测方法</a></h2>
<h3><a class="header" href="#整体架构" id="整体架构">整体架构</a></h3>
<p><img src="chapter_4/./image/safedrop/3.png" alt="3" /></p>
<p>上图为 SafeDrop 的工作流程图解。将「通过对路径敏感的数据流分析方法」集成到名为SafeDrop的编译器中进行分析。它输入每个功能的MIR并输出潜在的无效内存警告。</p>
<p><strong>SafeDrop的关键步骤：</strong></p>
<ul>
<li>路径提取：SafeDrop采用“ meet-over-path ”方法来实现路径敏感性。由于函数的路径可能是无限的，因此我们采用基于Tarjan 算法的新颖方法来合并冗余路径并生成生成树。 此步骤将遍历此树并最终枚举所有有价值的路径。</li>
<li>别名分析：SafeDrop 对字段敏感。 此步骤分析每个数据流的变量和复合类型的字段之间的别名关系。 SafeDrop 也是跨程序的，对上下文不敏感。 它缓存并重用在返回值和参数之间获得的被调用者的别名关系。</li>
<li>无效的 drop 检测：基于之前建立的别名集，此步骤为每个数据流搜索有潜在风险的 drop 模式并记录可疑代码段。</li>
</ul>
<p>上面三个步骤的具体算法在论文中有详细描述，对算法细节感兴趣可以自行阅读论文。</p>
<p>该团队已经把 SafeDrop 和 Rust编译器v1.52 进行了集成（非官方动作），并且可以由诸如 rustc 和 cargo之类的命令行工具使用。</p>
<h2><a class="header" href="#miri-vs-safedrop" id="miri-vs-safedrop">Miri vs SafeDrop</a></h2>
<p>Rust Miri 是Rust MIR的实验解释器，它可以运行二进制文件，Cargo 项目的测试套件并检测一些未定义的行为。 </p>
<p>Miri的功能比 SafeDrop 更广泛。Miri支持检查越界内存访问，对齐内存访问不足以及违反某些基本类型不变式的情况。 </p>
<p>但是，Miri是一种动态分析方法，无法跟踪无法展开分析和库分析的程序的所有有价值的路径。 相反，SafeDrop是一种静态方法，可以在编译时分析每个函数的所有有价值的路径。</p>
<h2><a class="header" href="#未来挑战" id="未来挑战">未来挑战</a></h2>
<ul>
<li>增强性能。</li>
<li>降低检测误差。</li>
<li>对 Rust 标准库进行检测。</li>
<li>开源</li>
<li>其他</li>
</ul>
<h1><a class="header" href="#学界动态" id="学界动态">学界动态</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#2021全国大学生计算机系统能力大赛操作系统设计大赛-启动" id="2021全国大学生计算机系统能力大赛操作系统设计大赛-启动">2021全国大学生计算机系统能力大赛操作系统设计大赛 启动</a></h2>
<p>全国大学生计算机系统能力大赛操作系统设计大赛(以下简称“大赛”)是由教育部高等学校计算机类专业教学指导委员会和系统能力培养研究专家组共同发起，以学科竞赛推动专业建设和计算机领域创新人才培养体系改革、培育我国高端芯片及核心系统的技术突破与产业化后备人才为目标,面向高校大学生举办的全国性大赛。</p>
<p>大赛旨在选拔未来我国计算机系统相关领域的设计、分析、优化与应用人才,激发学生的想象力、创新力和工程实践能力并培养其团队协作精神,以赛促学、以赛促教,为高质量专业人才搭建交流、展示、合作的开源社区平台，让参与大赛的学生、指导教师、学校和企业都能从中获得补益，助力我国高校与企业在操作系统领域的产学研合作健康快速发展。</p>
<p>本次比赛除了学生之外，还针对非学生兴趣人员设立了兴趣小组，感兴趣的朋友可以联系，在本文下评论就可以。</p>
<p>本次比赛内核赛包含了清华大学 Rust 实现的 rCore 为指南。</p>
<ul>
<li><a href="https://os.educg.net/">官网：https://os.educg.net/</a></li>
<li><a href="https://github.com/oscomp/os-competition-info/blob/main/ref-info.md">与比赛相关的一些硬件，OS相关的实例/教程的参考信息</a></li>
<li><a href="https://www.bilibili.com/video/BV1GE41157Hc/?spm_id_from=333.788.b_7265636f5f6c697374.8">操作系统(RISC-V)_清华大学_国家精品视频课程合集</a></li>
</ul>
<h2><a class="header" href="#plct-lab-从零开始的risc-v模拟器开发-公开课" id="plct-lab-从零开始的risc-v模拟器开发-公开课">PLCT Lab: 从零开始的RISC-V模拟器开发 公开课</a></h2>
<p>本课程是由中科院研究所推出的在线公开课，虽然和 Rust 没有直接关系，但也算是 Rust 应用领域的一个前沿方向，比如有公司使用 Rust 和 RISC-V 实现 语言虚拟机。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV12Z4y1c74c">从零开始的RISC-V模拟器开发·第一季·2021春季·连载中</a></li>
<li><a href="https://github.com/plctlab/writing-your-first-riscv-simulator">《从零开始的RISC-V模拟器开发》配套的PPT和教学资料</a></li>
</ul>
<h1><a class="header" href="#华为--stratovirt-地址空间管理-基于rust的实现与优化" id="华为--stratovirt-地址空间管理-基于rust的实现与优化">华为 | StratoVirt 地址空间管理-基于Rust的实现与优化</a></h1>
<p>作者：杨晓鹤 / 后期编辑： 张汉东</p>
<p>上一篇： <a href="chapter_4/../chapter_3/hw_rust_stratovirt.html">华为 | 基于Rust的下一代虚拟化平台-StratoVirt</a></p>
<hr />
<p>StratoVirt是开源在openEuler社区的轻量级虚拟化平台，具备轻量低噪、强安全性的行业竞争力。StratoVirt进程运行在用户态，在虚拟机启动之前， StratoVirt会完成启动之前的准备工作，包括虚拟机内存初始化、CPU寄存器初始化、设备初始化等。其中，内存初始化工作和虚拟机的地址空间管理， 都是由StratoVirt的地址空间管理模块<code>AddressSpace</code>完成。如下是StratoVirt地址空间管理模块的组成，以及其在StratoVirt中的位置。</p>
<pre><code>stratovirt
├── address_space
│   ├── Cargo.toml
│   └── src
│       ├── address.rs
│       ├── address_space.rs
│       ├── host_mmap.rs
│       ├── lib.rs
│       ├── listener.rs
│       └── region.rs
├── boot_loader
├── Cargo.lock
├── Cargo.toml
├── cpu
├── devices
├── machine_manager
├── micro_vm
├── src
│   └── main.rs
├── sysbus
├── util
└── virtio
</code></pre>
<h2><a class="header" href="#stratovirt-地址空间模块整体设计" id="stratovirt-地址空间模块整体设计">StratoVirt 地址空间模块整体设计</a></h2>
<p><img src="chapter_4/./image/hw-stratovirt/address_space_topology.png" alt="image-20210425104007596" /></p>
<p>上图中的主要结构含义如下：</p>
<ul>
<li>
<p><code>AddressSpace</code></p>
<p>地址空间：为地址空间模块的管理结构， 负责整个虚拟机的地址空间管理</p>
</li>
<li>
<p><code>Region</code></p>
<p><img src="chapter_4/./image/hw-stratovirt/region_addr.png" alt="image-20210425152818160" /></p>
<p>代表一段地址区间，根据这段地址区间的使用者，可以分为以下类型：</p>
<ol>
<li>
<p>RAM： 虚拟机内存使用该段地址区间。</p>
</li>
<li>
<p>IO： 虚拟机设备使用该段地址区间。</p>
</li>
<li>
<p>Container ： 作为容器使用，可以包含多个子<code>Region</code>。如描述PCI总线域的地址管理就可以使用类型为<code>Container</code>的<code>Region</code>，它可以包含PCI总线域下的PCI设备使用的地址区间。该类型的<code>Region</code>可以帮助管理并区分存储器域、PCI总线域的地址管理。</p>
</li>
</ol>
</li>
</ul>
<p>地址空间模块的设计，采用树状结构和平坦视图结合的方案。通过树状结构可以快速的了解到各个Region之间的拓扑结构关系。这种分层、分类的设计， 可以管理并区分存储器域与PCI总线域的地址管理，并形成与PCI设备树相呼应的树状管理结构。对于平坦视图<code>FlatView</code>，则是根据这些<code>Region</code>的地址范围和优先级属性形成的线性视图。在通过地址空间管理结构<code>AddressSpace</code>访问设备或者内存时， 使用平坦视图<code>FlatView</code>可以更加方便快捷地找到对应的<code>Region</code>。</p>
<p>在树状拓扑结构中，每个<code>Region</code>都会对应一个优先级<code>priority</code>属性，如果低优先级的<code>Region</code>占用的地址区间和高优先级的<code>Region</code>占用的地址区间重叠，则低优先级的<code>Region</code> 的重叠部分，将会被覆盖，即在平坦视图<code>FlatView</code>中不可见。</p>
<p>树状拓扑结果的更新，很大可能会带来平坦视图<code>FlatView</code>的更新。一些设备或者模块需要获取最新的平坦视图，并相应的执行一些操作。例如Vhost设备，需要将平坦视图中的全部内存信息同步到内核Vhost模块，以便通过共享内存方式完成消息通知的流程。另外，我们也需要将已经分配并映射好的虚拟机物理地址和宿主机虚拟地址信息注册到KVM模块，这样可以借助硬件辅助虚拟化加速内存访问的性能。基于以上需求，我们引入上图中的地址空间监听函数链表，该链表在平坦视图<code>FlatView</code>更新后被依次调用，可以方便的完成信息同步。该链表允许其他模块添加一个自定义的监听回调函数。</p>
<h2><a class="header" href="#地址空间优化" id="地址空间优化">地址空间优化</a></h2>
<p>作为StratoVirt的基础模块和访问密集型的模块， 地址空间模块不仅要满足接口易用性、功能鲁棒性，而且需要不断优化性能。 如下是迭代过程中的几个优化点。</p>
<h3><a class="header" href="#拓扑结构更新优化" id="拓扑结构更新优化">拓扑结构更新优化</a></h3>
<p>地址空间管理模块提供向树状拓扑结构中添加和删除<code>Region</code>的接口，并设定<code>AddressSpace</code>结构负责管理整个数据结构并生成更新后的<code>FlatView</code>结构。</p>
<p>添加子<code>Region</code>的方式为， 调用<code>Region</code>结构的<code>add_subregion</code>接口，注意父<code>Region</code>必须是<code>Container</code>类型。这样会带来一个问题，如果向树状结构中的某个<code>Region</code>中添加或者删除子<code>Region</code>，并引起树状结构的拓扑发生变化，负责生成并更新平坦视图的<code>FlatView</code>的<code>AddressSpace</code>结构体如何得知已经发生变化呢？</p>
<p><img src="chapter_4/./image/hw-stratovirt/region_simple_pointer.png" alt="image-20210425140726741" /></p>
<p>最简单的实现为在<code>Region</code>结构中添加成员并指向自己所属的<code>AddressSpace</code>，如上图所示。熟悉Rust语言的同学应该知道，这种实现方式会引入资源相互引用的问题，导致<code>AddressSpace</code>和<code>Region</code>两者因相互引用而在生命周期结束时无法释放内存资源的问题。因此，在地址空间模块的树状结构中，所有 <code>Region</code>对自己所属的<code>AddressSpace</code>的指针都使用<code>std::sync::Weak</code>类指针，<code>Weak</code>指针不会增加所指向对象的引用计数，可确保在生命周期结束时对应结构的析构和资源释放。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Region {
    region_type: RegionType,
    priority: Arc&lt;AtomicI32&gt;,
    size: Arc&lt;AtomicU64&gt;,
    offset: Arc&lt;Mutex&lt;GuestAddress&gt;&gt;,
    mem_mapping: Option&lt;Arc&lt;HostMemMapping&gt;&gt;,
    ops: Option&lt;RegionOps&gt;,
    io_evtfds: Arc&lt;Mutex&lt;Vec&lt;RegionIoEventFd&gt;&gt;&gt;,
    space: Arc&lt;RwLock&lt;Weak&lt;AddressSpace&gt;&gt;&gt;,
    subregions: Arc&lt;RwLock&lt;Vec&lt;Region&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#锁优化" id="锁优化">锁优化</a></h3>
<h4><a class="header" href="#锁粒度最小化" id="锁粒度最小化">锁粒度最小化</a></h4>
<p>为增加接口的易用性，地址空间模块的设计必须保证多线程安全性，作为主要接口的<code>AddressSpace</code>结构体如下。可以看到，<code>AddressSpace</code>的关键成员都以<code>Arc&lt;Mutex&lt;..&gt;&gt;</code>的方式保证了多线程共享的安全性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AddressSpace {
    root: Region,
    flat_view: ArcSwap&lt;FlatView&gt;,
    listeners: Arc&lt;Mutex&lt;Vec&lt;Box&lt;dyn Listener&gt;&gt;&gt;&gt;,
    ioeventfds: Arc&lt;Mutex&lt;Vec&lt;RegionIoEventFd&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>地址空间空间管理在设计时将锁的粒度最小化，目的是降低多线程数据竞争带来的影响。</p>
<h4><a class="header" href="#锁性能优化" id="锁性能优化">锁性能优化</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AddressSpace优化前结构
pub struct AddressSpace {
    root: Region,
    flat_view: Arc&lt;RwLock&lt;FlatView&gt;&gt;,
    listeners: Arc&lt;Mutex&lt;Vec&lt;Box&lt;dyn Listener&gt;&gt;&gt;&gt;,
    ioeventfds: Arc&lt;Mutex&lt;Vec&lt;RegionIoEventFd&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>对于地址空间管理模块的关键数据结构，代表平坦视图的<code>FlatView</code>具有重要作用。其一，在树状拓扑结构发生变化时，例如添加和删除<code>Region</code>，会引起平坦视图<code>FlatView</code>发生变化，因此应该获取<code>AddressSpace</code>中<code>flat_view</code>成员的<strong>写锁</strong>，用于更新平坦视图；其二，设备访问内存、VCPU退出到StratoVirt访问设备，都要通过<code>AddressSpace</code>的<code>flat_view</code>成员，获取<strong>读锁</strong>，找到对应的<code>Region</code>，然后进行读写操作。</p>
<p>但是，使用Rust读写锁<code>RwLock</code>仍然存在连个问题：其一，经过测试，Rust读写锁的性能比互斥锁差。而读写锁和互斥锁的性能均比原子类型差；其二，在某些场景下，地址空间管理模块需要实现<strong>函数可重入</strong>的支持，即 在持有<code>FlatView</code>读锁的情况下，仍可以对树状拓扑结构和平坦视图<code>FlatView</code>更新（例如，PCI bar空间更新，需要通过<code>AddressSpace</code>访问设备寄存器来设置地址，并将确定好地址的PCI bar空间添加到<code>AddressSpace</code>中）。</p>
<p>基于上述问题和场景要求，使用Rust中的读写锁和互斥锁都会带来问题。而RCU锁不但能满足多读者、少写者的并发情况，而且能允许读写同时进行的要求。通过自行实现和已有第三方库的调研，最终我们选用<code>arc_swap</code>第三方库的RCU-like的机制，不但可以满足可重入性的要求，而且通过地址空间模块访问内存的性能可以提升20%以上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AddressSpace {
    root: Region,
    flat_view: ArcSwap&lt;FlatView&gt;,
    listeners: Arc&lt;Mutex&lt;Vec&lt;Box&lt;dyn Listener&gt;&gt;&gt;&gt;,
    ioeventfds: Arc&lt;Mutex&lt;Vec&lt;RegionIoEventFd&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#关注我们-1" id="关注我们-1">关注我们</a></h2>
<p>StratoVirt当前已经在openEuler社区（openEuler是一个开源、免费的Linux发行版平台，将通过开放的社区形式与全球的开发者共同构建一个开放、多元和架构包容的软件生态体系）开源。在未来的一段时间我们将开展一系列主题的分享，让大家更加详细的了解StratoVirt实现，非常期待您的围观和加入！</p>
<p>项目地址：https://gitee.com/openeuler/stratovirt</p>
<p>项目wiki：https://gitee.com/openeuler/stratovirt/wikis</p>
<p>项目交流：<a href="https://mailweb.openeuler.org/postorius/lists/virt.openeuler.org/">virt邮件列表</a>或是提交一个<a href="https://gitee.com/openeuler/stratovirt/issues">issue</a>。</p>
<h1><a class="header" href="#华为--rust-编译后二进制大小和常用优化方式" id="华为--rust-编译后二进制大小和常用优化方式">华为 | Rust 编译后二进制大小和常用优化方式</a></h1>
<p>作者： 周紫鹏 / 后期编辑：张汉东</p>
<hr />
<h4><a class="header" href="#背景介绍" id="背景介绍">背景介绍</a></h4>
<p>Rust编译后的可执行文件大小一直是大家谈论<a href="https://stackoverflow.com/questions/29008127/why-are-rust-executables-so-huge">比较多的问题</a>，对于嵌入式单板空间有限的场景下，太大的可执行文件往往是不可接受的。当前的项目也经常会因为几K的可执行文件增大而进行优化。</p>
<p>本篇文章对比Rust和C语言可执行文件大小和组成，并尝试提供一些有效的优化方式。Rust选择的是<a href="https://github.com/tokio-rs/tokio/releases/tag/tokio-1.5.0">Tokio v1.5.0</a>作为测试对象，C语言则选择公司内部某项目组模块作为测试对象。</p>
<h4><a class="header" href="#rust生成二进制类型介绍" id="rust生成二进制类型介绍">Rust生成二进制类型介绍</a></h4>
<p>Rust支持生成多种格式的动态库和静态库，在Cargo.toml文件中，新增[lib]段指定<a href="https://doc.rust-lang.org/reference/linkage.html">crate-type</a>就可以进行配置。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[lib]
crate-type = [&quot;dylib&quot;]
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>[crate_type = &quot;bin&quot;]</p>
<p>生成可执行文件，crate中必须要有main函数作为入口，如果crate中已经有main函数，其实不需要在toml文件中显示指定。生成的可执行文件中，会包含所有Rust相关的库和依赖。也就是生成的可执行文件可以在没有安装Rust环境的机器上运行。</p>
</li>
<li>
<p>[crate_type = &quot;lib&quot;]</p>
<p>生成一个Rust库，但是具体的形态会根据不同的编译器来生成对应的lib库，生成的库是给rustc使用的，所以这个库的形式也会跟着rustc的变化而变化。</p>
</li>
<li>
<p>[crate_type = &quot;dylib&quot;]</p>
<p>生成一个动态的Rust库（Linux 上为 .so，MacOS 上为 .dylib， Windows 上为 .dll），生成的动态库可以作为其他库或者可执行文件的依赖库。该动态库会包含Rust的一些特定段，如.rustc等。</p>
</li>
<li>
<p>[crate_type = &quot;staticlib&quot;]</p>
<p>生成一个静态库（Linux\MacOS 上为 .a，Windows 上为 .lib）,Rust编译器不会链接staticlib生成的静态库，因为该静态库会包含Rust库和依赖的第三方库，一般适合作为独立的Rust库实现提供给第三方，和bin的区别是，没有携带main函数。</p>
</li>
<li>
<p>[crate_type = &quot;cdylib&quot;]</p>
<p>C类型的动态库，与 dylib 类似，也会生成 .so, .dylib 或 .dll 文件，但是生成的为C-ABI格式的二进制，可以提供给C语言作为FFI调用。</p>
</li>
<li>
<p>[crate_type = &quot;rlib&quot;]</p>
<p>Rust lib文件，由于当前Rust的二进制格式是不稳定的，所以当前Rust还是使用源码集成一起编译的方式来进行构建，当前没有办法通过Cargo.toml的方式依赖编译好的SO、*.rlb或者.a。rlib作为Rust编译生成的中间二进制文件，会携带很多Rust语言相关的信息，最终是作为rustc的输入。在编译的过程中，可以在<code>target\release\deps</code>下看到依赖的三方库被编译成rlib。</p>
</li>
<li>
<p>[crate_type = &quot;proc-macro&quot;]</p>
<p>不会产生特定类型的库文件，Rust过程宏使用需要独立的crate，其他库通过依赖指定的<code>proc-macro</code>库进行使用。</p>
</li>
</ul>
<p>本次分析主要以dylib库方式进行，避免引入第三方库依赖的影响。</p>
<h4><a class="header" href="#可执行文件组成" id="可执行文件组成">可执行文件组成</a></h4>
<p><a href="https://github.com/tokio-rs/tokio/releases/tag/tokio-1.5.0">Tokio v1.5.0</a>中tokio模块的代码(NBNC)有36,473行，使用<a href="https://crates.io/crates/tokei">tokei</a>工具进行统计的结果。</p>
<p>在<code>tokio\tokio\Cargo.toml</code>文件中添加<code>crate-type = [&quot;dylib&quot;]</code>，指定编译结果为动态库形式。</p>
<ul>
<li>
<p>使用<code>cargo build --release</code>编译</p>
<p>生成的libtokio.so大小为<code>5,385,736</code>字节，每个段的分布如下。第二列为段名称，第三列为段大小，最后一列为每千行代码包含的二进制大小。段的大小单位都为字节。</p>
</li>
</ul>
<table><thead><tr><th>[Nr]</th><th>Section Name</th><th>Section Size</th><th>Section Size / KLOC</th></tr></thead><tbody>
<tr><td>[ 1]</td><td>.hash</td><td>12,496</td><td>347</td></tr>
<tr><td>[  2]</td><td>.gnu.hash</td><td>12,928</td><td>359</td></tr>
<tr><td>[  3]</td><td>.dynsym</td><td>50,376</td><td>1,399</td></tr>
<tr><td>[  4]</td><td>.dynstr</td><td>194,040</td><td>5,390</td></tr>
<tr><td>[  5]</td><td>.gnu.version</td><td>4,198</td><td>117</td></tr>
<tr><td>[  6]</td><td>.gnu.version_r</td><td>256</td><td>7</td></tr>
<tr><td>[  7]</td><td>.rela.dyn</td><td>59,616</td><td>1,656</td></tr>
<tr><td>[  8]</td><td>.rela.plt</td><td>48</td><td>1</td></tr>
<tr><td>[  9]</td><td>.init</td><td>26</td><td>1</td></tr>
<tr><td>[10]</td><td>.plt</td><td>48</td><td>1</td></tr>
<tr><td>[11]</td><td>.plt.got</td><td>16</td><td>0</td></tr>
<tr><td>[12]</td><td>.text</td><td>689,517</td><td>19,153</td></tr>
<tr><td>[13]</td><td>.fini</td><td>9</td><td>0</td></tr>
<tr><td>[14]</td><td>.rodata</td><td>31,222</td><td>867</td></tr>
<tr><td>[15]</td><td>.eh_frame_hdr</td><td>38,660</td><td>1,074</td></tr>
<tr><td>[16]</td><td>.eh_frame</td><td>179,868</td><td>4,996</td></tr>
<tr><td>[17]</td><td>.gcc_except_table</td><td>28,468</td><td>791</td></tr>
<tr><td>[18]</td><td>.tdata</td><td>56</td><td>2</td></tr>
<tr><td>[19]</td><td>.tbss</td><td>211</td><td>6</td></tr>
<tr><td>[20]</td><td>.init_array</td><td>8</td><td>0</td></tr>
<tr><td>[21]</td><td>.fini_array</td><td>8</td><td>0</td></tr>
<tr><td>[22]</td><td>.data.rel.ro</td><td>31,304</td><td>870</td></tr>
<tr><td>[23]</td><td>.dynamic</td><td>576</td><td>16</td></tr>
<tr><td>[24]</td><td>.got</td><td>5,008</td><td>139</td></tr>
<tr><td>[25]</td><td>.data</td><td>168</td><td>5</td></tr>
<tr><td>[26]</td><td>.bss</td><td>160</td><td>4</td></tr>
<tr><td>[27]</td><td>.comment</td><td>17</td><td>0</td></tr>
<tr><td>[28]</td><td>.rustc</td><td>3,318,060</td><td>92,168</td></tr>
<tr><td>[29]</td><td>.debug_aranges</td><td>128</td><td>4</td></tr>
<tr><td>[30]</td><td>.debug_info</td><td>68</td><td>2</td></tr>
<tr><td>[31]</td><td>.debug_abbrev</td><td>36</td><td>1</td></tr>
<tr><td>[32]</td><td>.debug_line</td><td>197</td><td>5</td></tr>
<tr><td>[33]</td><td>.debug_str</td><td>107</td><td>3</td></tr>
<tr><td>[34]</td><td>.debug_ranges</td><td>128</td><td>4</td></tr>
<tr><td>[35]</td><td>.symtab</td><td>185,592</td><td>5,155</td></tr>
<tr><td>[36]</td><td>.strtab</td><td>539,047</td><td>14,974</td></tr>
<tr><td>[37]</td><td>.shstrtab</td><td>342</td><td>10</td></tr>
</tbody></table>
<p>从表格中可以看到，release中仍然存在调试相关信息，包括符号表信息。针对调测信息，我们对SO进一步进行strip。</p>
<ul>
<li>
<p><strong>strip</strong></p>
<p>strip命令可以将29到37的调测信息段删除，删除之后的libtokio.so大小为<code>4,659,816</code>，仍有4.5M左右的大小。</p>
</li>
<li>
<p><strong>.rustc段</strong></p>
<p>.rustc段大概占了整体大小的60%，关于.rustc段的作用是这样的，由于动态库dylib采用Rust ABI，目前这个ABI尚不稳定，需要.rustc这一节来附加额外的版本控制信息，在最终的可执行文件中不会存在rustc段。可以通过<code>strip libtokio.so -R .rustc</code>将.rustc段删除，删除之后的大小为<code>1,341,680</code>大小为1.3M 左右。</p>
</li>
<li>
<p><strong>各段占比以及和C的对比</strong></p>
</li>
</ul>
<table><thead><tr><th>tokio数据</th><th></th><th></th><th></th><th></th><th>C语言数据</th><th></th><th></th></tr></thead><tbody>
<tr><td>序号</td><td>段</td><td>段大小</td><td>每千行大小</td><td>百分比</td><td>百分比</td><td>每千行大小</td><td>段</td></tr>
<tr><td>[  1]</td><td>.hash</td><td>12,496</td><td>347</td><td>0.93%</td><td>1.94%</td><td>270</td><td>.hash</td></tr>
<tr><td>[  2]</td><td>.gnu.hash</td><td>12,928</td><td>359</td><td>0.96%</td><td>2.25%</td><td>313</td><td>.gnu.hash</td></tr>
<tr><td>[  3]</td><td>.dynsym</td><td>50,376</td><td>1,399</td><td>3.75%</td><td>7.26%</td><td>1,010</td><td>.dynsym</td></tr>
<tr><td><strong>[  4]</strong></td><td><strong>.dynstr</strong></td><td><strong>194,040</strong></td><td><strong>5,390</strong></td><td><strong>14.46%</strong></td><td><strong>6.01%</strong></td><td><strong>836</strong></td><td><strong>.dynstr</strong></td></tr>
<tr><td>[  7]</td><td>.rela.dyn</td><td>59,616</td><td>1,656</td><td>4.44%</td><td>5.53%</td><td>769</td><td>.rela.dyn</td></tr>
<tr><td><strong>[12]</strong></td><td><strong>.text</strong></td><td><strong>689,517</strong></td><td><strong>19,153</strong></td><td><strong>51.39%</strong></td><td><strong>50.09%</strong></td><td><strong>6,965</strong></td><td><strong>.text</strong></td></tr>
<tr><td>[14]</td><td>.rodata</td><td>31,222</td><td>867</td><td>2.33%</td><td>8.34%</td><td>1,159</td><td>.rodata</td></tr>
<tr><td>[15]</td><td>.eh_frame_hdr</td><td>38,660</td><td>1,074</td><td>2.88%</td><td>1.87%</td><td>261</td><td>.eh_frame_hdr</td></tr>
<tr><td><strong>[16]</strong></td><td><strong>.eh_frame</strong></td><td><strong>179,868</strong></td><td><strong>4,996</strong></td><td><strong>13.41%</strong></td><td><strong>10.05%</strong></td><td><strong>1,397</strong></td><td><strong>.eh_frame</strong></td></tr>
<tr><td>[17]</td><td><strong>.gcc_except_table</strong></td><td><strong>28,468</strong></td><td><strong>791</strong></td><td><strong>2.12%</strong></td><td></td><td></td><td></td></tr>
<tr><td>[22]</td><td>.data.rel.ro</td><td>31,304</td><td>870</td><td>2.33%</td><td>0.01%</td><td>2</td><td>.data.rel.ro</td></tr>
<tr><td>[24]</td><td>.got</td><td>5,008</td><td>139</td><td>0.37%</td><td>1.56%</td><td>217</td><td>.got</td></tr>
<tr><td></td><td></td><td></td><td><strong>37042</strong></td><td></td><td></td><td><strong>13,198</strong></td><td></td></tr>
</tbody></table>
<p>表格中C采用<code>-O2</code>优化等级，并通过strip之后的数据。按照经验值来看，每千行C代码编译出的二进制大小大概在13K左右。从表格对比来看，Rust编译出来的可执行文件大概是C语言的3倍。最主要增大点在.text段和.dynstr段。其中tokio比C多了.gcc_except_table段，该段和try-catch-finally 控制流块的异常相关，部分信息用于处理异常，其他信息用于清除代码（即：在展开堆栈时调用对象析构函数）。</p>
<ul>
<li>
<p><strong>.dynsym</strong></p>
<p>这一节存储的是关于动态链接的符号表，每一个表项占24字节，tokio总共有2099个动态符号，相比较于C，Rust会存在更多的库函数、数据结构和异常处理等。</p>
<pre><code>//Rust dynsym符号表
Symbol table '.dynsym' contains 2099 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN3std3net3tcp9TcpStream
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN3std2fs8DirEntry9file_
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN4core3fmt3num53_$LT$im
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN4core3fmt3num53_$LT$im
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN51_$LT$$RF$std..fs..Fi
     6: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND _ZN3std10std_detect6detec
     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN3std3sys4unix6thread6T
     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN4core3fmt3num52_$LT$im
     9: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND pipe2@GLIBC_2.9 (2)
    10: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN91_$LT$std..io..cursor
    11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN74_$LT$std..fs..DirEnt
    12: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN4core6option13expect_f
    13: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN3std3net4addr12SocketA
    14: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN3std4path4Path5_join17
    15: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN4core3fmt3num53_$LT$im
    ....
</code></pre>
<pre><code>//C dynsym符号表
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND free@GLIBC_2.2.5 (2)
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __isoc99_fscanf@GLIBC_2.7 (3)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND clock_gettime@GLIBC_2.17 (4)
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fclose@GLIBC_2.2.5 (2)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (2)
     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __assert_fail@GLIBC_2.2.5 (2)
     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
     9: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND feof@GLIBC_2.2.5 (2)
    10: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memcpy@GLIBC_2.14 (5)
    12: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND malloc@GLIBC_2.2.5 (2)
    13: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fopen@GLIBC_2.2.5 (2)
</code></pre>
</li>
<li>
<p><strong>.dynstr</strong></p>
<p>dynstr段用来存储dysym符号表中的符号，本次测试使用的是rustc 1.48.0，组名规则为<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_symbol_mangling/index.html#the-rust-linkage-model-and-symbol-names">legacy</a>，类似于C++的组名规则，符号名中间会加上crate、mod、struct等信息，想比于C语言的组名要大很多。</p>
<p>当前nightly版本支持了新的组名规则，<a href="https://github.com/rust-lang/rfcs/blob/master/text/2603-rust-symbol-name-mangling-v0.md">V0规则</a>，新的规则会删除符号最后的哈希值，但是组名之后的符号仍然是很长的。</p>
<pre><code>//Rust 字符串表
String dump of section '.dynstr':
  [     1]  libstd-f14aca24435a5414.so
  [    1c]  _ITM_deregisterTMCloneTable
  [    38]  __gmon_start__
  [    47]  _Jv_RegisterClasses
  [    5b]  _ITM_registerTMCloneTable
  [    75]  _ZN58_$LT$std..io..error..Error$u20$as$u20$core..fmt..Debug$GT$3fmt17heb882e9e5723aaeaE
  [    cd]  _ZN244_$LT$std..error..$LT$impl$u20$core..convert..From$LT$alloc..string..String$GT$$u20$for$u20$alloc..boxed..Box$LT$dyn$u20$std..error..Error$u2b$core..marker..Send$u2b$core..marker..Sync$GT$$GT$..from..StringError$u20$as$u20$core..fmt..Display$GT$3fmt17h0381a183d16c0bdbE
  [   1e0]  _ZN3std2rt19lang_start_internal17h73711f37ecfcb277E
  [   214]  _ZN56_$LT$std..io..Guard$u20$as$u20$core..ops..drop..Drop$GT$4drop17h17ecb6f4aa594fe8E
  [   26b]  _ZN4core6result13unwrap_failed17he7cdc7a46f93cfbeE
  [   29e]  _ZN3std2fs11OpenOptions4read17hb9e61755aa4c5dd0E

</code></pre>
<pre><code>//C 字符串表
String dump of section '.dynstr':
  [     1]  libc.so.6
  [     b]  fopen
  [    11]  puts
  [    16]  __assert_fail
  [    24]  printf
  [    2b]  feof
  [    30]  __isoc99_fscanf
  [    40]  memcpy
  [    47]  fclose
  [    4e]  malloc
  [    55]  clock_gettime
</code></pre>
</li>
<li>
<p>.text段</p>
<p>最后再打开看看最大头的代码段。.text段大概也是C的三倍左右大小，通过汇编指令打开查看，Rust比C多出点在异常处理、调用栈、析构函数、泛型实例化、Vec，Result，Box，String，Map等结构的处理、运行时边界校验等。</p>
</li>
</ul>
<h4><a class="header" href="#优化方式" id="优化方式">优化方式</a></h4>
<p>上述我们只是用<code>cargo build --release</code>的方式进行了代码的优化，当然Rust编译器还提供了不同的优化手段。本节还是基于tokio，介绍常用的二进制优化手段。</p>
<table><thead><tr><th>优化手段</th><th>二进制大小（字节）</th></tr></thead><tbody>
<tr><td>debug模式编译</td><td>22,287,016</td></tr>
<tr><td>release模式编译</td><td>5,385,736</td></tr>
<tr><td>strip之后大小</td><td>4,659,816</td></tr>
<tr><td>strip libtokio.so -R .rustc</td><td>1,341,680</td></tr>
<tr><td>codegen-units = 1</td><td>1,046,768</td></tr>
<tr><td>panic = 'abort'</td><td>未测试</td></tr>
<tr><td>Optimize libstd with Xargo</td><td>未测试</td></tr>
</tbody></table>
<p>cargo支持的性能和二进制大小优化选项可以参见<a href="https://doc.rust-lang.org/cargo/reference/profiles.html#default-profiles">这里</a>。</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units">codegen-units</a> </p>
<p>其中codegen-units = 1优化效果比较明显。该选项用来将crate分割成多个代码生成单元，当生成多个代码单元时，LLVM会并行的来处理，减少编译的时间。如果将codegen-units设置为1的时候，可以提升代码的运行速度，和减少生成的可执行文件，但是会大大增加编译的时间开销。在仅使用release时tokio编译时间为25s，在设置codegen-units = 1的时候，编译时间为39s，大概增加了**60%**的时间。默认情况下全量编译设置的值为16，增量编译下设置的值为256。</p>
</li>
<li>
<p><a href="https://github.com/johnthagen/min-sized-rust">min-sized-rust</a></p>
<p>该仓中介绍了几种常用的优化方式，但是尝试使用<code>opt-level = 'z' </code>和<code>lto = true</code>两个选型对tokio最终生成的二进制并没有影响，当然这两个选项对性能有一定的提升。</p>
<p>Jemalloc在1.32版本已经被删除。</p>
<p>panic = 'abort'添加之后编译失败，正常Rust在panic的时候，会记录调用栈，如果改为panic='abort'之后，将会直接退出，而不会打印异常信息。</p>
<p>其他优化手段，如重新编译libstd、#![no_std]不使用标准库，也没有在本次测试范围内。</p>
</li>
</ul>
<h4><a class="header" href="#结论-6" id="结论-6">结论</a></h4>
<p>Rust由于其组名规则和语言特性等原因，在使用了各种优化之后，编译出来的二进制大小大概是C语言的三倍左右，主要增大在代码段和动态符号表上。但是Rust语言比C的表达能力更强，同样的功能下，可以使用更少于C的代码量来实现，所以其二进制的增大还是可以接受。</p>
<h1><a class="header" href="#蚂蚁集团--异步化os利用-asyncawait-带来-10-倍性能提升" id="蚂蚁集团--异步化os利用-asyncawait-带来-10-倍性能提升">蚂蚁集团 | 异步化OS：利用 async/await 带来 10 倍性能提升</a></h1>
<p>作者：蚂蚁集团 田洪亮 / 编辑： 张汉东</p>
<hr />
<p>Rust是第一个对异步I/O提供语言级支持的系统编程语言。自async/await特性在2019年稳定以来，Rust的异步编程生态已经有了长足了发展，比如async运行时有流行的<a href="https://github.com/tokio-rs/tokio">Tokio</a>和<a href="https://github.com/async-rs/async-std">async_std</a>两大选择。最近，Rust官方博客又连续两个月发布了展望async/await未来的博客(<a href="https://blog.rust-lang.org/2021/03/18/async-vision-doc.html">3月</a>和<a href="https://blog.rust-lang.org/2021/04/14/async-vision-doc-shiny-future.html">4月</a>)。async/await特性在社区的受认可和重视程度可见一斑。</p>
<p>那么，如何在我们自己的项目中有效使用async/await特性呢？更进一步，如何搭建属于自己项目的异步架构、运行时和软件栈呢？</p>
<p>本文将分享作者在蚂蚁集团的开源项目Occlum (<a href="https://github.com/occlum/occlum">https://github.com/occlum/occlum</a>)中收获的实战经验。基于async/await特性，我们以一种名为“以异步为中心”的新设计对Occlum做了架构升级，并取得了大幅性能提升的理想效果。</p>
<p>具体来说，我们在实践中遇到并解决了如下一些async/await相关问题：</p>
<ul>
<li>是否值得为一个项目引入async/await？</li>
<li>如何在no_std环境使用async/await？</li>
<li>如何重构大量老代码以适应async/await？</li>
<li>如何充分利用异步优化机会来提升性能？</li>
</ul>
<p>如果你对这些Rust问题或对OS感兴趣，那来听我们的故事吧。</p>
<p>（长文预警，强烈建议阅读前准备充足的水和食物～）</p>
<h2><a class="header" href="#让数据可用而不可见" id="让数据可用而不可见">让数据可用而不可见</a></h2>
<blockquote>
<p>My safe bet: &quot;In 10 years, most chips will have secure enclave capabilities.”
— UC Berkeley华人教授Dawn Song</p>
</blockquote>
<p>任何故事都有一个时代背景，而我们的是机密计算（Confidential Computing）。</p>
<p>机密计算是一种新兴的安全技术，其目标是保护内存中正在使用中数据的机密性和完整性——即便攻击者来自特权级软件（比如OS）也不例外！</p>
<p>这是一个非常强的安全保证，因为传统上来讲，软件栈是按照特权级分层的（特权从低到高）：应用 --&gt; OS --&gt; 虚拟机管理器 --&gt; 固件。应用的安全性依赖于其下的所有特权软件的安全性。但机密计算颠覆了这一传统的安全模型！</p>
<p>那么，机密计算是如何做到这一点的呢？这就要引出机密计算的硬件基础了——可信执行环境（Trusted Execution Environment，简称TEE）。</p>
<p>TEE是由可信硬件（通常是CPU）提供的私有内存区域，能保证其中的代码和数据的安全，即任何TEE外的软硬件都无法窃取或者篡改TEE中的内容。该安全保证是硬件通过访问控制、内存加密等手段实现的。</p>
<p>因此，利用TEE的硬件安全能力，我们就可以实现机密计算的安全保证。</p>
<p>机密计算被广泛应用于公有云安全、隐私保护的机器学习、多方安全计算、区块链等应用场景。</p>
<p>所有的主流体系架构都已经推出了它们的TEE实现：<a href="https://developer.arm.com/ip-products/security-ip/trustzone">ARM TrustZone</a>、<a href="https://www.arm.com/company/news/2021/03/arms-answer-to-the-future-of-ai-armv9-architecture">ARM CCA</a>、<a href="https://developer.amd.com/sev/">AMD SEV</a>、<a href="https://www.intel.com/content/www/us/en/architecture-and-technology/software-guard-extensions.html">Intel SGX</a>、<a href="https://software.intel.com/content/www/us/en/develop/articles/intel-trust-domain-extensions.html">Intel TDX</a>、<a href="https://keystone-enclave.org/">RISC-V Keystone</a>等等。除了CPU以外，GPU以及AI加速器的硬件厂商也在积极筹划引入TEE能力。这也是为什么UC Berkeley的Dawn Song教授几年前就预测，几乎所有芯片都将拥有TEE能力！</p>
<p>目前适用于数据中心的、最成熟、经过最多测试和研究的TEE技术非Intel SGX莫属。在SGX中，TEE被称为Enclave（飞地）。就本文目的而言，我们可以忽略TEE和Enclave的差异，认为两者是同义词即可。</p>
<h2><a class="header" href="#让天下没有难用的tee" id="让天下没有难用的tee">让天下没有难用的TEE</a></h2>
<blockquote>
<p>Enpowering everyone to run every app inside TEEs.
——Occlum的项目目标</p>
</blockquote>
<p>我们故事的主角是开源项目Occlum(<a href="https://github.com/occlum/occlum">https://github.com/occlum/occlum</a>)，它可以将一个未经修改的Linux应用直接放在TEE中运行，从而大大降低使用TEE和采用机密计算的门槛。简而言之，项目使命就是“让天下没有难用的TEE”！</p>
<p><img src="chapter_4/image/ant/5D7D44CD541FCBB88062D99CAD080D61.jpg" alt="IMAGE" />
<strong>图. Occlum的架构图</strong></p>
<p>从架构图可以看到，Occlum本质上是一个面向TEE的OS，向TEE中的可信应用提供Linux兼容的系统调用。Occlum中包含内存管理、进程管理、线程调度、进程间通信、文件和网路I/O等功能。</p>
<p>TEE总是依附于一个普通主机环境运行的（也就是Host OS，通常是Linux）。因此，TEE OS可以在必要的时候请求Host OS的服务，完成某些功能。但因为Host OS是不可信的，因此TEE OS需要确保这种请求是安全的，比如I/O需要做加密解密，防止Host OS窃取或者篡改隐私数据。</p>
<p>出于安全和性能考虑，Occlum的核心部分采用Rust语言开发。</p>
<p>Occlum项目历经三年，已经发展为目前业界最好的开源TEE OS之一。下面列出了部分重要里程碑：</p>
<ul>
<li>2019年3月，项目正式开源；</li>
<li>2020年3月，国际顶级学术会议ASPLOS‘20录用Occlum的论文；</li>
<li>2020年5月，阿里云公布开源项目Inclavare Containers，采用Occlum作为后端引擎；</li>
<li>2020年9月，微软Ignite大会的Azure Confidential Computing在官方文档推荐Occlum；</li>
<li>2020年10月，Linux基金会下属的Confidential Computing Consortium组织接收Occlum为旗下开源项目之一。</li>
</ul>
<h2><a class="header" href="#tee的代价" id="tee的代价">TEE的代价</a></h2>
<blockquote>
<p>There ain't no such thing as a free lunch.
——诺贝尔经济学奖得主Milton Friedman</p>
</blockquote>
<p>No free lunch的道理谁都懂，这当然也适用于安全。具体到TEE的话，就是TEE有一个几乎无法避免的硬件开销——TEE切换。</p>
<p>我们以Intel SGX为例说明（如下图所示）。我们知道CPU有很多执行模式；最为人熟知的，就是用户态（Ring 3）和内核态（Ring 0）。CPU在这两种模式之间做转换，就是用户-内核模式切换。在引入SGX之后，又多了一种模式，即TEE态（也就是Enclave态）。也因此多了一种额外的模式切换，即TEE切换。</p>
<p><img src="chapter_4/image/ant/807CF4872BD959848CC71F31BBFDB0A7.jpg" alt="IMAGE" />
<strong>图. Intel CPU的模式切换，包括Enclave切换</strong></p>
<p>出于安全原因，TEE切换时，CPU要做更多的安全检查，更彻底的状态重置（比如寄存器、cache、TLB等等）。这最终导致TEE切换的开销要远高于传统的模式切换开销。实际上，根据我们的实际测试，TEE切换的开销是用户-内核切换的60倍以上！</p>
<p>而Occlum的原实现（异步化之前）在执行调度和I/O等系统调用时会触发TEE切换。因此，当TEE中的可信应用程序频繁请求Occlum做调度和I/O操作时，用户会观测到比较大的性能下降。</p>
<p>那怎么解决这一性能瓶颈呢？</p>
<p>想必你已经猜到了。对，这就是异步化！</p>
<h2><a class="header" href="#异步os之旅lets-go" id="异步os之旅lets-go">异步OS之旅——Let's Go！</a></h2>
<blockquote>
<p>Asynchrony, in computer programming, refers to the occurrence of events independent of the main program flow and ways to deal with such events... Doing so provides a degree of parallelism.
——维基百科关于“异步”的词条</p>
</blockquote>
<p>对于Occlum来说，异步化对性能有两方面的提升效果：</p>
<ol>
<li><strong>避免TEE切换.</strong> 我们可以通过使用（不可信的）共享缓冲区与Host OS通信，来发起异步I/O的请求和接受异步I/O的完成，这样就可以避免为了I/O而触发TEE切换。</li>
<li><strong>提高OS并行性.</strong> 如维基百科所描述的，异步的好处就是增加并行性，而并行性的增加通常意味着性能提升。实际上，增加OS并行性可以帮助掩盖TEE除切换以外的其他硬件相关性能开销（篇幅所限，无法详细介绍）。</li>
</ol>
<p><img src="chapter_4/image/ant/C7038D5E7E3C455548F68542DC1388C8.jpg" alt="IMAGE" />
<strong>图. 以异步为中心的设计</strong></p>
<p>异步化是一个系统工程。我们提出了一个“以异步为中心的设计”，在四个层面（如上图所示）对Occlum做了相应的异步化改造。接下来，我们从底向上分四个小节依次介绍。</p>
<h3><a class="header" href="#第1站语言层" id="第1站语言层">第1站：语言层</a></h3>
<blockquote>
<p>A language that doesn’t affect the way you think about programming is not worth knowing.
— Alan Perlis</p>
</blockquote>
<p>异步化会引入额外的代码复杂度，这是为什么大家通常都认为异步编程是困难的。</p>
<p>但幸运的是，我们是Rust开发者。Rust的async/await使得异步代码可以用同步代码的方式表达，这大大降低了编写异步代码的头脑负担。更难得的是，Rust对async/await实现，确实达到了零开销抽象（Zero-Cost Abstraction）的设计目标，在运行时只会带来几乎可以忽略不计的开销。</p>
<p>采用Rust的async/await特性，是我们实现异步化的语言层基础。</p>
<p>更多关于Rust的async/await以及异步编程，见<a href="https://rust-lang.github.io/async-book/">The Async Book</a>，这里不再赘述。</p>
<h3><a class="header" href="#第2站调度层" id="第2站调度层">第2站：调度层</a></h3>
<p>运行异步代码依赖于执行器。在异步化的Occlum中，这个执行器就是调度层。</p>
<p>我们的调度层兼具两个职责，分别由Rust异步化的目标与OS语意的功能所决定：</p>
<ol>
<li>调度TEE OS中的协程。我们知道Rust的异步代码的执行单元是任务，或者说协程。一般来说，异步Rust程序中协程的调度是由一个异步运行时负责的，比如Tokio或async_std。但我们的TEE OS中没有现成的异步运行时可用，因此必须由我们自己实现。协程都是我们的OS代码，因此协作式调度就足够了。</li>
<li>调度TEE OS上的用户线程。作为TEE OS，Occlum必须要为其上的可信应用提供进程和线程这两种OS资源。而且，因为可信应用的代码可以由任何语言编写，可能执行任意复杂的代码逻辑，因此Occlum有必要实现抢占式调度。</li>
</ol>
<p>为了同时承担上述两个职责，我们在TEE中实现了一种M:N:P的调度模型（如下图所示）。</p>
<p><img src="chapter_4/image/ant/D57E7CC9464F1C81AF1D5358D579D7E8.jpg" alt="IMAGE" />
<strong>图. 异步化Occlum的调度层</strong></p>
<p>在该调度模型中，处于中心地位的是TEE OS协程（数量记为N），他们具有内存占用少、启动延迟低、上下文切换快等协程的典型优点。这些协程是运行在Host OS的线程之上的（数量记为P），P的数量决定了硬件层面的并行性和CPU资源占用，可由用户在运行时指定。TEE OS协程既可以用于执行OS任务，也可以运行应用任务，而后者就是TEE OS的用户线程（数量记为M，且有M&lt;=N）。我们实现了TEE的中断处理，因此可以强迫用户线程放弃CPU，实现抢占式调度。</p>
<p>相比Occlum原先的调度层（限于篇幅而没有介绍），异步化改造之后的调度层具有下面两方面的优势：</p>
<ol>
<li>完全TEE内调度，不会引发TEE切换，因此调度相关的性能大幅提升；</li>
<li>引入了非常轻量的协程，这使得TEE OS可以以低成本和开销创建协程来增加OS的并行性，从而提高TEE OS的整体性能。</li>
</ol>
<h3><a class="header" href="#第3站io层" id="第3站io层">第3站：I/O层</a></h3>
<p>有了调度层，异步代码已经可以执行了，我们的下一步就是要支持异步I/O。</p>
<p>在异步化的Occlum中，我们引入了<a href="https://lwn.net/Articles/810414/">Linux的异步I/O机制io_uring</a>，这是一个Linux的非常新的特性，首次合入是在5.1版，目前仍在快速发展和迭代中。基于io_uring之后，Occlum的底层I/O就是如下图所示的样子了。</p>
<p>![IMAGE](resources/BD85FC29BE588B9641746B91752E34D7.jpg =581x367)</p>
<p>我们认为io_uring与Occlum的异步化架构可以说天作之合，理由有二：</p>
<ol>
<li><strong>io_uring支持基于polling模式的I/O.</strong> Polling模式使得Occlum和Linux之间的通信只需要访问共享内存（即I/O的submission queue和completion queue），不需要做TEE切换，因此避免TEE切换的开销。</li>
<li><strong>io_uring提供真正的异步I/O接口.</strong> io_uring的API是真正的异步I/O：Occlum在发起I/O之后，并不需要等待该I/O的完成即可继续发起其他I/O（I/O并行性）或者执行其他代码逻辑（代码并行性）。</li>
</ol>
<p>io_uring被认为是<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-5.6-IO-uring-Tests">目前Linux提供的最快的I/O机制</a>（无论是做网络还是磁盘I/O），而且其性能<a href="https://kernel.dk/io_uring.pdf">还在持续提升</a>。但io_uring在接口上与传统I/O差异巨大，这要求应用做大幅修改和适配才能用上io_uring。而Occlum可以让TEE中的可信应用透明地获得io_uring的好处，“免费”获得性能提升。</p>
<h3><a class="header" href="#第4步内核层" id="第4步内核层">第4步：内核层</a></h3>
<p>我们的终极目标是，提升Occlum的系统调用的性能。</p>
<p>为此，我们提出了两类异步优化技巧：积极执行（Eager Execution）和承诺执行（Promised Execution）。</p>
<p><strong>积极执行</strong>是一种在用户真正发起系统调用之前、就提前实施某种高耗时操作的异步优化技巧。由于高耗时操作已经提前发起执行，当用户向Occlum请求系统调用时，该高耗时操作很可能已经完成，这样Occlum可以直接返回结果。这就大大降低了用户可见的系统调用开销，也就是延迟。</p>
<p>积极执行主要适用于<code>read</code>类的系统调用，比如<code>read</code>、<code>recvmsg</code>、<code>accept</code>等系统调用。我们可以在用户发起这些系统调用之前，提前用io_uring发起相应的异步I/O，然后把返回结果暂存起来。取决于具体的系统调用，暂存结果的数据结构可能是文件系统的page cache、已连接socket的接收缓冲区、或监听socket的backlog等等。</p>
<p><strong>承诺执行</strong>是一种延后高耗时操作执行、不等高耗时操作完成就提前返回系统调用结果的异步优化技巧。由于避免了对高耗时操作的等待，用户可见的系统调用延迟被大幅降低。承诺执行的关键在于对高耗时操作的延后执行不能影响相关系统调用的语意。</p>
<p>承诺执行主要适用于<code>write</code>类的系统调用，比如<code>write</code>和<code>sendmsg</code>等系统调用。当收到这类系统调用之后，我们可以先把这类数据暂存起来，然后就可以立刻返回该系统调用了。在未来某个合适的时间点，我们通过io_uring真正发起相应的I/O。取决于具体的系统调用，暂存结果的数据结构可能是文件系统的page cache、或已连接socket的发送缓冲区等等。</p>
<p>不管是积极执行、还是承诺执行，我们都通过异步的方法，降低了用户可感知的系统调用延迟，从而提高了应用程序的性能。</p>
<h3><a class="header" href="#终点站性能评估" id="终点站性能评估">终点站：性能评估</a></h3>
<p>为了评估“以异步为中心”设计的性能优化效果，我们比较了异步化Occlum（Next-Gen Occlum，简称NGO）和Linux在调度、网络I/O、文件I/O等方面的性能。结果显示（下图的三张图），异步化Occlum在这三个方面都达到了Linux的性能水平。而相对于异步化之前，Occlum的性能取得了显著的10X以上的提升（虽然图表中没有展示）。</p>
<p><img src="chapter_4/image/ant/D9C871036AF7429E8C2C3533E4E3280A.jpg" alt="IMAGE" />
<strong>图. 调度性能（其中NGO表示异步化Occlum）</strong></p>
<p><img src="chapter_4/image/ant/04CB926BD47FB8B1C7405B9BFCFF7163.jpg" alt="IMAGE" />
<strong>图. 网络I/O性能（其中NGO表示异步化Occlum）</strong></p>
<p><img src="chapter_4/image/ant/B52295D13FAE28E54EDB167BCA3D64F3.jpg" alt="IMAGE" />
<strong>图. （非加密）文件I/O性能（其中NGO表示异步化Occlum）</strong></p>
<h2><a class="header" href="#旅程的尾声" id="旅程的尾声">旅程的尾声</a></h2>
<p>对读到这里的读者，我想向你表示感谢，谢谢你的兴趣和耐心。希望我们在Rust的异步编程方面的探索和实践对你也能有所启发和帮助。</p>
<p>如果你对Rust编程、底层软件、系统安全或机密计算等方面感兴趣，欢迎联系我（email: tate.thl@antgroup.com，WeChat ID：tatetian），期待与你相遇。</p>
<h1><a class="header" href="#蚂蚁集团--trait-使用及实现分析" id="蚂蚁集团--trait-使用及实现分析">蚂蚁集团 | Trait 使用及实现分析</a></h1>
<p>作者：Jiacai Liu / 后期编辑：张汉东</p>
<hr />
<ul>
<li><a href="chapter_4/ant_trait.html#org2ef86fc">使用方式</a>
<ul>
<li><a href="chapter_4/ant_trait.html#org8e6944f">静态派发</a></li>
<li><a href="chapter_4/ant_trait.html#org701d455">动态派发</a></li>
<li><a href="chapter_4/ant_trait.html#org477c7d4">impl trait</a></li>
</ul>
</li>
<li><a href="chapter_4/ant_trait.html#orgd875cd7">常见问题</a>
<ul>
<li><a href="chapter_4/ant_trait.html#orgd1f35e7">向上转型（upcast）</a></li>
<li><a href="chapter_4/ant_trait.html#org9b7752f">Object safety</a></li>
</ul>
</li>
<li><a href="chapter_4/ant_trait.html#org414df86">总结</a></li>
<li><a href="chapter_4/ant_trait.html#orge4c5893">参考</a></li>
</ul>
<p>在 Rust 设计目标中，零成本抽象是非常重要的一条，它让 Rust 具备高级语言表达能力的同时，又不会带来性能损耗。零成本的基石是范型与 trait，它们可以在编译期把高级语法编译成与高效的底层代码，从而实现运行时的高效。这篇文章就来介绍 trait，包括使用方式与两个常见问题的分析，在问题探究的过程中来阐述其实现原理。</p>
<p><a id="org2ef86fc"></a></p>
<h1><a class="header" href="#使用方式" id="使用方式">使用方式</a></h1>
<p>Trait 的主要作用是用来抽象行为，类似于其他编程语言中的「接口」，这里举一示例阐述 trait 的主要使用方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Greeting {
    fn greeting(&amp;self) -&gt; String;
}

struct Cat;
impl Greeting for Cat {
    fn greeting(&amp;self) -&gt;String {
        &quot;Meow...&quot;.to_string()
    }
}

struct Dog;
impl Greeting for Dog {
    fn greeting(&amp;self) -&gt;String {
        &quot;Bark...&quot;.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在上述代码中，定义了一个 trait Greeting，两个 struct 实现了它，根据函数调用方式，主要两种使用方式：</p>
<ul>
<li>基于范型的静态派发</li>
<li>基于 trait object 的动态派发</li>
</ul>
<p>范型的概念比较常见，这里着重介绍下 trait object 的<a href="https://doc.rust-lang.org/1.51.0/reference/types/trait-object.html">定义</a>：</p>
<blockquote>
<p>A trait object is an opaque value of another type that implements a set of traits. The set of traits is made up of an object safe base trait plus any number of auto traits.</p>
</blockquote>
<p>比较重要的一点是 trait object 属于 <a href="https://doc.rust-lang.org/1.51.0/reference/dynamically-sized-types.html">Dynamically Sized Types</a>（DST），在编译期无法确定大小，只能通过指针来间接访问，常见的形式有 <code>Box&lt;dyn trait&gt;</code> <code>&amp;dyn trait</code> 等。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_greeting_static&lt;G: Greeting&gt;(g: G) {
    println!(&quot;{}&quot;, g.greeting());
}
fn print_greeting_dynamic(g: Box&lt;dyn Greeting&gt;) {
    println!(&quot;{}&quot;, g.greeting());
}

print_greeting_static(Cat);
print_greeting_static(Dog);

print_greeting_dynamic(Box::new(Cat));
print_greeting_dynamic(Box::new(Dog));

<span class="boring">}
</span></code></pre></pre>
<p><a id="org8e6944f"></a></p>
<h2><a class="header" href="#静态派发" id="静态派发">静态派发</a></h2>
<p>在 Rust 中，范型的实现采用的是单态化（monomorphization），会针对不同类型的调用者，在编译时生成不同版本的函数，所以范型也被称为<a href="https://bluejekyll.github.io/blog/posts/type-parameters/">类型参数</a>。好处是没有虚函数调用的开销，缺点是最终的二进制文件膨胀。在上面的例子中， <code>print_greeting_static</code> 会编译成下面这两个版本：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_greeting_static_cat(Cat);
print_greeting_static_dog(Dog);
<span class="boring">}
</span></code></pre></pre>
<p><a id="org701d455"></a></p>
<h2><a class="header" href="#动态派发" id="动态派发">动态派发</a></h2>
<p>不是所有函数的调用都能在编译期确定调用者类型，一个常见的场景是 GUI 编程中事件响应的 callback，一般来说一个事件可能对应多个 callback 函数，而这些 callback 函数都是在编译期不确定的，因此范型在这里就不适用了，需要采用动态派发的方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ClickCallback {
    fn on_click(&amp;self, x: i64, y: i64);
}

struct Button {
    listeners: Vec&lt;Box&lt;dyn ClickCallback&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><a id="org477c7d4"></a></p>
<h2><a class="header" href="#impl-trait" id="impl-trait">impl trait</a></h2>
<p>在 Rust 1.26 版本中，引入了一种新的 trait 使用方式，即：<a href="https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html">impl trait</a>，可以用在两个地方：函数参数与返回值。 该方式主要是简化复杂 trait 的使用，算是范型的特例版，因为在使用 impl trait 的地方，也是静态派发，而且作为函数返回值时，数据类型只能有一种，这一点要尤为注意！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_greeting_impl(g: impl Greeting) {
    println!(&quot;{}&quot;, g.greeting());
}
print_greeting_impl(Cat);
print_greeting_impl(Dog);

// 下面代码会编译报错
fn return_greeting_impl(i: i32) -&gt; impl Greeting {
    if i &gt; 10 {
        return Cat;
    }
    Dog
}

// | fn return_greeting_impl(i: i32) -&gt; impl Greeting {
// |                                    ------------- expected because this return type...
// |     if i &gt; 10 {
// |         return Cat;
// |                --- ...is found to be `Cat` here
// |     }
// |     Dog
// |     ^^^ expected struct `Cat`, found struct `Dog`
<span class="boring">}
</span></code></pre></pre>
<p><a id="orgd875cd7"></a></p>
<h1><a class="header" href="#常见问题" id="常见问题">常见问题</a></h1>
<p><a id="orgd1f35e7"></a></p>
<h2><a class="header" href="#向上转型upcast" id="向上转型upcast">向上转型（upcast）</a></h2>
<p>对于 <code>trait SubTrait: Base</code> ，在目前的 Rust 版本中，是无法将 <code>&amp;dyn SubTrait</code> 转换到 <code>&amp;dyn Base</code> 的。这个限制与 trait object 的内存结构有关。</p>
<p>在 <a href="https://iandouglasscott.com/2018/05/28/exploring-rust-fat-pointers/">Exploring Rust fat pointers</a> 一文中，该作者通过 transmute 将 trait object 的引用转为两个 usize，并且验证它们是指向数据与函数虚表的指针：</p>
<pre><pre class="playground"><code class="language-rust">use std::mem::transmute;
use std::fmt::Debug;

fn main() {
    let v = vec![1, 2, 3, 4];
    let a: &amp;Vec&lt;u64&gt; = &amp;v;
    // 转为 trait object
    let b: &amp;dyn Debug = &amp;v;
    println!(&quot;a: {}&quot;, a as *const _ as usize);
    println!(&quot;b: {:?}&quot;, unsafe { transmute::&lt;_, (usize, usize)&gt;(b) });
}

// a: 140735227204568
// b: (140735227204568, 94484672107880)
</code></pre></pre>
<p>从这里可以看出：Rust 使用 fat pointer（即两个指针） 来表示 trait object 的引用，分布指向 data 与 vtable，这和 Go 中的 <a href="https://research.swtch.com/interfaces">interface</a> 十分类似。</p>
<p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01esAA7q1z6A3inQpnF_!!581166664.jpg" alt="img" title="trait object reference" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TraitObjectReference {
    pub data: *mut (),
    pub vtable: *mut (),
}

struct Vtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -&gt; String,
}
<span class="boring">}
</span></code></pre></pre>
<p>尽管 fat pointer 导致指针体积变大（无法使用 Atomic 之类指令），但是好处是更明显的：</p>
<ol>
<li>
<p>可以为已有类型实现 trait（比如 <a href="https://users.rust-lang.org/t/what-are-blanket-implementations/49904">blanket implementations</a>）</p>
</li>
<li>
<p>调用虚表中的函数时，只需要引用一次，而在 C++ 中，vtable 是存在对象内部的，导致每一次函数调用都需要两次引用，如下图所示：</p>
<p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01u6ms841z6A3cHRdJw_!!581166664.jpg" alt="img" title="cpp vtable two-level indirect" /></p>
</li>
</ol>
<p>如果 trait 有继承关系时，vtable 是怎么存储不同 trait 的方法的呢？在目前的实现中，是依次存放在一个 vtable 中的，如下图：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01x8adaQ1z6A3bkyKqY_!!581166664.png" alt="img" title="多 trait 时 vtable 示意图" /></p>
<p>可以看到，所有 trait 的方法是顺序放在一起，并没有区分方法属于哪个 trait，这样也就导致无法进行 upcast，社区内有 <a href="https://github.com/rust-lang/rfcs/issues/2765">RFC 2765</a> 在追踪这个问题，感兴趣的读者可参考，这里就不讨论解决方案了，介绍一种比较通用的<a href="http://stackoverflow.com/a/28664881/403742">解决方案</a>，通过引入一个 AsBase 的 trait 来解决：</p>
<pre><pre class="playground"><code class="language-rust">trait Base {
    fn base(&amp;self) {
        println!(&quot;base...&quot;);
    }
}

trait AsBase {
    fn as_base(&amp;self) -&gt; &amp;dyn Base;
}

// blanket implementation
impl&lt;T: Base&gt; AsBase for T {
    fn as_base(&amp;self) -&gt; &amp;dyn Base {
        self
    }
}

trait Foo: AsBase {
    fn foo(&amp;self) {
        println!(&quot;foo..&quot;);
    }
}

#[derive(Debug)]
struct MyStruct;

impl Foo for MyStruct {}
impl Base for MyStruct {}

fn main() {
    let s = MyStruct;
    let foo: &amp;dyn Foo = &amp;s;
    foo.foo();
    let base: &amp;dyn Base = foo.as_base();
    base.base();
}
</code></pre></pre>
<p><a id="org9b7752f"></a></p>
<h2><a class="header" href="#object-safety" id="object-safety">Object safety</a></h2>
<p>在 Rust 中，并不是所有的 trait 都可用作 trait object，需要满足一定的条件，称之为 <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects">object safety</a> 属性。主要有以下几点：</p>
<ol>
<li>
<p>函数返回类型不能是 Self（即当前类型）。这主要因为把一个对象转为 trait object 后，原始类型信息就丢失了，所以这里的 Self 也就无法确定了。</p>
</li>
<li>
<p>函数中不允许有范型参数。主要原因在于单态化时会生成大量的函数，很容易导致 trait 内的方法膨胀。比如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T);
    // more methods
}

// 10 implementations
fn call_foo(thing: Box&lt;Trait&gt;) {
    thing.foo(true); // this could be any one of the 10 types above
    thing.foo(1);
    thing.foo(&quot;hello&quot;);
}

// 总共会有 10 * 3 = 30 个实现
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Trait 不能继承 Sized。这是由于 Rust 会默认为 trait object 实现该 trait，生成类似下面的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn method1(&amp;self);
    fn method2(&amp;mut self, x: i32, y: String) -&gt; usize;
}

// autogenerated impl
impl Foo for TraitObject {
    fn method1(&amp;self) {
        // `self` is an `&amp;Foo` trait object.

        // load the right function pointer and call it with the opaque data pointer
        (self.vtable.method1)(self.data)
    }
    fn method2(&amp;mut self, x: i32, y: String) -&gt; usize {
        // `self` is an `&amp;mut Foo` trait object

        // as above, passing along the other arguments
        (self.vtable.method2)(self.data, x, y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果 Foo 继承了 Sized，那么就要求 trait object 也是 Sized，而 trait object 是 DST 类型，属于 <code>?Sized</code> ，所以 trait 不能继承 Sized。</p>
<p>对于非 safe 的 trait，能修改成 safe 是最好的方案，如果不能，可以尝试范型的方式。</p>
</li>
</ol>
<p><a id="org414df86"></a></p>
<h1><a class="header" href="#总结-5" id="总结-5">总结</a></h1>
<p>本文开篇就介绍了 trait 是实现零成本抽象的基础，通过 trait 可以为已有类型增加新方法，这其实解决了<a href="https://en.wikipedia.org/wiki/Expression_problem">表达式问题</a>，可以进行运算符重载，可以进行面向接口编程等。希望通过本文的分析，可以让读者更好的驾驭 trait 的使用，在面对编译器错误时，能够做到游刃有余。</p>
<p><a id="orge4c5893"></a></p>
<h1><a class="header" href="#参考-1" id="参考-1">参考</a></h1>
<ul>
<li><a href="https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM">想要改变世界的 Rust 语言</a></li>
<li><a href="https://blog.rust-lang.org/2015/05/11/traits.html">Abstraction without overhead: traits in Rust</a></li>
<li><a href="http://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/">Peeking inside Trait Objects</a></li>
<li><a href="http://huonw.github.io/blog/2015/01/object-safety">Object Safety</a></li>
<li><a href="https://lukasatkinson.de/2018/interface-dispatch/">Interface Dispatch</a></li>
<li><a href="https://www.possiblerust.com/pattern/3-things-to-try-when-you-can-t-make-a-trait-object">3 Things to Try When You Can't Make a Trait Object</a></li>
</ul>
<p><a id="org9f48097"></a></p>
<h1><a class="header" href="#关于我们-2" id="关于我们-2">关于我们</a></h1>
<p>我们是蚂蚁智能监控技术中台的时序存储团队，我们正在使用 Rust 构建高性能、低成本并具备实时分析能力的新一代时序数据库，欢迎加入或者推荐，目前我们也正在寻找优秀的实习生，也欢迎广大应届同学来我们团队实习，请联系：jiachun.fjc@antgroup.com</p>
<h1><a class="header" href="#知乎--基于-simd-指令优化-rucene" id="知乎--基于-simd-指令优化-rucene">知乎 | <strong>基于</strong> <strong>SIMD</strong> <strong>指令优化</strong> <strong>Rucene</strong></a></h1>
<p>作者：<em>知乎搜索技术团队</em> / 后期编辑：张汉东</p>
<hr />
<p><em>Rucene</em>，是知乎搜索技术团队基于 <em>Lucene</em>、使用 <em>Rust</em> 语言重写的一套搜索引擎核心库。对外，<em>Rucene</em> 负责知乎搜索和推荐两大核心业务的召回；对内，<em>Rucene</em> 支撑了知乎公司级的 <em>Logging</em> 服务。2019 年，我们已将 <em>Rucene</em> 开源到 <em>Github</em>，项目地址：https://github.com/zhihu/rucene。</p>
<p><em>SIMD</em>，即 <em>Single Instruction Multiple Data</em>，单指令多数据，通俗来讲，就是借助现代 <em>CPU</em> 架构中提供的扩展指令集，比如 <em>SSE</em>、<em>AVX</em> 等，通过一条 <em>CPU SIMD</em> 指令，一次对多个数据进行并行存取和计算。</p>
<p>目前，在中文互联网上，很少有文章针对具体业务介绍 <em>SIMD</em> 优化的，具体到 <em>Rust</em> 语言，就更是少之又少。本文基于知乎搜索团队对 <em>Rucene</em> 的一些优化实践，总结下如何利用 <em>SIMD</em> 指令优化 <em>Rust</em> 程序。</p>
<p>利用 <em>SIMD</em> 优化程序，大体有三个主要途径：一是让编译器去做优化，这是一种尽力而为的行径，也依赖于编译器具体实现（笔者在调研 <em>SIMD</em> 过程中了解到，<em>Java</em> 中要使用 <em>SIMD</em> 需要按照一些约定来编写程序，然后可以让 <em>JVM</em> 去尽量做 <em>SIMD</em> 优化，对 <em>Java</em> 中使用 <em>SIMD</em> 感兴趣的同学可以参考下 <em>Lucene</em> 最新版本中关于这个话题的讨论）； 二是使用第三方库，借助别人封装好的库，通过简单调用，针对一些特定场景做 <em>SIMD</em> 优化，比如 <em>simdjson</em>、<em>Rust</em> 中的 <em>faster</em> 库等；三是直接手撕 <em>SIMD</em> 指令，针对具体的业务特点，有时很难直接调用封装库来使用 <em>SIMD</em>，这种情况只能自己编写调用 <em>SIMD</em> 指令的程序。接下来，本文将从这三个方面做下介绍。</p>
<h2><a class="header" href="#rust-编译器参数调优" id="rust-编译器参数调优"><strong>Rust</strong> <strong>编译器参数调优</strong></a></h2>
<p>我们翻阅了 <em>Rust</em> 官方提供的 <em>rustc</em> 和 <em>cargo</em> 的相关文档，没有发现和 <em>SIMD</em> 优化相关的内容，但在这个过程中，我们发现有三个编译参数，通过合理配置，可以明显提升 <em>Rucene</em> 的性能，其使用方式如下所示，每个参数的具体含义可以参考官方文档，这里不做详细介绍。</p>
<pre><code class="language-toml">#使用方式一：配置 Cargo.toml
[profile.release]
lto=true
opt_level=3
codegen_units=1

#使用方式二：通过环境变量传递给 cargo
CARGO_PROFILE_RELEASE_LTO=true \
CARGO_PROFILE_RELEASE_OPT_LEVEL=3 \
CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1 \
cargo build --release
</code></pre>
<p>使用这三个参数配置有两点需要注意：一是编译过程会变得非常慢，我们的解决方法是使用第二种方式，仅在镜像发布构建时使用；二是并不是所有程序都会有效，我们的一些简单服务使用这三个参数没有任何效果，反而增加了编译时间。因此，当你的 <em>Rust</em> 程序相对复杂的时候，我们建议你尝试使用这三个参数来优化程序性能。</p>
<h2><a class="header" href="#使用-faster-库优化-embbeding-计算" id="使用-faster-库优化-embbeding-计算"><strong>使用</strong> <strong>faster</strong> <strong>库优化</strong> <strong>Embbeding</strong> <strong>计算</strong></a></h2>
<p>2020 年，我们尝试在引擎端做 <em>Embbeding</em> 召回提权，当时灰度上线后，<em>P95</em> 上涨明显，我们用 <em>faster</em> 库做向量计算优化后，<em>P95</em> 上涨控制在了可接受范围。大家不用关心什么是 <em>Embbeding</em>，需要解决的问题就是优化向量内积计算。以下第一段代码是普通的内积计算，第二段代码是使用 <em>faster</em> 利用 <em>SIMD</em> 指令的编写方式。随着向量维度的增加，<em>SIMD</em> 的方式性能优势会非常明显。<em>faster</em> 库的具体使用，大家可以参考相关文档。</p>
<pre><pre class="playground"><code class="language-rust">// 简单的内积计算示例
fn main() {
    let mut score = 0.0;
    let dots1: Vec&lt;f32&gt; = vec![1.04177, 0.28162, 2.02021];
    let dots2: Vec&lt;f32&gt; = vec![1.59189, 1.94172, 1.02021];
    for i in 0..dots1.len() {
        score += dots1[i] * dots2[i];
    }
    println!(&quot;score={}&quot;, score);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">use faster::{f32s, IntoSIMDRefIterator, IntoSIMDZip, SIMDZippedIterator};
// 使用 faster SIMD 库优化向量内积计算
fn main() {
    let dots1: Vec&lt;f32&gt; = vec![1.04177, 0.28162, 2.02021];
    let dots2: Vec&lt;f32&gt; = vec![1.59189, 1.94172, 1.02021];
    let score = (dots1.simd_iter(f32s(0.0)), dots2.simd_iter(f32s(0.0)))
        .zip()
        .simd_reduce(f32s(0.0), |acc, (a, b)| acc + a * b)
        .sum();
    println!(&quot;score = {}&quot;, score);
}
</code></pre></pre>
<h2><a class="header" href="#使用-simd-指令优化倒排链的解压缩性能" id="使用-simd-指令优化倒排链的解压缩性能"><strong>使用</strong> <strong>SIMD</strong> <strong>指令优化倒排链的解压缩性能</strong></a></h2>
<p><em>Rucene</em> 的高效检索基于倒排索引，倒排索引中的倒排链按文档 <em>ID</em> 升序排列，128 个文档 <em>ID</em> 组成一个压缩的 <em>block</em>。搜索引擎提供在线检索服务时，大量 <em>block</em> 的解压操作是引擎的一个主要性能瓶颈点。接下来，我们撇开搜索引擎，将问题描述的更直白一些。</p>
<p>一个 <em>block</em> 中存 128 个整数，升序，以前 8 个数为例:
1，3，8，15，19，31，58，100，…</p>
<p>相邻数字相减，差值称为 <em>delta</em>，第一个数减去上一个 <em>block</em> 的最后一个数，假使这是第一个块，第一个数减去 0，得到以下 <em>delta</em> 序列:
1，2，5，7，4，12，27，42，…</p>
<p>假使 128 个 <em>delta</em> 之中 42 是最大值，其二进制表示 101010，共计 6 个有效位，那么128 个 <em>delta</em> 值全部用 6 个 <em>bit</em> 位存储。</p>
<p>原先的存储方案:一个挨着一个串行存储
1				 2         	  5              7              4               12             27            42              	…
000001      000010    000101   000111   000100    001100    011011   101010    	 ...</p>
<p><em>SIMD</em> 存储方案：并行存储，前 4 个数存储在紧邻的 4 个 i32 的低 6 位，后 4 个数存储在这 4 个i32 的第 7～第 12 个 <em>bit</em> 位上</p>
<p>→    第一个 i32   ←   <strong>|</strong>   –&gt;    第二个 i32    ←   <strong>|</strong>   –&gt;   第三个 i32   ←   <strong>|</strong>   –&gt;   第四个 i32   ←  <strong>|</strong> 
<strong>000001</strong> <font color='#ff0000'>
<strong>000100</strong></font> ...      <strong>000010</strong> 001100 ...          <strong>000101</strong> 011011 ...          <strong>000111</strong> 101010 ...  ......
<strong>1</strong>            <font color='#ff0000'>
<strong>4</strong></font>                     <strong>2</strong>            12                       <strong>5</strong>            27                       <strong>7</strong>            42               …</p>
<p>下面的示意图应该会更清晰些</p>
<p><img src="chapter_4/image/zhihu/image12.png" alt="" /></p>
<p>4 个 i32 作为一个存储单元，第一个数存储在第一个 i32 的低六位，第二个数存储在第二个 i32 的低六位，第三个数存储在第三个 i32 的低六位，第四个数存储在第四个 i32 的低六位，第五个数存储在第一个 i32 的第二个六位，依次类推。1 至 32 的位宽都可以用 4n 个 i32 存下，1 位的位宽需要 4 个 i32，32 位的位宽需要 128 个 i32 存储。数据是对齐的，不存在 4 个 i32 中有些 i32 存满了，有些没存满的情况，非常适合并行操作。</p>
<p>解决完如何存储，剩下的解压操作就相对简单了。用一条 <em>SIMD</em> 加载指令读取 4 个 i32，用 <em>SIMD</em> 的按位与操作，取 4 个 i32 的低 6 位，获取前 4 个整数值，然后，4 个 i32 同时右移 6 个 <em>bit</em>，再做按位与操作，又获取 <em>4</em> 个整数值，依此类推。下图列出示例代码片段和 <em>SIMD</em> 优化中用到的几个主要指令。详细 <em>SIMD</em> 指令介绍可以查看 <em>Rust</em> 标准库文档或 <em>Intel</em> 的官方指令集文档，具体的代码实现可以查看 <em>Rucene</em> 的对应 <em>MR</em>。</p>
<p><em>MR</em>：https://github.com/zhihu/rucene/commit/6629d2f7971bdc7ff113dbfa627b291bbfb257e9</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//解压前4个i32的伪代码：
mask = _mm_set1_epi32(0b111111)                      // 设置掩码
values = _mm_lddqu_si128(block_ptr)                  // 加载4个i32
new_values = _mm_and_si128(values, mask)             // 还原4个i32
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//主要用到的sse指令（共10条）：
_mm_set1_epi32        // 4个i32设为同一个值
_mm_lddqu_si128       // 加载4个i32到寄存器
_mm_storeu_si128      // 存储4个i32到内存
_mm_and_si128         // 128位按位与操作 
_mm_or_si128          // 128位按位或操作
_mm_slli_epi32        // 4个i32同时左移指定位数
_mm_srli_epi32        // 4个i32同时右移指定位数
_mm_sub_epi32         // 4个i32对另外4个i32做减法操作
_mm_add_epi32         // 4个i32对另外4个i32做加法操作
_mm_cvtsi128_si32     // 取4个i32中最右边的一个
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#优化效果" id="优化效果"><strong>优化效果</strong></a></h2>
<p>我们先后上线了两个优化版本：一个是部分解压 + 编译器参数调优版本，这个版本，单就编译器参数调优这一点，大概有 10% 的性能提升；第二个是 <em>SIMD</em> 的优化版本，这个版本在第一个优化基础上，大概又有 15% 的性能提升。总体来看，<em>benchmark</em> 测试，性能提升明显，引擎 <em>Merger P95</em> 总体下降 30%+。以下是一些性能表现截图：</p>
<p>版本说明：</p>
<p><em>Rucene-stdbase</em>：	  <em>Rucene</em> 基线版本
<em>Rucene-partial</em>：	    按需解压 + 编译器参数调优版本
<em>Rucene-simdnew</em>：	<em>SIMD</em> 优化版本</p>
<p><img src="chapter_4/image/zhihu/image6.png" alt="" /></p>
<center>求交操作性能对比</center>
<p><img src="chapter_4/image/zhihu/image10.png" alt="" /></p>
<center>求或操作性能对比</center>
<p><img src="chapter_4/image/zhihu/image8.png" alt="" /></p>
<center>按需解压 + 编译器参数调优 P95 降 20%+</center>
<p><img src="chapter_4/image/zhihu/image3.png" alt="img" /></p>
<center>SIMD 版本上线前 P95</center>
<p><img src="chapter_4/image/zhihu/image1.png" alt="img" /></p>
<center>SIMD 版本上线后 P95</center>
<p><img src="chapter_4/image/zhihu/image4.png" alt="img" /></p>
<center>SIMD 版本上线 P95 再降 15% 左右（PS：图中抖动是附带上线的其他 MR 所致）</center>
<h2><a class="header" href="#总结-6" id="总结-6"><strong>总结</strong></a></h2>
<p>本文结合程序中使用 <em>SIMD</em> 技术的三种可能途径，概述了知乎搜索技术团队在 <em>Rucene</em> 优化中落地 <em>SIMD</em> 优化的一些实践经验。我们自身对 <em>CPU</em> 指令集相关技术的了解也比较有限，也是摸着石头过河，文中如有谬误之处，欢迎读者批评指正。</p>
<h2><a class="header" href="#参考资料" id="参考资料"><strong>参考资料</strong></a></h2>
<ol>
<li>基于 SIMD 指令的 PFOR-DELTA 解压和查找：https://zhuanlan.zhihu.com/p/63662886</li>
<li>索引压缩算法New PForDelta简介以及使用SIMD技术的优化：https://yq.aliyun.com/articles/563081</li>
<li>SIMD应用：https://www.zhihu.com/market/pub/119608271/manuscript/1102576357040644096Intel </li>
<li>intrinsics guide：https://software.intel.com/sites/landingpage/IntrinsicsGuide/</li>
</ol>
<h2><a class="header" href="#招聘信息" id="招聘信息"><strong>招聘信息</strong></a></h2>
<p>知乎搜索技术团队目前在招前端、后端、搜索引擎开发人员，欢迎感兴趣的同学踊跃投递简历，邮箱 wangjingjing@zhihu.com。</p>
<h1><a class="header" href="#datenlord--io_uring-rust-异步库实现方法" id="datenlord--io_uring-rust-异步库实现方法">Datenlord | io_uring Rust 异步库实现方法</a></h1>
<p>作者：施继成 / 后期编辑：张汉东</p>
<hr />
<h2><a class="header" href="#简介" id="简介">简介</a></h2>
<p>io_uring 是 Linux 最新的异步 I/O 接口，采用两个用户和内核共享的 ring buffer 进行交互，性能优于之前的接口且限制更少。虽然 io_uring 仍然处于开发迭代中，但是基本的 I/O 接口已经基本定型，作为高效系统语言的 Rust 则成为使用该接口的不二之选。现在已经有许多针对 io_uring 的 Rust 封装，但是有的存在soundness问题，有的存在性能问题，都不是安全高效 I/O 的好选项。我们团队（DatenLord）也进行了自己的尝试，本文就是介绍我们的 io_uring 异步库实现方法。</p>
<h2><a class="header" href="#rust-现有异步模式" id="rust-现有异步模式">Rust 现有异步模式</a></h2>
<p>Rust 的异步库都有自己的异步 I/O 实现方法，但是内部原理大同小异，都是 Reactor 模式，如下图所示:</p>
<p><img src="chapter_4/./image/io_uring/reactor.jpg" alt="reactor" /></p>
<p>Worker 线程将关注的 fd 注册到 Epoll 等待队列中，Reactor 线程通过 Epoll wait 等待可以进行操作的 fd，当有 fd 可以操作时，Reactor 线程通知 Worker 线程进行真正的 I/O 操作。在此过程中，Reactor 线程仅仅起到等待和通知的作用，并不真正进行 I/O 操作，并且这里的 I/O 接口仍然是同步 I/O 接口。这种模式就好比请人帮忙烧开水，但是泡茶的过程还是自己亲自来。</p>
<p>Reactor 模式中，内存 buffer 一直在用户的控制下，在进行真正的 I/O 操作发生前，随时可以cancel正在等待的请求，因此Reactor 模式中不存在内存data race的情况，接口也就顺势使用了 reference，及借用机制。接口示例如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut [u8]) -&gt; ImplFuture&lt;'a, Result&lt;usize&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#io_uring-rust-底层封装" id="io_uring-rust-底层封装">io_uring Rust 底层封装</a></h2>
<p>io_uring 的官方库只有 C 语言版本及 <a href="https://github.com/axboe/liburing">liburing</a>，因此 Rust 异步封装之前必须有一套可用的 Rust 底层封装。这一层封装大家有不同的选择：有的选择自己从头实现，如 tokio 的 <a href="https://github.com/tokio-rs/io-uring">io-uring</a>；我们的选择则是复用 liburing，先进行一层binding，然后在进行一层面向对象的封装，抽象出 SQ，CQ 和 Register 等，这一层抽象借鉴的 tokio 的 io-uring。前一种方法对实现具有更强的控制力，后一种方法则降低了维护成本。无论哪一种方法，最终的目的和效果是一样的——搭建脚手架，为异步封装扫平障碍。</p>
<h2><a class="header" href="#io_uring-异步模式" id="io_uring-异步模式">io_uring 异步模式</a></h2>
<p>io_uring 和 Rust 现有异步模型不同，该异步操作是由操作系统完成的，并不需要用户线程参与，该工作方式非常适合 Proactor 模式。下图为 Proactor 模式示意图：</p>
<p><img src="chapter_4/./image/io_uring/proactor.jpg" alt="proactor" /></p>
<p>根据图中所示，异步操作由 Proactor 线程完成，更准确说是由 Proactor 线程提交 I/O 任务给内核，等内核完成了 I/O 操作再讲结果通知给 Worker 线程。和 Reactor 模式相比，Proactor 为用户完成了更多的任务，这就好比请人帮忙把烧水和泡茶的活一起干了，直接喝茶就行。</p>
<h2><a class="header" href="#io_uring-proactor-设计" id="io_uring-proactor-设计">io_uring Proactor 设计</a></h2>
<p>在决定了采用 Proactor 模式来完成 io_uring 之后，我们还需要考虑 io_uring 自己的特性。io_uring 在设计的时候只考虑了一个线程一个io_uring实例，因此无论是内核接口还是libfuse的封装接口都不易实现多线程并发访问。基于这个考虑，有两个方法解决，第一个方法为 io_uring 操作上锁，也就是间接的将多线程并发操作串行化；第二个方法为只用单线程进行 io_uring 操作，其他任务给该线程提交任务。<a href="https://github.com/tokio-rs/io-uring">ringbahn</a> 采用了第一种方法，我们采取了第二种方法。第二种方法的好处在于，可以将连续的多个 I/O 操作一次提交，在繁忙的系统中能够提高性能。</p>
<p>下图为我们的架构设计：</p>
<p><img src="chapter_4/./image/io_uring/arch.jpg" alt="architect" /></p>
<p>在我们的设计中，所有的Worker Task通过全局的channel向 Submitter Task 提交 I/O 任务，当没有 I/O 任务时Submitter Task 会在等待在该 channel 上，而当请求繁忙时 Submitter Task 会打包多个任务一次性提交。Completer Thread 会收取 ring 上完成的任务，并且唤醒等待这些任务的 Worker Task。</p>
<p>单个 io_uring 实例同时处理的 I/O 请求数目是有上限的，如果完成的任务不及时接收则会出现丢失的情况，因此我们维护了一个全局计数器来统计正在被处理的 I/O 请求数目，当数目达到上限时则会挂起 Worker Task 让其等待。</p>
<h2><a class="header" href="#内存安全" id="内存安全">内存安全</a></h2>
<p>Rust 语言的内存安全要求不能出现 data race 和 use after free 的情况，而 io_uring 的使用模型则存在现在的风险。操作系统会异步地操作内存 buffer，这块 buffer 如果被用户同步操作则会出现 data race 的情况。因此被Proactor 线程占用的内存必须独占，否则任何被取消的 I/O 操作都会导致内存被用户态同时使用。</p>
<p>为了达到上述目的，Reactor 的基于 引用（reference） 的接口不能被使用，需要采用新的接口，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn read(
    fd: RawFd,
    buffer: Vec&lt;u8&gt;,
    count: usize,
    offset: isize,
) -&gt; (io::Result&lt;usize&gt;, (RawFd, Vec&lt;u8&gt;)) 
<span class="boring">}
</span></code></pre></pre>
<p>在该接口中用户会在 I/O 操作过程中交出 buffer 所有权，在任务完成时返还 buffer 所有权。</p>
<h2><a class="header" href="#总结-7" id="总结-7">总结</a></h2>
<p>现有的 Rust 异步 I/O 模型（Reactor）其实分为两步，第一步由操作系统通知用户哪些 fd 可以使用，第二步再由用户完成 I/O 操作，操作系统仅仅负责通知，真正干活的还是用户自己。区别于该 I/O 模型，io_uring 的 I/O 模型为 Proactor，所有的异步 I/O 请求都是操作系统来完成，用户仅仅需要发送请求和接收结果。</p>
<p>我们 DatenLord 团队在充分考虑了 io_uring 特点和 Rust 语言的需求后实现了一个 io_uring 的异步库。这个库同时照顾到性能和易用性，方便用户迁移现有代码，同时该库不依赖于任何一部框架，可以和绝大多数已知的异步框架一起使用。此<a href="https://github.com/datenlord/datenlord/tree/master/async_fuse/src/proactor">链接</a>为该库的代码地址，欢迎大家提交 PR 和 issue，帮助进一步完善功能。</p>
<h1><a class="header" href="#pingcap--使用-rust-ffi-心得" id="pingcap--使用-rust-ffi-心得">PingCAP | 使用 Rust FFI 心得</a></h1>
<p>作者：骆迪安（AndyLok）/ 后期编辑：张汉东</p>
<blockquote>
<p>本文是对 深圳 3.27 Rust Meetup 来自 骆迪安（AndyLok）分享的简单摘录， 对内容感兴趣可以直接观看<a href="https://www.bilibili.com/video/BV1C5411A7sG?p=3">视频</a>。</p>
</blockquote>
<hr />
<p><img src="chapter_4/image/ffi/2.png" alt="2" /></p>
<p><strong>在 TiKV 里为什么需要 FFi ？</strong></p>
<p><img src="chapter_4/image/ffi/3.png" alt="3" /></p>
<p>TiKV 是一个支持事务，也支持强一致性，低延迟（比HBase 延迟低十倍左右），分布式的数据存储。</p>
<p><img src="chapter_4/image/ffi/4.png" alt="4" /></p>
<p>整体架构如上图所示，每个 TiKV 是一个独立的 Server，多个 TiKV 节点用于处理分布式数据。客户端会通过 RPC 和 TiKV 进行通信。</p>
<p><img src="chapter_4/image/ffi/5.png" alt="5" /></p>
<p>客户端支持多种语言。但是客户端代码核心其实只有一个版本，就是 Rust 版本。其他语言是通过 FFi 来调用 Rust 版本的库，实现多语言客户端支持。</p>
<p>接下来看 Python 客户端。</p>
<p><img src="chapter_4/image/ffi/12.png" alt="12" /></p>
<p><strong>为什么不直接使用 Python 实现 Client ？</strong></p>
<p><img src="chapter_4/image/ffi/14.png" alt="14" />
<img src="chapter_4/image/ffi/20.png" alt="20" /></p>
<p>有几个原因:</p>
<ol>
<li>因为 TiKV Client 很复杂。如上图里面的结构所示，底层是和服务器沟通的 RPC，上面还有缓存，再往上是两种访问模式：RawKV 和 支持事务模块（要求强一致，用于OLTP场景，比如银行）。代码量现在包含 1.8w行代码。</li>
<li>正确性很难。现在有集成测试、单元测试和一致性测试、混沌测试。这些只能跑在 Rust 相关组件上。</li>
<li>需要做到代码只需编写一次，就可以应用到其他语言。</li>
</ol>
<p>所以就使用了 FFi 。</p>
<p><img src="chapter_4/image/ffi/21.png" alt="21" /></p>
<p><strong>那么现在 TiKV Client 的架构是怎么样的？</strong></p>
<p><img src="chapter_4/image/ffi/22.png" alt="22" /></p>
<p>最左边是 Rust Client 的 API，和它对比的是 Cpp Client 和 Python Client。</p>
<p><img src="chapter_4/image/ffi/25.png" alt="25" /></p>
<p>现在是一个洋葱结构。最里面红色部分是那1.8w的Rust 代码。</p>
<p>Cxx 是一个安全沟通 Rust 和 Cpp 的库。在 Rust 这边会封装一个安全的 C-ABI，然后在 Cpp 那边把 C-ABI 转换为 Cpp ，就形成一个胶水层。 最后再把这个胶水层封装为一个让用户使用的库。</p>
<p>这两种颜色实际对应两个静态库，然后把它们链接在一起使用。</p>
<p>其他语言客户端和这个 Cpp 客户端结构完全一致。唯一的区别是 Java 和 Nodejs 客户端需要动态库。</p>
<p><img src="chapter_4/image/ffi/28.png" alt="26" /></p>
<p><strong>现在展示 FFi 的一些细节。</strong></p>
<p><img src="chapter_4/image/ffi/30.png" alt="30" /></p>
<p>如图，如果想在 Cpp 里调用 左边的 <code>impl.rs</code> 中的 <code>foo</code> 函数，该怎么做？</p>
<p>我们可以引入 cxx，该库提供了一个过程宏 <code>#[cxx::bridge]</code>来帮助我们自动生成 Cpp 里的头文件。</p>
<p><img src="chapter_4/image/ffi/31.png" alt="31" /></p>
<p>然后编译左边 Rust 代码，会生成一个静态库。</p>
<p><img src="chapter_4/image/ffi/32.png" alt="32" /></p>
<p>然后使用 Cpp 编译工具把 Cpp 代码编译得到<code>.o</code>文件，然后和Rust编译生成的静态库合在一起，最终生成一个新的静态库。这样 Cpp 那边就可以调用 Rust 代码了。</p>
<p>同理，Cpp Client 的机制是类似的。</p>
<p><strong>接下来看一下 Cxx 在做 FFi 的时候考虑的重点。</strong></p>
<p><img src="chapter_4/image/ffi/34.png" alt="34" /></p>
<p>FFi 比较常见的问题就是内存分配问题。比如，想把Rust 里的 String 传递给 Cpp 来使用。如果 Cpp 去析构这个 String，那么就会引发段错误。因为 Cpp 不知道这个String是哪来的，它会当作自己的。</p>
<p><img src="chapter_4/image/ffi/36.png" alt="36" /></p>
<p>如何解决这个问题？</p>
<p>Rust 这边只传一个引用到 Cpp，Cpp 这边调用 Rust 这边定义的析构函数 Callback。</p>
<p>反过来也一样。谁分配谁负责释放，通过callback函数调用。</p>
<p>Cxx 这个库会帮你来做这些。</p>
<p><img src="chapter_4/image/ffi/38.png" alt="38" /></p>
<p>Cxx 库还定义了其他类型。</p>
<p><img src="chapter_4/image/ffi/39.png" alt="39" /></p>
<p>这是从 Cpp Client 里提取出的代码。</p>
<p>首先，在 Rust 这边定义了一个事务 Get 的请求。这个请求就是简单的通过 Key 获取一个 Value 。它返回的值是一个 Optional 的。很有可能这个值是不存在的，所以这里定义了一个 Struct ，添加一个字段来表明这个值是否存在。</p>
<p><img src="chapter_4/image/ffi/41.png" alt="41" /></p>
<p>然后 Cxx 会自动生成 Cpp 的头文件，对应关系如图。</p>
<p><img src="chapter_4/image/ffi/47.png" alt="47" /></p>
<p>用户可以这样去使用。</p>
<p>Cpp 里的 <code>transaction_get</code>函数会调用 Rust里对应的函数。</p>
<p>Cpp 这边会把一个 String 的引用传过去，并没有所有权。此时是一个 <code>cxx::CxxString</code> 引用。</p>
<p>然后 Rust 这边会通过<code>transaction.inner.get(key)</code>调用底层 Rust 实现，然后返回一个 Rust String(Vec)，传给 Cpp 。</p>
<p>经过 Cxx 的包装，开发起来还是极方便的，很爽。</p>
<p><img src="chapter_4/image/ffi/48.png" alt="48" /></p>
<p>那么 Python Client 怎么样呢？</p>
<p><img src="chapter_4/image/ffi/49.png" alt="49" /></p>
<p>通过 PyO3 库来帮助轻松绑定 Rust 库。</p>
<blockquote>
<p>编者按：PyO3，命名形式像化学表达式，取自「氧化」之意。这和 Rust 有「锈」这层意思有关。</p>
</blockquote>
<p>基本原理和 Cpp Client 类似。</p>
<p><img src="chapter_4/image/ffi/53.png" alt="53" /></p>
<p>同样是一个 CET 请求。但是这里 Rust 返回的是一个 异步Future 对象，但是 Python 的异步模型是 Python Coroutine。所以需要一个 <code>PyCoroutine</code>的类把 Future 包起来。</p>
<p><img src="chapter_4/image/ffi/57.png" alt="57" /></p>
<p>Python 的 Goroutine 调用 await 之后会返回 Awaitable，然后再调用  awaitable的iter得到迭代器，然后进行迭代，直到异步任务完成。</p>
<p>Python 里只要调用方法符合这三步，因为 Duck Type 的设计，就都可以用 Pyhton 都 await 来调用。</p>
<p>所以就可以模仿这个过程。</p>
<p><img src="chapter_4/image/ffi/61.png" alt="61" /></p>
<p>第一步，在生成 Coroutine 的时候，要生成一个配对的 Future。但不去执行它。右边 PyGoroutine 也只是一个包装。它们俩通过 Channel 沟通，PyGoroutine 这边拿着 Reciver。</p>
<p>然后，当 Python 那边调用一个 await 的时候，就会通知 Rust 这边，把 Future 放到 tokio 运行时来跑，真正开始干活。</p>
<p>当 Python 调用 iter 的时候，则什么都不干。因为对于这个模型来说，iter没有用。</p>
<p>当 Python 调用 next 的时候，则会尝试从 channel Reciver 中拿结果。假如 Rust 里 poll 没有完成，那么 Reciver 里就没有值，但是 Python 的 next 会一直轮询，直到有值。</p>
<p><img src="chapter_4/image/ffi/62.png" alt="62" /></p>
<p>那么 TiKV Client 未来准备做什么？</p>
<p><img src="chapter_4/image/ffi/65.png" alt="65" /></p>
<p>目前 Java Client 和 Node Client 是正在测试阶段。</p>
<p>Java Client 会调用 JNI ，而 JNI 可能会给 FFI 带来不确定的因素，比如 延时/ GC。</p>
<p>虽然都套用同一套 Rust 实现，但是还需要测试去保证正确性。然后准备在 Client 之上再构建一套统一的测试代码，这样就可以达到 核心代码是同一套，测试代码是同一套。</p>
<hr />
<h2><a class="header" href="#作者简介" id="作者简介">作者简介：</a></h2>
<p>骆迪安，目前为 PingCAP 分布式存储工程师，负责 TiKV 事务模块的开发，同时也负责 TiKV 社区管理和运营。对 Rust 社区和函数式编程感兴趣。</p>
<h1><a class="header" href="#netwarp--从-libp2p-rs-与-ipfs" id="netwarp--从-libp2p-rs-与-ipfs">Netwarp | 从 Libp2p-rs 与 IPFS</a></h1>
<p>作者：刀哥@netwarp / 编辑： 张汉东</p>
<blockquote>
<p>本文是对 深圳 3.27 Rust Meetup 来自 NetWarp 的刀哥分享的简单摘录， 对内容感兴趣可以直接观看<a href="https://www.bilibili.com/video/BV1C5411A7sG">视频</a>。</p>
</blockquote>
<hr />
<p><img src="chapter_4/image/libp2p/1.png" alt="1" /></p>
<p>Libp2p 主要为 IPFS 和 Filecoin 提供服务，是一个协议集。</p>
<p>Libp2p 分为网络层、路由层和交换层。网络层核心概念是 PeerId（节点标识），路由层负责发现 PeerId的地址，交换层则是其上的各种应用。</p>
<p>Libp2p 被认为是一种基础设施，不仅仅是为 IPFS 使用，还可以给其他应用使用。</p>
<p><img src="chapter_4/image/libp2p/2.png" alt="2" /></p>
<p>概念介绍：</p>
<ul>
<li>IPFS（InterPlanetary File System，星际文件系统）： 旨在创建持久且分布式存储和共享文件的网络传输协议。它是一种内容可寻址的对等超媒体分发协议。在IPFS网络中的节点将构成一个分布式文件系统。</li>
<li>Filecoin：一个云存储市场、运行加密货币协议的区块链系统。</li>
<li>IPFS提供分布式内容存储； Filecoin是激励层。</li>
</ul>
<p>IPFS 的愿景看上去很有野心，但实际上它们有些问题，后续会深入讲一下原因。</p>
<p>Filecoin 到底是不是激励层，我认为这种提法不是很准确，后面会稍微提到一点。</p>
<p><img src="chapter_4/image/libp2p/3.png" alt="3" /></p>
<p>今天主要话题是从Libp2p 开始，先来看一下 Libp2p 的一些现有实现。</p>
<ul>
<li>Go-libp2p： 比较成熟，功能完整。是ipfs/file-coin项目的基石。</li>
<li>Rust-libp2p
<ul>
<li>ParityTech 开源的rust实现，在polkadot和substrate项目中</li>
<li>泛型过分抽象，晦涩难懂</li>
<li>基于 poll 方式的状态机嵌套，代码繁琐</li>
</ul>
</li>
<li>其他 </li>
</ul>
<p>Go-libp2p，我们做过深入的代码研究，我认为它们的实现是非常完整的，各种功能很全，代码质量非常好。</p>
<p>我们做的工作和 Rust-libp2p 相关的，这个代码已经使用在波卡等项目中。</p>
<p>但是这个 Rust 代码实现的非常复杂，泛型参数使用的非常非常多，抽象层次很难理解。比如基础网络部分有十个泛型参数。这并不是智商的问题，而是耐心的问题。如果你想把它搞清楚会很花时间。</p>
<p><img src="chapter_4/image/libp2p/4.png" alt="4" /></p>
<p>而且这份代码在几年前就开始做了，代码里还没有使用 aysnc/await 现在的语法，所以比较旧。</p>
<p>Rust-Lip2p 的作者也承认代码非常复杂，但这个也是有原因的。所以，为了简化这个实现，我们重新做了 libp2p-rs，当然也重用了 Rust-libp2p 的一些实现，但最重要的是使用了现在的 async/await 的语法。</p>
<h3><a class="header" href="#基本设计原则-1" id="基本设计原则-1">基本设计原则 1</a></h3>
<p>我们在实现 Libp2p-rs 的时候，遵循了一些原则：</p>
<ol>
<li>不使用 Unsafe。Unsafe 写不好，会有很大的风险。
<ul>
<li>底层网络功能由异步运行库提供</li>
<li>Libp2p 的应用逻辑暂时看不到有 Unsafe 的必要</li>
</ul>
</li>
<li>除非绝对必要，不手工实现任何 Future。因为 Pin 这个概念比较难以理解，比如 Pin 在栈上和 Pin 在堆上有什么区别。
<ul>
<li>Async 帮助实现 GenFuture</li>
</ul>
</li>
<li>尽可能不使用 future combinator书写代码
<ul>
<li>代码逻辑更简单易读</li>
<li>Combinator等效于<code>await: a.and_then(b) ➔ a.await; b.await; </code></li>
</ul>
</li>
<li>尽可能减少泛型参数以及Trait关联参数的使用
<ul>
<li>代码可读性问题</li>
<li>参数的限定极为复杂</li>
<li>基于静态派发的多态，使用上诸多不变（参见rust-libp2p 中 <code>SelectUpgrade&lt;A, B&gt;</code>。泛型参数需要具体化，实现同一Trait的不同类型具体化后是不同的数据类型。）</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#基本设计原则2" id="基本设计原则2">基本设计原则2:</a></h3>
<ul>
<li>尽可能使用<code>&lt;dyn Trait&gt;</code>动态派发实现多态，避免写泛型参数
<ul>
<li>典型例子：Swarm子流支持同种协议，协议需要实现 ProtocolHandler Trait，通过 tait object 动态派发</li>
<li>代码篇幅减少，易于理解</li>
</ul>
</li>
<li>尽量推迟引入异步运行库
<ul>
<li>Libp2p-core部分 不引入 运行库的依赖
<ul>
<li>Yamux/Mplex需要实现任务循环，作为一个BoxFuture暴露至Swarm，由Swarm调用
task::spwan()来执行</li>
<li>Wstransport, TcpTransport 必须使用task与socket。通过 Transport trait 的封装，不必放入 core</li>
</ul>
</li>
<li>在 Swarm以及各种协议的实现正式引入运行库，使用任务/协程完成连接与子流的管理</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#基本设计原则3-" id="基本设计原则3-">基本设计原则3 ：</a></h3>
<ul>
<li>减少 Mutex&lt;&gt;之类同步原语的使用
<ul>
<li>使用不当容易造成协程死锁</li>
<li>使用mpsc::channel，通过消息机制解决所有权问题</li>
<li>Swarm功能主体运行在一个协程任务上下文，通过channel接收内部或外部事件</li>
<li>原则上，处理消息不做耗时操作，不可以 <code>.await</code></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#基本设计原则4-" id="基本设计原则4-">基本设计原则4 ：</a></h3>
<ul>
<li>通过 async-trait加持，在 Trait 中定义 async 方法
<ul>
<li>Trait 实现多态，支持异步方法的Trait可提供更为强大的抽象能力</li>
</ul>
</li>
</ul>
<p>Rust 异步目前还不太成熟，还不支持 async trait，只能使用 async-trait 库来达成目的。</p>
<p>而且目前 Rust 还不支持 async drop。目前我们的解决办法是实现了一个 引用计数器 GC。</p>
<p><img src="chapter_4/image/libp2p/9.png" alt="9" /></p>
<blockquote>
<p>编者按：</p>
<p>4.23号 <code>libp2p-rs</code> 已经发布了 0.3 版本，使用 <code>AsyncRead &amp; Asyncwrite</code>来替换 <code>ReadEx &amp; WriteEx &amp; SplitEx</code>；简化了 <code>Kad/DHT </code>的实现逻辑。</p>
</blockquote>
<blockquote>
<p>详细也可以看这里： <a href="https://mp.weixin.qq.com/s/bN7cnFN5KmZIBthBPcdiVA">libp2p-rs v0.3.0 版本介绍</a></p>
</blockquote>
<p><img src="chapter_4/image/libp2p/11.png" alt="11" />
<img src="chapter_4/image/libp2p/12.png" alt="12" />
<img src="chapter_4/image/libp2p/13.png" alt="13" />
<img src="chapter_4/image/libp2p/14.png" alt="14" />
<img src="chapter_4/image/libp2p/15.png" alt="15" /></p>
<hr />
<h3><a class="header" href="#作者介绍-1" id="作者介绍-1">作者介绍：</a></h3>
<p>刀哥，互联网老司机，在 NetWarp 负责分布式存储。</p>
<h1><a class="header" href="#google--在-android-平台使用-rust" id="google--在-android-平台使用-rust">Google | 在 Android 平台使用 Rust</a></h1>
<p>翻译：budshome / 编辑：张汉东</p>
<blockquote>
<p>原文：<a href="https://security.googleblog.com/2021/04/rust-in-android-platform.html">https://security.googleblog.com/2021/04/rust-in-android-platform.html</a></p>
<p>译文转载自：<a href="https://blog.budshome.com/budshome/android-tuan-dui-xuan-bu-android-kai-yuan-xiang-mu-(aosp),yi-zhi-chi-rust-yu-yan-lai-kai-fa-android-xi-tong-ben-shen">https://blog.budshome.com/budshome/android-tuan-dui-xuan-bu-android-kai-yuan-xiang-mu-(aosp),yi-zhi-chi-rust-yu-yan-lai-kai-fa-android-xi-tong-ben-shen</a></p>
</blockquote>
<hr />
<blockquote>
<p>对于 Android 来说，如果代码是用 C/C++ 编写的，并且在解析不可信的输入，那么它应该包含在一个严格受约束和特殊的沙箱中。但沙盒的开销昂贵：需要引入新进程，消耗额外的开销，并且由于 IPC 和额外的内存使用，而引入了延迟机制。沙箱技术，并不能消除代码中的漏洞，它的效率，会随着高 bug 密度而降低，从而允许攻击者将多个漏洞链接在一起。像 Rust 这样的内存安全语言，通过两种方式帮助 Android 克服这些限制：降低了代码中 bug 的密度，从而提高了当前沙盒的有效性；减少了 Android 的沙箱技术需求，允许引入更安全、资源更轻的新功能。</p>
</blockquote>
<p>Android 平台中，代码的正确性，是每个版本 Android 系统的安全性、稳定性，及其质量的重中之重。C/C++ 语言中的内存安全漏洞，仍然是最难解决的错误来源。我们投入了大量的精力和资源来检测、修复和缓解这类 bug，这些努力有效地防止了大量 bug 进入 Android 系统。然而，尽管做出了这些努力，内存安全漏洞仍然是稳定性问题的主要原因。并且，在 Android 系统高严重性的安全漏洞中，其始终占据<a href="https://security.googleblog.com/2021/01/data-driven-security-hardening-in.html">大约 70% 的比例</a>。</p>
<p>除了<a href="https://android-developers.googleblog.com/2020/02/detecting-memory-corruption-bugs-with-hwasan.html">正在进行的</a>和<a href="https://security.googleblog.com/2019/08/adopting-arm-memory-tagging-extension.html">即将进行的</a>改进内存错误检测的工作之外。首当其冲地，我们正在加大力度防止它们。内存安全类编程语言，是防止内存错误的最经济有效方法。除了像 Kotlin 和 Java 这样的内存安全语言之外，我们很高兴地宣布：Android 开源项目（AOSP），现在支持 Rust 编程语言来开发 Android 操作系统本身。</p>
<h2><a class="header" href="#系统级编程" id="系统级编程">系统级编程</a></h2>
<p>Java 和 Kotlin 等受监管/托管类语言，是 Android 应用开发的最佳选择。这些语言是为易于使用、可移植性，以及安全性而设计的。<a href="https://source.android.com/devices/tech/dalvik">Android 运行时（ART）</a>，代表开发者管理内存。Android 操作系统广泛使用 Java，有效地保护了大部分 Android 平台不受内存缺陷的影响。不幸的是，对于操作系统的底层，Java 和 Kotlin 不是一个选项。</p>
<p>较低级别的操作系统，需要系统级编程语言，如 C、C++，以及 Rust。这些语言的设计目标是控制性和可预测性。它们提供对底层系统资源和硬件资源的访问。它们占用资源较少，并且具有更可预测的性能特征。</p>
<p>对于 C/C++，开发人员需要负责管理内存生命周期。不幸的是，这样做很容易出错，特别是在复杂的多线程代码中。</p>
<h2><a class="header" href="#沙箱技术sandboxing的极限" id="沙箱技术sandboxing的极限">沙箱技术（sandboxing）的极限</a></h2>
<p>C/C++ 语言，不提供相同的安全保证，需要强大的手动隔离。所有 Android 进程，都是基于沙箱技术（sandboxing）的，我们遵循 <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/security/rule-of-2.md">规则 2</a>（译注：是指 Android 开发中关于 App 沙箱的规则限制，下同），以决定功能是否需要额外的隔离和剥离。规则 2 很简单：给定三个选项，开发人员只能选择三个选项中的两个。</p>
<p>对于 Android 来说，这意味着：如果代码是用 C/C++ 编写的，并且在解析不可信的输入，那么它应该包含在一个严格受约束和特殊的沙箱中。虽然<a href="https://android-developers.googleblog.com/2019/05/queue-hardening-enhancements.html">遵守规则 2</a>，在降低安全漏洞的严重性和可访问性方面是有效的，但它确实有局限性。沙盒的开销昂贵：<a href="https://www.usenix.org/conference/enigma2021/presentation/palmer">需要引入新进程，消耗额外的开销，并且由于 IPC 和额外的内存使用，而引入了延迟机制</a>。沙箱技术，并不能消除代码中的漏洞，它的效率，会随着高 bug 密度而降低，从而允许攻击者将多个漏洞链接在一起。</p>
<p>像 Rust 这样的内存安全语言，通过两种方式帮助我们克服这些限制：</p>
<ul>
<li>降低了代码中 bug 的密度，从而提高了当前沙盒的有效性。</li>
<li>减少了我们的沙箱技术需求，允许引入更安全、资源更轻的新功能。</li>
</ul>
<h2><a class="header" href="#那么现有的-c-呢" id="那么现有的-c-呢">那么，现有的 C++ 呢？</a></h2>
<p>当然，引入一种新的编程语言，并不能解决现有 C/C++ 代码中的问题。即使我们重新调整了 Android 团队中每个软件工程师的工作方向，重写数千万行代码，也是很难解决的。</p>
<p>上文中，对 Android 平台中内存安全漏洞的历史分析（从它们第一次引入时，就已经测量过），表明了为什么我们的内存安全语言工作，最关注的是新开发，而不是重写成熟的 C/C++ 代码。我们的大多数内存错误都发生在新的，或最近修改的代码中，大约 50% 的错误发生在不到一年的时间里。</p>
<p>比较稀疏的老旧内存错误，可能会让一些人感到惊讶，但我们发现旧代码并不是我们最迫切需要改进的地方。随着时间的推移，软件缺陷会被发现并修复，因此我们预计正在维护的，但未积极开发的代码中，其缺陷数量会随着时间的推移而减少。正如减少 bug 的数量和密度，可以提高沙盒的有效性一样，它也可以提高 bug 检测的有效性。</p>
<h2><a class="header" href="#检测的局限性" id="检测的局限性">检测的局限性</a></h2>
<p>通过健壮的测试、<a href="https://github.com/rust-lang/rust/pull/81506">清理（sanitization）</a>，以及<a href="https://android-review.googlesource.com/c/platform/build/soong/+/1403607/">模糊测试（fuzzing ）</a>，进行 bug 检测，对于提高所有软件（包括用 Rust 编写的软件）的质量和正确性至关重要。最有效的内存安全检测技术，其一个关键限制是：为了检测到错误状态，必须在代码中实际触发错误状态。即使在具有出色的 test/fuzz 覆盖的代码库中，这也会导致许多错误未被发现。</p>
<p>另一个限制是，<a href="https://lore.kernel.org/dri-devel/20200710103910.GD1203263@kroah.com/">bug 检测比 bug 修复扩展得更快</a>。在一些项目中，检测到的 bug 并不总是得到修复。错误修复是一个漫长而昂贵的过程。</p>
<p>这些步骤都很昂贵，缺少其中任何一个，都可能导致某些或所有用户无法对 bug 进行调度。对于复杂的 C/C++ 代码库，通常只有少数人能够开发和检查修复，即使花费大量的精力来修复错误，<a href="https://googleprojectzero.blogspot.com/2015/09/stagefrightened.html">有时修复后也不完全正确</a>。</p>
<p>当错误相对较少时，bug 检测最有效，并且可以给予它们紧急性和优先级。我们从改进 bug 检测中，获益的能力要求我们优先考虑：防止引入新的 bug。</p>
<h2><a class="header" href="#优先性任务" id="优先性任务">优先性任务</a></h2>
<p>Rust 对一系列语言特性，进行了现代化的设计和开发，从而提高了代码的正确性：</p>
<ul>
<li>内存安全——通过编译器和运行时检查的组合，以强制执行内存安全。</li>
<li>数据并行——防止数据争用。这使得开发者能够轻松地编写高效、线程安全的代码，这也催生了 “<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">Rust 无畏并行（Fearless Concurrency）</a>”的口号。</li>
<li>更具表现力的类型系统——有助于防止逻辑编程错误（例如：newtype 包装、包含内容的枚举变量等）。</li>
<li>默认情况下，引用和变量在是不可变的——帮助开发人员遵循最小特权的安全原则，仅当他们真正希望引用或变量可变时，才将其标记为可变。尽管 C++ 有一定的特点，但它往往不经常使用，也不一致。相比之下，Rust 编译器通过为从不突变的可变值提供警告，来帮助避免不必要的可变注释。</li>
<li>在标准库中，有更好的错误处理方式——在结果中，包装可能失败的调用，这会导致编译器要求用户检查失败原因，甚至是没有返回所需值的函数。这可以防止诸如 <a href="https://android.googlesource.com/platform/system/core/+/44db990d3a4ce0edbdd16fa7ac20693ef601b723%5E%21/">Rage Against the Cage</a> 漏洞之类的 bug，该漏洞即是由未处理的错误导致的。</li>
<li>初始化赋值——要求在使用前，初始化所有变量。未初始化的内存漏洞一直是 Android 平台上 3-5% 比例的安全漏洞的根本原因。在 Android 11 中，我们开始在 <a href="https://security.googleblog.com/2020/06/system-hardening-in-android-11.html">C/C++ 中自动初始化内存</a>，以减少这个问题。但是，初始化为零并不总是安全的，特别是对于返回值这样的情况，这可能成为错误处理的新来源。Rust 要求每个变量在使用前，都初始化为其类型的合法成员，避免了无意中初始化为不安全值的问题。类似于 C/C++ 的编译器 Clang，Rust 编译器知道初始化要求，并且避免了多次初始化的任何潜在性能开销。</li>
<li>更安全的整数处理——默认情况下，对 Rust 调试和构建，启用溢位清理（overflow sanitization），鼓励程序员指定一个 <code>wrapping_add</code>（如果他们真的希望溢位计算），或 <code>saturating_add</code>（如果他们不希望溢位计算）。我们打算为 Android 平台中的所有构建，都启用溢位清理。此外，所有整数类型转换，都是显式强制转换：当分配给变量或尝试对其他类型执行算术运算时，开发人员不能在函数调用期间，意外地强制转换。</li>
</ul>
<h2><a class="header" href="#未来计划" id="未来计划">未来计划</a></h2>
<p>为 Android 平台添加一种新的编程语言，是一项艰巨的任务。有需要维护的工具链，以及依赖项。也必须有更新的测试基础设施和工具，以及需要培训的开发人员。在过去的 18 个月里，我们一直在为 Android 开源项目添加 Rust 支持。我们有几个早期采用者项目，我们将在未来几个月内分享。将其扩展到更多的操作系统，是一个多年的项目。请继续关注，我们将在这个博客上发布更多更新。</p>
<h1><a class="header" href="#meilisearch--开源搜索引擎" id="meilisearch--开源搜索引擎">MeiliSearch | 开源搜索引擎</a></h1>
<ul>
<li>原文作者：Gints Dreimanis</li>
<li>翻译/编辑：张汉东</li>
</ul>
<blockquote>
<p>原文：<a href="https://serokell.io/blog/rust-in-production-meilisearch">https://serokell.io/blog/rust-in-production-meilisearch</a></p>
</blockquote>
<hr />
<p>在这次采访中，我与<a href="https://www.meilisearch.com/">MeiliSearch</a>的联合创始人兼首席运营官 Thomas Payet 进行了交谈。 MeiliSearch 是一个开源搜索引擎，在撰写本文时，它是 GitHub 上最受瞩目的Rust项目之一。我们谈论MeiliSearch，以及 Rust 及其生态系统如何帮助他们创建它。</p>
<p>进一步阅读以了解他们在 Rust 方面的经验，并发现启动自己的开源项目的技巧。</p>
<h2><a class="header" href="#能否向我们介绍一下您的公司以及您的角色" id="能否向我们介绍一下您的公司以及您的角色">能否向我们介绍一下您的公司以及您的角色？</a></h2>
<p>MeiliSearch 是一个开源搜索 API。由于存在计算机，因此搜索一直是一个问题。如今，大多数人习惯使用Google或Amazon来获得出色的搜索结果，但是如果您没有这些大型高科技公司的能力，要提供这样的用户体验可能会面临挑战。在MeiliSearch，我们正在开发一种开源技术，我们认为该技术可以帮助许多开发人员立即提供出色的搜索体验。</p>
<p>我是 MeiliSearch 背后的公司 Meili 的联合创始人之一（公司三岁）。我的角色是使团队保持同步，以确保每个人都可以在我们公司内尽最大努力，同时遵循相同的目标。我们大多数人都是开发人员，因为我可能是技术水平较低的人之一，所以我是第一个改变角色以支持组织发展的人之一。</p>
<h2><a class="header" href="#meilisearch代码库的哪些部分是用rust编写的" id="meilisearch代码库的哪些部分是用rust编写的">MeiliSearch代码库的哪些部分是用Rust编写的？</a></h2>
<p>MeiliSearch 是一个由引擎以及针对不同语言和框架的多个SDK和库组成的项目，以简化核心引擎的使用。该引擎是100％用Rust编码的，并且我们与社区一起以8种不同的语言维护了20多个集成。</p>
<p>我们试图不成为任何特定技术的倡导者；在内部，我们将只为工作选择最佳工具。 :)</p>
<h2><a class="header" href="#您是如何决定在项目中使用rust的-rust的任何优势例如速度或类型内存安全性是否影响选择" id="您是如何决定在项目中使用rust的-rust的任何优势例如速度或类型内存安全性是否影响选择">您是如何决定在项目中使用Rust的？ Rust的任何优势（例如速度或类型/内存安全性）是否影响选择？</a></h2>
<p>当然，速度和安全性是Rust的主要论点。</p>
<p>搜索引擎的两个关键要素是性能和相关性。只要您的算法和逻辑都不错，就可以使用任何语言进行关联。就今天的性能而言，您可以选择C ++，Rust或Go。</p>
<p>在以前的工作中，我们在Go中构建了一个搜索引擎，并且在设计面向性能的程序时，我们很快了解了垃圾收集语言的弊端。在运行基准测试时，我们发现了一些变慢的情况，然后我们很快意识到，正是常规的垃圾收集使整个系统变慢了。 ^^</p>
<p>对于C++，从长远来看，对于我们来说，维护C++代码库似乎更加困难。另外，自从第一个稳定版本发布以来，我们的CTO kero就一直是Rust的开发人员。</p>
<p>最后，我们从未做出使用Rust的“决定”，因为在我们看来这很明显，这就是我们完成这项工作所需要的工具！</p>
<h2><a class="header" href="#rust在哪里最适合使用在堆栈中何处不足" id="rust在哪里最适合使用在堆栈中何处不足">Rust在哪里最适合使用，在堆栈中何处不足？</a></h2>
<p>Rust生态系统是现代的，在实际的GitHub贡献流程中，它很容易用作日常语言。我们对使用Rust进行构建感到非常有信心，因为它消除了其他语言可能带来的许多不确定性。我们可以专注于我们面临的其他挑战，例如设计和性能。</p>
<p>强大的CS研究人员社区实现了底层库，以实现我们经常会从中受益的最新技术。另一方面，我们进行了多次迭代以找到适合的HTTP框架，最终选择了actix-web，这最适合我们的用例。</p>
<h2><a class="header" href="#您发现有什么特别的rust库在开发过程中非常有用并且想提及吗" id="您发现有什么特别的rust库在开发过程中非常有用并且想提及吗">您发现有什么特别的Rust库在开发过程中非常有用并且想提及吗？</a></h2>
<p>有很多，但这里只推荐三个：</p>
<ul>
<li>来自BurntSushi的<a href="https://github.com/BurntSushi/fst">fst</a>。它使我们可以在单词词典中进行存储和搜索，并且性能非常好。</li>
<li><a href="https://github.com/tantivy-search/levenshtein-automata">Levenshtein-automaton</a>-来自fulmicoton。我们使用它从具有特定Levenshtein规则的字典中快速获取单词。</li>
<li><a href="https://github.com/RoaringBitmap/roaring-rs">roaring-rs</a>，我们用于优化设置操作。</li>
</ul>
<h2><a class="header" href="#用rust开发meilisearch时最大的挑战是什么" id="用rust开发meilisearch时最大的挑战是什么">用Rust开发MeiliSearch时最大的挑战是什么？</a></h2>
<p>在MeiliSearch路线图中，我们希望提供一些分布式系统功能，例如高可用性和分片。</p>
<p>我们非常嫉妒Hashicorp的<a href="https://github.com/hashicorp/raft">Go Raft</a>库。我希望在Rust中也有类似的东西，但到目前为止，我们还没有找到这样的Crate可以帮助我们使用共识算法轻松构建MeiliSearch集群。</p>
<p>自从两年半前我们开始该项目以来，我们就已经想到了这一点，并且我们正在尝试集成不同的Raft实现库，但是我们发现还没有一个能够满足我们的期望。这是我们在路线图中面临的最大挑战之一。</p>
<h2><a class="header" href="#我在meilisearch-github个人资料中看到了一个名为a-hrefhttpsgithubcommeilisearchmillimillia的项目这是meilisearch的未来吗您想谈谈吗" id="我在meilisearch-github个人资料中看到了一个名为a-hrefhttpsgithubcommeilisearchmillimillia的项目这是meilisearch的未来吗您想谈谈吗">我在MeiliSearch GitHub个人资料中看到了一个名为<a href="https://github.com/meilisearch/milli">milli</a>的项目。这是MeiliSearch的未来吗？您想谈谈吗？</a></h2>
<p>当然。 ^^</p>
<p>随着我们不断壮大的团队和项目，我们正在不断学习。去年，我们意识到，为了简化外部贡献者的入门工作和开发新功能，我们需要重新架构整个代码库，以使其更具可读性和可维护性。</p>
<p>我们的首席技术官kero在大约一年前（2020年8月）开始研究这种新的引擎迭代，我们计划在未来几个月内发布它。</p>
<p>我们在内部面临一些困难，难以在新的引擎迭代上确定工作的优先级，同时又要保持MeiliSearch的最新稳定版本。不过，我们迫不及待要正式发布它。性能提升令人难以置信！</p>
<p>Milli存储库托管核心引擎库的第4次迭代，但是使用该库使之成为可用二进制文件的代码将在MeiliSearch存储库中发布。</p>
<h2><a class="header" href="#据我了解meilisearch是完全开源的您如何支持它" id="据我了解meilisearch是完全开源的您如何支持它">据我了解，MeiliSearch是完全开源的。您如何支持它？</a></h2>
<p>我们在担任路易威登的承包商的同时启动了该项目。在与他们合作的同时，我们开发了大多数项目。在某个时候，我们意识到我们必须从风投那里筹集资金，以专注于开源项目。</p>
<p>我们认为，可以通过围绕MeiliSearch开展业务来使MeiliSearch可持续发展，该业务将以云产品（SaaS）的形式出售MeiliSearch并根据业务许可向具有特定需求的公司出售特定功能。</p>
<h2><a class="header" href="#您对想要启动自己的开源rust项目可以是技术性的也可以是非技术性的的人有什么建议" id="您对想要启动自己的开源rust项目可以是技术性的也可以是非技术性的的人有什么建议">您对想要启动自己的开源Rust项目（可以是技术性的也可以是非技术性的）的人有什么建议？</a></h2>
<p>开发和维护开源项目可以很快成为整个团队的全职工作。我建议任何想要开始维护开源项目以寻找合作伙伴的人，因为还有很多其他事情要做：您将不得不编写文档，文稿指南，回答问题并提出要求！</p>
<p>与您可能永远都不会见面的陌生人一起工作真是太好了，但我担心如果您一个人做，它很快就会变得不知所措。</p>
<h1><a class="header" href="#学习资源" id="学习资源">学习资源</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#rust-cheat-sheet-速查" id="rust-cheat-sheet-速查">Rust Cheat Sheet 速查</a></h2>
<p>内容包含：The Book BK, Rust by Example EX, Std Docs STD, Nomicon NOM, Reference REF。</p>
<p><a href="https://cheats.rs/">https://cheats.rs/</a></p>
<h2><a class="header" href="#微软出-rust-新手教程了" id="微软出-rust-新手教程了">微软出 Rust 新手教程了</a></h2>
<p>微软给想学习 Rust 的朋友提供了一份新手教程, 手把手带你走出 Rust 第一步.</p>
<p><a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/</a></p>
<h2><a class="header" href="#rust-标准库的-trait-引导大全" id="rust-标准库的-trait-引导大全">Rust 标准库的 trait 引导大全</a></h2>
<p>Rust 标准库提供了大量的 Trait，每个 Trait 的功能是什么？怎样区分功能有点类似的 Trait 的使用场景？这篇博客非常详细的介绍了标准库中各种内置 Trait，非常值得阅读。</p>
<p><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md">https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md</a></p>
<h2><a class="header" href="#面向-rust-初学者的错误处理指南" id="面向-rust-初学者的错误处理指南">面向 Rust 初学者的错误处理指南</a></h2>
<p><a href="https://dev.to/seanchen1991/a-beginner-s-guide-to-handling-errors-in-rust-40k2">https://dev.to/seanchen1991/a-beginner-s-guide-to-handling-errors-in-rust-40k2</a></p>
<h2><a class="header" href="#easy-rust---learn-to-program-in-rust-with-simple-english" id="easy-rust---learn-to-program-in-rust-with-simple-english">Easy Rust - learn to program in Rust with simple English</a></h2>
<p>Easy Rust 的作者用简单的英语词汇录制了一系列 Rust 教程的视频，发布在了 YouTube。每集 5 到 10 分钟，总共 186 集，23 个小时。</p>
<p><a href="https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk</a></p>
<h2><a class="header" href="#rust中的异步流part-1--future缓冲和难理解的编译错误" id="rust中的异步流part-1--future缓冲和难理解的编译错误">Rust中的异步流（Part 1）- Future，缓冲和难理解的编译错误</a></h2>
<p><a href="https://gendignoux.com/blog/2021/04/01/rust-async-streams-futures-part1.html">https://gendignoux.com/blog/2021/04/01/rust-async-streams-futures-part1.html</a></p>
<h2><a class="header" href="#kafka和rust入门-part-1" id="kafka和rust入门-part-1">Kafka和Rust入门 Part 1</a></h2>
<p><a href="https://dev.to/abhirockzz/getting-started-with-kafka-and-rust-part-1-4hkb">https://dev.to/abhirockzz/getting-started-with-kafka-and-rust-part-1-4hkb</a></p>
<h2><a class="header" href="#如何构建最精简的-rust-docker-镜像" id="如何构建最精简的-rust-docker-镜像">如何构建最精简的 Rust Docker 镜像</a></h2>
<ul>
<li><a href="https://kerkour.com/blog/rust-small-docker-image/">https://kerkour.com/blog/rust-small-docker-image/</a></li>
<li><a href="https://blog.budshome.com/budshome/gou-jian-zui-jing-jian-de-rust-docker-jing-xiang">译文</a></li>
</ul>
<h2><a class="header" href="#first-class-io" id="first-class-io">First-Class I/O</a></h2>
<p>即执行 I/O 的函数，可作为参数或返回值在程序中传递，如 File。</p>
<blockquote>
<p>纯函数式编程是一种巧妙的技巧，用以证明你无需可变即可编码，而 Rust 则是一种更加巧妙的技巧，用以表明你可以进行可变。</p>
</blockquote>
<p>First-Class I/O是广泛应用的有用概念，例如面向能力的安全性如何帮助实现<a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md#creating-maximally-reusable-modules">无共享链接</a>。 增量应用也很有用，例如io-stream 或cap-std 库如何帮助程序的各个部分高效地和惯用地进行协作。</p>
<p><a href="https://blog.sunfishcode.online/first-class-io/">https://blog.sunfishcode.online/first-class-io/</a></p>
<h2><a class="header" href="#盘点使用-safe-rust-实现的-标记-gc" id="盘点使用-safe-rust-实现的-标记-gc">盘点使用 Safe Rust 实现的 标记 GC</a></h2>
<p>本文盘点了近几年基于 Safe Rust 实现的 跟踪/标记类 GC 库。</p>
<p><a href="https://manishearth.github.io/blog/2021/04/05/a-tour-of-safe-tracing-gc-designs-in-rust/">https://manishearth.github.io/blog/2021/04/05/a-tour-of-safe-tracing-gc-designs-in-rust/</a></p>
<h2><a class="header" href="#rust-机器学习列表" id="rust-机器学习列表">Rust 机器学习列表</a></h2>
<p>有点 awesome-rust-ml 的意思。</p>
<p><a href="https://github.com/e-tony/best-of-ml-rust">https://github.com/e-tony/best-of-ml-rust</a></p>
<h2><a class="header" href="#使用-rust--lunatic--webassembly-构建-telnet-chat-server" id="使用-rust--lunatic--webassembly-构建-telnet-chat-server">使用 Rust + Lunatic + WebAssembly 构建 TelNet Chat Server</a></h2>
<p><a href="https://www.hackernoon.com/how-i-used-rust-lunatic-to-build-a-telnet-chat-server-with-webassembly-rb3l33cg">https://www.hackernoon.com/how-i-used-rust-lunatic-to-build-a-telnet-chat-server-with-webassembly-rb3l33cg</a></p>
<h2><a class="header" href="#将-actor-和-asyncawait-连接起来-part-1" id="将-actor-和-asyncawait-连接起来-part-1">将 Actor 和 Async/Await 连接起来 Part 1</a></h2>
<p>该文作者受官方异步基础组愿景文档影响，也写了一篇关于如何将他实现的 Stakker Actor 库和异步连接起来的一些思考。</p>
<p>Stakker 被设计为分层放置在用户喜欢使用的任何事件循环之上。 它旨在最大程度地利用Rust的编译时检查和优化。</p>
<ul>
<li><a href="https://github.com/uazu/stakker">https://github.com/uazu/stakker</a></li>
<li><a href="https://uazu.github.io/blog/20210406.html">https://uazu.github.io/blog/20210406.html</a></li>
</ul>
<h2><a class="header" href="#系列使用-warp-进行-rest-api-开发" id="系列使用-warp-进行-rest-api-开发">【系列】使用 Warp 进行 REST Api 开发</a></h2>
<p><a href="https://dev.to/rogertorres/series/12179">https://dev.to/rogertorres/series/12179</a></p>
<h2><a class="header" href="#rust-库的错误管理" id="rust-库的错误管理">Rust 库的错误管理</a></h2>
<p>如何提供易于理解，易于管理且足够具体的错误，以使用户能够易于处理？文章里给出一种方案。</p>
<p><a href="http://www.tglman.com/posts/rust_lib_error_management.html">http://www.tglman.com/posts/rust_lib_error_management.html</a></p>
<h2><a class="header" href="#libp2p-教程-使用-rust-构建一个点对点应用" id="libp2p-教程-使用-rust-构建一个点对点应用">libp2p 教程: 使用 Rust 构建一个点对点应用</a></h2>
<p>在这个教程里,作者会使用 libp2p 来构建一个简单的 peer-to-peer 菜谱应用.</p>
<p>在这个菜谱应用会有以下基本功能:</p>
<ul>
<li>创建菜谱.</li>
<li>发布菜谱.</li>
<li>列出本地菜谱.</li>
<li>列出网络上发现的其他菜谱.</li>
<li>列出一个节点上的菜谱.</li>
<li>列出所有已知节点上所有的菜谱.</li>
</ul>
<p><a href="https://blog.logrocket.com/libp2p-tutorial-build-a-peer-to-peer-app-in-rust/">https://blog.logrocket.com/libp2p-tutorial-build-a-peer-to-peer-app-in-rust/</a></p>
<h2><a class="header" href="#编写--sys-crate-帮助-rust-程序使用-c-库" id="编写--sys-crate-帮助-rust-程序使用-c-库">编写 <code>*-sys</code> crate 帮助 Rust 程序使用 C 库</a></h2>
<p>这篇文章简要解释了什么是 <code>*-sys</code> crate ，以及如何利用构建脚本以一次性完成 <code>*-sys</code> crate 的创建。</p>
<p><a href="https://kornel.ski/rust-sys-crate">https://kornel.ski/rust-sys-crate</a></p>
<h2><a class="header" href="#为什么rust字符串看起来很难" id="为什么rust字符串看起来很难">为什么Rust字符串看起来很难</a></h2>
<p>对于常规语言来说，字符串的理解对于大多数人来说不是难事。当新手开始接触Rust时,字符串&amp;str,String会让他们丈二和尚摸不着头脑。本文详细介绍了Rust中字符串使用困难的原因。</p>
<p><a href="https://www.brandons.me/blog/why-rust-strings-seem-hard">https://www.brandons.me/blog/why-rust-strings-seem-hard</a></p>
<h2><a class="header" href="#用rust构建小型滴灌系统" id="用rust构建小型滴灌系统">用Rust构建小型滴灌系统</a></h2>
<p>作者用Rust编写了一个给绿植的灌溉功能的小型系统。非常有意思的是，用的还是国内厂商的电磁阀。如果你对树莓派、硬件电路感兴趣的话，不要错过它。</p>
<p><a href="https://github.com/kitallis/WAP">https://github.com/kitallis/WAP</a></p>
<h2><a class="header" href="#嵌入式系统中使用-std" id="嵌入式系统中使用-std">嵌入式系统中使用 std</a></h2>
<p>估计很多有人也有这个疑问, 我们能在嵌入式系统编程中使用标准库 std 吗?</p>
<p>作者同样有这个疑问, 但是他找到了自己的答案, 有同样困扰的小伙伴可以参考一下.</p>
<p><a href="http://blog.timhutt.co.uk/std-embedded-rust/index.html">http://blog.timhutt.co.uk/std-embedded-rust/index.html</a></p>
<h2><a class="header" href="#rust-github-actions-最好的实践" id="rust-github-actions-最好的实践">[Rust] Github Actions 最好的实践</a></h2>
<p>在一个相当大的项目中，作者用 GitHub Actions 来完成一些重复性的工作，主要的两个改进就是：合并多个任务，使用 sccahe 提高测试速度</p>
<ul>
<li>GitHub workflows 矩阵</li>
<li>包含和排除规则</li>
<li>使用 sccahe 优化Rust编译速度</li>
<li>检验 sccache 结果</li>
</ul>
<p><a href="https://www.fluvio.io/blog/2021/04/github-actions-best-practices/">https://www.fluvio.io/blog/2021/04/github-actions-best-practices/</a></p>
<h2><a class="header" href="#rust-实现的一款有意思的迷宫游戏" id="rust-实现的一款有意思的迷宫游戏">Rust 实现的一款有意思的迷宫游戏</a></h2>
<p>挺好玩的 。。。</p>
<p>基于 Rust 实现，并可以导出 wasm </p>
<p><a href="https://ldjam.com/events/ludum-dare/48/$242669">https://ldjam.com/events/ludum-dare/48/$242669</a></p>
<ul>
<li>源码：<a href="https://github.com/Healthire/ld48">https://github.com/Healthire/ld48</a></li>
<li>浏览器play：<a href="https://healthire.github.io/ld48/">https://healthire.github.io/ld48/</a></li>
</ul>
<p>你可以关注 https://github.com/Healthire ，他不止用 Rust 做了这一个游戏</p>
<h2><a class="header" href="#rust-中如何使用-grpc" id="rust-中如何使用-grpc">Rust 中如何使用 gRPC</a></h2>
<p>本文介绍了 如何在Rust中创建gRPC服务器和客户端。 出于可见性目的，客户端还将是Telegram机器人。</p>
<p><a href="https://romankudryashov.com/blog/2021/04/grpc-rust/">https://romankudryashov.com/blog/2021/04/grpc-rust/</a></p>
<h2><a class="header" href="#一个-actix-web-中使用-tokio-tracing-的示例" id="一个-actix-web-中使用-tokio-tracing-的示例">一个 actix-web 中使用 tokio-tracing 的示例</a></h2>
<p><a href="https://github.com/LukeMathWalker/tracing-actix-web">https://github.com/LukeMathWalker/tracing-actix-web</a></p>
<h2><a class="header" href="#rust-中可能实现-移动构造函数move-constructors-吗" id="rust-中可能实现-移动构造函数move-constructors-吗">Rust 中可能实现 移动构造函数（Move Constructors） 吗？</a></h2>
<p>移动构造函数（Move Constructors） 是 Cpp 11 引入的一个特性，它允许开发者通过拿其他已存在对象来构造新的对象，从而避免深拷贝导致的效率问题。</p>
<p>如果 Rust 里也支持，那么也可以同样减少深拷贝效率问题，实现就地构造对象。 本文作者探讨了如何安全地实现这个特性，作者为此也实现了一个库 <a href="https://crates.io/crates/moveit">moveit</a>。</p>
<p>moveit 中充分利用了 Pin/Unpin 来实现该特性，除了 Rust 还支持 Cpp 的移动构造函数，以备 FFi 时候方便。虽然实现了 Unsafe trait ，但作者指明了 Safety 边界。</p>
<ul>
<li><a href="https://mcyoung.xyz/2021/04/26/move-ctors/">https://mcyoung.xyz/2021/04/26/move-ctors/</a></li>
</ul>
<h1><a class="header" href="#译rust-的-result-类型基础" id="译rust-的-result-类型基础">【译】Rust 的 Result 类型基础</a></h1>
<blockquote>
<ul>
<li>原文链接：https://medium.com/@JoeKreydt/a-primer-on-rusts-result-type-66363cf18e6a</li>
<li>原文作者：<a href="https://medium.com/@JoeKreydt?">Joe Kreydt</a></li>
<li>译者：<a href="https://www.github.com/suhanyujie">suhanyujie</a></li>
<li>后期整理：张汉东</li>
</ul>
</blockquote>
<hr />
<ul>
<li><img src="https://miro.medium.com/max/2099/1*AoZOz1AJS15yyB3TLUn93A.jpeg" alt="" /></li>
</ul>
<p><code>Result</code> 类型是 Rust 中处理错误的常用方法类型，它比较灵活；应该是非常灵活！</p>
<p>对于那些正在学 Rust 的人来讲，Result 可能不太直观，你可以通过阅读它的标准库<a href="https://doc.rust-lang.org/std/result/">文档</a>来了解如何使用是个不错的方法。如果你想迫切的学会它，也是可以的，但如果你只是用它处理错误或者使用某个返回 Result 类型的函数（很多人都这样做），你可能体会不到它的妙处。</p>
<p>为了节省大家的时间，我打算使用英语来解释 Rust 的 Result 类型。</p>
<h1><a class="header" href="#result-是什么" id="result-是什么">Result 是什么？</a></h1>
<h2><a class="header" href="#参考a-hrefhttpsdocrust-langorg1300bookfirst-editionerror-handlinghtmlrust-权威指南a" id="参考a-hrefhttpsdocrust-langorg1300bookfirst-editionerror-handlinghtmlrust-权威指南a">参考<a href="https://doc.rust-lang.org/1.30.0/book/first-edition/error-handling.html">Rust 权威指南</a></a></h2>
<p>“Result 表达的是错误的可能性。通常错误是用来解释某种任务执行失败的原因。”</p>
<p><img src="https://miro.medium.com/max/400/1*g1A-DkLZ6dPjOKTo4kzrGg.gif" alt="" /></p>
<h2><a class="header" href="#用朴素的英语解释" id="用朴素的英语解释">用朴素的英语解释</a></h2>
<p>Result 是一个函数返回的类型，它可以是 Ok，也可以是 Err。如果是 Ok，则表示函数按照预期执行完成。如果是 Err，则该函数出现了错误。</p>
<h1><a class="header" href="#result-用来做什么" id="result-用来做什么">Result 用来做什么？</a></h1>
<h2><a class="header" href="#根据-rust-权威指南" id="根据-rust-权威指南">根据 Rust 权威指南</a></h2>
<p>Result 类型是对计算过程中可能出现的结果的表示方式。按照惯例，如果一个结果是预期的 <code>Ok</code>，那么另一个结果则是意料之外的，即 <code>Err</code>。</p>
<h2><a class="header" href="#请再直观点" id="请再直观点">请再直观点</a></h2>
<p>函数返回了值。这些值具有特定的数据类型。函数可以返回 Result 类型的结果。Result 类型根据函数是否按预期执行而变化。然后，程序员可以编写一些代码，如果函数按预期执行则返回 A，如果遇到异常，则返回 B。</p>
<h1><a class="header" href="#不处理-result则产生异常" id="不处理-result则产生异常">不处理 Result，则产生异常</a></h1>
<pre><code>error[E0308]: mismatched types
  --&gt; main.rs:20:26
   |
20 |     let my_number: f64 = my_string.trim().parse(); //.unwrap();
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected f64, found enum `std::result::Result`
   |
   = note: expected type `f64`
              found type `std::result::Result&lt;_, _&gt;`
error: aborting due to previous error
For more information about this error, try `rustc --explain E0308`.
compiler exit status 1
</code></pre>
<p>报错信息中关键的部分是，“expected f64, found enum.”，类似的场景中，可能还会有：</p>
<pre><code>- “expected u32, found enum”
- “expected String, found enum”
- “expected [insert type here], found enum”
</code></pre>
<p><strong>如果你得到一个类似上面的错误，那是因为需要你处理函数返回的 Result 类型数据</strong></p>
<h1><a class="header" href="#类型为-error-的-result-的程序" id="类型为-error-的-result-的程序">类型为 Error 的 Result 的程序</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::io::{stdin, self, Write};
fn main(){
    let mut my_string = String::new();
    print!(“Enter a number: “);
    io::stdout().flush().unwrap();
    stdin().read_line(&amp;mut my_string)
        .expect(“Did not enter a correct string”);
    let my_number: f64 = my_string.trim().parse();
    println!(“Yay! You entered a number. It was {:?}”, my_num);
}
</code></pre></pre>
<p>在这个程序中，它提示用户输入一个数字。然后将输入作为字符串读入并存储下来。我们想要的是一个数值类型，不是 String，所以我们需要使用 <em>parse()</em> 函数将其转换为一个 64 位浮点数（f64）。</p>
<p>如果用户输入的是一个数字，那么 <em>parse()</em> 函数将其转换为 f64 没什么大问题。但我们仍然会得到一个错误。</p>
<p>发生错误是因为 <em>parse()</em> 函数不只是将 String 转换为数字并返回。相反，它接受字符串，将其转换为数字，然后返回 Result 类型。Result 类型需要被解包才能得到我们需要的数值。</p>
<h2><a class="header" href="#用-unwrap-或-expect-修复错误" id="用-unwrap-或-expect-修复错误">用 Unwrap() 或 Expect() 修复错误</a></h2>
<p>转换后的数字可以可以通过在 <em>parse()</em> 后面附加调用 <em>unwrap()</em> 函数将数字从 Result 中“解包”出来，类似于这样： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_number: f64 = my_string.trim().parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><em>unwrap()</em> 函数可以看出 Result 中类型，可能是 <em>Ok</em>，也可能是 <em>Err</em>。如果 Result 中包裹的类型是 <em>Ok</em>，那么 <em>unwrap()</em> 则返回它的值。如果 Result 中的类型是 <em>Err</em>，<em>unwrap()</em> 则会让程序崩溃。</p>
<p><img src="https://miro.medium.com/max/470/1*bPYM5NAZ8OYenRAejcI7uA.gif" alt="" /></p>
<p>你也可以用 <em>expect()</em> 函数像下方这样来处理 Result：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_number: f64 = my_string.trim().parse().expect(“Parse failed”);
<span class="boring">}
</span></code></pre></pre>
<p><em>expect()</em> 的工作方式类似于 <em>unwrap()</em>，假如 Result 是 <em>Err</em>，<em>expect()</em> 将会使程序崩溃<strong>并且</strong>将其中的字符串内容 —— “Parse failed.”展示在标准输出中。</p>
<h2><a class="header" href="#使用-unwrap-和-expect-的缺点" id="使用-unwrap-和-expect-的缺点">使用 unwrap() 和 expect() 的缺点</a></h2>
<p>当我们使用 <em>unwrap()</em> 和 <em>expect()</em> 函数时，如果遇到错误，程序会发生崩溃。如果错误发生的几率非常小，这也许可以容忍，但在某些情况下，错误发生的概率会比较大。</p>
<p>在上面的示例中，用户可能输入错误，输入的不是数值（可能是字母或者特殊符号）。我们并不想每次用户输入错误的内容程序就发生崩溃。相反，我们应该提示用户应该输入数字。这种场景下，Result 就非常有用，尤其是当它与一个模式匹配的表达式相结合的时候。</p>
<h1><a class="header" href="#用匹配表达式修复错误" id="用匹配表达式修复错误">用匹配表达式修复错误</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::io::{stdin, self, Write};
fn main(){
    let mut my_string = String::new();
    print!(“Enter a number: “);
    io::stdout().flush().unwrap();
    let my_num = loop {
        my_string.clear();
        stdin().read_line(&amp;mut my_string)
            .expect(“Did not enter a correct string”);
        match my_string.trim().parse::&lt;f64&gt;() {
            Ok(_s) =&gt; break _s,
            Err(_err) =&gt; println!(“Try again. Enter a number.”)
        }
    };
    println!(“You entered {:?}”, my_num);
}
</code></pre></pre>
<p>如果你问我怎么实现，上面就是示例代码！</p>
<p>前面提到的不优雅的实现和优雅的实现方式的不同点是在循环体内部。我们可以分解一下。</p>
<h1><a class="header" href="#代码分析" id="代码分析">代码分析</a></h1>
<p>在 loop 之前，我们提示用户输入一个数字。接着我们声明 my_num。</p>
<p>我们将循环体中返回的值（用户的输入，它将从字符串转换为数字）赋给 my_num：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_num = loop {
<span class="boring">}
</span></code></pre></pre>
<p>在循环体中，我们阻塞等待用户输入。然后接收用户的输入，在这个过程中我们有三个问题要解决。</p>
<ul>
<li>1.我们需要确定用户输入的是数字而非其他的字符，一个词或者一个字母。</li>
<li>2.Rust 中的 <em>read_line()</em> 函数能够以字符串的类型拿到用户的输入。我们需要将其转换为浮点数。</li>
<li>3.如果用户没有输入数字，我们需要清理变量，并提示和等待用户再次输入。</li>
</ul>
<p>在第三部分问题（清理 my_string 变量）在循环体内的第一行就已经实现了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>my_string.clear();
<span class="boring">}
</span></code></pre></pre>
<p>下一步，我们接收用户的输入：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stdin().read_line(&amp;mut my_string)
    .expect(“Did not enter a correct string”);
<span class="boring">}
</span></code></pre></pre>
<p><em>read_line()</em> 函数返回一个 Result 类型。我们使用 <em>expect()</em> 函数处理它。在这种情形下是完全没问题的，因为 <em>read_line()</em> 出错的几率非常小。用户通常只能在终端输入一个字符串，而这正是 <em>read_line()</em> 所需要处理的。</p>
<p>通过 <em>read_line()</em> 把用户输入的字符串返回并存在 <em>my_string</em> 变量中。</p>
<h2><a class="header" href="#重要部分" id="重要部分">重要部分</a></h2>
<p>现在我们已经将输入的字符串存在 <em>my_string</em> 中，我们需要将其转换为浮点数。使用 <em>parse()</em> 函数可以实现，然后将浮点数结果返回。所以我们有不止 Result 的类型需要处理，但这一次，我们很可能会出现一个错误。如果用户输入的是非数字， <em>parse()</em> 将会返回一个错误类型的 Result（<em>Err</em>）。如果发生这种情况，我们不希望程序崩溃。而是希望提示用户没有输入正确的数字，请再试一次。为此，我们需要写好调用 <em>parse()</em> 成功时的逻辑，还要写好调用失败时的逻辑。类似于逐个处理匹配表达式可能的结果。</p>
<h2><a class="header" href="#分析匹配表达式" id="分析匹配表达式">分析匹配表达式</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match my_string.trim().parse::&lt;f64&gt;() {
    Ok(_s) =&gt; break _s,
    Err(_err) =&gt; println!(“Try again. Enter a number.”)
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们使用 match 关键字来声明匹配表达式。然后，我们提供与表达式匹配的可能的值。这个值就是下面所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>my_string.trim().parse::&lt;f64&gt;()
<span class="boring">}
</span></code></pre></pre>
<p>这段代码接收 my_string 参数，它将用户输入的内容保存下来，并提供给 <em>trim()</em> 函数。<em>trim()</em> 函数会删除掉字符串两侧可能存在的额外空行或空格。我们之所以需要 <em>trim()</em> 是因为 <em>read_line()</em> 函数在输入中附加了一个额外的空行，这会导致转换会出现异常。然后将清理了空格字符的 my_string 传递到 <em>parse()</em> 函数中，该函数会尝试将其转换为浮点数。</p>
<p>如果 <em>parse()</em> 成功地将 my_string 转换为数字，则返回 Ok。在这个情况下，我们可以得到浮点数。如果用户输入的不是数字，那么 <em>parse()</em> 将无法正常完成转换，它会返回 Err。</p>
<p>在匹配表达式的花括号（主体）中，我们根据 <em>parse()</em> 返回的类型告诉计算机怎么做：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Ok(_s) =&gt; break _s,
Err(_err) =&gt; println!(“Try again. Enter a number.”)
<span class="boring">}
</span></code></pre></pre>
<p><strong>如果结果是 Ok</strong>，则表示 <em>parse()</em> 能够转换该类型。这时，我们调用一个 break，停止循环，并返回存储在 Ok 中的值，这个值会被放在 _s 变量中。</p>
<p><strong>如果结果是 Err</strong>，<em>parse()</em> 无法完成转换。这时，我们会告诉用户“重试一次。输入一个数字”。由于我们不调用 break，所以循环重新开始。</p>
<blockquote>
<p>如果必须用一句话解释 Result，那就是：如果一个函数返回 Result，一个匹配表达式可以根据结果是 Ok 还是 Err 来执行不同的代码。</p>
</blockquote>
<h2><a class="header" href="#在你的函数中使用-result" id="在你的函数中使用-result">在你的函数中使用 Result</a></h2>
<p>既然你已经了解了处理 Result 的方法，那么你可能会希望在你自己创建的函数中使用它。</p>
<p>我们先看一个例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let my_num = 50;
    
    fn is_it_fifty(num: u32) -&gt; Result&lt;u32, &amp;’static str&gt; {
        let error = “It didn’t work”;
        if num == 50 {
            Ok(num)
        } else {
            Err(error)
        }
    }
    match is_it_fifty(my_num) {
        Ok(_v) =&gt; println!(“Good! my_num is 50”),
        Err(_e) =&gt; println!(“Error. my_num is {:?}”, my_num)
    }
}
</code></pre></pre>
<p>这个程序检查 <em>my_num</em> 的值。如果值为 50，则表示成功；如果不是，则表示错误。</p>
<p>这段代码的主体是 <em>is_it_fifty()</em> 函数。它是有返回结果的声明式函数。我们逐行看其中的代码。</p>
<p>首先，我们声明 <em>my_num</em> 并给它赋值。然后，我们声明 <em>is_it_fifty()</em> 函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_it_fifty(num: u32) -&gt; Result&lt;u32, &amp;’static str&gt; {
<span class="boring">}
</span></code></pre></pre>
<p>在我们的声明中，我们指定该函数接收一个名为 num 的参数，其类型是 32 位无符号整数类型（u32）。接下来，我们指定函数的返回值类型。表示函数会返回一个结果，类型是 u32 或字串（&amp;'static str）</p>
<p>然后，我们编写 <em>is_it_fifty()</em> 的函数体。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let error = “It didn’t work”;
if num == 50 {
    Ok(num)
} else {
    Err(error)
}
<span class="boring">}
</span></code></pre></pre>
<p>函数体中的代码是一个 if else 表达式。它用于判断传入的参数。</p>
<p>如果值是 50，那么函数将返回 Ok 的 Result。Ok 中将会包含传递给函数的值（<em>num</em>）。</p>
<p>如果参数不是 50，函数将返回 Err 的 Result。<em>Err</em> 会包含错误变量的值，也即 “It didn’t work.”</p>
<p>无论何时使用该函数，都必须处理它返回的 Result。在我们的程序中，与大多数 Rust 程序一样，是通过一个匹配表达式完成的。我在之前已经描述过部分匹配表达式。</p>
<p>Result 类型可以使用 <em>unwrap()</em> 或 <em>expect()</em> 来处理 —— 前面也已经解释过。</p>
<p><img src="https://miro.medium.com/max/480/1*ZLronSWbmj4IwGoWepecHQ.gif" alt="" /></p>
<h2><a class="header" href="#总结-8" id="总结-8">总结</a></h2>
<p>Result 是一个函数的返回类型，它表示函数执行是否成功。</p>
<p>Rust 的许多内置函数都是返回 Result 类型，如果是这样的话，就没有办法避开它。如果一个函数返回 Result，它必须要被妥善处理。</p>
<p>处理 Result 常用的方法是使用 <em>unwrap()</em> 和 _expect() 函数以及匹配表达式。</p>
<p>可以从自己定义的函数中返回 Result。这是处理错误的好办法。</p>
<p>关于 Rust 的 Result 类型，你需要知道的就这些了，但是如果想了解更多信息，或者想知道我从哪儿收集的这些信息，可以参考下方的资源列表。</p>
<h2><a class="header" href="#资源" id="资源">资源</a></h2>
<ul>
<li>https://doc.rust-lang.org/std/result/</li>
<li>https://doc.rust-lang.org/1.2.0/book/match.html
<ul>
<li>查看 <code>matching on enums</code> 部分</li>
</ul>
</li>
<li>https://doc.rust-lang.org/1.30.0/book/first-edition/error-handling.html</li>
<li>https://doc.rust-lang.org/rust-by-example/flow_control/match.html</li>
<li>https://blog.jonstodle.com/things-i-enjoy-in-rust-error-handling/</li>
<li>https://stevedonovan.github.io/rust-gentle-intro/6-error-handling.html</li>
<li>https://doc.rust-lang.org/book/ch03-03-how-functions-work.html</li>
<li>https://doc.rust-lang.org/std/result/enum.Result.html#method.expect</li>
</ul>
<h1><a class="header" href="#常见问题汇总-1" id="常见问题汇总-1">常见问题汇总</a></h1>
<blockquote>
<p>来源：<a href="https://rust-zh.github.io/faq/">https://rust-zh.github.io/faq/</a></p>
<p>欢迎贡献：</p>
<p>更多阅读： <a href="https://rust-zh.github.io/faq/">https://rust-zh.github.io/faq/</a></p>
</blockquote>
<hr />
<p>本期摘录：</p>
<h2><a class="header" href="#如何同时等待多个-future" id="如何同时等待多个-future">如何同时等待多个 Future？</a></h2>
<p>如果想要等待多个 <code>Future</code> 都完成后返回，对于固定数量的 <code>Future</code> 可以使用 <a href="https://crates.io/crates/futures">futures</a> 所提供的 <a href="https://docs.rs/futures/0.3/futures/future/fn.join.html"><code>join</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.join3.html"><code>join3</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.join4.html"><code>join4</code></a> 等函数，或者 <a href="https://crates.io/crates/tokio">tokio</a> 所提供的 <a href="https://docs.rs/tokio/1/tokio/macro.join.html"><code>join!</code></a> 宏，将多个 <code>Future</code> 合并为一个进行等待。对于不定数量的 <code>Future</code>，比如有一个 <code>Vec</code>，则可以使用 <code>futures</code> 的 <a href="https://docs.rs/futures/0.3/futures/future/fn.join_all.html"><code>join_all</code></a> 函数。</p>
<p>若要在数个 <code>Future</code> 中第一个错误发生时就返回，则可以使用它们对应的 <a href="https://docs.rs/futures/0.3/futures/future/fn.try_join.html"><code>try_join</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join3.html"><code>try_join3</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join4.html"><code>try_join4</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join_all.html"><code>try_join_all</code></a> 等函数以及 <a href="https://docs.rs/tokio/1/tokio/macro.try_join.html"><code>try_join!</code></a> 宏。</p>
<p>如果想要在多个 <code>Future</code> 中的第一个完成后就返回，可以使用 futures 的 <a href="https://docs.rs/futures/0.3/futures/future/fn.select.html"><code>select</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.select_all.html"><code>select_all</code></a> 和 <a href="https://docs.rs/futures/0.3/futures/future/fn.select_ok.html"><code>select_ok</code></a> 函数或 tokio 的 <a href="https://docs.rs/tokio/1/tokio/macro.select.html"><code>select!</code></a> 宏。</p>
<p>需要注意的是，上面这些函数和宏在每次被轮询的时候，都会轮询里面每一个未完成的 <code>Future</code>，因此当其所带的 <code>Future</code> 很多时可能会有性能问题。</p>
<p>使用 futures 提供的 <a href="https://docs.rs/futures/0.3/futures/stream/struct.FuturesOrdered.html"><code>FuturesOrdered</code></a> 和 <a href="https://docs.rs/futures/0.3/futures/stream/struct.FuturesUnordered.html"><code>FuturesUnordered</code></a> 这两个结构可以解决这一问题。它们是为管理大量的 <code>Future</code> 而设计的，只会去轮询收到了唤醒通知的 <code>Future</code>。它们将这些 <code>Future</code> 聚合成一个 <a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>Stream</code></a> 逐个返回里面 <code>Future</code> 的结果，其中前者会按照输入的 <code>Future</code> 的顺序返回，而后者则是以任意顺序（可以近似看作按照完成顺序）返回。</p>
<h2><a class="header" href="#新创建的空-vect-的指针为何指向1248等地址" id="新创建的空-vect-的指针为何指向1248等地址"># 新创建的空 <code>Vec&lt;T&gt;</code> 的指针为何指向<code>1</code>、<code>2</code>、<code>4</code>、<code>8</code>等地址？</a></h2>
<p>当 <code>Vec</code> 的容量为0时，没有合法的操作会向其指针指向的位置进行读取和写入，进行任何读写之前都必然会有一次内存分配，因此这个初始的指针并不需要是一个有效的指针。这也使得创建 <code>Vec</code> 本身没有进行实际内存分配的必要，既省去了内存分配的开销，也让创建容器的操作可以在常量上下文中使用。</p>
<p>而因为 <code>Vec</code> 需要能被作为[切片]使用，由于切片对数据指针的<a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety">要求</a>，它的指针的地址需要是非空并且正确对齐的，因而简单起见便选择了类型的对齐的大小作为这个无效指针指向的地址。</p>
<h2><a class="header" href="#如果有一个-trait-foo-base如何将一个-dyn-foo-转换到-dyn-base" id="如果有一个-trait-foo-base如何将一个-dyn-foo-转换到-dyn-base">如果有一个 <code>trait Foo: Base</code>，如何将一个 <code>&amp;dyn Foo</code> 转换到 <code>&amp;dyn Base</code>？</a></h2>
<p>Rust 目前不直接提供这种转换，如果需要转换可以使用一个中间[特质]来实现，如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Base {
    // ...
}

trait AsBase {
    fn as_base(&amp;self) -&gt; &amp;dyn Base;
}

impl&lt;T: Base&gt; AsBase for T {
    fn as_base(&amp;self) -&gt; &amp;dyn Base { self }
}

trait Foo: AsBase {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>不支持的主要原因是在[特质对象]的[虚表]中没有相应的数据指向另一个特质的虚表，而不提供相应数据的原因可能是由于这很容易产生过多无用的虚表，进而导致二进制体积的膨胀。</p>
<p>更多关于这一话题的讨论可以参考 <a href="https://github.com/rust-lang/rfcs/issues/2765">RFC 2765</a> 以及 <a href="https://articles.bchlr.de/traits-dynamic-dispatch-upcasting">Traits, dynamic dispatch and upcasting</a>。</p>
<h1><a class="header" href="#语言技巧" id="语言技巧">语言技巧</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#返回多态类型" id="返回多态类型">返回多态类型</a></h2>
<pre><pre class="playground"><code class="language-rust">use rand::{thread_rng, Rng};

/// This is the trait that every die needs to implement to be... well... &quot;rollable&quot;, right?
pub trait Rollable {
    /// Roll the die
    fn roll() -&gt; Self;
    /// Get the value from the latest roll
    fn val(&amp;self) -&gt; u8;
}

/// A generic function to roll a given die.
pub fn roll&lt;T: Rollable&gt;() -&gt; T {
    Rollable::roll() // &lt;- Note that here `Rollable` is the current type for a given call!
}

/// A D6 die (6 faces): a roll will give you a `u8` in the `1..=6` range.
#[derive(Debug)]
pub struct D6(u8);

impl Rollable for D6 {
    fn roll() -&gt; D6 {
        D6 {
            0: thread_rng().gen_range(1..=6),
        }
    }
    fn val(&amp;self) -&gt; u8 {
        self.0
    }
}

/// A D8 die (8 faces): a roll will give you a `u8` in the `1..=8` range.
#[derive(Debug)]
pub struct D8(u8);

impl Rollable for D8 {
    fn roll() -&gt; D8 {
        D8 {
            0: thread_rng().gen_range(1..=8),
        }
    }
    fn val(&amp;self) -&gt; u8 {
        self.0
    }
}

#[derive(Debug)]
struct Fake100(u8);

impl Rollable for Fake100 {
    fn roll() -&gt; Fake100 {
        Fake100 { 0: 100 } // &lt;- forces it to roll 100
    }
    fn val(&amp;self) -&gt; u8 {
        self.0
    }
}

fn main() {
    // let's roll a D6
    let r: D6 = roll();
    println!(&quot;{:?}&quot;, r); // D6(3)

    // let's roll a D8
    let r: D8 = roll();
    println!(&quot;{:?}&quot;, r); // D8(3)

    println!(&quot;I bet I'll get a 100 this time!&quot;);
    let d: Fake100 = roll();
    println!(&quot;Look what I got: {}!&quot;, d.val()) // &lt;- yeah this will always be 100
}
</code></pre></pre>
<p>也支持类型推断：</p>
<pre><pre class="playground"><code class="language-rust">fn try_dodge_attack(d6: D6, d8: D8) -&gt; bool {
    d6.val() + d8.val() &gt; 10
}

fn main() {
    let escaped = try_dodge_attack(roll(), roll());
    println!(
        &quot;{}&quot;,
        match escaped {
            true =&gt; &quot;You dogded!&quot;,
            false =&gt; &quot;Ouch! The attack hit you!&quot;,
        }
    );
}
</code></pre></pre>
<p><a href="https://loige.co/rust-shenanigans-return-type-polymorphism/">来源</a></p>
<h2><a class="header" href="#一个零开销链表的实现" id="一个零开销链表的实现">一个零开销链表的实现</a></h2>
<p>下面代码实现了一个 持久性/不变性（Persistent / Immutable ）的单向链表（Singly-linked）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum List&lt;'a, T&gt; {
    Node { data: T, next: &amp;'a List&lt;'a, T&gt; },
    Tail,
}

impl&lt;T&gt; Default for List&lt;'_, T&gt; {
    fn default() -&gt; Self {
        List::Tail
    }
}

impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn add(&amp;'a self, data: T) -&gt; Self {
        List::Node { data, next: self }
    }

    pub fn rev_iter(&amp;'a self, f: impl Fn(&amp;'a T)) {
        if let List::Node { data, next } = self {
            next.rev_iter(&amp;f);
            f(data);
        }
    }

    pub fn try_rev_iter&lt;E, F&gt;(&amp;'a self, f: F) -&gt; Result&lt;(), E&gt;
    where
        F: Fn(&amp;'a T) -&gt; Result&lt;(), E&gt;,
    {
        if let List::Node { data, next } = self {
            next.try_rev_iter(&amp;f)?;
            f(data)?;
        }
        Ok(())
    }
}

pub struct ListIter&lt;'a, T&gt;(&amp;'a List&lt;'a, T&gt;);

impl&lt;'a, T&gt; IntoIterator for &amp;'a List&lt;'a, T&gt; {
    type Item = &amp;'a T;

    type IntoIter = ListIter&lt;'a, T&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        ListIter(self)
    }
}

impl&lt;'a, T&gt; Iterator for ListIter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.0 {
            List::Node { data, next } =&gt; {
                self.0 = next;
                Some(data)
            }
            List::Tail =&gt; None,
        }
    }
}


#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Num(f64),
    Bool(bool),
    String(String),
}

#[derive(PartialEq)]
pub enum ValueKind {
    Num,
    Bool,
    String,
}

impl Value {
    pub fn kind(&amp;self) -&gt; ValueKind {
        match self {
            Value::Num(_) =&gt; ValueKind::Num,
            Value::Bool(_) =&gt; ValueKind::Bool,
            Value::String(_) =&gt; ValueKind::String,
        }
    }
}

#[derive(Debug, Clone)]
pub enum Expr {
    Value(Value),
    Variable(String),
    UnExpr(UnExprKind, Box&lt;Expr&gt;),
    BinExpr(BinExprKind, Box&lt;(Expr, Expr)&gt;),
    Define(String, Box&lt;(Expr, Expr)&gt;),
    IfThenElse(Box&lt;(Expr, Expr, Expr)&gt;),
}

#[derive(Debug, Copy, Clone)]
pub enum UnExprKind {
    Not,
    Neg,
}

#[derive(Debug, PartialEq, Copy, Clone)]
pub enum BinExprKind {
    // Arithmetic
    Add,
    Sub,
    Mul,
    Div,

    // Logic
    And,
    Or,
    Equals,
    NotEquals,
}

type Variables&lt;'a&gt; = List&lt;'a, (String, Value)&gt;;

pub fn eval(vars: &amp;Variables&lt;'_&gt;, expr: Expr) -&gt; Option&lt;Value&gt; {
    match expr {
        Expr::Value(val) =&gt; Some(val),

        Expr::Variable(var) =&gt; vars
            .into_iter()
            .find(|&amp;(v, _)| *v == var)
            .map(|(_, val)| val.clone()),

        Expr::UnExpr(kind, expr) =&gt; {
            eval_unary(kind, vars, *expr)
        }

        Expr::BinExpr(kind, exprs) =&gt; {
            eval_binary(kind, vars, exprs.0, exprs.1)
        }

        Expr::Define(name, exprs) =&gt; {
            let value = eval(vars, exprs.0)?;
            let vars = vars.add((name, value));
            eval(&amp;vars, exprs.1)
        }

        Expr::IfThenElse(exprs) =&gt; {
            if let Value::Bool(b) = eval(vars, exprs.0)? {
                eval(vars, if b { exprs.1 } else { exprs.2 })
            } else {
                None
            }
        }
    }
}

fn eval_unary(
    kind: UnExprKind,
    vars: &amp;Variables&lt;'_&gt;,
    expr: Expr,
) -&gt; Option&lt;Value&gt; {
    let val = eval(vars, expr)?;
    match (kind, val) {
        (UnExprKind::Not, Value::Bool(b)) =&gt; {
            Some(Value::Bool(!b))
        }
        (UnExprKind::Neg, Value::Num(n)) =&gt; Some(Value::Num(-n)),
        _ =&gt; None,
    }
}

fn eval_binary(
    kind: BinExprKind,
    vars: &amp;Variables&lt;'_&gt;,
    lhs: Expr,
    rhs: Expr,
) -&gt; Option&lt;Value&gt; {
    let lhs = eval(vars, lhs)?;

    match kind {
        BinExprKind::Add =&gt; {
            if let Value::Num(lhs) = lhs {
                if let Value::Num(rhs) = eval(vars, rhs)? {
                    return Some(Value::Num(lhs + rhs));
                }
            }
            None
        }
        BinExprKind::Sub =&gt; {
            if let Value::Num(lhs) = lhs {
                if let Value::Num(rhs) = eval(vars, rhs)? {
                    return Some(Value::Num(lhs - rhs));
                }
            }
            None
        }
        BinExprKind::Mul =&gt; {
            if let Value::Num(lhs) = lhs {
                if let Value::Num(rhs) = eval(vars, rhs)? {
                    return Some(Value::Num(lhs * rhs));
                }
            }
            None
        }
        BinExprKind::Div =&gt; {
            if let Value::Num(lhs) = lhs {
                if let Value::Num(rhs) = eval(vars, rhs)? {
                    return Some(Value::Num(lhs / rhs));
                }
            }
            None
        }

        BinExprKind::And =&gt; {
            if let Value::Bool(lhs) = lhs {
                if !lhs {
                    return Some(Value::Bool(false));
                }
                if let Value::Bool(rhs) = eval(vars, rhs)? {
                    return Some(Value::Bool(rhs));
                }
            }
            None
        }
        BinExprKind::Or =&gt; {
            if let Value::Bool(lhs) = lhs {
                if lhs {
                    return Some(Value::Bool(true));
                }
                if let Value::Bool(rhs) = eval(vars, rhs)? {
                    return Some(Value::Bool(rhs));
                }
            }
            None
        }
        BinExprKind::Equals =&gt; {
            let rhs = eval(vars, rhs)?;
            if lhs.kind() == rhs.kind() {
                Some(Value::Bool(lhs == rhs))
            } else {
                None
            }
        }
        BinExprKind::NotEquals =&gt; {
            let rhs = eval(vars, rhs)?;
            if lhs.kind() == rhs.kind() {
                Some(Value::Bool(lhs != rhs))
            } else {
                None
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://aloso.github.io/2021/04/12/linked-list.html">来源</a></p>
<h1><a class="header" href="#rfc-介绍--try-trait-v2" id="rfc-介绍--try-trait-v2">RFC 介绍 | try-trait v2</a></h1>
<p>编辑： 张汉东</p>
<blockquote>
<p>编者按：</p>
<p><a href="https://rust-lang.github.io/rfcs/3058-try-trait-v2.html">RFC 3058 try_trait_v2</a> 被合并了，这意味着，<code>?</code> 操作符的行为在设计上已经趋于稳定，只等待它的实现。</p>
<p>在 RustFriday 飞书群线上沙龙 第四期 也讲过这个 RFC ，可以观看录播：<a href="https://www.bilibili.com/video/BV1xy4y147Ve/">https://www.bilibili.com/video/BV1xy4y147Ve/</a></p>
<p>Rust 中文社群 飞书群 邀请你加入：<a href="https://applink.feishu.cn/TeLAcbDR">https://applink.feishu.cn/TeLAcbDR </a></p>
</blockquote>
<hr />
<h2><a class="header" href="#背景介绍-1" id="背景介绍-1">背景介绍</a></h2>
<p>目前 Rust 允许通过 <code>?</code> 操作符可以自动返回的 <code>Result&lt;T, E&gt;</code> 的 <code>Err(e)</code> ，但是对于 <code>Ok(o)</code> 还需要手动包装。</p>
<p>比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Result&lt;PathBuf, io::Error&gt; {
    let base = env::current_dir()?;
    Ok(base.join(&quot;foo&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<p>那么这就引出了一个 术语： Ok-Wrapping 。很明显，这个写法不够优雅，还有很大的改进空间。</p>
<p>因此 Rust 官方成员 withoutboats 开发了一个库 <a href="https://github.com/withoutboats/fehler">fehler</a>，引入了一个 throw 语法。</p>
<p>用法如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[throws(i32)]
fn foo(x: bool) -&gt; i32 {
    if x {
        0
    } else {
        throw!(1);
    }
}

// 上面foo函数错误处理等价于下面bar函数

fn bar(x: bool) -&gt; Result&lt;i32, i32&gt; {
    if x {
        Ok(0)
    } else {
        Err(1)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过 throw 宏语法来帮助开发者省略 Ok-wrapping 和 Err-wrapping 的手动操作。这个库一时在社区引起了一些讨论。它也在促进着 Rust 错误处理体验提升。</p>
<p>于是错误处理就围绕着 Ok-wrapping 和 Err-wrapping 这两条路径，该如何设计语法才更加优雅为出发点。</p>
<h2><a class="header" href="#try块-和-try-trait-的区别" id="try块-和-try-trait-的区别"><code>try</code>块 和 <code>try trait</code> 的区别</a></h2>
<p>当前 Nightly Rust 中也提供了一个 <code>try</code> 块语法，要使用 <code>#![feature(try_blocks)]</code>。</p>
<p>用法如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
#![feature(try_blocks)]
<span class="boring">fn main() {
</span>use std::path::PathBuf;

fn foo() -&gt; Result&lt;PathBuf, std::io::Error&gt; {
    try {
        let base = std::env::current_dir()?;
        base.join(&quot;foo&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>try</code> 块在 <code>Ok</code> 情况下自动 Ok-wrapping 返回 <code>Ok(PathBuf)</code>，而问号操作符返回 <code>Err(io::Error)</code>。所以，这个 <code>try</code> 块语法 和 <code>try trait</code> 是相互配合的。</p>
<p>所以：</p>
<ul>
<li><code>try</code> 块 （try-block）是控制 Ok-wrapping</li>
<li><code>try trait</code> 是控制问号操作符的行为 Err-wrapping</li>
</ul>
<h2><a class="header" href="#try-trait-rfc-导读" id="try-trait-rfc-导读">try-trait RFC 导读</a></h2>
<p>经过很久很久的讨论，try-trait-v2 RFC 被合并了，意味着一个确定的方案出现了。</p>
<p><strong>在这个方案中，引入了一个新类型：<code>ControlFlow</code>。</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ControlFlow&lt;B, C = ()&gt; {
    /// Exit the operation without running subsequent phases.
    Break(B),
    /// Move on to the next phase of the operation as normal.
    Continue(C),
}

impl&lt;B, C&gt; ControlFlow&lt;B, C&gt; {
    fn is_break(&amp;self) -&gt; bool;
    fn is_continue(&amp;self) -&gt; bool;
    fn break_value(self) -&gt; Option&lt;B&gt;;
    fn continue_value(self) -&gt; Option&lt;C&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>ControlFlow</code> 中包含了两个值：</p>
<ul>
<li><code>ControlFlow::Break</code>，表示提前退出。但不一定是<code>Error</code>  的情况，也可能是 <code>Ok</code>。 </li>
<li><code>ControlFlow::Continue</code>，表示继续。</li>
</ul>
<p><strong>还引入了一个新的trait：<code>FromResidual</code></strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FromResidual&lt;Residual = &lt;Self as Try&gt;::Residual&gt; {
    fn from_residual(r: Residual) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>Residual 单词有 「剩余」之意，因为 要把 Result / Option/ ControlFlow 之类的类型，拆分成两部分（两条路径），用这个词就好理解了。</p>
<p>而  <code>Try</code> trait 继承自 <code>FromResidual</code> trait ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Try: FromResidual {
    /// The type of the value consumed or produced when not short-circuiting.
    type Output;

    /// A type that &quot;colours&quot; the short-circuit value so it can stay associated
    /// with the type constructor from which it came.
    type Residual;

    /// Used in `try{}` blocks to wrap the result of the block.
    fn from_output(x: Self::Output) -&gt; Self;

    /// Determine whether to short-circuit (by returning `ControlFlow::Break`)
    /// or continue executing (by returning `ControlFlow::Continue`).
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
}

pub trait FromResidual&lt;Residual = &lt;Self as Try&gt;::Residual&gt; {
    /// Recreate the type implementing `Try` from a related residual
    fn from_residual(x: Residual) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>所以，在 <code>Try</code> trait 中有两个关联类型：</p>
<ul>
<li><code>Output</code>，如果是 Result 的话，就对应 Ok-wrapping 。</li>
<li><code>Residual</code>，如果是 Result 的话，就对应 Err-wrapping 。</li>
</ul>
<p>所以，现在 <code>?</code> 操作符的行为就变成了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>match Try::branch(x) {
    ControlFlow::Continue(v) =&gt; v,
    ControlFlow::Break(r) =&gt; return FromResidual::from_residual(r),
}

<span class="boring">}
</span></code></pre></pre>
<p>然后内部给 Rusult 实现 <code>Try</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, E&gt; ops::Try for Result&lt;T, E&gt; {
    type Output = T;
    type Residual = Result&lt;!, E&gt;;

    #[inline]
    fn from_output(c: T) -&gt; Self {
        Ok(c)
    }

    #[inline]
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, T&gt; {
        match self {
            Ok(c) =&gt; ControlFlow::Continue(c),
            Err(e) =&gt; ControlFlow::Break(Err(e)),
        }
    }
}

impl&lt;T, E, F: From&lt;E&gt;&gt; ops::FromResidual&lt;Result&lt;!, E&gt;&gt; for Result&lt;T, F&gt; {
    fn from_residual(x: Result&lt;!, E&gt;) -&gt; Self {
        match x {
            Err(e) =&gt; Err(From::from(e)),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>再给 Option 实现 <code>Try</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; ops::Try for Option&lt;T&gt; {
    type Output = T;
    type Residual = Option&lt;!&gt;;

    #[inline]
    fn from_output(c: T) -&gt; Self {
        Some(c)
    }

    #[inline]
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, T&gt; {
        match self {
            Some(c) =&gt; ControlFlow::Continue(c),
            None =&gt; ControlFlow::Break(None),
        }
    }
}

impl&lt;T&gt; ops::FromResidual for Option&lt;T&gt; {
    fn from_residual(x: &lt;Self as ops::Try&gt;::Residual) -&gt; Self {
        match x {
            None =&gt; None,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>再给 Poll 实现 <code>Try</code> : </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, E&gt; ops::Try for Poll&lt;Result&lt;T, E&gt;&gt; {
    type Output = Poll&lt;T&gt;;
    type Residual = &lt;Result&lt;T, E&gt; as ops::Try&gt;::Residual;

    fn from_output(c: Self::Output) -&gt; Self {
        c.map(Ok)
    }

    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt; {
        match self {
            Poll::Ready(Ok(x)) =&gt; ControlFlow::Continue(Poll::Ready(x)),
            Poll::Ready(Err(e)) =&gt; ControlFlow::Break(Err(e)),
            Poll::Pending =&gt; ControlFlow::Continue(Poll::Pending),
        }
    }
}

impl&lt;T, E, F: From&lt;E&gt;&gt; ops::FromResidual&lt;Result&lt;!, E&gt;&gt; for Poll&lt;Result&lt;T, F&gt;&gt; {
    fn from_residual(x: Result&lt;!, E&gt;) -&gt; Self {
        match x {
            Err(e) =&gt; Poll::Ready(Err(From::from(e))),
        }
    }
}

impl&lt;T, E&gt; ops::Try for Poll&lt;Option&lt;Result&lt;T, E&gt;&gt;&gt; {
    type Output = Poll&lt;Option&lt;T&gt;&gt;;
    type Residual = &lt;Result&lt;T, E&gt; as ops::Try&gt;::Residual;

    fn from_output(c: Self::Output) -&gt; Self {
        c.map(|x| x.map(Ok))
    }

    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt; {
        match self {
            Poll::Ready(Some(Ok(x))) =&gt; ControlFlow::Continue(Poll::Ready(Some(x))),
            Poll::Ready(Some(Err(e))) =&gt; ControlFlow::Break(Err(e)),
            Poll::Ready(None) =&gt; ControlFlow::Continue(Poll::Ready(None)),
            Poll::Pending =&gt; ControlFlow::Continue(Poll::Pending),
        }
    }
}

impl&lt;T, E, F: From&lt;E&gt;&gt; ops::FromResidual&lt;Result&lt;!, E&gt;&gt; for Poll&lt;Option&lt;Result&lt;T, F&gt;&gt;&gt; {
    fn from_residual(x: Result&lt;!, E&gt;) -&gt; Self {
        match x {
            Err(e) =&gt; Poll::Ready(Some(Err(From::from(e)))),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>再给 ControlFlow 实现 <code>Try</code> : </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B, C&gt; ops::Try for ControlFlow&lt;B, C&gt; {
    type Output = C;
    type Residual = ControlFlow&lt;B, !&gt;;

    fn from_output(c: C) -&gt; Self {
        ControlFlow::Continue(c)
    }

    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, C&gt; {
        match self {
            ControlFlow::Continue(c) =&gt; ControlFlow::Continue(c),
            ControlFlow::Break(b) =&gt; ControlFlow::Break(ControlFlow::Break(b)),
        }
    }
}

impl&lt;B, C&gt; ops::FromResidual for ControlFlow&lt;B, C&gt; {
    fn from_residual(x: &lt;Self as ops::Try&gt;::Residual) -&gt; Self {
        match x {
            ControlFlow::Break(r) =&gt; ControlFlow::Break(r),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>这就实现了 错误类型转换 大统一。</strong> </p>
<p>我在 2017 年给官方提过一个 Issue: <a href="https://github.com/rust-lang/rust/issues/46871">why havn't implemented Error trait for std::option::NoneError ?</a>，是因为当时引入了 <code>NoneError，但没有个</code> <code>NoneError</code> 实现 <code>Error</code> trait，所以无法在 Result 和 Option 之间无缝转换。</p>
<p>现在如果这个 RFC 实现，Result/Option 之间可以无缝转换，而完全不需要 <code>NoneError</code> 了，也许 <code>NoneError</code>就可以移除了。甚至在写异步 poll 方法的时候，也会变得非常简单了。</p>
<h2><a class="header" href="#最后再看一个示例" id="最后再看一个示例">最后再看一个示例：</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[repr(transparent)]
pub struct ResultCode(pub i32);
impl ResultCode {
    const SUCCESS: Self = ResultCode(0);
}

use std::num::NonZeroI32;
pub struct ResultCodeResidual(NonZeroI32);

impl Try for ResultCode {
    type Output = ();
    type Residual = ResultCodeResidual;
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual&gt; {
        match NonZeroI32::new(self.0) {
            Some(r) =&gt; ControlFlow::Break(ResultCodeResidual(r)),
            None =&gt; ControlFlow::Continue(()),
        }
    }
    fn from_output((): ()) -&gt; Self {
        ResultCode::SUCCESS
    }
}

impl FromResidual for ResultCode {
    fn from_residual(r: ResultCodeResidual) -&gt; Self {
        ResultCode(r.0.into())
    }
}

#[derive(Debug, Clone)]
pub struct FancyError(String);

impl&lt;T, E: From&lt;FancyError&gt;&gt; FromResidual&lt;ResultCodeResidual&gt; for Result&lt;T, E&gt; {
    fn from_residual(r: ResultCodeResidual) -&gt; Self {
        Err(FancyError(format!(&quot;Something fancy about {} at {:?}&quot;, r.0, std::time::SystemTime::now())).into())
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#官宣rust-2021-edition-计划" id="官宣rust-2021-edition-计划">【官宣】Rust 2021 Edition 计划</a></h1>
<p>翻译/编辑：张汉东</p>
<p>原文: <a href="https://github.com/m-ou-se/blog.rust-lang.org/blob/1cbd1ee944b1c1f3e369ad70f0d8fc4181f0e4f2/posts/2021-04-30-edition-2021.md">The Plan for the Rust 2021 Edition</a></p>
<hr />
<p>我们很高兴地宣布，Rust语言的第三版次（Edition） Rust 2021 edition 计划于今年10月发布。 Rust 2021 包含许多细微的变化，但仍有望在实践中对 Rust 产生很大的影响。</p>
<blockquote>
<p>译注：</p>
<p>这里把 Edition 译为 「版次」，是特意为了在中文中和 「版本」区别开来。</p>
<p>一般情况下，「版次」代表 Edition，而「版本」特指语义化版本。如果不做这样的区分，都用「版本」就会很乱。</p>
<p>为什么不用「版」呢，因为「版」对应发行版本，对应 Stable/Nightly/Beta 发行版。</p>
</blockquote>
<h2><a class="header" href="#什么是版次-edition" id="什么是版次-edition">什么是「版次（ Edition）」？</a></h2>
<p>Rust 1.0 的发布确立了 <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">“无停滞的稳定性”</a> 作为 Rust 交付的核心。从 1.0 发行版开始，Rust 的规则是，一旦某个功能在稳定版(Stable)上发布，我们将致力于在所有将来的发行版中都支持该功能。</p>
<p>但是，有时候在 Rust 的语法层面中进行一些小的更改，版次是有用的，否则这些更改将无法向后兼容。最明显的例子是引入一个新的关键字，它会使变量等现有名称无效。即使这样的更改不会“感觉到”向后不兼容，它们仍然有可能破坏现有代码。如果要进行此类更改，人们会很快发现现有程序停止编译。</p>
<p>版次（Edition）是我们用来把这种不可能变成可能的机制。当我们希望发布一个向后不兼容的功能时，我们会将其作为新的Rust 版次的一部分发布。版次是可选的（Opt-in），因此，现有的 Crate 除非将其明确迁移到新版次，否则不会看到这些更改。Cargo 创建的新的 Crate 始终默认使用最新版次。</p>
<h2><a class="header" href="#版次不会分裂生态系统" id="版次不会分裂生态系统">版次不会分裂生态系统</a></h2>
<p>版次的最重要规则是，一个版次中的 Crate 可以与其他版次中编译的 Crate 无缝地互操作。这确保了迁移到较新版次的决定是 Crate 可以做出的“私人”决定，而不影响其他人，除了它影响所需的 rustc 语义版本（version）之外（类似于使用任何新功能）。</p>
<p>Crate 互操作性的要求对我们在一个版次中可以进行的更改种类有一定的限制。通常，一个版次中发生的更改往往是“很薄的一层”。不管版次如何，所有 Rust 代码最终都会在编译器中编译为相同的内部表示形式。</p>
<blockquote>
<p>译注：版次(Edition)之间的差异，最终会在 MIR 层面消除。</p>
</blockquote>
<h2><a class="header" href="#版次迁移很容易而且很大程度上是自动化的" id="版次迁移很容易而且很大程度上是自动化的">版次迁移很容易，而且很大程度上是自动化的</a></h2>
<p>我们的目标是使 Crate 轻松升级到新版次。每当我们发布新版次时，我们也会发布工具来自动进行迁移。工具不一定是完美的：它可能无法涵盖所有​​极端情况，并且仍然可能需要手动更改。该工具尽力避免对语义的更改，这些更改可能影响代码的正确性或性能。</p>
<p>除工具外，我们还维护一个<a href="https://doc.rust-lang.org/edition-guide/">《版次迁移指南(Edition Migration Guide)》</a>，其中涵盖了版次中的更改。该指南将描述更改，并提供指向人们可以在其中了解更多信息的指南。它还将涵盖人们应注意的任何极端情况或细节。该指南既可以作为该版次的概述，也可以作为人们在使用自动化工具时遇到问题的快速疑难解答参考。最终版次列表将成为 Rust 2021 的一部分。所有这些摘要总结如下。</p>
<h2><a class="header" href="#rust-2021-计划进行哪些更改" id="rust-2021-计划进行哪些更改">Rust 2021 计划进行哪些更改？</a></h2>
<p>在过去的几个月中，Rust 2021工作组已经就新版次中包含的内容提出了许多建议。 我们很高兴宣布最终候选名单。每个功能都必须满足两个条件才能进入此清单。 </p>
<p>首先，它们必须得到相应 Rust 团队的批准。 </p>
<p>第二，它们的实现必须考虑周全，以使我们确信，它们能按计划的里程碑及时完成。</p>
<h3><a class="header" href="#增补-prelude" id="增补-prelude">增补 Prelude</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/prelude/index.html">标准库的 Prelude </a>是一个模块，该模块包含了标准库中其他每个模块必须自动导入的所有内容。它包含了常用的<strong>语言项</strong>（Item)，比如 <code>Option</code>、<code>Vec</code>、<code>drop</code> 和 <code>Clone</code>。</p>
<p>Rust编译器会优先处理任何手动导入的项（Item），使其优先于 Prelude 中的项（Item），以确保在 Prelude 中添加的内容不会破坏任何现有代码。例如，如果您有一个名为 <code>example</code> 的 Crate 或 模块，其中包含<code>pub struct Option ;</code>，则使用<code>example::*;</code>。这样就能明确引用 <code>example</code> 中的<code>Option</code>，而不是标准库中的<code>Option</code>。</p>
<p>但是，在 Prelude 中添加 trait 可以以微妙的方式破坏现有代码。比如，<code>x.try_into()</code> ，在使用<code>MyTryInto</code> trait 中的方法进行调用时，如果还导入了<code>std</code>的<code>TryInto</code>，则这个调用可能会变得模棱两可，并且无法编译，因为它提供了具有相同名称的方法。这就是我们尚未将<code>TryInto</code>添加到 Prelude 的原因，因为有很多代码会破坏这种方式。</p>
<p>作为解决方案，Rust 2021 将使用新的 Prelude。除了以下三个新增功能外，其余与当前的功能相同：</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html">std::convert::TryInto</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html">std::convert::TryFrom</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html">std::iter::FromIterator</a></li>
</ul>
<p>仍然需要等待库团队（Library team）来批准这三条，但应该很快批准。</p>
<h3><a class="header" href="#默认-cargo-feature-解析器resolver" id="默认-cargo-feature-解析器resolver">默认 Cargo Feature 解析器（Resolver）</a></h3>
<p>从Rust 1.51.0开始，Cargo 支持了<a href="https://doc.rust-lang.org/cargo/reference/resolver.html#feature-resolver-version-2">可选的新的 Feature 解析器</a>，可以通过<code>Cargo.toml</code>中的<code>resolver =&quot;2&quot;</code> 激活该功能。</p>
<p>从 Rust 2021 开始，这将是默认设置。 也就是说，在<code>Cargo.toml</code>中写入<code>edition =&quot;2021&quot;</code> 会暗含 <code>resolver =&quot;2&quot;</code>。</p>
<p>新的 Feature 解析器不再合并所有请求的功能，这些功能将以多种方式依赖于 Crate。 有关详细信息，请参见<a href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver"> <code>Rust 1.51</code> 的公告</a>。</p>
<h3><a class="header" href="#数组array支持-intoiterator" id="数组array支持-intoiterator">数组（Array）支持 <code>IntoIterator</code></a></h3>
<p>在<code>Rust 1.53</code>之前，只有对数组的引用才实现 <code>IntoIterator</code>。 这意味着您可以遍历<code>＆[1、2、3]</code>和<code>＆mut [1、2、3]</code>，但不能直接遍历<code>[1、2、3]</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for &amp;e in &amp;[1, 2, 3] {} // Ok :)

for e in [1, 2, 3] {} // Error :(
<span class="boring">}
</span></code></pre></pre>
<p>这是一个长期存在的问题，但是解决方案并不像看起来那样简单。仅添加<code>trait</code>实现会破坏现有代码。 <code>array.into_iter()</code>现在已可编译，由于方法调用语法的工作原理，该函数隐式调用<code>(＆array).into_iter()</code>。添加<code>trait</code>实现将改变含义。</p>
<p>通常，我们将这种类型的破坏(breakage)（添加<code>trait</code>实现）分类为“轻微(minor)”和“可接受(acceptable)”。但是在这种情况下，有太多的代码会被它破坏。</p>
<p>多次建议“仅在 Rust 2021 中为数组实现IntoIterator”。但是，这根本不可能。您不能在一个版次中存在<code>trait</code>实现，而在另一个版次中则不能存在，因为版次可以混合使用。</p>
<p>因此，我们决定在所有版次中添加<code>trait</code>实现（从Rust 1.53.0开始），但添加一个小技巧以避免在Rust 2021之前损坏。在 Rust 2015 和 2018 代码中，编译器仍将解析<code>array.into_iter()</code>为<code>(&amp;array).into_iter()</code>，就好像<code>trait</code>实现不存在一样。这仅适用于<code>.into_iter()</code>方法调用语法。它不会影响任何其他语法，例如<code>[1、2、3]</code>中的<code>e</code>或<code>iter.zip([1、2、3])</code>。这些将开始在所有版次中使用。</p>
<p>遗憾的是，这需要上述小技巧以避免破损，但我们对这种如何将两个版次之间的差异保持在最低限度的解决方案感到非常满意。</p>
<h3><a class="header" href="#闭包中不相关的捕获" id="闭包中不相关的捕获">闭包中不相关的捕获</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">闭包(Closure) </a>会自动从上下文捕获其引用的任何内容。 例如，<code>|| a + 1</code>会自动从周围的上下文中捕获对<code>a</code>的引用。</p>
<p>当前，即使仅使用一个字段，也将影响整个结构。 例如，<code>|| a.x +1</code>捕获对<code>a</code>的引用，而不仅仅是<code>a.x</code>。 在某些情况下，这是一个问题。 当结构的某个字段已被借用（可变）或移出时，其他字段将无法再用于闭包中，因为这将捕获整个结构，而该结构不再可用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = SomeStruct::new();

drop(a.x); // Move out of one field of the struct

println!(&quot;{}&quot;, a.y); // Ok: Still use another field of the struct

let c = || println!(&quot;{}&quot;, a.y); // Error: Tries to capture all of `a`
c();
<span class="boring">}
</span></code></pre></pre>
<p>从 Rust 2021 开始，闭包将仅捕获其使用的字段。 因此，以上示例在 Rust 2021 中可以很好地进行编译。</p>
<p>此新行为仅在新版次中才被激活，<strong>因为它可以更改字段的 drop 顺序</strong>。 对于所有版次更改，都可以进行自动迁移。 <code>Cargo fix --edition</code>将能够更新与此相关的闭包。 也可以通过在闭包插入 <code>let _ =＆a; </code> 来强制闭包像以前一样捕获整个结构。</p>
<h3><a class="header" href="#panic-宏的一致性" id="panic-宏的一致性">Panic 宏的一致性</a></h3>
<p><code>panic!()</code>宏是 Rust 中最常见的宏之一。 但是，它有一些<a href="https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md">微妙的惊喜</a>，我们不能仅仅因为向后兼容而进行更改。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!(&quot;{}&quot;, 1); // Ok, panics with the message &quot;1&quot;
panic!(&quot;{}&quot;); // Ok, panics with the message &quot;{}&quot;
<span class="boring">}
</span></code></pre></pre>
<p><code>panic!()</code>宏仅在使用多个参数调用时才使用字符串格式。当使用单个参数调用时，它甚至不会查看该参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = &quot;{&quot;;
println!(a); // Error: First argument must be a format string literal
panic!(a); // Ok: The panic macro doesn't care
<span class="boring">}
</span></code></pre></pre>
<p>（它甚至接受诸如<code>panic!(123)</code>之类的非字符串，这是罕见的，很少有用。）</p>
<p>当<a href="https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html">隐式格式参数</a>将被稳定时，这尤其是一个问题。 该功能将使<code>println!(&quot;hello {name}&quot;)</code> 成为 <code>println!(&quot; hello {}&quot;，name)</code>的简写形式。 但是，<code>panic!(&quot;hello {name}&quot;)</code>不能按预期工作，因为<code>panic!()</code>不会将单个参数作为格式字符串处理。</p>
<p>为了避免这种混乱的情况，Rust 2021 提供了更一致的<code>panic!()</code>宏。 新的<code>panic!()</code>宏将不再接受任意表达式作为唯一参数。 就像<code>println!()</code>一样，它将始终将第一个参数作为格式字符串处理。</p>
<p>另外，Rust 2021 中的<code>core::panic!()</code>和<code>std::panic!()</code>相同。当前，这两者之间存在一些历史差异，当打开或关闭<code>＃！[no_std]</code>时，这是很明显的。 </p>
<h3><a class="header" href="#保留语法" id="保留语法">保留语法</a></h3>
<p>为了将来为某些新语法腾出空间，我们决定为前缀的标识符和文字保留语法：<code>prefix#identifier</code>，<code>prefix&quot; string&quot;</code>，<code>prefix'c'</code>和<code>prefix#123</code>，其中<code>prefix</code>可以是任何标识符。 （除了已经具有含义的含义，例如<code>b''</code>和<code>r“”</code>。）</p>
<p>这是一个重大变化，因为宏当前可以接受<code>hello&quot;world&quot;</code>，它们将被视为两个单独的标记：<code>hello</code>和<code>&quot;world&quot;</code>。 （自动）修复很简单。 只需插入一个空格：<code>hello &quot;world&quot;</code>。</p>
<p>除了将它们转换为标记化错误外，RFC 尚未将含义附加到任何前缀。 为特定的前缀分配含义留给将来的建议，由于现在保留了这些前缀，因此不会破坏更改。</p>
<p>这些是您将来可能会看到的一些新前缀：</p>
<p><code>f&quot;&quot;</code>是格式字符串的简写形式。 例如，<code>f&quot;hello {name}&quot;</code>是等效的<code>format_args!()</code>调用的简写形式。</p>
<p><code>c&quot;&quot;</code>或<code>z&quot;&quot;</code>用于以<code>N</code>结尾的<code>C</code>字符串。</p>
<p><code>k#keyword</code>允许编写当前版次中尚不存在的关键字。 例如，虽然<code>async</code>在 <code>2015 edition</code> 中不是关键字，但使用此前缀可以使我们在<code>2015 edition</code>中接受<code>k#async</code>，而不必等待<code>2018 edition</code>将<code>async</code>保留为关键字。</p>
<h3><a class="header" href="#代码质量检查lint" id="代码质量检查lint">代码质量检查（Lint）</a></h3>
<p>使用 Rust 2021，许多现有的 Lint 正成为 Crate 中的硬错误，在旧版次中，这些 Lint 将仍然是警告。</p>
<ul>
<li><code>bare_trait_objects</code>：在Rust 2021中，必须使用<code>dyn</code>关键字来标识“ trait 对象”。</li>
<li><code>ellipsis_inclusive_range_patterns</code>：Rust 2021中包含范围模式的<code>...</code>语法将是一个硬错误； 新语法为<code>..=</code>，与表达式一致。</li>
</ul>
<p>我们可能会在此列表中添加更多Lint。</p>
<h3><a class="header" href="#macro_rules-中的-或or-模式" id="macro_rules-中的-或or-模式"><code>macro_rules</code> 中的 或（Or） 模式</a></h3>
<p>从 Rust 1.53.0 开始，<a href="https://doc.rust-lang.org/stable/reference/patterns.html">模式(pattern)</a>被扩展以支持<code>|</code>用于嵌套在模式中的任何位置。例如，现在可以写<code>Some(1 | 2)</code>代替<code>Some(1) | Some(2)</code>。由于以前根本不允许这样做，所以这不是一个重大变化。</p>
<p>但是，此更改也会影响<a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html"><code>macro_rules</code>宏</a>。这样的宏可以使用<code>:pat</code>片段说明符接受模式。当前，<code>:pat</code>不匹配<code>|</code>，因为在 Rust 1.53 之前，并非所有模式（在所有嵌套级别）都可以包含<code>|</code>。接受像<code>A | B</code>这样的模式的宏，例如<a href="https://doc.rust-lang.org/1.51.0/std/macro.matches.html"><code>match!()</code></a>使用类似<code>$($_:pat)|+</code>的东西。因为我们不想破坏任何现有的宏，所以我们没有将 Rust 1.53.0 中的<code>:pat</code>的含义更改为包括<code>|</code>。</p>
<p>相反，我们将在 Rust 2021 中进行该更改。在新版本中，<code>:pat</code>片段说明符将匹配<code>A | B</code>。</p>
<p>由于有时仍然希望匹配不带<code>|</code>的单个模式变量，因此添加了指定的片段<code>:pat_param</code>以保留较旧的行为。该名称旨在表示使用这种模式的主要用于闭合参数。</p>
<p>就是说，到目前为止，我们的工作如期进行，许多困难的部分已经解决，这要归功于所有为 Rust 2021 做出贡献的人们。</p>
<h2><a class="header" href="#接下来是什么" id="接下来是什么">接下来是什么？</a></h2>
<p>2021 版次的计划里程碑如下：</p>
<ul>
<li>✅ 今天：功能集已最终确定。</li>
<li>🚧 5月17日：在 Nightly 中完成实现，包括迁移（正在进行中）</li>
<li>⌛ 6月15日：《版次迁移指南》和其他文档完成</li>
<li>⌛ 7月1日：呼吁进行公开测试</li>
<li>⌛ 9月1日：先在 Nightly 中稳定 2021 版次</li>
<li>⌛ 10月21日：随着Rust 1.56.0的发布，稳定 2021 版次。</li>
</ul>
<p>在撰写本文时，我们正在按时完成这些截止日期，并且不会预见任何问题。 但是，Rust是一个由志愿者运行的项目。 我们优先考虑在 Rust 上工作的每个人的个人福祉，而不是我们设定的任何截止日期和期望。 这可能意味着如果需要的话，会延迟版次的发布，或者放弃一项事实证明过于困难或压力太大而无法及时完成的功能。</p>
<p>如果您想继续，可以在<a href="https://docs.google.com/spreadsheets/d/1chZ2SL9T444nvU9al1kQ7TJMwC3IVQQV2xIv1HWGQ_k/edit#gid=1034375760"> Rust 2021 Edition 电子表格</a>或<a href="https://github.com/orgs/rust-lang/projects/7">项目板</a>上跟踪状态。</p>
<p>感谢阅读！</p>
<h1><a class="header" href="#用-rustc-源码实现拼写错误候选词建议" id="用-rustc-源码实现拼写错误候选词建议">用 rustc 源码实现拼写错误候选词建议</a></h1>
<p>作者: 吴翱翔@pymongo / 后期编辑：张汉东</p>
<blockquote>
<p>原文: <a href="https://pymongo.github.io/#/2021/04/rustc_edit_distance_and_typo_checker.md">用 rustc 源码实现拼写错误候选词建议</a></p>
</blockquote>
<hr />
<p>最近想给一个聊天应用的聊天消息输入框加上拼写错误检查，毕竟 word, keynote 等涉及文本输入的软件都有拼写错误检查和纠错功能</p>
<p>于是想到开发中经常用的 rustup, cargo, rustc 不就内置了拼写错误时纠错建议的功能么?</p>
<p>在 rustup 输入错误的单词时例如 <code>rustup dog</code>，此时 rustup 就会提示把 <code>dog</code> 改成 <code>doc</code></p>
<pre><code>[w@w-manjaro ~]$ rustup dog
error: The subcommand 'dog' wasn't recognized
        Did you mean 'doc'?
</code></pre>
<h2><a class="header" href="#字符串的编辑距离" id="字符串的编辑距离">字符串的编辑距离</a></h2>
<h3><a class="header" href="#rustup-的拼写纠错建议的实现" id="rustup-的拼写纠错建议的实现">rustup 的拼写纠错建议的实现</a></h3>
<p>以 <code>Did you mean</code> 的关键词全文搜索 rustup 源码，找到出处在 <code>src/cli/error.rs</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn maybe_suggest_toolchain(bad_name: &amp;str) -&gt; String {
    let bad_name = &amp;bad_name.to_ascii_lowercase();
    static VALID_CHANNELS: &amp;[&amp;str] = &amp;[&quot;stable&quot;, &quot;beta&quot;, &quot;nightly&quot;];
    lazy_static! {
        static ref NUMBERED: Regex = Regex::new(r&quot;^\d+\.\d+$&quot;).unwrap();
    }

    if NUMBERED.is_match(bad_name) {
        return format!(
            &quot;. Toolchain numbers tend to have three parts, e.g. {}.0&quot;,
            bad_name
        );
    }

    // Suggest only for very small differences
    // High number can result in inaccurate suggestions for short queries e.g. `rls`
    const MAX_DISTANCE: usize = 3;

    let mut scored: Vec&lt;_&gt; = VALID_CHANNELS
        .iter()
        .filter_map(|s| {
            let distance = damerau_levenshtein(bad_name, s);
            if distance &lt;= MAX_DISTANCE {
                Some((distance, s))
            } else {
                None
            }
        })
        .collect();
    scored.sort();
    if scored.is_empty() {
        String::new()
    } else {
        format!(&quot;. Did you mean '{}'?&quot;, scored[0].1)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>damerau_levenshtein</code> 其实就是描述两个字符串之间的差异，<code>damerau_levenshtein</code> 距离越小则两个字符串越接近</p>
<p>该函数的将输入的错误单词跟正确的候选词挨个计算 <code>damerau_levenshtein</code> 距离，</p>
<p>最后排序下 <code>damerau_levenshtein</code> 距离输出最小的候选词</p>
<p>rustup的 <code>damerau_levenshtein</code> 来自 <em><strong>strsim</strong></em> 库，除了 rustup, darling 等知名库也导入了 strsim 库</p>
<p>查阅维基百科的 <code>damerau_levenshtein</code> 词条后发现 <code>damerau_levenshtein</code> 的同义词是 <code>levenshtein_distance</code> 和 <code>edit_distance</code></p>
<h3><a class="header" href="#用-rustc-源码竟然过了算法题" id="用-rustc-源码竟然过了算法题">用 rustc 源码竟然过了算法题</a></h3>
<p>rustc 源码会尽量不用第三方库，所以我猜测 rustc 不会像 rustup 那样用 strsim 源码，那就看看 rustc 的实现会不会更好</p>
<p>在 Rust 的 github 仓库中搜索<code>edit distance</code>关键字能找到<a href="https://github.com/rust-lang/rust/commit/93d01eb443d0f871716c9d7faa3b69dc49662663">Make the maximum edit distance of typo suggestions</a> 的 commit</p>
<p>typo 就是单词拼写错误的意思，本文也会将单词拼写错误简称为 typo</p>
<p>顺着这个 commit 的改动在 <code>find_best_match_for_name</code> 函数内调用了 <code>lev_distance</code> 函数去计算两个字符串的编辑距离</p>
<p>edit_distance 是个动态规划算法或字符串算法的经典问题，果然 leetcode 上有 <a href="https://leetcode.com/problems/edit-distance/">edit_distance 的算法题</a></p>
<p>我拿 rustc 源码的 lev_distance 函数在 leetcode上通过 edit_distance 一题</p>
<p><img src="chapter_4/image/rustc_edit/rustc_edit_distance_and_typo_checker_1.png" alt="" /></p>
<p>用 strsim 的相关函数也能通过编辑距离这题，但是运行耗时 4ms 会比 rustc 源码运行耗时 0ms 慢点</p>
<p>原因是 strsim 的 edit_distance 算法动态规划的空间复杂度是 O(n^2)，而 rustc 的实现空间复杂度是 O(n)</p>
<h3><a class="header" href="#edit_distance-算法" id="edit_distance-算法">edit_distance 算法</a></h3>
<p>从 rustc 源码的 lev_distance 函数签名 <code>fn lev_distance(a: &amp;str, b: &amp;str) -&gt; usize</code> 来看</p>
<p>输入的是两个字符串 a 和 b, 返回值表示 a 和 b 的 edit_distance</p>
<p>edit_distance 表示从字符串 a 修改成 b 或从字符串 b 修改成 a 至少需要的操作(插入/删除/替换一个字母)次数</p>
<p>例如一个拼写错误的单词 <code>bpple</code> 需要一次替换操作，将第一个字母 <code>b</code> 替换成 <code>a</code> 才能变成 <code>apple</code></p>
<p>所以字符串 <code>bpple</code> 和 <code>apple</code> 之间的 edit_distance 就是 1</p>
<p>以下是一段 edit_distance 的二维数组 dp 状态的实现，可以结合代码注释进行理解，详细的推断和动态规划状态转移方程可以看 leetcode 的官方题解</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 从字符串word1修改成word2至少需要多少次操作(replace/insert/delete)
#[allow(clippy::needless_range_loop)]
fn edit_distance_dp(word1: String, word2: String) -&gt; i32 {
    let (word1, word2) = (word1.into_bytes(), word2.into_bytes());
    let (word1_len, word2_len) = (word1.len(), word2.len());
    // # dp[i][j]表示word1[..i]至少需要多少次操作(replace/insert/delete)替换成B[..j]
    // 很容易想到的其中一种状态转移的情况: 如果word1[i]==word2[j]，那么dp[i][j]==dp[i-1][j-1]
    let mut dp = vec![vec![0; word2_len+1]; word1_len+1];
    for i in 0..=word1_len {
        // 需要i次删除操作才能让word1[..i]修改成空的字符串word2[..0]
        dp[i][0] = i;
    }
    for j in 0..=word2_len {
        // 需要j次插入操作才能让空字符串word1[..0]修改成word2[..j]
        dp[0][j] = j;
    }
    for i in 1..=word1_len {
        for j in 1..=word2_len {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1];
            } else {
                // dp[i-1][j-1] + 1: word1[i-1]和word2[i-2]不同，所以替换次数+1,
                //                   如果dp的决策层选择replace操作，dp[i][j]总共操作数等于dp[i-1][j-1]+1
                // d[i-1][j]表示往word1末尾插入word2[j]，dp[i][j-1]表示word1删掉末尾的字母让word1和word2更接近
                dp[i][j] = dp[i-1][j-1].min(dp[i-1][j]).min(dp[i][j-1]) + 1;
            }
        }
    }
    dp[word1_len][word2_len] as i32
}
<span class="boring">}
</span></code></pre></pre>
<p>由于 rustc 源码为了性能选用了一位数组存储动态规划的状态，用到了很多状态压缩、滚动数组之类的技巧，较难理解，本文就不对 rustc 的动态规划 edit_distance 算法做解释</p>
<hr />
<h2><a class="header" href="#引用-rustc-编辑距离的函数" id="引用-rustc-编辑距离的函数">引用 rustc 编辑距离的函数</a></h2>
<h3><a class="header" href="#rustc-动态链接库" id="rustc-动态链接库">rustc 动态链接库?</a></h3>
<p>考虑到 rustc 源码的 lev_distance 会比 strsim 库性能略微好点，所以就直接调 rustc 源码的 lev_distance 就行了</p>
<p>当我尝试在代码中加入 <code>extern crate rustc</code> 时就出现以下报错:</p>
<blockquote>
<p>error[E0462]: found staticlib <code>rustc</code> instead of rlib or dylib</p>
</blockquote>
<p>然后 rustc 会提示找到个类似的静态链接库文件 </p>
<blockquote>
<p>/home/w/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/librustc-nightly_rt.asan.a</p>
</blockquote>
<p>然后我试着用 nm 命令去读取库文件的函数符号表</p>
<pre><code>$ nm -D librustc-nightly_rt.tsan.a
...
sanitizer_linux_s390.cpp.o:
nm: sanitizer_linux_s390.cpp.o: no symbols

sanitizer_mac.cpp.o:
nm: sanitizer_mac.cpp.o: no symbols

sanitizer_netbsd.cpp.o:
nm: sanitizer_netbsd.cpp.o: no symbols
...
</code></pre>
<p>发现里面有一个 <code>sanitizer_netbsd.cpp</code> 的文件，网上搜索得知这是 llvm 的源文件</p>
<p>所以这些 <code>librustc-nightly_rt</code> 开头的库全是 llvm 相关的静态链接库，并不是 rustc 的库</p>
<h3><a class="header" href="#rustc-ap-rustc_span" id="rustc-ap-rustc_span">rustc-ap-rustc_span</a></h3>
<p>我相信我编译过很多像 rust-analyzer, racer 等静态分析的库，说不定电脑本地的 cargo 缓存就有 rustc 源码的 lev_distance.rs</p>
<p><img src="chapter_4/image/rustc_edit/rustc_edit_distance_and_typo_checker_2.png" alt="" /></p>
<p>果然发现 rustc-ap-rustc_span 这个 crate 就有 lev_distance 函数</p>
<p>再参考 StackoverFlow 的问题 <a href="https://stackoverflow.com/questions/48372993/how-to-use-rustc-crate?rq=1">How to use <code>rustc</code> crate?</a> 和 racer 源码后发现</p>
<p>而以 <code>rustc-ap-rustc_</code> 命名开头的库都是由 Rust 官方团队的 <a href="https://github.com/alexcrichton/rustc-auto-publish">alexcrichton</a>
定期从 rustc 源码中同步代码并发布到 crates.io 中</p>
<p>为了进一步验证带<code>rustc-ap</code>前缀的库是不是从 rustc 源码导出的，再看看很可能用到部分 rustc 源码的 rust-analyzer</p>
<pre><code>[w@w-manjaro rust-analyzer]$ grep -r --include=&quot;*.toml&quot; &quot;rustc-ap&quot; .
./crates/syntax/Cargo.toml:rustc_lexer = { version = &quot;714.0.0&quot;, package = &quot;rustc-ap-rustc_lexer&quot; }
</code></pre>
<p>果然发现 rust-analyzer 用到了 <code>rustc-ap-rustc_lexer</code> 这个库，毕竟 rust-analyzer 是做静态分析的，跟编译器的部分功能有点重合很正常</p>
<p>其实像 rust-analyzer 和 racer 等静态分析工具都会用到 rustc-ap-rustc_* 这样命名开头的 rustc 编译器组件库</p>
<p>我参考 racer 源码可以在 Cargo.toml 中这么引入 rustc_span，进而使用 rustc_span 的 lev_distance 函数</p>
<blockquote>
<p>rustc_span = { package=&quot;rustc-ap-rustc_span&quot;, version=&quot;714.0.0&quot; }</p>
</blockquote>
<h3><a class="header" href="#rustc-dev-component" id="rustc-dev-component">rustc-dev component</a></h3>
<p>阅读 rustup component 相关文档得知，rustc-dev 组件包含了 rustc 的动态链接库和源码(方便静态分析)</p>
<blockquote>
<p>rustup component add rustc-dev</p>
</blockquote>
<p>然后就可以使用 rustc 编译器的各种组件</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(rustc_private)]
<span class="boring">fn main() {
</span>extern crate rustc_span;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#rust-analyzer-对-rustc-静态分析" id="rust-analyzer-对-rustc-静态分析">rust-analyzer 对 rustc 静态分析</a></h3>
<p>然后在 Cargo.toml 中加入以下内容，</p>
<pre><code class="language-toml">[package.metadata.rust-analyzer]
rustc_private = true
</code></pre>
<p>然后 rust-analyzer 能对 rustc API 的使用进行静态分析</p>
<p>然后参考 rust-analyzer 的这两个 <a href="https://github.com/rust-analyzer/rust-analyzer/issues/6714">#6714</a>, <a href="https://github.com/rust-analyzer/rust-analyzer/issues/7589">#7589</a></p>
<p>想让 rust-analyzer 对 rustc 函数的使用进行静态分析，需要设置 rustc 源码的路径:</p>
<blockquote>
<p>&quot;rust-analyzer.rustcSource&quot;: &quot;/home/w/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/rustc-src/rust/compiler/rustc_driver/Cargo.toml&quot;</p>
</blockquote>
<p>rustc-dev component 会提供 rustc-src 也就是 rustc 源码</p>
<p>目前 rust-analyzer 还不支持 <code>extern crate test</code> 的静态分析，但我看 rust-src component 提供了 test crate 的源码:</p>
<blockquote>
<p>/home/w/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/test/Cargo.toml</p>
</blockquote>
<p>所以 rust-analyzer 和 intellij-rust 将来有望支持 test crate 的静态分析</p>
<p>不过像 libc 虽然 rustup 每个 toolchain 都装了 libc 的 rlib 类型的动态链接库，可惜 rust-src component 没有包括 libc 源码</p>
<p>所以用 <code>extern crate libc</code> 的方式引入 toolchain 自带的 libc 还是不能做静态分析的</p>
<hr />
<h2><a class="header" href="#语料库" id="语料库">语料库</a></h2>
<p>拼写错误候选词建议需求的实现思路可以是: 对常用英语单词的每个单词跟拼写错误的单词去计算编辑距离，取编辑距离最近的 5 个单词作为获选词建议</p>
<p>字符串间编辑距离的算法可以直接用 rustc 源码的 lev_distance，常用英语单词表则需要一个语料库</p>
<h3><a class="header" href="#usrsharedictwords" id="usrsharedictwords">/usr/share/dict/words</a></h3>
<p>mac 和树莓派的 raspbian 系统都在 <code>/usr/share/dict/words</code> 存放英语语料库，用于系统预装的记事本等应用进行拼写错误检查</p>
<p>像 ubuntu_desktop 或 raspbian 这种带图形桌面环境的 linux 发行版一般会在 <code>/usr/share/dict/words</code> 内置语料库</p>
<p>如果没有找到语料库，可以通过 <code>sudo apt install wbritish</code> 或 <code>sudo pacman -S words</code> 进行安装</p>
<p>除了用操作系统自带的语料库，还可以选用 github 的 <a href="https://github.com/dwyl/english-words">english-words</a> 仓库作为语料库</p>
<hr />
<h2><a class="header" href="#拼写错误检查器-trait" id="拼写错误检查器-trait">拼写错误检查器 trait</a></h2>
<p>为了方便更换语料库存储的数据结构，需要先对语料库的行为抽象出一个 trait，便于重构或复用代码</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TypoSuggestion: Sized + Default {
    const MAX_EDIT_DISTANCE: usize = 1;
    const NUMBER_OF_SUGGESTIONS: usize = 5;
    fn insert(&amp;mut self, word: String);
    fn read_os_dictionary(&amp;mut self) {
        /** OS_DICTIONARY_PATH
        macos/raspbian: os built-in diction
        ubuntu: sudo apt install wbritish
        archlinux: sudo pacman -S words
        */
        const OS_DICTIONARY_PATH: &amp;str = &quot;/usr/share/dict/words&quot;;
        use std::io::{BufRead, BufReader};
        let word_file = BufReader::new(std::fs::File::open(OS_DICTIONARY_PATH).unwrap());
        for word in word_file.lines().flatten() {
            self.insert(word)
        }
    }
    /// return type Self must bound Sized
    fn new() -&gt; Self {
        let mut typo_checker = Self::default();
        typo_checker.read_os_dictionary();
        typo_checker
    }
    fn is_typo(&amp;self, word: &amp;str) -&gt; bool;
    fn typo_suggestions(&amp;self, word: &amp;str) -&gt; Vec&lt;String&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>trait TypoSuggestion 核心就两个函数: <code>fn is_typo()</code> 判断输入的单词是否在语料库中， <code>fn typo_suggestions()</code> 如果输入的单词拼写错误才返回若干个最相似的候选词建议</p>
<h2><a class="header" href="#vecstring-实现候选词建议" id="vecstring-实现候选词建议">Vec<String> 实现候选词建议</a></h2>
<p>既然操作系统语料库是个每行都是一个单词的文本文件，很容易想到用 <code>Vec&lt;String&gt;</code> 去存储每个单词，我将这个实现命名为: VecTypoChecker</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct VecTypoChecker {
    words: Vec&lt;String&gt;,
}

impl TypoSuggestion for VecTypoChecker {
    fn insert(&amp;mut self, word: String) {
        self.words.push(word);
    }

    fn is_typo(&amp;self, word: &amp;str) -&gt; bool {
        !self.words.contains(&amp;word.to_string())
    }

    fn typo_suggestions(&amp;self, word: &amp;str) -&gt; Vec&lt;String&gt; {
        let input_word = word.to_string();
        if !self.is_typo(&amp;input_word) {
            return vec![];
        }
        let mut suggestions = vec![];
        for word in self.words.iter() {
            let edit_distance = rustc_span::lev_distance::lev_distance(&amp;input_word, word);
            if edit_distance &lt;= Self::MAX_EDIT_DISTANCE {
                suggestions.push(word.clone());
            }
            if suggestions.len() &gt; Self::NUMBER_OF_SUGGESTIONS {
                break;
            }
        }
        suggestions
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>VecTypoChecker 的测试代码如下:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_typo_checker() {
    let typo_checker = VecTypoChecker::new();
    let input_word = &quot;doo&quot;;
    println!(
        &quot;Unknown word `{}`, did you mean one of {:?}?&quot;,
        input_word,
        typo_checker.typo_suggestions(input_word)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>测试代码的输出结果示例:</p>
<blockquote>
<p>Unknown word <code>doo</code>, did you mean one of [&quot;boo&quot;, &quot;coo&quot;, &quot;dao&quot;, &quot;do&quot;, &quot;doa&quot;, &quot;dob&quot;]?</p>
</blockquote>
<h3><a class="header" href="#vectypochecker-的时间复杂度" id="vectypochecker-的时间复杂度">VecTypoChecker 的时间复杂度</a></h3>
<p>is_typo 要遍历整个数组判断输入单词是否在单词表里，显然时间复杂度是 O(n)</p>
<p>假设单词表中平均单词长度为 k，输入单词的长度为 L，typo_suggestions 的时间复杂度则要 O(n*L*k)</p>
<h3><a class="header" href="#valgrind-和-memusage-测量堆内存使用" id="valgrind-和-memusage-测量堆内存使用">valgrind 和 memusage 测量堆内存使用</a></h3>
<p>其实用数组去存储语料库的每个单词的内存利用率是很低的，很多单词都是重复部分很多</p>
<p>先用 wc 和 du 命令查看操作系统单词表的收录的单词数和占用硬盘空间大小</p>
<blockquote>
<p>[w@w-manjaro ~]$ wc -l /usr/share/dict/words</p>
<p>123115 /usr/share/dict/words</p>
<p>[w@w-manjaro ~]$ du -h `readlink -f /usr/share/dict/words`</p>
<p>1.2M    /usr/share/dict/american-english</p>
</blockquote>
<p>那 12 万个单词 1.2M 的单词文件以数组的数据结构在内存中需要占用多少空间呢？</p>
<p>由于 Rust 标准库的 <code>std::mem::size_of</code> 只能测量栈上的空间，标准库没有测量智能指针在堆上占用空间的方法</p>
<p>所以只能借助可执行文件的内存分析工具 <code>valgrind --tool=massif</code> 或 <code>memusage</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_vec_typo_checker() {
    let _ = VecTypoChecker::new();
}
<span class="boring">}
</span></code></pre></pre>
<p>在 memusage 工具内运行上述单元测试，测试内只进行将操作系统语料库读取成 <code>Vec&lt;String&gt;</code> 的操作</p>
<blockquote>
<p>memusage cargo test test_vec_typo_checker</p>
</blockquote>
<p>这里只关注 memeusage 输出结果的<strong>堆内存</strong>峰值信息:</p>
<blockquote>
<p>Memory usage summary: heap total: 4450158, heap peak: 4409655, stack peak: 8800</p>
</blockquote>
<p><code>VecTypoChecker::new()</code> 过程的堆内存峰值 大约是 4.2 MB，可能有些 Rust内部对象 堆内存使用会影响结果</p>
<p>所以我效仿称重是要「去皮」的操作，让 memusage 测量一个 Rust 空函数的运行时堆内存峰值，空函数的堆内存峰值是 2-3 kb</p>
<p>Rust 其它的一些堆内存使用相比 <code>VecTypoChecker::new()</code> 的 4.2 MB 小到可以忽略不计</p>
<h2><a class="header" href="#trie-前缀树字典树" id="trie-前缀树字典树">Trie 前缀树/字典树</a></h2>
<p>1.2M 大约 12 万个单词用数组去存储大约需要 4.2M 的堆空间，显然不是很高效</p>
<p>例如 doc, dot, dog 三个单词，如果用 Vec 数组去存储，大约需要 9 个字节</p>
<p>但是如果用&quot;链表&quot;去存储，这三个单词链表的前两个节点 'd' 和 'o' 可以共用，这样只需要 5 个链表节点大约 5 个字节的内存空间</p>
<p>这样像链表一样共用单词的共同前缀的数据结构叫 <strong>trie</strong>，广泛用于输入法，搜索引擎候选词，代码自动补全等领域</p>
<h3><a class="header" href="#前缀树的数据结构" id="前缀树的数据结构">前缀树的数据结构</a></h3>
<p>正好 leetcode 上也有 <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree) 这种实现 trie 的算法题</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct TrieTypoChecker {
    children: [Option&lt;Box&lt;Self&gt;&gt;; 26],
    is_word: bool
}
<span class="boring">}
</span></code></pre></pre>
<p>解读下前缀树数据结构的 <code>children: [Option&lt;Box&lt;Self&gt;&gt;; 26]</code> 字段</p>
<p>26 表示当前节点往下延伸一共能扩展出 26 个小写字母，用 Option 表达了某个小写字母的子节点是否存在</p>
<p>用 Box 是因为参考了 Rust 单链表的实现，我们希望树的节点能分配到堆内存上，否则编译器会报错 <code>recursive type has infinite size</code></p>
<p>想更深入探讨 Rust 链表相关问题的读者可以自行阅读 <a href="https://rust-unofficial.github.io/too-many-lists/">too-many-lists</a> 系列文章</p>
<p>前缀树的 is_word 字段表示从根节点到当前节点的路径能组成一个单词</p>
<p>如果没有这个 is_word 标注，那么插入一个 apple 单词时，无法得知 apple 路径上的 app 是不是也是一个单词</p>
<p><code>#[derive(Default)]</code>的目的是方便创建一个子节点全为 None 的前缀树节点</p>
<h3><a class="header" href="#前缀树的路径压缩" id="前缀树的路径压缩">前缀树的路径压缩</a></h3>
<p>实际生产环境中前缀树实现会比上述实现要复杂得多，要考虑类似「<strong>并查集</strong>」的「<strong>路径压缩</strong>」</p>
<p>例如有个单词是<code>aaaaa</code>，那么插入到前缀树就会形成深度为 5 层的树</p>
<p>树的深度过深不够&quot;饱满&quot;，这样内存利用率不高，需要把树 <em><strong>压扁</strong></em> (路径压缩)</p>
<h3><a class="header" href="#前缀树的插入" id="前缀树的插入">前缀树的插入</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TypoSuggestion for TrieTypoChecker {
    fn insert(&amp;mut self, word: String) {
        let mut curr_node = self;
        for letter in word.into_bytes().into_iter().map(|ch| (ch - b'a') as usize) {
            curr_node = curr_node.children[letter].get_or_insert_with(|| Box::new(Self::default()))
        }
        curr_node.is_word = true;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>但上述前缀树的插入方法，在读取操作系统的自带的单词表时会 <code>panicked at 'attempt to subtract with overflow'</code></p>
<p>原因是操作系统的单词表中除了小写字母还有大写字母和单引号</p>
<p>为了简便我们把单词表中的大写字母转为小写再去掉除小写字母以外的字符，这样就能把单词表转为前缀树</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert(&amp;mut self, word: String) {
    let word = word
        .into_bytes()
        .into_iter()
        .map(|ch| ch.to_ascii_lowercase())
        .filter(|ch| matches!(ch, b'a'..=b'z'))
        .collect::&lt;Vec&lt;u8&gt;&gt;();
    let mut curr_node = self;
    for letter in word.into_iter().map(|ch| (ch - b'a') as usize) {
        curr_node = curr_node.children[letter].get_or_insert_with(|| Box::new(Self::default()))
    }
    curr_node.is_word = true;
}
<span class="boring">}
</span></code></pre></pre>
<p>再写个构造前缀树并读取操作系统单词表的测试用例，跟数组的实现对比下空间复杂度</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_trie_typo_checker() {
    let _ = TrieTypoChecker::new();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>memusage cargo test test_trie_typo_checker</p>
</blockquote>
<p>memusage 测试结果显示，前缀树存储 12 万 个单词只需要花 784 kb 的堆内存空间</p>
<p>相比单词表磁盘文件占用 1.2M 硬盘空间，用前缀树存储只 700 多 kb 确实有「<strong>压缩</strong>」的效果</p>
<p>相比用数组存储单词表消耗 4.2M 内存，前缀树在<em>空间复杂度</em>上大约有 80% 的提升</p>
<p>再写一个性能测试对比数组和前缀树读取单词表的时间复杂度</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]
<span class="boring">fn main() {
</span>extern crate test;
use typo_checker::{TypoSuggestion, VecTypoChecker, TrieTypoChecker};

#[bench]
fn bench_vec_read_dictionary(bencher: &amp;mut test::Bencher) {
    bencher.iter(|| {
        VecTypoChecker::new();
    });
}

#[bench]
fn bench_trie_read_dictionary(bencher: &amp;mut test::Bencher) {
    bencher.iter(|| {
        TrieTypoChecker::new();
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>benchmark 的运行结果:</p>
<pre><code>     Running unittests (target/release/deps/bench-c073956b9e337dbe)

running 2 tests
test bench_trie_read_dictionary ... bench:  39,724,024 ns/iter (+/- 2,954,476)
test bench_vec_read_dictionary  ... bench:  11,928,761 ns/iter (+/- 386,083)
</code></pre>
<p>发现前缀树插入 12 万个单词比数组快 3 倍，而且前缀树插入单词时还有「<strong>去重</strong>」的功能，数组插入单词想去重还要额外的性能开销</p>
<p>小结: 前缀树读单词表，时间复杂度上比数组快 3 倍多，空间复杂度上比数组节约 80%</p>
<h3><a class="header" href="#前缀树的查询" id="前缀树的查询">前缀树的查询</a></h3>
<p>查询某个单词是否在前缀树内，其实就是前文提到的 TypoSuggestion trait 的 is_typo 函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_typo(&amp;self, word: &amp;str) -&gt; bool {
    let word = word.as_bytes();
    let mut curr_node = self;
    for letter in word {
        let index = (letter - b'a') as usize;
        match curr_node.children[index] {
            Some(ref child_node) =&gt; {
                curr_node = child_node.as_ref();
            }
            None =&gt; {
                return true;
            }
        }
    }
    !curr_node.is_word
}
<span class="boring">}
</span></code></pre></pre>
<p>再写一个 benchmark 对比数组和前缀树的查询功能</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[bench]
fn bench_vec_search(bencher: &amp;mut test::Bencher) {
    let typo_checker = VecTypoChecker::new();
    bencher.iter(|| {
        assert_eq!(typo_checker.is_typo(&quot;doo&quot;), true);
        assert_eq!(typo_checker.is_typo(&quot;lettuce&quot;), false);
    });
}

#[bench]
fn bench_trie_search(bencher: &amp;mut test::Bencher) {
    let typo_checker = TrieTypoChecker::new();
    bencher.iter(|| {
        assert_eq!(typo_checker.is_typo(&quot;doo&quot;), true);
        assert_eq!(typo_checker.is_typo(&quot;lettuce&quot;), false);
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>查询功能的测试结果:</p>
<pre><code>test bench_trie_search          ... bench:           8 ns/iter (+/- 2)
test bench_vec_search           ... bench:     351,254 ns/iter (+/- 176,276)
</code></pre>
<p>小结: 查询某个单词是否在前缀树比数组快了 5 个数量级</p>
<hr />
<h2><a class="header" href="#前缀树的编辑距离" id="前缀树的编辑距离">前缀树的编辑距离</a></h2>
<p>虽说前缀树的插入和查询都比数组快，但前缀树的删除比数组要难，前缀树编辑距离的实现更是非常难(需要记忆化深度优先搜索等诸多复杂算法)</p>
<p>知乎上有个相关的提问: <a href="https://www.zhihu.com/question/29592463">鹅厂面试题，英语单词拼写检查算法 - 知乎</a></p>
<p>很多回答都引用了<a href="http://norvig.com/spell-correct.html">这篇文章</a></p>
<p>说实话最佳回答或上述文章都大量使用了 Python 的字符串拼接，每次拼接操作都会 new 一块字符串的堆内存</p>
<p>这样频繁字符串拼接操作性能开销大，不能让我满意</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TypoSuggestion for TrieTypoChecker {
    fn typo_suggestions(&amp;self, word: &amp;str) -&gt; Vec&lt;String&gt; {
        let mut dfs_helper = DfsHelper {
            suggestions: vec![],
            path: vec![],
            typo_checker: &amp;self,
        };
        dfs_helper.dfs(&amp;self);
        dfs_helper.suggestions
    }
}

/// 为了偷懒，把dfs一些不关键的递归间全局共享的状态放到一个结构体
struct DfsHelper&lt;'a&gt; {
    /// 返回值
    suggestions: Vec&lt;String&gt;,
    /// 当前深度优先搜索，从根节点到当前节点的遍历路径
    path: Vec&lt;u8&gt;,
    typo_checker: &amp;'a TrieTypoChecker,
}

impl&lt;'a&gt; DfsHelper&lt;'a&gt; {
    fn dfs(&amp;mut self, curr_node: &amp;TrieTypoChecker) {

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>由于搜索的是前缀树内相似的单词，所以不适合用广度优先搜索去遍历，用递归实现深度优先搜索比较方便</p>
<p>为了减少 dfs 函数传参个数以及便于增删和管理递归函数的「无需<strong>回溯</strong>」的入参，我定义了一个 DfsHelper</p>
<p>首先由于前缀树整体是个树，不方便像数组实现遍历所有单词挨个与输入单词之间计算编辑距离</p>
<p>虽然较难前缀树的编辑距离实现难度很高，但是还是先写出<strong>单元测试</strong>，以 TDD 的方式开发逐渐迭代和逼近正确的实现代码</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[test]
fn test_trie_typo_checker() {
    const TEST_CASES: [(&amp;str, &amp;[&amp;str]); 1] = [
        (&quot;doo&quot;, &amp;[&quot;boo&quot;, &quot;coo&quot;, &quot;dao&quot;, &quot;do&quot;, &quot;doa&quot;, &quot;dob&quot;])
    ];
    let typo_checker = TrieTypoChecker::new();
    for (input, output) in std::array::IntoIter::new(TEST_CASES) {
        assert_eq!(typo_checker.typo_suggestions(input), output);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#递归的结束条件" id="递归的结束条件">递归的结束条件</a></h3>
<p>由于前文中的 trait TypoSuggestion 的 NUMBER_OF_SUGGESTIONS 参数默认为 5</p>
<p>所以很容易想到一个递归结束条件就是 当前深度优先搜索已经找到 5 个 候选词了</p>
<p>另一个递归结束条件就是输入单词已经被扫描完了</p>
<h3><a class="header" href="#深度优先搜索的剪枝" id="深度优先搜索的剪枝">深度优先搜索的剪枝</a></h3>
<p>如果当前遍历到的单词跟输入的单词的编辑距离超过 1,就可以进行「剪枝」</p>
<p>这样能大大减少遍历前缀树的节点数量，作者水平有限，可能还有其它递归结束条件和剪枝条件没能想到</p>
<h3><a class="header" href="#简陋的编辑距离搜索" id="简陋的编辑距离搜索">简陋的编辑距离搜索</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TypoSuggestion for TrieTypoChecker {
    // ...
    fn typo_suggestions(&amp;self, word: &amp;str) -&gt; Vec&lt;String&gt; {
        let mut dfs_helper = DfsHelper {
            input_word: word.as_bytes().to_vec(),
            input_word_len: word.len(),
            output_suggestions: vec![],
            path: vec![],
        };
        dfs_helper.dfs(&amp;self, 0, 1);
        dfs_helper.output_suggestions
    }
}

struct DfsHelper {
    /// 输入的单词
    input_word: Vec&lt;u8&gt;,
    input_word_len: usize,
    /// 返回值
    output_suggestions: Vec&lt;String&gt;,
    /// 当前深度优先搜索，从根节点到当前节点的路径(path root to curr_node)
    path: Vec&lt;u8&gt;,
}

impl DfsHelper {
    fn dfs(&amp;mut self, curr_node: &amp;TrieTypoChecker, input_word_index: usize, edit_times: i32) {
        if edit_times &lt; 0 {
            return;
        }

        if input_word_index == self.input_word_len {
            if curr_node.is_word {
                self.output_suggestions.push(unsafe { String::from_utf8_unchecked(self.path.clone()) });
            }
            if edit_times == 0 {
                return;
            }
            // 输入单词遍历遍历完了，如果还有编辑次数可用，则用剩余的编辑次数给当前dfs遍历路径组成的单词词尾巴追加字母
            // 例如 input_word=&quot;do&quot;, trie从根到当前节点的路径d-&gt;o遍历完还剩余1次编辑次数，则可以用做增加操作，把g加到当前路径中
            for (i, child_node_opt) in curr_node.children.iter().take(26).enumerate() {
                if let Some(child_node) = child_node_opt {
                    self.path.push(b'a' + i as u8);
                    self.dfs(child_node, input_word_index, edit_times-1);
                    self.path.pop().unwrap();
                }
            }
            return;
        }

        if self.output_suggestions.len() &gt;= TrieTypoChecker::NUMBER_OF_SUGGESTIONS {
            return;
        }

        let curr_letter_index = (self.input_word[input_word_index] - b'a') as usize;
        for (i, child_node_opt) in curr_node.children.iter().take(26).enumerate() {
            if let Some(child_node) = child_node_opt {
                if i == curr_letter_index {
                    self.path.push(self.input_word[input_word_index]);
                    self.dfs(child_node, input_word_index+1, edit_times);
                    self.path.pop().unwrap();
                } else {
                    // replace
                    self.path.push(b'a' + i as u8);
                    self.dfs(child_node, input_word_index+1, edit_times-1);
                    self.path.pop().unwrap();
                }
            }
        }

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>输出看上去很接近拼写错误单词:</p>
<blockquote>
<p>Unknown word <code>doo</code>, did you mean one of [&quot;boo&quot;, &quot;coo&quot;, &quot;doa&quot;, &quot;dob&quot;, &quot;doc&quot;, &quot;dod&quot;, &quot;doe&quot;, &quot;dog&quot;, &quot;don&quot;, &quot;doom&quot;, &quot;door&quot;, &quot;dos&quot;, &quot;dot&quot;, &quot;dow&quot;, &quot;doz&quot;]?</p>
</blockquote>
<p>遗憾的是还未能实现编辑距离的删除操作，相比知乎上那个最佳回答还少了很多情况的判断</p>
<p>再看看单元测试的情况:</p>
<pre><code>thread 'test_trie_typo_checker' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;boo&quot;, &quot;coo&quot;, &quot;doa&quot;, &quot;dob&quot;, &quot;doc&quot;, &quot;dod&quot;, &quot;doe&quot;, &quot;dog&quot;, &quot;don&quot;, &quot;doom&quot;, &quot;door&quot;, &quot;dos&quot;, &quot;dot&quot;, &quot;dow&quot;, &quot;doz&quot;]`,
 right: `[&quot;boo&quot;, &quot;coo&quot;, &quot;dao&quot;, &quot;do&quot;, &quot;doa&quot;, &quot;dob&quot;]`', src/lib.rs:182:9
</code></pre>
<p>首先肉眼看错误单词 doo 返回的候选词基本满足，期望返回 5 个候选词，结果超过返回超过 5 个</p>
<p>但是没有将 do 收录进候选词，因为上述代码还没支持编辑距离的删除操作</p>
<p>其次候选词的排序似乎跟数组的实现不一样，原因是这个前缀树的遍历并不是跟数组按字母顺序遍历单词表一样</p>
<p>准确的说法是<strong>26 叉树的深度优先回溯搜索</strong>，类似的算法可以参考 <a href="https://leetcode.com/problems/lexicographical-numbers/">leetcode lexicographical 一题</a></p>
<p>所以单元测试的期待值校验应该改成，遍历每一个候选词用 rustc_span::lev_distance::lev_distance 去计算跟输入单词之间的编辑距离</p>
<p>如果全部候选词的编辑距离小于等于 1 则测试通过</p>
<h3><a class="header" href="#简陋编辑距离实现的不足" id="简陋编辑距离实现的不足">简陋编辑距离实现的不足</a></h3>
<ol>
<li>还没支持字符串编辑距离的删除操作</li>
<li>没有测试入参 edit_times &gt;= 2 的情况</li>
<li>应该用迭代模拟递归，递归代码对编译器不友好，难优化</li>
<li>应当做成 iterator 或 generator 可以逐个输出值，返回值要实现标准库相关的 Iter trait</li>
<li>改良测试用例的期待值校验方法</li>
</ol>
<hr />
<h2><a class="header" href="#单词拼写检查器还能干什么" id="单词拼写检查器还能干什么">单词拼写检查器还能干什么</a></h2>
<p>作者一开始参与 sqlx 项目也是只能提 PR 修些 <code>typo</code> (typo 就是单词拼写错误的意思)</p>
<p>通过修 typo 的过程更仔细的阅读了多遍源码，更深入理解 sqlx 的架构，日后渐渐修复了 sqlx sqlite 部分的几个 Bug</p>
<p>本文讲述的这个拼写检查器，还可以用来检查开源项目的一些 typo</p>
<p>Rust 2021 年 4 月的这个 <a href="https://github.com/rust-lang/rust/pull/84334/files">PR</a>
只是修复些拼写错误，但也算对 Rust 的开源社区做出贡献</p>
<p>希望更多人能像作者这样从修复 typo 开始参与开源项目，慢慢能解决更困难的 issue，逐渐为开源社区做出更大的贡献</p>
<h2><a class="header" href="#项目的-github-链接与总结" id="项目的-github-链接与总结">项目的 github 链接与总结</a></h2>
<p>拼写错误候选词建议源码的 github 仓库链接: <a href="https://github.com/pymongo/typo_checker">https://github.com/pymongo/typo_checker</a> (持续更新，欢迎 star)</p>
<p>总的来说前缀树存储单词表性能会比数组优秀太多，后续打算添加一个检查一篇文章的单词拼写错误例子</p>
<p>然后再加一个实时检测 android 的 EditText 文本输入组件的单词拼写错误的示例</p>
<h1><a class="header" href="#使用-nom-解析-url" id="使用-nom-解析-url">使用 nom 解析 url</a></h1>
<p>编辑：张汉东</p>
<hr />
<blockquote>
<p><a href="https://blog.logrocket.com/parsing-in-rust-with-nom/">原文</a> </p>
</blockquote>
</br>
<p><img src="chapter_4/../image/parsing-rust-nom.png" alt="nom" /></p>
</br>
<p>在本教程中，我们将演示如何使用 nom 解析器组合器库在 Rust 中编写一个非常基础的 URL 解析器。我们将包含以下内容</p>
<ul>
<li><a href="chapter_4/nom_url.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8?">什么是解析器组合器?</a></li>
<li><a href="chapter_4/nom_url.html#nom%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">nom是如何工作的</a></li>
<li><a href="chapter_4/nom_url.html#%E8%AE%BE%E7%BD%AEnom">设置nom</a></li>
<li><a href="chapter_4/nom_url.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="chapter_4/nom_url.html#nom%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">nom中的错误处理</a></li>
<li><a href="chapter_4/nom_url.html#%E4%BD%BF%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%9E%90%E5%99%A8">使用Rust写一个解析器</a></li>
<li><a href="chapter_4/nom_url.html#%E8%A7%A3%E6%9E%90%E5%BE%85%E6%8E%88%E6%9D%83%E7%9A%84URL">解析待授权的URL</a></li>
<li><a href="chapter_4/nom_url.html#Rust%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%B8%BB%E6%9C%BA%EF%BC%8CIP%E5%92%8C%E7%AB%AF%E5%8F%A3">Rust解析：主机，IP和端口</a></li>
<li><a href="chapter_4/nom_url.html#%E4%BD%BF%E7%94%A8Rust%E8%A7%A3%E6%9E%90%E8%B7%AF%E5%BE%84">使用Rust解析路径</a></li>
<li><a href="chapter_4/nom_url.html#%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%89%87%E6%AE%B5">查询和片段</a></li>
<li><a href="chapter_4/nom_url.html#%E5%9C%A8Rust%E4%B8%AD%E4%BD%BF%E7%94%A8nom%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%9C%80%E7%BB%88%E7%9A%84%E6%B5%8B%E8%AF%95">在Rust中使用nom解析：最终的测试</a></li>
</ul>
<h2><a class="header" href="#什么是解析器组合器" id="什么是解析器组合器">什么是解析器组合器?</a></h2>
<p>解析器组合器是高阶函数，可以接受多个解析器作为输入，并返回一个新的解析器作为输出。</p>
<p>这种方式让你可以为简单的任务(如：解析某个字符串或数字)构建解析器，并使用组合器函数将它们组合成一个递归下降(recursive descent)的解析器。</p>
<p>组合解析的好处包括可测试性，可维护性和可读性。每个部件都非常小且具有自我隔离性，从而使整个解析器由模块化组件构成。</p>
<p>如果你对这个概念不熟悉，我强烈推荐你阅读 Bodil Stokke 的<a href="chapter_4/./01-%E7%94%A8Rust%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E5%90%88%E5%99%A8.html">用 Rust 学习解析器组合器</a>。</p>
<h2><a class="header" href="#nom是如何工作的" id="nom是如何工作的">nom是如何工作的</a></h2>
<p><a href="https://github.com/Geal/nom">nom</a> 是使用 Rust 编写的解析器组合器库，它可以让你创建安全的解析器，而不会占用内存或影响性能。它依靠 Rust 强大的类型系统和内存安全来生成既正确又高效的解析器，并使用函数，宏和特征来抽象出容易出错的管道。</p>
<p>为了演示 <code>nom</code> 是如何工作的，我们将创建一个基础的 URL 解析器。我们不会完整的实现 <a href="https://url.spec.whatwg.org/">URL 规范</a>；这将远远超出此代码示例的范围。相反，我们将采用一些捷径。</p>
<p>最终的目标是能够将合法的 URL (如：<a href="https://www.zupzup.org/about/?someVal=5&amp;anotherVal=hello#anchor">https://www.zupzup.org/about/?someVal=5&amp;anotherVal=hello#anchor</a> 和 <a href="http://user:pw@127.0.0.1:8080">http://user:pw@127.0.0.1:8080</a>) 解析成相关的结构，并在解析过程中为非法的 URL 返回一个有用的错误。</p>
<p>而且，由于可测试性被认为是解析器组合器的一大优势，我们将对大多数组件进行测试，以了解其具体的优势。</p>
<p>让我们开始吧！</p>
<h2><a class="header" href="#设置nom" id="设置nom">设置nom</a></h2>
<p>为了进行下面的一系列操作，你需要安装最新的 Rust 版本 (1.44+)。</p>
<p>首先，创建一个新的 Rust 项目:</p>
<pre><code class="language-console">cargo new --lib rust-nom-example
cd rust-nom-example
</code></pre>
<p>然后，编辑<code>Cargo.toml</code>文件并添加你需要的依赖：</p>
<pre><code class="language-toml">[dependencies]
nom = &quot;6.0&quot;
</code></pre>
<p>是的，我们需要的是最新版本的<code>nom</code>库(在撰写本文时是 6.0)。</p>
<h2><a class="header" href="#数据类型" id="数据类型">数据类型</a></h2>
<p>编写解析器时，通常先定义输出结构以了解你需要哪些部分是很有意义的。</p>
<p>在这里，我们正在解析一个 URL，因此，让我们给它定义一个结构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq, Eq)]
pub struct URI&lt;'a&gt; {
    scheme: Scheme,
    authority: Option&lt;Authority&lt;'a&gt;&gt;,
    host: Host,
    port: Option&lt;u16&gt;,
    path: Option&lt;Vec&lt;&amp;'a str&gt;&gt;,
    query: Option&lt;QueryParams&lt;'a&gt;&gt;,
    fragment: Option&lt;&amp;'a str&gt;,
}

#[derive(Debug, PartialEq, Eq)]
pub enum Scheme {
    HTTP,
    HTTPS,
}

pub type Authority&lt;'a&gt; = (&amp;'a str, Option&lt;&amp;'a str&gt;);

#[derive(Debug, PartialEq, Eq)]
pub enum Host {
    HOST(String),
    IP([u8; 4]),
}

pub type QueryParam&lt;'a&gt; = (&amp;'a str, &amp;'a str);
pub type QueryParams&lt;'a&gt; = Vec&lt;QueryParam&lt;'a&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>让我们逐行进行说明。</p>
<p>这些字段是根据它们在常规 URI 中出现的顺序进行排列的。首先，我们有 scheme。在这里，我们将 URI 的前缀限制为<code>http://</code>和<code>https://</code>，但是请注意，这里还有很多其它可选的 scheme。</p>
<p>接下来是<code>authority</code>部分，它由用户名和可选密码组成，通常是完全可选的。</p>
<p>host 可以是 IP，(在我们的示例中仅为 IPv4)，也可以是主机字符串，如：<code>example.org</code>，后面跟一个可选的port，port 仅是个数字：如：<code>localhost:8080</code>。</p>
<p>在端口之后是 path。它是由<code>/</code>分割的字符串序列，如：<code>/some/important/path</code>。query 和 fragment 部分是可选的，它们表示 URL 的<code>?query=some-value&amp;another=5</code>和<code>#anchor</code>部分。query 是字符串元组的可选列表，而 fragment 只是可选字符串(完整的 URL 示例是<code>https://some/important/?query=some-value&amp;another=5#anchor</code>)。</p>
<p>如果你对这些类型中的生命周期(<code>'a</code>)感到困惑，请不用感到沮丧；它不会真的影响到我们写代码的方式。本质上，我们可以使用指向输入字符串各部分的指针，而不是为 URL 的每一部分分配新的字符串，只要输入的生命周期和我们 URI 结构一样长就可以了。</p>
<p>在开始解析之前，让我们实现<code>From</code>特征将合法的 scheme 转换成<code>Scheme</code>枚举：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;&amp;str&gt; for Scheme {
    fn from(i: &amp;str) -&gt; Self {
        match i.to_lowercase().as_str() {
            &quot;http://&quot; =&gt; Scheme::HTTP,
            &quot;https://&quot; =&gt; Scheme::HTTPS,
            _ =&gt; unimplemented!(&quot;no other schemes supported&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>顺便说一句，让我们从顶部开始，开始解析 scheme。</p>
<h2><a class="header" href="#nom中的错误处理" id="nom中的错误处理">nom中的错误处理</a></h2>
<p>在我们开始之前，先讨论一下 <code>nom</code> 中的错误处理。虽然我们不会面面俱到，但是至少会让调用者大致了解在解析的哪一步出了什么问题。</p>
<p>为了达到我们的目的，我们将使用<code>nom</code>中的<code>context</code>组合器。在<code>nom</code>中，一个解析器通常会返回如下类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type IResult&lt;I, O, E = (I, ErrorKind)&gt; = Result&lt;(I, O), Err&lt;E&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>在本例中，我们将返回一个输入值(<code>&amp;str</code> - 输入字符串)的元组类型。它包含仍需要解析的字符串，以及输出的值。当解析失败时，它也会返回一个错误。</p>
<p>标准的<code>IResult</code>只允许我们使用 nom 内置的错误类型，如果我们想要创建自定义的错误类型以及在这些错误中添加一些上下文呢？</p>
<p><code>ParserError</code> 特征和 <code>VerboseError</code> 类型让我们可以构建自己的错误类型，并可以在已有的错误中添加上下文。在这个简单的例子中，我们将会在我们的解析错误类型中添加上下文。为了方便起见，让我们定义一个自己的结果类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Res&lt;T, U&gt; = IResult&lt;T, U, VerboseError&lt;T&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>除了它带有<code>VerboseError</code>之外，本质上是相同的。这意味着我们可以使用 nom 的上下文组合器，它允许我们在任何解析器中隐式地添加错误上下文。</p>
<p>nom 的官方文档包含这些选项，但是错误处理并不是最直观的方法。</p>
<p>为了看到它的实际效果，让我们为该 scheme 创建第一个解析器。</p>
<h2><a class="header" href="#使用rust写一个解析器" id="使用rust写一个解析器">使用Rust写一个解析器</a></h2>
<p>为了解析 URL 的scheme，我们想要匹配<code>http://</code>和<code>https://</code>，除此之外没有别的了。由于我们使用的是功能强大的解析器组合器库，因此我们不需要手动编写底层的解析器。<code>nom</code> 已经帮我们覆盖了。</p>
<p><a href="https://github.com/fucking-translation/tutorial/Rust/nom/%E9%80%89%E6%8B%A9nom%E7%BB%84%E5%90%88%E5%99%A8.md">解析器组合器宏清单</a>讲述了在某些用例中如何使用 nom 中的解析器组合器。</p>
<p>我们将会使用<code>tag_no_case</code>解析器和<code>alt</code>组合器来做基础的说明：“每个小写(输入)应该是<code>http://</code>或<code>https://</code>” 。在本教程中，我们将只使用常规函数，但请注意，nom 中的许多解析器和组合器也可以作为宏使用。</p>
<p>在 Rust 中使用 nom 如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scheme(input: &amp;str) -&gt; Res&lt;&amp;str, Scheme&gt; {
    context(
        &quot;scheme&quot;,
        alt((tag_no_case(&quot;HTTP://&quot;), tag_no_case(&quot;HTTPS://&quot;))),
    )(input)
    .map(|(next_input, res)| (next_input, res.into()))
}
<span class="boring">}
</span></code></pre></pre>
<p>如你所示：我们使用<code>context</code>组合器封装了实际的解析器并在其中添加了<code>scheme</code>上下文，因此，此处触发的任何错误都将在结果中标记为<code>scheme</code>。</p>
<p>一旦将解析器和组合器组装成了整个解析器，便使用输入字符串来调用它，这是我们唯一的输入参数。然后我们对结果进行<code>map</code> - 如上所述，它由剩余的输入和解析的输出组成，并通过实现前面提到的<code>.into()</code>特征将我们解析后的 scheme 转换成<code>Scheme</code>枚举。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use nom::{
        error::{ErrorKind, VerboseError, VerboseErrorKind},
        Err as NomErr,
    };

    #[test]
    fn test_scheme() {
        assert_eq!(scheme(&quot;https://yay&quot;), Ok((&quot;yay&quot;, Scheme::HTTPS)));
        assert_eq!(scheme(&quot;http://yay&quot;), Ok((&quot;yay&quot;, Scheme::HTTP)));
        assert_eq!(
            scheme(&quot;bla://yay&quot;),
            Err(NomErr::Error(VerboseError {
                errors: vec![
                    (&quot;bla://yay&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                    (&quot;bla://yay&quot;, VerboseErrorKind::Nom(ErrorKind::Alt)),
                    (&quot;bla://yay&quot;, VerboseErrorKind::Context(&quot;scheme&quot;)),
                ]
            }))
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如你所见，在成功的情况下，我们取回已解析<code>Scheme</code>枚举和剩余待解析的字符串(<code>yay</code>)。另外，如果有错误，我们将列举出已触发的错误以及定义的上下文列表(<code>scheme</code>)。</p>
<p>在本例中，两次<code>tag</code>调用都失败了，因此，<code>alt</code>组合器也失败了，因为它无法产生单个值。</p>
<p>那不是很难。在上面我们基本上只是解析了一个常量的字符串，让我们通过解析<code>authority</code>部分来尝试更高级的内容。</p>
<h2><a class="header" href="#解析待授权的url" id="解析待授权的url">解析待授权的URL</a></h2>
<p>如果我们还记得我们在之前的 URI 的结构，尤其是 authority 部分，我们会看到我们正在寻找一个完全可选的结构。如果它存在，则需要一个用户名和一个可选的密码。</p>
<p>这是我们使用的类型别名：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Authority&lt;'a&gt; = (&amp;'a str, Option&lt;&amp;'a str&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>我们该怎么办呢？在 URL 中，它看起来像：</p>
<p><a href="https://username:password@example.org">https://username:password@example.org</a></p>
<p><code>:password</code>是可选的，但是在任何情况下，它都会以<code>@</code>作为结尾，所以我们可以通过使用<code>terminated</code>解析器开始。这给了我们一个字符串，该字符串是通过终止另一个字符串得到的。</p>
<p>在<code>authority</code>部分中，我们看到<code>:</code>作为一个分隔符。根据文档，我们可以使用<code>separated_pair</code>组合器，它通过分割一个字符串给我们提供了两个值。但是我们如何处理实际的文本呢？这里有几种选项，一种是使用<code>alphanumeric1</code>解析器。它生成了一个至少包含一个字符的字母数字字符串。</p>
<p>为了简单起见，我们不必担心可以在 URL 的不同部分使用哪些字符。这与编写和构造解析器无关，只会使所有的内容变得更长且更不方便。出于我们的目的，我们假设 URL 的大部分都可以由字母数字组成，有时候还包含连字符和点 - 根据 <a href="https://url.spec.whatwg.org/#url-code-points">URL 标准</a>，这当然是错误的。</p>
<p>让我们来看看组合后的<code>authority</code>解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn authority(input: &amp;str) -&gt; Res&lt;&amp;str, (&amp;str, Option&lt;&amp;str&gt;)&gt; {
    context(
        &quot;authority&quot;,
        terminated(
            separated_pair(alphanumeric1, opt(tag(&quot;:&quot;)), opt(alphanumeric1)),
            tag(&quot;@&quot;),
        ),
    )(input)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们通过运行一些测试用例来检验它是否工作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_authority() {
    assert_eq!(
        authority(&quot;username:password@zupzup.org&quot;),
        Ok((&quot;zupzup.org&quot;, (&quot;username&quot;, Some(&quot;password&quot;))))
    );
    assert_eq!(
        authority(&quot;username@zupzup.org&quot;),
        Ok((&quot;zupzup.org&quot;, (&quot;username&quot;, None)))
    );
    assert_eq!(
        authority(&quot;zupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;.org&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (&quot;zupzup.org&quot;, VerboseErrorKind::Context(&quot;authority&quot;)),
            ]
        }))
    );
    assert_eq!(
        authority(&quot;:zupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (
                    &quot;:zupzup.org&quot;,
                    VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)
                ),
                (&quot;:zupzup.org&quot;, VerboseErrorKind::Context(&quot;authority&quot;)),
            ]
        }))
    );
    assert_eq!(
        authority(&quot;username:passwordzupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;.org&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (
                    &quot;username:passwordzupzup.org&quot;,
                    VerboseErrorKind::Context(&quot;authority&quot;)
                ),
            ]
        }))
    );
    assert_eq!(
        authority(&quot;@zupzup.org&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (
                    &quot;@zupzup.org&quot;,
                    VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)
                ),
                (&quot;@zupzup.org&quot;, VerboseErrorKind::Context(&quot;authority&quot;)),
            ]
        }))
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>看起来很不错！对于各种情况，我们都有与之对应的测试用例，缺少密码，缺少<code>@</code>以及其他几种错误的情况。</p>
<p>让我们继续来到 <code>host</code> 部分。</p>
<h2><a class="header" href="#rust解析主机ip和端口" id="rust解析主机ip和端口">Rust解析：主机，IP和端口</a></h2>
<p>因为 host 部分可以包含 主机字符串或者 IP，这一步将会有点复杂。更糟的是，在结尾还有一个可选的<code>:port</code>。</p>
<p>为了尽可能保持简单，我们只支持 IPv4 的 IP。我们将从 host 开始。让我们看一下它的实现并逐行进行说明。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn host(input: &amp;str) -&gt; Res&lt;&amp;str, Host&gt; {
    context(
        &quot;host&quot;,
        alt((
            tuple((many1(terminated(alphanumerichyphen1, tag(&quot;.&quot;))), alpha1)),
            tuple((many_m_n(1, 1, alphanumerichyphen1), take(0 as usize))),
        )),
    )(input)
    .map(|(next_input, mut res)| {
        if !res.1.is_empty() {
            res.0.push(res.1);
        }
        (next_input, Host::HOST(res.0.join(&quot;.&quot;)))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>首先你注意到这里有两个选项(<code>alt</code>)。在这两种情况下，都有一个元组，并包含了一个解析器链。</p>
<p>在第一种情况下，我们想要一个或多个(<code>many1</code>)字母数字字符串，包含一个连字符，被一个<code>.</code>终结并以顶级域名 (alpha1) 结尾。</p>
<p><code>alphanumerichyphen1</code>解析器如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn alphanumerichyphen1&lt;T&gt;(i: T) -&gt; Res&lt;T, T&gt;
where
    T: InputTakeAtPosition,
    &lt;T as InputTakeAtPosition&gt;::Item: AsChar,
{
    i.split_at_position1_complete(
        |item| {
            let char_item = item.as_char();
            !(char_item == '-') &amp;&amp; !char_item.is_alphanum()
        },
        ErrorKind::AlphaNumeric,
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>这有点复杂，但基本上是 nom 中<code>alphanumeric1</code>解析器带有<code>-</code>的复制版本。我不知道它是否是最好的方式，但是它确实有用。</p>
<p>在任何情况下，主机部分都有第二个选项，它是一个字符串，如：<code>localhost</code>。</p>
<p>为什么我们要用将1和1传给<code>many_m_n</code>解析器这种看起来很无用的方式来表示呢？这里的问题是，在<code>alt</code>组合器中，所有的选项都必须返回相同的类型 - 在这里，它是一个字符串向量和另一个字符串的元组。</p>
<p>我们也在<code>map</code>函数中看到，如果元组的第二部分不为空(顶级域名)，则将其添加到元组的第一部分。最后，我们构建了一个 HOST 枚举，将字符串部分用一个<code>.</code>相连，并创建了一个原始的主机字符串。</p>
<p>让我们来看一些测试用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_host() {
    assert_eq!(
        host(&quot;localhost:8080&quot;),
        Ok((&quot;:8080&quot;, Host::HOST(&quot;localhost&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;example.org:8080&quot;),
        Ok((&quot;:8080&quot;, Host::HOST(&quot;example.org&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;some-subsite.example.org:8080&quot;),
        Ok((&quot;:8080&quot;, Host::HOST(&quot;some-subsite.example.org&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;example.123&quot;),
        Ok((&quot;.123&quot;, Host::HOST(&quot;example&quot;.to_string())))
    );
    assert_eq!(
        host(&quot;$$$.com&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;$$$.com&quot;, VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)),
                (&quot;$$$.com&quot;, VerboseErrorKind::Nom(ErrorKind::ManyMN)),
                (&quot;$$$.com&quot;, VerboseErrorKind::Nom(ErrorKind::Alt)),
                (&quot;$$$.com&quot;, VerboseErrorKind::Context(&quot;host&quot;)),
            ]
        }))
    );
    assert_eq!(
        host(&quot;.com&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;.com&quot;, VerboseErrorKind::Nom(ErrorKind::AlphaNumeric)),
                (&quot;.com&quot;, VerboseErrorKind::Nom(ErrorKind::ManyMN)),
                (&quot;.com&quot;, VerboseErrorKind::Nom(ErrorKind::Alt)),
                (&quot;.com&quot;, VerboseErrorKind::Context(&quot;host&quot;)),
            ]
        }))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们来到 主机是 IP 的情况。首先，我们需要能够解析 IPv4 的 IP 中每一个的部分(如：127.0.0.1)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ip_num(input: &amp;str) -&gt; Res&lt;&amp;str, u8&gt; {
    context(&quot;ip number&quot;, n_to_m_digits(1, 3))(input).and_then(|(next_input, result)| {
        match result.parse::&lt;u8&gt;() {
            Ok(n) =&gt; Ok((next_input, n)),
            Err(_) =&gt; Err(NomErr::Error(VerboseError { errors: vec![] })),
        }
    })
}

fn n_to_m_digits&lt;'a&gt;(n: usize, m: usize) -&gt; impl FnMut(&amp;'a str) -&gt; Res&lt;&amp;str, String&gt; {
    move |input| {
        many_m_n(n, m, one_of(&quot;0123456789&quot;))(input)
            .map(|(next_input, result)| (next_input, result.into_iter().collect()))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为了获取每一个数字，我们尝试使用<code>n_to_m_digits</code>解析器来寻找一到三个连续的数字并将他们转换成 <code>u8</code>。</p>
<p>通过这种方式，我们可以查看如何将完整的 IP 解析成<code>u8</code>数组：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ip(input: &amp;str) -&gt; Res&lt;&amp;str, Host&gt; {
    context(
        &quot;ip&quot;,
        tuple((count(terminated(ip_num, tag(&quot;.&quot;)), 3), ip_num)),
    )(input)
    .map(|(next_input, res)| {
        let mut result: [u8; 4] = [0, 0, 0, 0];
        res.0
            .into_iter()
            .enumerate()
            .for_each(|(i, v)| result[i] = v);
        result[3] = res.1;
        (next_input, Host::IP(result))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们要查找的查好是3个后面跟<code>.</code>的<code>ip_num</code>，然后是另一个<code>ip_num</code>。在映射函数中，我们将这些独立的结果拼接，从而将<code>u8</code>数组转换成<code>Host::IP</code>枚举。</p>
<p>再一次，我们将写一些测试用例来确保它是正常工作的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ipv4() {
    assert_eq!(
        ip(&quot;192.168.0.1:8080&quot;),
        Ok((&quot;:8080&quot;, Host::IP([192, 168, 0, 1])))
    );
    assert_eq!(ip(&quot;0.0.0.0:8080&quot;), Ok((&quot;:8080&quot;, Host::IP([0, 0, 0, 0]))));
    assert_eq!(
        ip(&quot;1924.168.0.1:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;4.168.0.1:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (&quot;1924.168.0.1:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Count)),
                (&quot;1924.168.0.1:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
    assert_eq!(
        ip(&quot;192.168.0000.144:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;0.144:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (
                    &quot;192.168.0000.144:8080&quot;,
                    VerboseErrorKind::Nom(ErrorKind::Count)
                ),
                (&quot;192.168.0000.144:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
    assert_eq!(
        ip(&quot;192.168.0.1444:8080&quot;),
        Ok((&quot;4:8080&quot;, Host::IP([192, 168, 0, 144])))
    );
    assert_eq!(
        ip(&quot;192.168.0:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Tag)),
                (&quot;192.168.0:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Count)),
                (&quot;192.168.0:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
    assert_eq!(
        ip(&quot;999.168.0.0:8080&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;999.168.0.0:8080&quot;, VerboseErrorKind::Nom(ErrorKind::Count)),
                (&quot;999.168.0.0:8080&quot;, VerboseErrorKind::Context(&quot;ip&quot;)),
            ]
        }))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>将它们放置在一起，我们需要另一个可以同时解析 IP 和 host 的解析器，并返回一个<code>Host</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ip_or_host(input: &amp;str) -&gt; Res&lt;&amp;str, Host&gt; {
    context(&quot;ip or host&quot;, alt((ip, host)))(input)
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，让我们来解析端口(原文遗漏)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn port(input: &amp;str) -&gt; Res&lt;&amp;str, u16&gt; {
    context(
        &quot;port&quot;,
        tuple((
            tag(&quot;:&quot;),
            n_to_m_digits(1, 5)
        )),
    )(input)
        .and_then(|(next_input, result)| {
            let port = result.1.parse::&lt;u16&gt;();
            match port {
                Ok(port) =&gt; Ok((next_input, port)),
                Err(e) =&gt; Err(NomErr::Error(VerboseError { errors: vec![ (input, VerboseErrorKind::Nom(ErrorKind::Digit))] }))
            }
        })
}
<span class="boring">}
</span></code></pre></pre>
<p>并使用一些测试用例保证它是可以正常工作的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_port() {
    assert_eq!(port(&quot;:0&quot;), Ok((&quot;&quot;, 0u16)));
    assert_eq!(port(&quot;:65535&quot;), Ok((&quot;&quot;, 65535u16)));
    assert_eq!(
        port(&quot;:65536&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;:65536&quot;, VerboseErrorKind::Nom(ErrorKind::Digit))
            ]
        })));
    assert_eq!(
        port(&quot;:a&quot;),
        Err(NomErr::Error(VerboseError {
            errors: vec![
                (&quot;a&quot;, VerboseErrorKind::Nom(ErrorKind::OneOf)),
                (&quot;a&quot;, VerboseErrorKind::Nom(ErrorKind::ManyMN)),
                (&quot;:a&quot;, VerboseErrorKind::Context(&quot;port&quot;))
            ]
        })));
}
<span class="boring">}
</span></code></pre></pre>
<p>还不错，一切正常！</p>
<h2><a class="header" href="#使用rust解析路径" id="使用rust解析路径">使用Rust解析路径</a></h2>
<p>下一步是解决路径问题。在此，我们再次假设该路径中的字符串只能包含带有连字符和点的字母数字字符串，并使用以下帮助程序进行解析：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn url_code_points&lt;T&gt;(i: T) -&gt; Res&lt;T, T&gt;
where
    T: InputTakeAtPosition,
    &lt;T as InputTakeAtPosition&gt;::Item: AsChar,
{
    i.split_at_position1_complete(
        |item| {
            let char_item = item.as_char();
            !(char_item == '-') &amp;&amp; !char_item.is_alphanum() &amp;&amp; !(char_item == '.')
            // ... actual ascii code points and url encoding...: https://infra.spec.whatwg.org/#ascii-code-point
        },
        ErrorKind::AlphaNumeric,
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>为了解析<code>path</code>，我们希望可以将由<code>/</code>分隔的字符串解析成字符串向量：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn path(input: &amp;str) -&gt; Res&lt;&amp;str, Vec&lt;&amp;str&gt;&gt; {
    context(
        &quot;path&quot;,
        tuple((
            tag(&quot;/&quot;),
            many0(terminated(url_code_points, tag(&quot;/&quot;))),
            opt(url_code_points),
        )),
    )(input)
    .map(|(next_input, res)| {
        let mut path: Vec&lt;&amp;str&gt; = res.1.iter().map(|p| p.to_owned()).collect();
        if let Some(last) = res.2 {
            path.push(last);
        }
        (next_input, path)
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>我们总是由<code>/</code>开始。这已经是一个合法的路径了，但是我们仍然可以有<code>0</code>个或更多个(<code>many0</code>)由<code>/</code>分隔的字符串，后面跟一个最终的可选的字符串(如：<code>index.php</code>)。</p>
<p>在映射中，我们检查元组的第三部分(最后一部分)是否存在，如果存在，则将其添加到路径向量中。</p>
<p>让我们为路径也写一点测试用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_path() {
    assert_eq!(path(&quot;/a/b/c?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])));
    assert_eq!(path(&quot;/a/b/c/?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])));
    assert_eq!(path(&quot;/a/b-c-d/c/?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;b-c-d&quot;, &quot;c&quot;])));
    assert_eq!(path(&quot;/a/1234/c/?d&quot;), Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;1234&quot;, &quot;c&quot;])));
    assert_eq!(
        path(&quot;/a/1234/c.txt?d&quot;),
        Ok((&quot;?d&quot;, vec![&quot;a&quot;, &quot;1234&quot;, &quot;c.txt&quot;]))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>看起来不错！我们获取到了路径中的不同部分以及剩余的字符串，并且它们都被添加到了字符串向量中了。</p>
<p>让我们通过解析 query 和 URL 部分的 fragment 来增强功能。</p>
<h2><a class="header" href="#查询和片段" id="查询和片段">查询和片段</a></h2>
<p>查询主要是由键值对组成：第一个键前面跟一个<code>?</code>，其余的查询由<code>&amp;</code>进行分隔。再一次，我们将自己限制为有限的<code>url_code_points</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn query_params(input: &amp;str) -&gt; Res&lt;&amp;str, QueryParams&gt; {
    context(
        &quot;query params&quot;,
        tuple((
            tag(&quot;?&quot;),
            url_code_points,
            tag(&quot;=&quot;),
            url_code_points,
            many0(tuple((
                tag(&quot;&amp;&quot;),
                url_code_points,
                tag(&quot;=&quot;),
                url_code_points,
            ))),
        )),
    )(input)
    .map(|(next_input, res)| {
        let mut qps = Vec::new();
        qps.push((res.1, res.3));
        for qp in res.4 {
            qps.push((qp.1, qp.3));
        }
        (next_input, qps)
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>实际上这相当不错，因为解析器是非常直观(intuitive)且可读性的。我们解析<code>?</code>后面的第一个键值对的元组，使用<code>=</code>分隔，然后同样的操作执行<code>0</code>或多次，它们是以<code>&amp;</code>而不是<code>?</code>开头。</p>
<p>然后，在映射中，我们简单的将所有的键值对放在向量中，然后就有了我们在文章的开头定义的结构。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type QueryParam&lt;'a&gt; = (&amp;'a str, &amp;'a str);
pub type QueryParams&lt;'a&gt; = Vec&lt;QueryParam&lt;'a&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这里有一组基础的测试用例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_query_params() {
    assert_eq!(
        query_params(&quot;?bla=5&amp;blub=val#yay&quot;),
        Ok((&quot;#yay&quot;, vec![(&quot;bla&quot;, &quot;5&quot;), (&quot;blub&quot;, &quot;val&quot;)]))
    );

    assert_eq!(
        query_params(&quot;?bla-blub=arr-arr#yay&quot;),
        Ok((&quot;#yay&quot;, vec![(&quot;bla-blub&quot;, &quot;arr-arr&quot;),]))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>最后一部分是 fragment，它其实就是一个<code>#</code>后面跟一个字符串：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fragment(input: &amp;str) -&gt; Res&lt;&amp;str, &amp;str&gt; {
    context(&quot;fragment&quot;, tuple((tag(&quot;#&quot;), url_code_points)))(input)
        .map(|(next_input, res)| (next_input, res.1))
}
<span class="boring">}
</span></code></pre></pre>
<p>在介绍了所有这些复杂的解析器之后，为了达到良好的效果，让我们编写一些完整性检查测试：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_fragment() {
    assert_eq!(fragment(&quot;#bla&quot;), Ok((&quot;&quot;, &quot;bla&quot;)));
    assert_eq!(fragment(&quot;#bla-blub&quot;), Ok((&quot;&quot;, &quot;bla-blub&quot;)));
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#在rust中使用nom解析最终的测试" id="在rust中使用nom解析最终的测试">在Rust中使用nom解析:最终的测试</a></h2>
<p>让我们将它们都放在最顶层的 URI 解析器函数中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn uri(input: &amp;str) -&gt; Res&lt;&amp;str, URI&gt; {
    context(
        &quot;uri&quot;,
        tuple((
            scheme,
            opt(authority),
            ip_or_host,
            opt(port),
            opt(path),
            opt(query_params),
            opt(fragment),
        )),
    )(input)
    .map(|(next_input, res)| {
        let (scheme, authority, host, port, path, query, fragment) = res;
        (
            next_input,
            URI {
                scheme,
                authority,
                host,
                port,
                path,
                query,
                fragment,
            },
        )
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>我们有一个强制的(mandatory)<code>scheme</code>，后面跟一个可选的<code>authority</code>，然后再跟一个强制的<code>ip 或 host</code>。最后后面跟可选的<code>port</code>，<code>path</code>，<code>query 参数</code>，和一个<code>fragment</code>。</p>
<p>在映射中，剩下的唯一一件事就是将解析后的元素构成成我们的<code>URI</code>结构。</p>
<p>在这一点上，你可以看到整个结构的美观性和模块化。如果 uri 函数是你的起点，那么你可以从头到尾查看每个单独的解析器，以了解整个过程在做什么。</p>
<p>当然，我们也需要对<code>uri</code>解析器进行一些测试：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_uri() {
    assert_eq!(
        uri(&quot;https://www.zupzup.org/about/&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTPS,
                authority: None,
                host: Host::HOST(&quot;www.zupzup.org&quot;.to_string()),
                port: None,
                path: Some(vec![&quot;about&quot;]),
                query: None,
                fragment: None
            }
        ))
    );

    assert_eq!(
        uri(&quot;http://localhost&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTP,
                authority: None,
                host: Host::HOST(&quot;localhost&quot;.to_string()),
                port: None,
                path: None,
                query: None,
                fragment: None
            }
        ))
    );

    assert_eq!(
        uri(&quot;https://www.zupzup.org:443/about/?someVal=5#anchor&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTPS,
                authority: None,
                host: Host::HOST(&quot;www.zupzup.org&quot;.to_string()),
                port: Some(443),
                path: Some(vec![&quot;about&quot;]),
                query: Some(vec![(&quot;someVal&quot;, &quot;5&quot;)]),
                fragment: Some(&quot;anchor&quot;)
            }
        ))
    );

    assert_eq!(
        uri(&quot;http://user:pw@127.0.0.1:8080&quot;),
        Ok((
            &quot;&quot;,
            URI {
                scheme: Scheme::HTTP,
                authority: Some((&quot;user&quot;, Some(&quot;pw&quot;))),
                host: Host::IP([127, 0, 0, 1]),
                port: Some(8080),
                path: None,
                query: None,
                fragment: None
            }
        ))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>它没问题！你可以在 <a href="https://github.com/zupzup/rust-nom-parsing">Github</a>找到完整的代码。</p>
<h2><a class="header" href="#结论-7" id="结论-7">结论</a></h2>
<p>真是太好了！我希望本文能够使你对 Rust 中的解析器特别是解析器组合器感到兴奋。</p>
<p><code>nom</code>库解析速度特别快，是很多生产级别的库和系统的基础。除此之外，它还提供了出色的 API 和文档。</p>
<p>Rust 生态系统还提供了更多的解析选项，如：<a href="https://github.com/Marwes/combine">combine</a> 和 <a href="https://github.com/pest-parser/pest">pest</a>。</p>
<h1><a class="header" href="#真实世界的设计模式--外观模式facade-pattern" id="真实世界的设计模式--外观模式facade-pattern">真实世界的设计模式 | 外观模式（Facade Pattern）</a></h1>
<p>作者：张汉东 / 编辑：张汉东</p>
<blockquote>
<p>编者按：</p>
<p>本文摘录自<a href="https://github.com/ZhangHanDong/real-world-rust-design-pattern">开源电子书《Real World Rust Design Pattern》</a>，这本书也是我创建的免费开源电子书，目前正在逐步完善中，欢迎贡献。</p>
<p>这本书旨在挖掘和记录 Rust 开源生态中设计模式的真实实践。欢迎参与贡献！</p>
</blockquote>
<hr />
<h1><a class="header" href="#facade外观模式" id="facade外观模式">Facade（外观）模式</a></h1>
<p>Rust 中最常用的设计模式是哪个？答案是，外观模式。</p>
<p>为什么这么说？看完本文就明白了。</p>
<h2><a class="header" href="#一句话介绍" id="一句话介绍">一句话介绍</a></h2>
<p>Facade，中文术语叫「外观模式」，也叫「门面模式」。在经典设计模式中，归为结构型（Structural）模式分类，因为这种模式用于帮助构建结构。它可以为程序库、框架或其他复杂情况提供一个简单的接口。</p>
<h2><a class="header" href="#解决了什么问题" id="解决了什么问题">解决了什么问题</a></h2>
<p>在软件开发中，有时候要处理很多同类型的业务，但具体处理方式却不同的场景。因此，建立一个「门面」来达到统一管理和分发的目的。</p>
<p>Facade 模式，帮忙建立了统一的接口，使得调用复杂的子系统变得更加简单。因为 Facade 模式只包括应用真正关心的核心功能。</p>
<h2><a class="header" href="#如何解决" id="如何解决">如何解决</a></h2>
<p>心智图：</p>
<pre><code class="language-text">                 +------------------+
+-------+        |                  |         +---------------+
|       |        |                  |         |  additional   |
|client +------&gt; |     facade       +-------&gt; |  facade       |
+-------+        |                  |         |               |
                 |                  |         |               |
                 +--+----+------+--++         +---------------+
                    |    |      |  |
           +--------+    |      |  +--------+
           |          +--+      +-+         |
           |          |           |         |
           v          |           v         v
       +---+---+  +---v--+   +----+--+  +---+----+
       |       |  |      |   |       |  |        |
       | system|  |system|   |system |  | system |
       |       |  |      |   |       |  |        |
       +-------+  +------+   +-------+  +--------+

</code></pre>
<h2><a class="header" href="#真实案例" id="真实案例">真实案例</a></h2>
<p><strong>实现方式：</strong></p>
<p>Rust 中的 门面模式 实现有三类：</p>
<ul>
<li>模块 re-export： 
<ul>
<li><a href="https://github.com/rust-lang/rust/tree/master/library/std/src/sys">Rust libstd reexport libcore</a></li>
<li><a href="https://github.com/rust-lang/futures-rs/blob/master/futures/src/lib.rs">Futures-rs</a></li>
</ul>
</li>
<li>条件编译：<a href="https://github.com/tikv/tikv/tree/master/components/tikv_alloc">tikv/tikv</a></li>
<li>利用 「类型」 和 「Trait」： 
<ul>
<li><a href="https://github.com/rust-lang/log">log</a></li>
<li><a href="https://github.com/tokio-rs/mio">mio</a></li>
<li><a href="chapter_4/">cranelift</a>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/search?q=MachBackend">MachBackend</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/search?q=LowerBackend">LowerBackend</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#模块-re-export" id="模块-re-export">模块 Re-Export</a></h3>
<p>模块 Re-Export 是重导出功能。</p>
<p>比如，现在有如下模块层级：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src/
    - lib.rs
    - module/
        -- mod.rs
        -- submodule/
            --- mod.rs
<span class="boring">}
</span></code></pre></pre>
<p>Rust 允许你将 潜入到最深处的那个模块 submodule 里定义的函数，使用重导出功能，变成整个库的「门面」接口。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in module/submodule/mod.rs
pub fn goodbye(){}

// in lib.rs
pub use module::submodule::goodbye;
<span class="boring">}
</span></code></pre></pre>
<p>那么在使用这个库（假设叫 hello）的时候，只需要使用 <code>hello::goodby</code>就可以使用这个函数。</p>
<p>这种方式在 Rust 的世界大量使用。比如 标准库 很多接口是重导出了 核心库 的 API。</p>
<p>在 Furutes-rs 中也有很多重导出。</p>
<h3><a class="header" href="#条件编译" id="条件编译">条件编译</a></h3>
<p>条件编译也是一种 门面模式。</p>
<p>比如在 TiKV 中，使用 条件编译 和 features 来支持多种内存分配器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(all(unix, not(fuzzing), feature = &quot;jemalloc&quot;))]
#[path = &quot;jemalloc.rs&quot;]
mod imp;
#[cfg(all(unix, not(fuzzing), feature = &quot;tcmalloc&quot;))]
#[path = &quot;tcmalloc.rs&quot;]
mod imp;
#[cfg(all(unix, not(fuzzing), feature = &quot;mimalloc&quot;))]
#[path = &quot;mimalloc.rs&quot;]
mod imp;
#[cfg(not(all(
    unix,
    not(fuzzing),
    any(feature = &quot;jemalloc&quot;, feature = &quot;tcmalloc&quot;, feature = &quot;mimalloc&quot;)
)))]
#[path = &quot;system.rs&quot;]
mod imp;
<span class="boring">}
</span></code></pre></pre>
<p>实际上并不存在 imp 模块，通过不同的 <code>cfg</code> 判断，对应不同的 <code>path</code>，从而选择相应的模块：<code>jemalloc.rs</code>/<code>tcmalloc.rs</code>/<code>mimalloc.rs</code>/<code>system.rs</code>。而 imp 模块就是一个「门面」。</p>
<h3><a class="header" href="#利用-类型-和-trait" id="利用-类型-和-trait">利用 类型 和 Trait</a></h3>
<p>第三种方式，就是常规的 利用 类型 和 trait 来实现门面模型。</p>
<p><strong>最典型的就是官方出的 log 库。</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Log: Sync + Send {
    /// Determines if a log message with the specified metadata would be
    /// logged.
    ///
    /// This is used by the `log_enabled!` macro to allow callers to avoid
    /// expensive computation of log message arguments if the message would be
    /// discarded anyway.
    fn enabled(&amp;self, metadata: &amp;Metadata) -&gt; bool;

    /// Logs the `Record`.
    ///
    /// Note that `enabled` is *not* necessarily called before this method.
    /// Implementations of `log` should perform all necessary filtering
    /// internally.
    fn log(&amp;self, record: &amp;Record);

    /// Flushes any buffered records.
    fn flush(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p>官方通过指定这个 trait ，来创建了一个 「门面」。其他 log 库，比如 env_log / sys_log 等其他 log 库，都可以实现 <code>Log</code> trait。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// env_log
impl Log for Logger {
    fn enabled(&amp;self, metadata: &amp;Metadata) -&gt; bool {
        self.filter.enabled(metadata)
    }

    fn log(&amp;self, record: &amp;Record) {
        if self.matches(record) {
            // ignore many codes
        }
    }

    fn flush(&amp;self) {}
}


// syslog

impl Log for BasicLogger {
  fn enabled(&amp;self, metadata: &amp;Metadata) -&gt; bool {
    true
  }

  fn log(&amp;self, record: &amp;Record) {
    //FIXME: temporary patch to compile
    let message = format!(&quot;{}&quot;, record.args());
    let mut logger = self.logger.lock().unwrap();
    match record.level() {
      Level::Error =&gt; logger.err(message),
      Level::Warn  =&gt; logger.warning(message),
      Level::Info  =&gt; logger.info(message),
      Level::Debug =&gt; logger.debug(message),
      Level::Trace =&gt; logger.debug(message)
    };
  }

  fn flush(&amp;self) {
      let _ = self.logger.lock().unwrap().backend.flush();
  }
}

<span class="boring">}
</span></code></pre></pre>
<p>这样，不管用户使用哪个 log 库，行为是一样的，达到了一致的用户体验。</p>
<p><strong>第二个例子是 mio 库。</strong></p>
<p>mio 库中的 poll 方法，就使用了门面模式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct Poll {
    registry: Registry,
}

/// Registers I/O resources.
pub struct Registry {
    selector: sys::Selector,
}

impl Poll {
    /// Create a separate `Registry` which can be used to register
    /// `event::Source`s.
    pub fn registry(&amp;self) -&gt; &amp;Registry {
        &amp;self.registry
    }

    pub fn poll(&amp;mut self, events: &amp;mut Events, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;()&gt; {
        self.registry.selector.select(events.sys(), timeout)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>mio 是实现了跨平台的非阻塞I/O接口的 Rust 抽象，通过实现 Poll 这样一个门面，屏蔽了底层不同平台的 I/O 系统调用细节，比如 epoll/kqueue/IOCP。</p>
<p><strong>第三个案例是 Cranelift</strong></p>
<p>Cranelift 是一个编译器，目前用于 wasmtime 和 rustc debug 模式下。最近 Cranelift 在重构新的 后端，以支持不同的架构平台：Arm/X86等。</p>
<p>在 Cranelift 内部通过一个 <code>MachBackend</code> trait 来抽象出一个 后台门面，只关心核心逻辑：编译给定的函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Top-level machine backend trait, which wraps all monomorphized code and
/// allows a virtual call from the machine-independent `Function::compile()`.
pub trait MachBackend {
    /// Compile the given function.
    fn compile_function(
        &amp;self,
        func: &amp;Function,
        want_disasm: bool,
    ) -&gt; CodegenResult&lt;MachCompileResult&gt;;

    // ignore others functions
}
<span class="boring">}
</span></code></pre></pre>
<p>然后给不同的平台来实现这个 trait：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl MachBackend for AArch64Backend {
    fn compile_function(
        //...
    ){/* ... */}
}

impl MachBackend for X64Backend {
    fn compile_function(
        //...
    ){/* ... */}
}

impl MachBackend for Arm32Backend {
    fn compile_function(
        //...
    ){/* ... */}
}

<span class="boring">}
</span></code></pre></pre>
<p>然后在上层代码 Context 接口调用 <a href="https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/context.rs#L129">compile_and_emit</a> 方法时，就可以按当前平台信息生成相应指令：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compile_and_emit(/*...*/){

    // ...
    let info = self.compile(isa)?;
    //
}

pub fn compile(&amp;mut self, isa: &amp;dyn TargetIsa) -&gt; CodegenResult&lt;CodeInfo&gt; {
    // ...
    if let Some(backend) = isa.get_mach_backend() {
        let result = backend.compile_function(&amp;self.func, self.want_disasm)?; // 调用 compile_function
        let info = result.code_info();
        self.mach_compile_result = Some(result);
        Ok(info)
    } 
    // ...

}

// cranelift/codegen/src/machinst/adapter.rs 
// 返回 MachBackend 对象
fn get_mach_backend(&amp;self) -&gt; Option&lt;&amp;dyn MachBackend&gt; {
    Some(&amp;*self.backend)
}

<span class="boring">}
</span></code></pre></pre>
<p>所以，整个调用流程是：<code>Context -&gt; compile_and_emit -&gt; compile -&gt; get_mach_backend -&gt; compile_function</code> ，然后到各个架构平台。</p>
<h2><a class="header" href="#结语-1" id="结语-1">结语</a></h2>
<p>综上，门面模式是 Rust 应用最广泛的一个设计模式。感谢阅读，如有错漏，欢迎反馈和补充。</p>
<h1><a class="header" href="#rust-探索系统本原--raii" id="rust-探索系统本原--raii">Rust 探索系统本原 | RAII</a></h1>
<p>作者：陈天 / 后期编辑：张汉东</p>
<blockquote>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/jaKjzc_1rkDe67rfpnFTgg">https://mp.weixin.qq.com/s/jaKjzc_1rkDe67rfpnFTgg</a></p>
</blockquote>
<hr />
<h1><a class="header" href="#透过-rust-探索系统的本原raii" id="透过-rust-探索系统的本原raii">透过 Rust 探索系统的本原：RAII</a></h1>
<p>RAII - Resource Acquisition Is Initialization[1] 是个听起来高深莫测不知所云，但实际理解起来并不困难的概念。我们在理解一个新的解决方案的时候，先深入了解它面临的问题，再看之前的解决方案（prior work），然后再看它是怎么解决同样的问题，最后比较优劣。这大概是做研究的通识，也是我们从本原去真正理解事物的最佳途径。</p>
<p>如果要找计算机历史上最离谱的缩略词，RAII 一定会榜上有名，从嘴里吐出这个词却不做额外解释，除了用于居高临下地吓唬初学者，似乎别无他用。Resource Acquisition Is Initialization，中文翻译为「资源获取即初始化」，无论中英文，都很难让人明白它的真实含义。但这里有个词值得我们警觉：资源。</p>
<p>这里的资源，是指文件，锁，套接字等由操作系统提供给应用程序的，数量有限的东西。虽然内存往往也是操作系统提供的一种资源，但它的处理和上述其它资源还是有许多不同。</p>
<p>在我的上一篇文章《透过 Rust 探索系统的本原：编程语言》里，我提到了 Rust 是如何通过把问题回归到「一个值（value）在上下文中被安全访问的基本规则」，从而解决了内存安全的问题。</p>
<p>虽然很多语言也可以通过其他手段解决内存安全的问题，比如使用 GC 来在运行时对内存的使用做引用计数，如果一个 socket 对象的引用计数为零，GC 会把 socket 对象对应的内存清除，但如果 socket 本身没有被显式 close，这个 socket 资源就会被泄露。很多 Java 工程师会遇到系统运行一段时间便累计了大量 <code>CLOSE_WAIT</code> 的 socket，最终会吃光进程的文件句柄，抛出 too many files 异常的问题[2]。所以，如果你没有在各种可能的路径中妥善地关闭 socket，那么，即便使用一个内存安全的系统，依然有资源泄露的可能。</p>
<p>所以，虽然同为资源，内存和其它操作系统提供的资源，对于程序员来说，其处理方式是非常不同的。你即便不用担心内存资源的释放，但却要妥善地释放锁，关闭 socket，关闭文件等等。</p>
<p>有没有可能让资源的处理方式和内存的处理方式统一起来？这就是 RAII 要解决的问题。统一的方式其实很直观，就是让资源和资源对应的对象的生命周期保持一致，具体来说：</p>
<ul>
<li>对象的初始化会导致资源的初始化</li>
<li>对象的释放会导致资源的释放</li>
</ul>
<p>这里有两重保障：对象创建成功一定意味着资源获取成功；而对象释放成功则资源一定得到释放。所以使用 RAII 的话，我们只需要保证内存安全（没有内存泄漏），就能够保证资源安全（没有资源泄露）。</p>
<p>从这里我们可以看到 RAII 是一个多么奇怪的名字 —— 它字面上只包含了上面的第一层功能（对象的初始化会导致资源的初始化），直接忽略了第二层功能，而被忽略的第二层功能其实是 RAII 真正需要保障的。</p>
<p>RAII 是一种资源释放的思路，这种思路被应用在各种语言之中（尽管具体采用的方法不同），比如：</p>
<ul>
<li>在 Python 中，我们可以使用 <code>with</code> 来确保资源在退出某个 scope 时一定会被释放</li>
<li>在 Golang 中，我们可以使用 <code>defer</code> 让资源获取的代码和资源释放的代码尽可能靠近，这样让程序容易理解。</li>
<li>在 Rust 中，RAII 的思维被深深地嵌入到语言之中：所有权模型保证了当前 scope 所拥有的对象在退出 scope 时必然会被释放，而 <code>Drop</code> trait 保证了释放时，其相关的操作系统资源也得到释放。</li>
</ul>
<p>我们以 Mutex Lock 为例，看看 Non-RAII 代码和 RAII 代码的区别：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bad() {
  m.lock();
  f(protected_data);
  if failed() return;
  m.unlock();
  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码是典型的 Non-RAII 代码（也是很多语言处理资源的通用方式），调用者需要显式地释放锁。然而在整个过程中，可能出现错误，可能抛出异常，所以，释放锁的代码很可能没有执行，导致锁资源泄露。这是很多死锁问题出现的一大原因。</p>
<p>而支持 RAII 的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn good(m: Arc&lt;Mutex&lt;Protected&gt;&gt;) {
  let guard = m.lock();
  f(*guard);
  if failed() return;
  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里例子里，<code>lock()</code> 使用 RAII 实现，在获取这个锁的时候，它初始化了一个 <code>MutexGuard</code> 结构，这个结构里包含了对 <code>Mutex</code> 的引用，在做 <code>DerefMut</code> 时，可以访问到 <code>Mutex</code> 内部数据的可变引用，因而可以对数据进行修改。同时，<code>MutexGuard</code> 实现了 <code>Drop</code> ，里面处理了锁的释放，这样，当前的函数（scope）执行完退出时，锁就自动被释放了。</p>
<h2><a class="header" href="#为什么-raii-没有被普遍实现" id="为什么-raii-没有被普遍实现">为什么 RAII 没有被普遍实现？</a></h2>
<p>通过上文的介绍，我们可以看到 RAII 极大地解放了开发者，使其不必关心资源的释放，所写的代码反而比进行资源释放的代码更加安全可靠。为什么这种实践没有成为一种更加广泛的实践呢？似乎目前只有 C++ 在有限的场合使用，而实现地比较透彻的只有 Rust？</p>
<p>这还是因为 Rust 的所有权模型从本质上规范了一个值可以被安全使用和安全释放的场景，而这种规范对资源来说也是完美契合的。这就好比麦克斯韦把电磁光统一在一个框架之下，Rust 也把内存和其它资源统一成一种行为。</p>
<p>我们还是拿 Java 这种使用 GC 的语言来比较（不好意思 Java 我不是针对你）。如果你在堆上创建了一个文件资源，如果使用 RAII，意味着堆上的文件对象被释放的时候，这个文件资源也该关闭（<code>file.close()</code>），这么做是最安全也是最合理的。然而，因为堆上的对象什么时候被释放是不可知的，就算所有引用都不存在，GC 已经将其 mark 成可回收，回收线程什么时候被调度，依旧是无法保证的，就像薛定谔的猫。所以 Java 建议你资源用完了就要立刻关闭，于是你不得不殚精竭虑地照顾好每一个 try catch，每一次提前返回，以便 <code>finally</code> 你总是可以把资源关闭；你还得小心地处理资源的传递，传来传去，到处引用的资源，何时关闭可不是一件容易说清楚的事情。那么，既然你接受了「资源用完就立即关闭」的设定，你便不能在 <code>finalize</code> 里做关闭文件的事情，因为这将会导致资源的重复释放。这就是为什么 Java 无法做 RAII，或者 Python，golang 这些语言无法做 RAII 的原因。这也是为什么 Pythong 发展出了 <code>with</code>，golang 发展处 <code>defer</code> 来确保同一个 scope 下创建的资源，可以自动（正常）释放。不过，这些都是于小处的补丁，他们并不能完全解决 RAII 要解决的问题。</p>
<p>在 Rust 里，如果你在堆上创建一个文件资源，根据所有权模型，堆上的内存必然会有一个栈上的 owner（所有者），不管这个 owner 是单一 owner（如 Box），还是引用计数的 owner（如 Arc），也不管他们如何移动（move），被各种引用，Rust 只需关心 owner 离开 scope（对于 Arc 来说，最后一个 Arc 的 owner 离开 scope），此时 <code>Drop</code> 会被调用（仿佛此处有只麦克斯韦妖），从而释放堆上的内存和资源，简单直观。而所有这一切的决策，都在编译时完成，运行时只不过是按部就班执行编译出来的代码而已。</p>
<h2><a class="header" href="#贤者时刻-1" id="贤者时刻-1">贤者时刻</a></h2>
<p>和所有权模型一样，RAII 也是一种大道至简的处理问题的思路。相对于「使用完资源后，在所有可能的地方都妥善释放之以避免资源泄露」这种「头疼医头脚疼医脚」的方法，当我们重新考虑资源的生命周期，为其添加约束，限制住资源和对应的内存对象相同的生命期之后，一切变得简单而可控。</p>
<h2><a class="header" href="#参考资料-1" id="参考资料-1">参考资料</a></h2>
<p>[1] RAII: <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a></p>
<p>[2] Socket leak in Java app: <a href="http://www.javamonamour.org/2019/09/sockets-leak-case-study.html">http://www.javamonamour.org/2019/09/sockets-leak-case-study.html</a></p>
<p>[3] Socket leak in golang: <a href="https://www.reddit.com/r/golang/comments/b3adpq/nethttp_transport_leaking_established_connections/">https://www.reddit.com/r/golang/comments/b3adpq/nethttp_transport_leaking_established_connections/</a></p>
<h1><a class="header" href="#透过-rust-探索系统的本原编程语言" id="透过-rust-探索系统的本原编程语言">透过 Rust 探索系统的本原：编程语言</a></h1>
<p>作者：陈天 / 后期编辑：张汉东</p>
<blockquote>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/ZA-_BARVAWe0Q4eM0lYgwg">https://mp.weixin.qq.com/s/ZA-_BARVAWe0Q4eM0lYgwg</a></p>
</blockquote>
<hr />
<p>连续写了好几篇和 Rust 相关的文章，有朋友说：你好像还没有写过一篇比较正式的介绍 Rust 的文章哦。想了想确实如此，我写过不少介绍编程语言的文章，包括：Python，JavaScript，Racket，Clojure，Elixir，甚至我个人不怎么喜欢的 Golang，却没有正儿八经写一篇关于 Rust 特点或者 Rust 世界观的文章。</p>
<p>于是，我开始构思一篇从编程语言设计的角度出发，来探寻 Rust 的独到之处，以及这样的思想可以如何应用在我们的工作当中。正巧，我司（Tubi）内部也渐渐有越来越多的同学对 Rust 感兴趣，想让我做个 BBL 讲讲；我想了想，一个 BBL 似乎很难全面地介绍一门语言，于是构思了九讲，分九周完成；而这其中，第一讲是至关重要的，我需要让一群对 Rust 并不了解的工程师能在 45 分钟内 get 到 Rust 的精髓，这样，后续的讲座才有存在的意义。</p>
<p>结果就诞生了这篇文章，以及与之相关的 slides。</p>
<h2><a class="header" href="#编程语言的世界观" id="编程语言的世界观">编程语言的世界观</a></h2>
<p>一门编程语言的诞生，一定有它想解决的问题。而围绕着这个问题，语言会有自己的一个世界观。比如说我们熟知的 Erlang 的世界观：</p>
<ul>
<li>everything is a process.</li>
<li>process are strongly isolated.</li>
<li>process creation and destruction is a lightweight operation.</li>
<li>message passing is the only way for processes to interact.</li>
<li>processes have unique names.</li>
<li>if you know the name of a process you can send it a message.</li>
<li>processes share no resources.</li>
<li>error handling is non-local.</li>
<li>processes do what they are supposed to do or fail.</li>
</ul>
<p>在这个世界观下，Erlang 使用了 6 个基本函数：<code>spawn</code>，<code>send</code>，<code>receive</code>，<code>register</code>，<code>whereis</code>，<code>self</code>，构建了一个恢弘大气的分布式系统。</p>
<p>再比如 Golang，其基本的处理并发的思想人人熟知：Do not communicate by sharing memory; instead, share memory by communicating。但要想轻松地用几句话概括整个 golang 这门语言的世界观，似乎有些费劲。Rob Pike 介绍过 golang 的最初想法 [2]：</p>
<ul>
<li>a compiled, concurrent, garbage-collected, statically typed language</li>
<li>It must work at scale, for large programs with large numbers of dependencies, with large teams of programmers working on them.</li>
<li>It must be familiar, roughly C-like.</li>
<li>It must be modern.</li>
<li>Composition not inheritance.</li>
<li>No conventional exception facility since exceptions make it too easy to ignore</li>
</ul>
<p>所谓种瓜得瓜种豆得豆，语言诞生初期的世界观，决定了语言之后的走向。很多人抱怨 golang 没有泛型，但泛型恰恰和 C-like 这个思想是冲突的，因而如果要引入泛型， golang 势必需要对其世界观进行妥协，这种妥协带来的代价将会是巨大的（起码会急剧影响 golang 语言的简单性，以及其引以自豪的编译速度）。</p>
<p>对于 Rust 而言，它诞生的初衷是作为一门可以替代 C++ 的系统级语言，满足如下核心价值观[3]：</p>
<ul>
<li>Memory safety</li>
<li>Speed (Zero cost abstraction)</li>
<li>Productivity</li>
</ul>
<p>显然，Memory safety 和 productivity 是 C++ 开发者的痛点。一门新的系统级语言可以在不失其效率的情况下达到内存安全么？C++ 做了很多探索，创造了不少智能指针，把 RAII（Resource Acquisition Is Initialization）引入语言当中，但由于历史的包袱，使得 C++ 只能在现有的体系下修补，无法从根上解决这一问题。Rust 则不然，它站在 C++ 的肩膀上，引入了所有权（ownership）和借用机制来提供内存安全，并创造性地使用了类型安全来辅助并发安全。所有权和借用机制虽然优雅且很容易理解，但它和我们所熟知的编程范式大为不同，让程序员无法随心所欲写出错误的代码，再加上 Rust 有意地在编译时就把这些错误暴露给开发者，使得 Rust 初期的学习曲线变得非常陡峭，对那些学了个一知半解就喜欢上手的开发者来说，尤其陡峭。</p>
<p>也因为 Rust 对自己系统级语言的定位，使得它对性能有一种偏执 —— 语言提供给开发者的抽象需要尽可能达到零成本（Zero-cost abstraction）：任何功能只要你不用，就没有成本；你如果使用，你自己手工优化的代码也不可能比语言为你生成的代码效率更高。因为这种偏执，使得 Rust 即便早期对异步 IO 有 green thread 这样在其他语言看来已经是相当不错的支持，在 Rust 进入 1.0 版本时，这个功能还是被彻底拿掉[3]，因为它会像 golang 一样，即便开发者不使用任何 green thread，其运行时带来的额外开销还在那里。所以 Rust 对异步 IO 的支持，直到 1.0 发布数年后的 Rust 1.39 async/await 正式 stable，才重新完美具备。既然提到了 async/await，容我再多说一句，我认为 Rust 在 async/await 的零成本抽象上带给整个编程语言世界的影响是巨大而长远的，它就像那个打破了「四分钟一英里」魔咒的 Roger Banister，让世界知道：高级的抽象并不必然以牺牲性能或者添加额外的运行时为代价。</p>
<p>Rust 还有一个重要的，被大家低估的世界观：公开透明（explicitness）。使用者可以对他所写的代码做到完全了解和掌控。</p>
<p>很多「高级」编程语言会营造一种易于学习的氛围：你不需要了解一切，不需要熟悉计算机工作原理，不需要掌握操作系统的基本知识，你也可以「高效」编程。这其实是一种假象。如果你做的事情仅仅和 CRUD 相关，那么掌握一些高层次的 API 的确可以很好地完成工作，但当你面临更复杂的系统设计时，当你想成为一名<strong>有追求</strong>的开发者时，你会遭遇瓶颈 —— 你还是得老老实实构建需要的知识体系，可是当初的「轻松」已经成为负担，就像练习钢琴一开始在双手的姿势上走了捷径，随着联系难度的增高，这捷径会反噬你。</p>
<p>而且这种假象还会被人才市场无情戳破。Java 工程师的确不需要了解内存的运作机制也能编程，但面试的时候，GC 的原理，Java memory leak 可能产生的原因，Java VM 是如何工作的这类问题还是屡见不鲜。原因无他，你如果不了解一切，你无法写出高效安全且设计良好的代码。同样是程序员，在并非供不应求的大环境下，用人单位更青睐那些有追求的程序员。</p>
<p>Rust 没有试图遮掩，它将所有你需要了解的细节明确地在编译环节暴露出来，并且把什么可为什么不可为的边界清晰地展现。这的确会给开发者带来学习的负担 —— 如果一个开发者对一门语言的从小工到大牛的掌握过程中所经受的 <strong>全部痛苦</strong> 是 100 分的话，Rust 的公开透明 —— 编译器把丑话说在前面 —— 帮你把 100 分降低为 90 分，然后在头 6 个月让你经受 70 分痛苦，接下来的 5-8 年经受剩下 20 分的痛苦；而其它语言会让你在头一两年只经受 20-30 分的痛苦，哄着你，呵护着你，然后在接下来的 5-8 年让你慢慢经受之后的 70-80 分的痛苦。</p>
<p>此外，很多语言没有明确的边界，有些地方做很多限制，有些地方却什么限制都没有，使得编程本身需要靠开发者额外的自觉或者规范才能保证代码的正确性。比如 Java 在内存分配和回收上设定了边界和限制，但在内存的并发访问上没有设定边界和限制，开发者如果不遵循一定规范，很难做到代码的线程安全。C 语言几乎没有设定任何边界和限制，使得指针的解引用成为开发者的梦魇。而 Rust 对一个值在某个 scope 下的所有可能访问做了严格的限制，并通过编译器将这些规则明确地告诉开发者（我们下文再展开）。</p>
<h2><a class="header" href="#编程语言设计上的取舍" id="编程语言设计上的取舍">编程语言设计上的取舍</a></h2>
<p>不同的编程语言为了解决不同的问题，形成了自己初始的世界观和价值观。而这些世界观和价值观，会严重影响编程语言设计上的取舍。一般而言，一门语言在设计之初，总需要在：性能（performance），安全（safety）和表达力（expressiveness）上做取舍。我画了个图，粗略地概括了不同编程语言在这些方向上的取舍：</p>
<p><img src="chapter_4/image/lang/programming_lang1.jpg" alt="programming_lang1.jpg" /></p>
<p>Assembly/C/C++ 显然是为了效率牺牲（部分）安全性和表达能力。这带来的后果是开发难度太大。</p>
<p>为了达到内存安全，以 Java 为首的很多语言采用了 GC（垃圾回收）。这意味着用其开发出来的系统不得不忍受三大弊病：1) 巨量内存消耗 —— 内存使用可以达到非垃圾回收系统的 1.5-5 倍之多。2) STW（Stop The World），垃圾回收线程工作时会导致其它线程挂起以方便清理内存。Erlang 为解决这个问题，把垃圾回收的粒度缩小到每个 process。3) 开发者并不太在意堆上内存的分配，甚至会无节制地使用堆上的内存。</p>
<p>OjbC 和 Swift 采用了 ARC（自动引用计数）的方式管理内存，编译器会分析每个对象的生命周期，为其插入维护引用计数的代码，当引用计数为 0 时释放对象使用的内存。这种方式相对于 GC，其内存开销和计算开销都大大减小，没有 STW 的问题。但 ARC 无法很好处理循环引用（retain cycle），需要开发者手工处理（使用 weak reference 或者 unowned reference），如果处理不妥则会带来内存泄漏。</p>
<p>尽管 ARC 带来的开销很小，我们要记得，它还是有额外开销的。</p>
<p>大部分编程语言并不提供太多对并发安全的保护。Java 提供了内存安全，但如果你要保证代码的线程安全，需要遵循某些规范，比如：</p>
<ul>
<li>如果可能，使用 thread-local fields，避免在多个线程内共享状态</li>
<li>使用并发安全的数据结构，如 <code>ConcurrentHashMap</code>，atomic classes</li>
<li>如果要在多线程共享状态，那么，保证共享的状态是只读的</li>
<li>如果要在多线程共享可写状态，那么，使用 synchroized method/statement，或者加锁，保证「写」访问是独占的</li>
</ul>
<p>编译器并不强迫你遵循这些规范，所以，一个不理解并发安全的程序员很可能写出编译通过但导致 race condition 的代码。</p>
<p>而小部分保证了并发安全的语言，则在内存安全的前提下，引入了一些特定的规则：</p>
<ul>
<li>Javascript 运行在单线程之下，也就无所谓并发安全。</li>
<li>Erlang/Elixir/Sala(akka) 使用 actor model，开发者通过消息传递做 process 之间的同步，这样避免了共享内存，从而避免了 race condition。代价是额外的堆上的内存分配和拷贝。</li>
<li>Golang 采用了 CSP（Communication Sequential Process），使用 channel 来同步 goroutine，也避免了共享内存。同样的，代价是额外的堆上的内存分配和拷贝。</li>
</ul>
<p>以上无论内存安全还是并发安全的解决方案，都有不菲的代价。这对于把安全和性能作为语言核心要素的 Rust 来说是不可接受的。</p>
<p>所以 Rust 注定要另辟蹊径。这个「蹊径」就是上文提到的所有权和借用规则，其原理非常简单：</p>
<ol>
<li>在一个作用域（scope）内，一个值（value）只能有一个所有者（owner）：
<ol>
<li>当所有者离开作用域时，值被丢弃（Drop）</li>
<li>值可以从一个作用域移动（move）到另一个作用域，但当前所有者立刻失去对值的所有权</li>
</ol>
</li>
<li>值可以被借用（reference），但借用的生存期不能超过所有者的生存期（lifetime）：
<ol>
<li>在一个作用域内，允许有多个不可变借用</li>
<li>或者至多一个可变借用（可变借用是独占的）</li>
</ol>
</li>
</ol>
<p>这个规则非常简单，如果你回顾我们写线程安全代码所遵循的规则，二者非常类似。只不过，Rust 把这些规则变得更明确，并且在编译器里强制执行。如果开发者的代码违反了任何一条规则，代码将无法编译通过。</p>
<p>这成为 Rust 带给开发者极大痛苦的一个根源。和 C/C++/Java 相比，Rust 编译器苛责你不仅要写出语法正确的代码，还必须写出符合内存安全和并发安全的代码，否则，不让你编译通过。因而，你需要非常仔细地考虑你是如何设计你的系统的：数据是否共享，如果共享，它们是如何传递，如何被引用，都被谁引用，生存期有多长等等。</p>
<p>也就是说，Rust 强迫你好好设计你的系统，你的接口，减少写代码的随意性，减少内存访问的随意性，把大部分问题都扼杀在摇篮。这看似不近人情的处理方式，其实极大地帮助我们成为更好的程序员。</p>
<p>当然，Rust 的强迫和其它语言的强迫有本质的不同。为了并发安全，Golang 强迫你使用 channel，Erlang 强迫你接受 actor model，它们都剥夺了你创建线程的权力，即便你很明确你要做的事情是计算密集而非 I/O 密集的任务。在这些体系之下，开发者没有太多的选择。Rust 只是强迫你写「对」的代码，但并不强迫你选用什么样的工具来达到这一路径。同样是并发处理，你可以使用 atomics，可以共享内存（<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>），可以使用异步任务，当然也可以使用 channel（类似 Golang）。你可以使用线程，使用异步任务，甚至混用它们。Rust 不关心你实现的手段，只是强迫你把代码写对。</p>
<p>单单靠上面的所有权和借用规则，还不足以完全保证并发安全，Rust 巧妙地使用了类型系统，来帮助构建一个完整的并发安全体系。在 Rust 里，类型的行为是通过 Trait 来赋予的，几乎所有的数据结构都实现了一个到多个 Trait。其中，有一些特殊的 Trait 来说明类型安全：</p>
<ul>
<li>Send：标记一个类型是否可以安全地在进程间移动（move）所有权</li>
<li>Sync：标记一个类型是否可以安全地在进程间共享</li>
</ul>
<p>比如，<code>Rc&lt;T&gt;</code>（线程内引用计数的类型）被标记为没有实现 <code>Send</code> 或 <code>Sync</code>，因而，要想跨线程使用 <code>Rc&lt;T&gt;</code> ，Rust 编译器会报错，并且告诉你，你在某个上下文中使用了类型不安全的数据（在这里，你只能使用 <code>Arc</code>  - Atomic Reference Counter）。</p>
<p>这是一个非常漂亮地对类型系统的使用，它是如此地简单，优雅，且可扩展，使得编译器的工作只需做好类型安全的检查。</p>
<p>同时，Rust 还有其它一些 Trait，它们跟线程安全没有直接关系，但巧妙地辅助了线程安全：</p>
<ul>
<li>Copy：表明一个值在传递时会复制。所有的基本类型，如 <code>i32</code> ，被实现成 <code>Copy</code>，当你传一个数值到另一个函数或者另一个线程时，它被复制了一份，所以不存在线程安全的问题。</li>
<li>Closure（<code>Fn</code> 和 <code>FnMut</code>）：闭包是一种特殊的类型。默认情况下，闭包中使用的闭包外的值使用了引用，但当这个闭包是在另一个线程运行时，我们需要显式移动所有权，否则，会出现借用的生存期超过所有者的生存期的编译错误。通过这种方式，Rust 杜绝了多线程闭包带来的引用问题。</li>
<li>Deref/DerefMut。对于指针而言，通过解引用可以把指针转化成对应的类型进行操作。对于某些类型，Rust 控制其能否解引用，来控制其可用的范围。比如 <code>Arc</code> 类型不能解引用成为可变类型，如果你要多线程修改共享数据，只能通过 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 类似的结构来完成。</li>
</ul>
<p>上面说的这么多内容，可以用一张图来浓缩：</p>
<p><img src="chapter_4/image/lang/ownership.jpg" alt="ownership.jpg" /></p>
<p>当你对这幅图理解地越深，你会愈发感慨 Rust 设计上的巧妙：从定义一个变量的值如何在不同场景下访问，得出几条简单的规则，再辅以类型安全，不引入任何运行时额外的开销，就保证了内存安全和并发安全。这种回归本源的做法，很像物理学的「第一性原理」：我们拨开表面的纷繁复杂，回归事物的本质，往往能得到最简单，同时也是最精妙的解决方案。所谓「大道至简」，不过如此。</p>
<p><img src="chapter_4/image/lang/Untitled.png" alt="Untitled.png" /></p>
<p>下图的代码，我刻意违背几乎所有的所有权和借用规则，Rust 编译器就像坐在我身旁跟我 peer review 的老司机一样，清晰地告诉我代码中所存在的问题：</p>
<p><img src="chapter_4/image/lang/rust_safety.png" alt="rust_safety.png" /></p>
<p>以及，当我试图像一个 C 程序员那样，写出非并发安全的代码时，Rust 的所有权和借用规则，以及类型系统一起帮助我发现所有的并发安全方面的问题：</p>
<p><img src="chapter_4/image/lang/rust_safety1.png" alt="rust_safety1.png" /></p>
<h2><a class="header" href="#贤者时刻-2" id="贤者时刻-2">贤者时刻</a></h2>
<p>Rust 对我们做系统的启示：首先是把系统的运行规则清晰地定义出来，然后对其做类似从特殊化的定理到一般化的公理那样的推敲和抽象，找到满足系统运行的最小化的核心规则，最后用这些规则来限制系统的行为。</p>
<h2><a class="header" href="#参考资料-2" id="参考资料-2">参考资料</a></h2>
<p>[1] 思考，问题和方法：<a href="https://zhuanlan.zhihu.com/p/38813900">https://zhuanlan.zhihu.com/p/38813900</a></p>
<p>[2] Go at Google: Language Design in the Service of Software Engineering: <a href="https://talks.golang.org/2012/splash.article">https://talks.golang.org/2012/splash.article</a></p>
<p>[3] How rust views tradeoffs: <a href="https://www.infoq.com/presentations/rust-tradeoffs/">https://www.infoq.com/presentations/rust-tradeoffs/</a></p>
<h1><a class="header" href="#透过-rust-探索系统的本原内存管理" id="透过-rust-探索系统的本原内存管理">透过 Rust 探索系统的本原：内存管理</a></h1>
<p>作者：陈天 / 后期编辑：张汉东</p>
<blockquote>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/1juaadR3AqHa8H19sHWHmQ">https://mp.weixin.qq.com/s/1juaadR3AqHa8H19sHWHmQ</a></p>
</blockquote>
<hr />
<p>对于开发者来说，内存无非是两种管理模式：手动管理或者自动管理。C 语言是手动管理内存的大哥大，而 Java 则是自动管理的扛把子。很多人认为 Java 是使用垃圾回收做内存管理的鼻祖，其实不然，lisp 早于 Java 大概二三十年就武装上了简单的 GC。不过公认的高效率的 GC 是 Java 带给我们的。</p>
<p>不管手动管理还是自动管理内存，这个「管理」，我们说的都是堆上的内存。几乎所有的编程语言，一切栈上的内存都是自动管理的，并且在编译时就已经妥善完成了。</p>
<p>那么栈上的内存是怎么管理的呢？下面是一个简单的函数调用的例子：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
static int VALUE = 42;
void world(char *st, int num) {
    printf(&quot;%s(%d)\n&quot;, st, num);
}

void hello(int num) {
    char *st = &quot;hello world&quot;;
    int v = VALUE+num;
    world(st, v);
}

int main() {
    hello(2);
}
</code></pre>
<p>通过上面的代码，我们不难看出整个调用栈的关系：</p>
<p><img src="chapter_4/image/memory/Untitled.png" alt="Untitled.png" /></p>
<p>可以看到，栈上的内存管理简单高效：栈帧（frame pointer）一压，一个新的帧（frame）就开启了它全新的生命周期（lifetime），这生命周期结束后，栈帧一弹，所有在此期间「分配」的内存都得到了「释放」。分配和释放不过是动动指针的问题，一切在编译期就决定好了（这也是为什么栈上的对象一定是大小明确的）。</p>
<p>所以，生命周期不是个新鲜事，所有的自动内存管理，其实就是在管理内存的生命周期。栈上对象的生命周期非常简单，规则就一条：某个帧里「分配」的内存，其生命期不能超过该帧的生命期。</p>
<p>堆内存的管理就复杂很多。堆上的内存分配可以在运行时才决定长度，可以动态增长（分配新内存，拷贝，释放旧内存），也可以在不同的上下文中共享。这种灵活性，让堆上内存的生命周期不那么容易追踪，所以管理起来也颇费精力。</p>
<p>手动管理我们放下不表，我们看看不同的语言如何做堆内存的自动管理。</p>
<p>对于堆上的内存的生命周期的自动管理，Java 采用的是 Tracing GC。</p>
<p><img src="chapter_4/image/memory/tracing_gc.jpg" alt="tracing_gc.jpg" /></p>
<p>（图片来自 Mark-and-sweep [1]）</p>
<p>对于 GC 来说，栈上活跃的变量以及全局变量属于 root set。任何由 root set 直接或者间接引用的堆上的对象，都是还在使用的对象。在 GC 定期做标记（Mark）的时候，会标记到这些对象，那些没被标记到的对象，属于生命周期终止的对象，可以安全地被回收。</p>
<p>Mark 阶段结束后，GC 会做内存的清理（Sweep）。在清理阶段，所有没有被标记的对象会被放入 free list 等待释放，而那些被标记过的对象的标记会被清除，等待下一轮的处理。</p>
<p>Tracing GC 管理生命周期的方式很巧妙，它并不跟踪每个具体的对象，而是通过扫描当前还有哪些对象仍然在使用，找到那些已经不再使用的对象，释放之。这种方式简单直观高效，但非常粗犷，无法确保某个对象一定在生命周期结束后得到释放。它还有一些副作用，比如消耗额外的 CPU 时间，GC 工作时会打断工作线程的执行，以及需要在内存消耗情况和 GC 频次之间找到一个平衡点等等。Tracing GC 下的内存管理就像我们的大学生活：平时各种浪，考前狂突击。</p>
<p>Swift 采用的是另一种策略 —— ARC（Atomic Reference Counting）。它通过编译时根据每个对象的引用情况，插入相应的引用计数代码（进入函数时，retain - 被引用的对象引用计数增加，退出时 release - 被引用的对象引用计数减少），从而精确掌控每个对象的生命周期：</p>
<p><img src="chapter_4/image/memory/arc.png" alt="arc.png" /></p>
<p>（图片来自：Swift: Avoiding Memory Leaks by Examples [2]）</p>
<p>这种方式的虽然规避了 Tracing GC 的很多副作用，但它为了实时追踪对象的引用情况，在运行时也付出了不少代价：retain/release 做了很多事情，并且为了线程安全，修改引用计数需要加锁或者使用 atomics，这比我想象的要吃性能 [3]，并且 ARC 无法处理循环引用 —— 所以需要开发者在适当的地方使用 weak ref 来解除循环引用带来的引用计数问题。</p>
<p>ARC 下的内存管理就像在工厂打工：上班签到，下班打卡，兢兢业业，一丝不苟。</p>
<p>而 Rust，采用了完全不同的方式。对 Rust 而言，像 C/C++ 那样靠开发者手工来追踪对象的生命周期是不靠谱的 —— 人总是会犯错，何况这个世界上合格的程序员非常稀缺；但像 Java/Swift 这样在运行时花费额外代价来追踪生命周期，又和语言本身的目标不符。最终 Rust 沿用和发展了 Cyclone 的生命周期的处理方式。</p>
<p>在我之前的文章《透过 Rust 探索系统的本原：编程语言》中，用一幅图概述了 Rust 的所有权和借用规则：</p>
<p><img src="chapter_4/image/memory/ownership.jpg" alt="ownership.jpg" /></p>
<p>如果对所有权和借用规则不熟悉的读者，可以看我的那篇文章。我们来深入看看，Rust 的所有权和借用规则是如何结合编译期生命周期的推定，来解决堆上内存的生命周期管理的问题的。</p>
<p>我们先用一幅图看 move 是如何处理的：</p>
<p><img src="chapter_4/image/memory/rust_memory.jpg" alt="rust_memory.jpg" /></p>
<p>这段简单的代码里，我们生成了一个 <code>User</code> 对象，然后将其传递给 <code>insert()</code> 函数。在 Rust 里，除非特别声明（使用智能指针），对象（结构）是存储在栈上的。而 Rust 的 <code>String</code> 对象，会在栈上放一个指针，指向堆里的实际字符串数据。由于 Rust 的单一所有权模型，当 <code>user</code> 移动到 <code>insert</code> 函数后，<code>insert</code> 就是其新的 owner，编译器会确保之前的 owner 失去对 <code>user</code> 的访问权：如果继续访问，会得到编译错误。由此，堆上的字符串依旧只有一个 owner（图中红色实线），而旧的 owner 因为被禁止使用，也就间接失去了对堆上数据的引用。当 <code>insert</code> 函数结束时，<code>user</code> 被丢弃（Drop），也即意味着堆上分配的内存被释放（还记得上篇文章讲的 RAII 么）。所以，对于对象的 move，Rust 轻松搞定堆上的数据的生命周期的管理。</p>
<p>那位问了，move 好懂，borrow（或者 reference）怎么破？</p>
<p>我们把上图稍微变一变，让 <code>insert</code> 的参数变成接受一个对 <code>User</code> 的引用（ <code>&amp;User</code> ）：</p>
<p><img src="chapter_4/image/memory/rust_memory_ref.jpg" alt="rust_memory_ref.jpg" /></p>
<p>引用（reference），在 Rust 中，可以看做是受限的，带额外 metadata 的指针 —— 这里<code>&amp;user</code> 指向原有的 <code>user</code> 对象。根据所有权和借用规则 4：引用的生命周期不能超过对象的生命周期。在这个上下文中，显然 <code>user</code> 的生命期更长一些，所以不存在问题。当 <code>insert</code> 结束，借用被丢弃，随后图中整段代码结束，<code>user</code> 也被丢弃，堆上的内存于是也得到了释放。一切是那么地显而易见。</p>
<p>那位又问：你这仅仅是一个借用，如果同一个对象有很多借用呢？</p>
<p>其实我们只要把多个借用分开来看：1) 同一个调用栈上的多个借用 2) 不同调用栈上的多个借用。对于 1)，由于 <code>user</code> 对象是在最外层的栈分配的，其生命周期必然大于内层的调用栈（见本文开篇的那幅图），因而不存在任何问题；对于 2)，我们继续看图说话：</p>
<p><img src="chapter_4/image/memory/borrow_cross_threads.jpg" alt="borrow_cross_threads.jpg" /></p>
<p>这个借用跑去另一个调用栈的唯一机会是 <code>insert</code> 或者其后的函数创建了一个新的线程，并且将这个借用 move（copy 同理）给新的线程。由于两个独立线程的生命周期完全无法比较，所以存在 <code>user</code> 结束生命期被释放，而其另一个线程中的引用还继续存在的情形。</p>
<p>在 C/C++ 里，这样的问题很难规避，需要靠良好的代码规范来杜绝 —— 比如我之前学到的 C 的 best practice 之一就是：尽量避免用指针传递栈上的数据，这样不安全。</p>
<p>但 Rust 巧妙地通过类型推断在编译期就捕获了这样的问题。</p>
<p>怎么个巧妙法？</p>
<p>我们站在编译器的角度想想这个问题：如果我是一个编译器，我该怎么判断这里存在一个编译问题？我有什么信息可以利用？我还需要什么信息？</p>
<p>编译时编译器能够依赖的主要信息来源是类型。对于一个函数调用，其期待的输入（输出）类型，和实际传入（传出）的类型不匹配，那么编译器就可以稳稳地抛出编译错误。</p>
<p>如果我们把变量的生命周期看做类型的一部分，是不是就可以在编译期捕获生命周期的问题？</p>
<p>哈，听起来就像宇宙学中原本无处不在却被忽略的时间被爱因斯坦揉进了广袤无垠的空间，形成了独特的时空观，一下子解决了很多让人费解的问题那样子。在这里，类型是空间，生命周期是时间，两者组合，于是便有了光 —— 一抹如文艺复兴般点亮了内存管理漫长中世纪的亮光。</p>
<p>这抹亮光是 Cyclone 点燃的，后来被 Rust 沿袭，形成燎原之势。</p>
<p>在上图，<code>&amp;user</code> 因为在另一个线程中使用，存在和 <code>user</code> 生命期不匹配的问题，那么，如果我们明确<strong>界定</strong>在创建线程时，允许传递什么生命周期的数据，不就可以把生命期不匹配的问题杜绝了么？</p>
<p>以下是 Rust 里 <code>std::thread::spawn</code> 的函数签名：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到，调用 <code>spawn</code> 传入的闭包函数（<code>FnOnce</code>）需要 <code>Send + 'static</code>，这里的 <code>'static</code> 类型意味着，这个闭包只能携带生命周期是静态（意味着和整个程序同生共死）的引用，比如 bss/data/text 段中的全局数据/代码的引用，或者具有所有权的数据 —— 也就是说不能传一个非静态的引用。这就是 Rust 的解决之道。</p>
<p>如此一来，上图的场景就无法通过编译了。通过把生命周期嵌入类型系统，Rust 很自然地解决了这个问题。</p>
<p>这种解决方法还带来一个非常棒的副作用：由此，你可以放心地引用栈上的数据 —— 只要编译通过，你的代码就没有安全问题。而其它语言，因为无法规避这类问题，只好无一例外地把引用型数据存放在堆上：</p>
<ul>
<li>C/C++：虽然理论上可以引用栈上的数据，但 best practice 不建议你这么做（的确不安全）</li>
<li>Java：对象都存储在堆上，只有基础类型（primitive type）—— 其实就是拷贝类型，才放在栈上</li>
<li>Swift：引用类型存储在堆上，拷贝类型存储在栈上</li>
</ul>
<p>而 Rust，允许你把所有在编译期长度确定的数据放在栈上，并安全引用。相比之下，这能带来很多性能上的提升（大大减少了 heap alloc/dealloc 的开销）。同时，Rust 下，栈的使用更加<strong>有效</strong>，堆的使用更加<strong>纯粹</strong> —— 除非不得已（Rc，Arc 这样的使用场景），我们不再需要依赖堆上的分配来「记录」生命周期。</p>
<p>当然，凡事都有代价。其它语言，生命周期的管理被掩盖在了语言的细节之中，你无需直接跟生命周期打交道。而在 Rust 中，你的数据结构，函数声明，都潜在需要做生命周期的标注，因为它们是类型系统的一部分。虽然 Rust 编译器做了很多工作，使得 80% 常用的场景下，你不需要标注生命周期，编译器会自动推导；但还是有一些场合，你需要手工添加生命周期，告诉编译器你对调用者的期待。在 C 语言里，一个刚入门的工程师可以很轻松地写出 <code>strtok</code>，但对 Rust 工程师来说，掌握生命周期，并在实战中运用，需要一定的时间 —— 同样是 <code>strtok</code>，在 Rust 里搞明白并且写出来并不轻松：</p>
<p><img src="chapter_4/image/memory/strtok.jpg" alt="strtok.jpg" /></p>
<p>对此感兴趣的同学，建议你看看 Jon Gjengset 的 Crust of Rust: lifetime annotation[5]。</p>
<p>本文是我上周三在 Tubi 内部的 Rust BBL 的文字版，需要 slides 的同学可以去我的 github：tyrchen/rust-training 或者点击「阅读原文」自取。</p>
<h2><a class="header" href="#贤者时刻-3" id="贤者时刻-3">贤者时刻</a></h2>
<p>对于软件中的缺陷，不同阶段被发现会导致非常不同的解决时间：</p>
<ol>
<li>不要引入任何缺陷（可惜我们是人，不是神，这不现实）—— 无需解决时间</li>
<li>当敲下代码的那一刻，有缺陷的地方就能够被捕获到（很多语言的 language server 已经在做这样的事情了）—— 秒级</li>
<li>在编译时被捕获到 —— 秒级到分钟级</li>
<li>在 UT 时被捕获到 —— 分钟级</li>
<li>在 CI 时被捕获到 —— 分钟级到小时级</li>
<li>在 code review 时被捕获到 —— 分钟级到天级</li>
<li>在 End-to-End test / QA 时被捕获到 —— 小时级到天级</li>
<li>在部署后被捕获到 —— 若干小时，若干天，甚至若干月之后</li>
<li>部署后被用户捕获到 —— 若干天，若干月，甚至若干年之后（也许永远无法解决 —— 很难复现）</li>
</ol>
<p>所以：早发现，早隔离，早诊断，早治疗 —— 鲁迅诚不我欺也。</p>
<h2><a class="header" href="#参考资料-3" id="参考资料-3">参考资料</a></h2>
<p>[1] Mark-and-sweep: <a href="https://www.linkedin.com/pulse/mark-and-sweep-garbage-collection-algorithm-saral-saxena/">https://www.linkedin.com/pulse/mark-and-sweep-garbage-collection-algorithm-saral-saxena/</a></p>
<p>[2] Swift: Avoiding Memory Leaks by Examples: <a href="https://medium.com/hackernoon/swift-avoiding-memory-leaks-by-examples-f901883d96e5">https://medium.com/hackernoon/swift-avoiding-memory-leaks-by-examples-f901883d96e5</a></p>
<p>[3] How does Object-C runtime do multithreaded reference counting without downgraded performance? <a href="https://stackoverflow.com/questions/13942226/how-does-apples-objective-c-runtime-do-multithreaded-reference-counting-without">https://stackoverflow.com/questions/13942226/how-does-apples-objective-c-runtime-do-multithreaded-reference-counting-without</a></p>
<p>[4] Cyclone: <a href="https://en.wikipedia.org/wiki/Cyclone_(programming_language)">https://en.wikipedia.org/wiki/Cyclone_(programming_language)</a></p>
<p>[5] Crust of Rust: lifetime annotation: <a href="https://www.youtube.com/watch?v=rAl-9HwD858">https://www.youtube.com/watch?v=rAl-9HwD858</a></p>
<h1><a class="header" href="#透过-rust-探索系统的本原网络篇" id="透过-rust-探索系统的本原网络篇">透过 Rust 探索系统的本原：网络篇</a></h1>
<p>作者：陈天 / 后期编辑：张汉东</p>
<blockquote>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/bOxEEK7Hh_tsua8HBahsjg">https://mp.weixin.qq.com/s/bOxEEK7Hh_tsua8HBahsjg</a></p>
</blockquote>
<hr />
<p>如今所有的应用程序几乎都离不开网络。从应用开发的角度，绝大多数应用以及其后端系统都工作在应用层：</p>
<p><img src="chapter_4/image/network/0.png" alt="0" /></p>
<p>一般来说，应用程序的网络层除了发生在客户端和服务器之间，还存在于整个后端。下图是一个典型的应用程序：</p>
<p><img src="chapter_4/image/network/1.png" alt="1" /></p>
<p>客户端和服务端之间的流量会走这些网络协议：</p>
<ol>
<li>API 和 analytics 大多会走 HTTP(S)/1.1 或 HTTP(S)/2，以及在其之上的 websocket。</li>
<li>trace/metrics 走 UDP</li>
</ol>
<p>服务端内部：</p>
<ol>
<li>服务和服务间如果走 gRPC 的话，是 HTTP/2。</li>
<li>服务跟数据库之间走数据库自己的网络协议（一般直接建立在 TLS 之上）。</li>
<li>服务跟第三方的云服务，一般走 HTTPS。</li>
<li>服务器和 Message queue 之间，也许会走 AMQP 协议。</li>
</ol>
<p>大多数时候，这些网络协议都被封装好，或以 SDK 的形式，或以类库的形式供你调用，所以开发者基本不用操心协议的细节是怎么回事。顶多，把 HTTP/1.1 的状态码（200/301/302/304/400/404/429/500），方法（GET/POST/PUT/PATCH/DELETE/HEAD），常见的头字段记一记，知道什么情况下客户端该请求什么方法，返回什么状态码，什么时候数据应该放在头部，什么时候应该放在腰部（body），也就足够应付 80% 的应用场景了。</p>
<p>不过，为了更大的吞吐量，更小的延迟，更好的用户体验，我们还需要掌握更多的细节。本文就谈谈这些内容。</p>
<h2><a class="header" href="#异步处理" id="异步处理">异步处理</a></h2>
<p>提升网络性能的第一大法宝是异步处理。网络跟 I/O 相关，发送和接收数据都存在潜在的阻塞线程的风险，如果不妥善处理，会大大降低系统的吞吐量。传统的处理方式是用 non-blocking I/O，自己处理 <code>EWOULDBLOCK</code> —— 一般来说，去调度其它能执行的任务，避免线程闲置。当然，现代编程语言都有不错的异步支持，相当于帮助开发者完成这种原本需要手工完成的调度。Rust 提供了 <code>Future</code> trait，在语言核心支持了 <code>async</code> 和 <code>await</code>。相信大家对 <code>async</code> 和 <code>await</code> 并不陌生，下图对比了 sync/async File I/O：</p>
<p><img src="chapter_4/image/network/2.png" alt="2" /></p>
<p>（图片来自：Writing an OS in Rust - Async/Await [1]）</p>
<p>在众多不同语言的异步实现中，Rust 的实现是独树一帜的。它的异步库（无论 Tokio/async-std）使用了 Reactor/Executor 模式[2]，一个 <code>Future</code> 只有被主动 poll（await）才会得到执行。这一点和 javascript 有本质的不同 —— 在 js 里，一个 promise 一旦生成，就会放入 event loop 里等待执行。</p>
<p>在 Reactor/Executor 模式里， executor 就是我们常说的调度器（scheduler）。它负责调度可执行的 <code>Future</code> 的执行。每次执行意味着一次 poll，要么 poll 到整个 <code>Future</code> 结束，要么 poll 到 <code>Future</code> 直到  <code>Poll::Pending</code>。当一个 <code>Future</code> 不能做更多事情时（<code>Poll::Pending</code>），executor 不会再管它，直到有人（<code>Waker</code>）通知 executor 这个 <code>Future</code> 又重新 ready 了。这个 <code>Waker</code> 就是我们所说的 reactor。它一般会跟操作系统的 nonblocking I/O（linux 下是 epoll，bsd 下是 kqueue，以及 windows 下是 IOCP）协作，来唤醒 <code>Future</code>。下图概括了 Tokio 下 Reactor/Executor 是如何协作的：</p>
<p><img src="chapter_4/image/network/3.png" alt="3.png" /></p>
<p>（图片来自 Explained: How does async work in Rust? [3]）</p>
<p>如果你做过多核 CPU 下的（非 ASIC）网络设备相关的开发，会发现这个过程似曾相识。我觉得未来 Rust 会在高性能网络设备领域占据一席之地，这得益于其高效强大的易步处理库。</p>
<p>Rust 下主流的异步库有 Tokio 和 async-std。下图做了不错的总结，大家可以就着原文的讨论一起看：</p>
<p><img src="chapter_4/image/network/4.png" alt="4.png" /></p>
<p>（图片来自 reddit 讨论：Diagram of Async Architectures [4]，有些旧，async-std 现在已经基于 smol 了，但整个讨论值得一读）</p>
<p>异步开发的好处是：尽管底层的处理相当复杂，各种实现但对开发者来说，接口非常简单，只需要很少的代价就可以把一个同步的处理变成异步的处理。</p>
<p>但是，我们要小心其中的一些陷阱：</p>
<ul>
<li>锁的使用。如果对 I/O 相关的数据结构的锁，需要使用支持异步的锁。比如你要对 TCP stream 的 writer 加锁（不建议这么做，下文会讲），那么要用异步锁。异步锁和同步锁的区别是，异步锁只是让异步任务状态变为 <code>Poll::Pending</code>，不会锁线程，等锁 ready 后异步任务重新被唤醒；而同步锁会锁线程，导致性能问题甚至死锁。</li>
<li>异步代码和高延时同步代码的混用。如果在两个异步操作之间有高延时同步代码，要么把同步代码放在前面或者后面执行，要么把同步代码异步化（分阶段 poll）。</li>
</ul>
<p>对于后者，我这两天在做一个类似 Phoenix Channel[5] 的 Websocket 应用（以下简称 WS channel）时遇到了这个问题：我的 WebSocket 在 wss 连接时，每个连接要花大概 300-400ms，很奇怪。后来我用 jaeger 追踪了一下 tracing，发现客户端代码在连接时时间都耗在了 <code>new_with_rustls_cert</code> 上，真正花在 TLS handshake 上的时间只有 1.5ms：</p>
<p><img src="chapter_4/image/network/5.png" alt="5.png" /></p>
<p>由于我客户端做的操作是：</p>
<ol>
<li>TCP connect（异步）</li>
<li>准备 TLS connector（这里会做 <code>new_with_rustls_cert</code>），这是同步操作，耗时 ~300ms</li>
<li>TLS connect（异步）</li>
</ol>
<p>这直接导致服务端 <code>tls_accept</code> 每个新建连接的延迟奇高（因为客户端 TCP 连上了迟迟不做 handshake）：</p>
<p><img src="chapter_4/image/network/6.png" alt="6.png" /></p>
<p>解决办法：客户端准备 TLS connector 的步骤提前到第一步。之后，服务器的延迟正常了（~1ms）：</p>
<p><img src="chapter_4/image/network/7.png" alt="7.png" /></p>
<p>这是个有趣的 bug。<code>new_with_rustls_cert</code> 看上去是个人畜无害的纯内存操作，但因为里面有读取操作系统的受信证书的操作，所以延时高一些。其实它应该做成异步操作。</p>
<h2><a class="header" href="#队列" id="队列">队列</a></h2>
<p>在网络开发中，最快能提升性能的工具就是队列。虽然操作系统层面，已经使用了发送队列和接收队列来提升性能，在应用层面，我们最好也构建相应的队列，来让整个服务的处理变得更顺滑，更健壮，更高效。除此之外，队列还能帮助我们解耦，让应用本身的逻辑和 I/O 分离。</p>
<p>我们还是以上文中提到的 WS channel 为例。其产品逻辑是：客户端可以连接 websocket，然后 join/leave 某个 channel，当成功 join 某个 channel 后，客户端可以向 channel 里广播任意消息，其它连接到这个 channel 的客户端可以接收到这条消息。</p>
<p>服务器端需要处理这样的逻辑：</p>
<ul>
<li>收到客户端的 join channel X 的请求后，如果验证通过，就给该客户端发送成功响应，同时给 channel X 的其它客户端发送 presence update 通知。</li>
<li>收到客户端发往 channel Y 的消息后，验证客户端确实在 channel Y 中之后，将这条消息广播给 channel Y 中的其它客户端。</li>
<li>收到客户端的 leave channel Z 的消息后，如果客户端在 channel Z 中，就将客户端移除，并给 channel Y 的其它客户端发送 presence update 通知。</li>
</ul>
<p>很简单，是不是？</p>
<p>然而，如果把所有这些逻辑都塞在 accept socket 后的一个大的 <code>async move { loop {...} }</code> 里，代码晦涩难懂，到处耦合，不好单元测试；如果分成一个个子函数，又需要对 websocket 的 reader/writer 套上 <code>Arc&lt;RwLock&lt;...&gt;&gt;</code> 传递，啰嗦且性能不好，每个子函数还是不好单元测试（websocket reader/writer  不好构造）。</p>
<p>最好的方式是用队列将逻辑和 I/O 分离开：event loop 只负责从 websocket 中接收数据，将其发送到接收队列中，供后续的逻辑处理；以及从发送队列中 poll 出数据，写入 websocket。整体的示意图如下：</p>
<p><img src="chapter_4/image/network/8.png" alt="8.png" /></p>
<p>我们换个视角，只看一个 client，大概是这个样子： </p>
<p><img src="chapter_4/image/network/9.png" alt="9.png" /></p>
<p>服务器：</p>
<ol>
<li>accept socket，为 ws socket 创建一个本地 own 的 peer 结构和一个不在本地 own 的 client 结构。peer own socket 的 writer/reader，peer 和 client 之间建立一个双向队列。然后 spawn tokio task，处理该 peer。</li>
<li>peer 的 event loop 很简单，只处理 socket 的收发 —— 收到的消息放入 recv 队列；从 send 队列拿到要发的消息，写入 socket</li>
<li>client 在创建后会启动一个 tokio task，运行自己的 event loop：从 recv 队列收消息，根据消息类型进行相应处理（比如说 join 会和 channel 间建立队列）。如果消息需要 broadcast，将其放入 broadcast 的发送队列，由 channel 结构处理。</li>
<li>channel 从 broadcast 接收队列里收到消息后，遍历自己的所有 subscribers（排除发送者），然后将消息发送到他们的 broadcast 发送队列。</li>
</ol>
<p>这是理论上最佳的运作方式。实操的时候，为了节省内存，channel 可以不和 client 建立队列，直接获取 client send 队列的 rx 的浅拷贝，直接发送，省去了一层传递。</p>
<p>使用队列之后，我们可以很方便地测试 client / channel 处理的逻辑，而无需关心 I/O 部分（I/O 的构造是 unit test 中最困难的部分）。同时，整个结构的逻辑也更清晰，效率更高（使用队列缓存减少了等待），且更平滑（队列有效地缓解了 burst 请求）。</p>
<p>此外，我们还可以在 websocket 发送端，对 send 队列的 rx 做批处理，就像 ReactiveX 里的 Window 操作那样，让发送端在一段时间内等够一些数据再统一发送（比如：period=200ms / count=16 messages）：</p>
<p><img src="chapter_4/image/network/10.png" alt="10.png" /></p>
<h2><a class="header" href="#减少内存分配和拷贝" id="减少内存分配和拷贝">减少内存分配和拷贝</a></h2>
<p>网络应用中，数据从内核态到用户态，在用户态的多个线程之间，以及最后经过内核态把新的数据发送出去，里面免不了有很多内存的分配和拷贝。还是上面 WS Channel 的例子，我大概统计了一下在 channel  中广播一条用 protobuf 序列化的消息，应用程序自己所需要的内存分配和内存拷贝：</p>
<ol>
<li>首先 WebSocket 服务器收到消息后，需要把二进制的 protobuf 转化成 struct 进行一些处理。如果 protobuf 消息中含有 <code>repeated</code> （在 Rust 里对应的是 <code>Vec</code>）或者 <code>map</code> （在 Rust 里对应 <code>HashMap</code>）或者 <code>string</code> （在 Rust 里对应的是 <code>String</code>），那么都涉及到堆上的内存分配。堆上的内存的分配代价很大，切记。</li>
<li>假设 channel 里有 100 个用户，那么要做 broadcast 的话，这个 struct 需要被拷贝 100 次。</li>
<li>当要发送消息时，需要把 struct 再序列化成二进制，封装成 Websocket 消息，发送。这里面，序列化的过程涉及到承载二进制内容的 buf 的分配，如果不优化，也是在堆上进行。</li>
</ol>
<p>这里最多的内存分配和复制在 2。为了优化这里的拷贝，我们可以用 <code>Arc</code> 来做引用计数，避免拷贝数据本身。</p>
<p>对于 3，我们可以使用一个全局的可增长的 ring buffer，每次需要 buf 时，从 ring buffer 里取；也可以用 slab，预先分配好相同大小的内存，然后使用之。</p>
<p>此外，还可以使用一些零拷贝的序列化/反序列化工具，如 rkyv[8]。</p>
<p>我在开始写 Rust 项目时往往在做应用的时候过多使用拷贝，导致辛辛苦苦编译通过的代码效率低下，有时候做同样一件事，Rust 代码的性能还不如 go 和 java。所以说，合理使用引用，避免代码中不必要的拷贝，是撰写高性能应用的必经之路。</p>
<h2><a class="header" href="#降低延时" id="降低延时">降低延时</a></h2>
<p>在服务器和客户端的交互中，往往数据传输本身占据总延迟的大头。一种降低延时的方式是将数据甚至数据和计算本身都挪到网络的边缘处理，这样因为尽可能贴近用户，传输的距离大大减小，延迟就大为改观。目前很多 CDN 都支持了边缘计算（如 aws for edge）</p>
<p>另外一种降低总延时的方式是压缩。如果原本传输完成 1MB 的数据需要 1s，压缩后只剩下 400k，那么传输完成所需要的时间也相应降低到 400ms。一般 http 服务器和客户端都支持的压缩算法有：gzip，deflate，compress 等。随着时间的推移，类似 zstd[9] 这样高性能且高压缩比的算法也会得到越来越多的使用。如果你的应用是自己的客户端（不是浏览器）和服务器交互，那么可以考虑使用 zstd —— 它有媲美 gzip 的性能，以及比 gzip 好不少的压缩比。</p>
<h2><a class="header" href="#流式处理-streaming" id="流式处理-streaming">流式处理 （streaming）</a></h2>
<p>降低延时的另一个手段是流式处理：发送端不需准备好所有数据才发送，而接收端也无需接收到所有数据才处理。gRPC 是应用的最为广泛的支持流式处理的工具。在 Rust 里，有 tonic [10] 这个库支持高性能 gRPC 服务。</p>
<p>流式处理虽然能大大降低延时，并让数据在系统中流动得更加自然（我们的时间是一个流式运转的世界，但大部分系统在处理起数据来，只能做批处理），但它最大的问题是使用起来不想批处理那么显而易见，更要命的是，测试起来很多时候无从下手。</p>
<p>在 Rust 下，我们可以将 channel 和 tonic 的流式接口绑起来，使用起来比较方便。至于测试，我制作了一个 tonic-mock[11]，可以很方便地通过 prost 生成的 struct 从一个数组生成流式接口供测试使用。</p>
<p>如果你想在 TCP 之上构建流式处理，又希望能够避免应用层上的 head-of-line blocking[12]，可以使用 yamux [13]，它是 Hashicorp 提出的一种类似 HTTP/2 的流管理的 multiplexing spec。Rust 下的实现 有 Parity 的 yamux [14]。当然，HTTP/2 或者 yamux 只能解决应用层的 head-of-line blocking，无法解决 TCP 层的问题，如果对你而言，TCP 层是瓶颈所在，那么，可以试试 HTTP/3 或者在 QUIC（目前在 draft 34）[15] 上构建你自己的应用层。Rust 下对 HTTP/3 和 QUIC 的支持有 quinn（支持到 draft 32）[16] 和 cloudflare 出品的 quiche[17]。</p>
<h2><a class="header" href="#日志追踪loggingtracing" id="日志追踪loggingtracing">日志/追踪（logging/tracing）</a></h2>
<p>复杂的网络应用，在追踪问题的时候，合理的 logging/tracing 能帮助我们快速定位问题。在我用过的诸多语言的各种各样的库中，Rust 里的 tracing [18] 库是体验最佳的工具。它可以记录日志，生成 flamegraph，把数据以 opentelemetry[19] 的形式发送给第三方（比如 jaeger）。比如：</p>
<p><img src="chapter_4/image/network/11.png" alt="11.png" /></p>
<p>上文提到，通过使用它，我解决了一个非常令人困扰的 TLS 新建连接的延迟问题。</p>
<p>当我们构建应用的时候，最好从一开始就设计好你的 tracing infrastructure：</p>
<ul>
<li>日志：什么时候添置什么 level 的日志？日志要包含什么样的 metadata？</li>
<li>追踪：什么时候添置什么 level 的 span？span 要包含什么 metadata？</li>
<li>metrics：系统需要收集什么样的 metrics，它们可以被用作什么样的分析？比如：我想知道 WS channel 广播一条消息的 p99，需要如何收集这个 metrics。</li>
</ul>
<h2><a class="header" href="#贤者时刻-4" id="贤者时刻-4">贤者时刻</a></h2>
<p>下图囊括了 Rust 下面主流的和网络应用相关的库，希望能够帮助大家在合适的场合使用合适的协议和工具：</p>
<p><img src="chapter_4/image/network/12.png" alt="12.png" /></p>
<h2><a class="header" href="#参考资料-4" id="参考资料-4">参考资料</a></h2>
<p>[1] Writing an OS in Rust: <a href="https://os.phil-opp.com/async-await/">https://os.phil-opp.com/async-await/</a></p>
<p>[2] The Reactor-Executor Pattern: <a href="https://cfsamsonbooks.gitbook.io/epoll-kqueue-iocp-explained/appendix-1/reactor-executor-pattern">https://cfsamsonbooks.gitbook.io/epoll-kqueue-iocp-explained/appendix-1/reactor-executor-pattern</a></p>
<p>[3] Explained: How does async work in Rust: <a href="https://dev.to/gruberb/explained-how-does-async-work-in-rust-46f8">https://dev.to/gruberb/explained-how-does-async-work-in-rust-46f8</a></p>
<p>[4] Diagram of Async Architectures: <a href="https://www.reddit.com/r/rust/comments/jpcv2s/diagram_of_async_architectures/">https://www.reddit.com/r/rust/comments/jpcv2s/diagram_of_async_architectures/</a></p>
<p>[5] Phoenix channel: <a href="https://hexdocs.pm/phoenix/channels.html">https://hexdocs.pm/phoenix/channels.html</a></p>
<p>[6] Futures batch: <a href="https://github.com/mre/futures-batch">https://github.com/mre/futures-batch</a></p>
<p>[7] ReactiveX window operation: <a href="http://reactivex.io/documentation/operators/window.html">http://reactivex.io/documentation/operators/window.html</a></p>
<p>[8] rkyv: <a href="https://github.com/djkoloski/rkyv">https://github.com/djkoloski/rkyv</a></p>
<p>[9] zstd: <a href="https://facebook.github.io/zstd/">https://facebook.github.io/zstd/</a></p>
<p>[10] tonic: <a href="https://github.com/hyperium/tonic">https://github.com/hyperium/tonic</a></p>
<p>[11] tonic-mock: <a href="https://github.com/tyrchen/tonic-mock">https://github.com/tyrchen/tonic-mock</a></p>
<p>[12] Head-of-line blocking: <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">https://en.wikipedia.org/wiki/Head-of-line_blocking</a></p>
<p>[13] Yamux spec: <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">https://github.com/hashicorp/yamux/blob/master/spec.md</a></p>
<p>[14] Yamux rust: <a href="https://github.com/paritytech/yamux">https://github.com/paritytech/yamux</a></p>
<p>[15] QUIC: <a href="https://tools.ietf.org/html/draft-ietf-quic-transport-34">https://tools.ietf.org/html/draft-ietf-quic-transport-34</a></p>
<p>[16] Quinn: <a href="https://github.com/quinn-rs/quinn">https://github.com/quinn-rs/quinn</a></p>
<p>[17] Quiche: <a href="https://github.com/cloudflare/quiche">https://github.com/cloudflare/quiche</a></p>
<p>[18] tracing: <a href="https://github.com/tokio-rs/tracing">https://github.com/tokio-rs/tracing</a></p>
<p>[19] Opentelemetry: <a href="https://opentelemetry.io/">https://opentelemetry.io/</a></p>
<h1><a class="header" href="#如何为-rust-语言做贡献-part-3--年轻人的第一个代码质量检测lint" id="如何为-rust-语言做贡献-part-3--年轻人的第一个代码质量检测lint">如何为 Rust 语言做贡献 Part 3 | 年轻人的第一个代码质量检测(Lint)</a></h1>
<p>作者：CrLF0710（野喵）/ 后期编辑：张汉东</p>
<hr />
<p>大家好，这次以为 rustc 增加一个代码质量检测为例，介绍一下编译器的一些内部细节。</p>
<p>先来看下本次要讲的内容的主角。这个代码检测检测是 **Rust RFC《允许使用非ASCII标识符》**中的一个小的功能点，名叫 uncommon_codepoints 。这次要检查的内容是代码中的标识符中是否含有非常规的Unicode代码点，如果有，默认给用户报一个编译警告。如果大家想在Github上阅读原PR的代码的话，<a href="https://github.com/rust-lang/rust/pull/67810">链接在这里</a>。</p>
<h1><a class="header" href="#理解-rustc-总体过程" id="理解-rustc-总体过程">理解 Rustc 总体过程</a></h1>
<p>大家都知道，当前 rustc 的编译过程主要分成四个大的阶段：解析(parsing)，展开(expansion), 分析(analysis), 代码生成(codegen)。</p>
<ul>
<li>
<p>第一步的解析是读取你提供的源码的过程，把它变成编译器的内部数据结构。</p>
</li>
<li>
<p>第二步的展开是对内部结构进行一些初步的变换，去除各种语法糖，同时处理掉各种路径解析之类的工作，使其统一化。</p>
</li>
<li>
<p>第三步的分析是对内部结构描述的程序进行进一步的变换，在这个阶段里也会完成各种类型检查、借用检查等等工作，确保你的代码是符合Rust规格的。</p>
</li>
<li>
<p>第四部的代码生成则是将内部结构描述的程序单态化，然后送给后端（现在有两个官方支持的后端：LLVM和Cranelift）让它们生成优化过的目标指令，最后归档或链接。</p>
</li>
</ul>
<p>听起来有点繁琐对不对，但是实际上大多数部分都只是代码数量比较大，做的工作并不复杂。毕竟编译器只是一个数据变换程序，从你提供给它的文本输入数据变换成一些目标指令塞进某种作为容器的文件格式里而已。</p>
<h1><a class="header" href="#代码质量检测模块-rustc_lint" id="代码质量检测模块-rustc_lint">代码质量检测模块 (rustc_lint)</a></h1>
<p>在 rust 代码仓库 <code>compiler/rustc_lint</code>目录下是一个专门用来实现各种代码质量检测分析过程(Lint pass)的模块。Lint 有好几个时机执行，从而分成了若干种类，在这里我们这词要写的这个lint是要对编译器实际处理的字面代码进行检查，也不涉及到各种类型信息相关的分析，所以我们可以选择一个比较靠前的执行时机。</p>
<p>按照rustc_lint规定的分类，我们可以把它作为是early分类下的实现。</p>
<p>在 <code>src/librustc_lint/non_ascii_idents.rs</code>文件里，已经有一个关于非ASCII标识符的代码质量分析过程了，它现在含有一项lint，我们在里面加一项，代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_lint! {
    pub UNCOMMON_CODEPOINTS,
    Warn,
    &quot;detects uncommon Unicode codepoints in identifiers&quot;
}
<span class="boring">}
</span></code></pre></pre>
<p>这个宏是 rustc_lint 这个模块定义的，第一项是lint的名称的全大写形式<code>(UNCOMMON_CODEPOINTS)</code>；第二项是默认等级，我们在这里默认是报警告，所以是Warn；第三项是这个Lint的文本说明，这个说明是会显示在<code>rustc -W help</code>命令的输出中的。</p>
<p>以上就是这个lint本身的声明了，然后我们修改这个lint pass的声明，将</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_lint_pass!(NonAsciiIdents =&gt; [NON_ASCII_IDENTS]);
<span class="boring">}
</span></code></pre></pre>
<p>改成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_lint_pass!(NonAsciiIdents =&gt; [NON_ASCII_IDENTS, UNCOMMON_CODEPOINTS]);
<span class="boring">}
</span></code></pre></pre>
<p>这样编译器的代码就知道这个分析过程会负责这两项Lint的分析。</p>
<h1><a class="header" href="#实现代码质量检测逻辑" id="实现代码质量检测逻辑">实现代码质量检测逻辑</a></h1>
<p>接着我们开始真正实现必要的逻辑。修改下面的实际lint pass的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for NonAsciiIdents {
    fn check_ident(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, ident: ast::Ident) {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里我们要对<code>ident</code>的文本内容做个检查。我们调用<code>ident.name.as_str()</code>获取字符串，然后调用我们事先实现的包<code>unicode-security</code>中的检查方法，
就可以知道这个标识符里有没有非常规Unicode代码点了。</p>
<p>当我们发现了的确有这样的代码点存在，我们就调用cx上面的lint方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.struct_span_lint(
    UNCOMMON_CODEPOINTS,
    ident.span,
    &quot;identifier contains uncommon Unicode codepoints&quot;,
)
.emit();
<span class="boring">}
</span></code></pre></pre>
<p>这个函数会根据你第一个参数指定的lint，去检查lint机制本身的当前提示级别<code>(allow, warn, deny, forbid)</code>，有可能产生一个警告或报错。</p>
<p>第二个参数<code>span</code>在编译器里用来标识一段原始代码。编译器警告错误提示在有<code>span</code>的情况下会“引述”你的源代码，展示给用户说是这里产生了警告或错误。</p>
<p>第三个参数则是给用户展示的提示文字，告诉用户这里产生警告或错误的原因。</p>
<p>我们没有其他需要给用户显示的提示啦，所以这里最后调用<code>emit()</code>方法，就完成了。</p>
<h1><a class="header" href="#准备单元测试用例" id="准备单元测试用例">准备单元测试用例</a></h1>
<p>Rust 要求每个面向用户的功能都有测试用例。在这里我们新加了一个Lint，所以也需要写一个。
于是我在<code>src/test/ui/lint/rfc-2457-non-ascii-idents/</code>这个目录下增加一个<code>lint-uncommon-codepoints.rs</code>文件，
里面首先用<code>#![deny(uncommon_codepoints)]</code>来将警告变成了错误（这样方便写测试用例），然后试着写了几个具有不推荐使用的Unicode代码点的标识符。
其中一行是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const µ: f64 = 0.000001; //~ ERROR identifier contains uncommon Unicode codepoints
<span class="boring">}
</span></code></pre></pre>
<p>注意右边的注释，<code>//~ ERROR</code> 表示期望这一行产生一个编译错误，错误提示以右边的文本开头。我们编译并跑一下这个测试用例(<code>x.py test src/test/ui/ --bless</code>)，
还会记录一个参照用的错误提示文件<code>lint-uncommon-codepoints.stderr</code>。</p>
<h1><a class="header" href="#一点额外的收尾工作--上传提交" id="一点额外的收尾工作--上传提交">一点额外的收尾工作 &amp; 上传提交</a></h1>
<p>我们这次修改有一点额外的收尾工作，因为引入了<code>unicode-security</code>这个新的包和它的依赖项<code>unicode-script</code>，因此我们更新了<code>Cargo.toml</code>, <code>Cargo.lock</code> 还有
<code>src/tools/tidy/src/deps.rs</code>这些文件，新增了新的依赖项相关的信息。</p>
<p>都准备好之后，我们就提交PR，并且喊上官方的大佬来review 啦。在处理了官方大佬的几个review意见后，我们的代码就通过了review，并且合并进了仓库。</p>
<p>怎么样，是不是很容易呢？欢迎大家也来多多参与，做出自己的贡献。</p>
<h1><a class="header" href="#优化-rust-标准库的-binary_search" id="优化-rust-标准库的-binary_search">优化 Rust 标准库的 binary_search</a></h1>
<p>2021 年 5 月 6 号发布的 Rust 1.52 版将会包含我的一个 PR，将标准库 <code>slice::binary_search_by()</code> 的最好时间复杂度优化到 <strong>O(1)</strong>。PR 编号 <a href="https://github.com/rust-lang/rust/pull/74024">#74024</a>，从 2020 年 7 月初提交的 PR，到 2021 年 3 月 6 号才正式合并，其中包含 70 多条评论，前后历时大半年。这个 PR 虽然改动不算很大，但是笔者在其中也学到了不少知识点，所以特意写一篇文章总结一下，希望能帮助到大家。</p>
<p>首先看一下 <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search_by"><code>slice::binary_search_by()</code></a> 这个方法的示例来了解一下它的用途。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

let seek = 13;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Ok(9));
let seek = 4;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Err(7));
let seek = 100;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Err(13));
let seek = 1;
let r = s.binary_search_by(|probe| probe.cmp(&amp;seek));
assert!(match r { Ok(1..=4) =&gt; true, _ =&gt; false, });
<span class="boring">}
</span></code></pre></pre>
<p>这个函数的作用就是在给定的有序 slice 中二分查找目标值 <code>seek</code>。如果找到了返回 <code>Ok(pos)</code>，<code>pos</code> 即目标值所在的位置；没找到则返回 <code>Err(pos)</code>, 这里的 <code>pos</code> 的位置可以用来将 <code>seek</code> 插入 slice 后依然保持有序。其他的 <code>slice::binary_search()</code>，<code>slice::binary_search_by_key()</code> 系列方法都是调用这个 <code>slice::binary_search_by()</code>，这里不再赘叙。</p>
<p>但是，1.52 之前的实现有一个小问题，如果 slice 中存在多个连续的目标值，则它会一直找到最后一个才返回，所以最好时间复杂度也是 <code>O(log n)</code>，而不是 <code>O(1)</code>，也就是找到了就马上返回。这是 1.52 之前的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
#[inline]
pub fn binary_search_by&lt;'a, F&gt;(&amp;'a self, mut f: F) -&gt; Result&lt;usize, usize&gt;
where
    F: FnMut(&amp;'a T) -&gt; Ordering,
{
    let s = self;
    let mut size = s.len();
    if size == 0 {
        return Err(0);
    }
    let mut base = 0usize;
    while size &gt; 1 {
        let half = size / 2;
        let mid = base + half;
        // SAFETY: the call is made safe by the following inconstants:
        // - `mid &gt;= 0`: by definition
        // - `mid &lt; size`: `mid = size / 2 + size / 4 + size / 8 ...`
        let cmp = f(unsafe { s.get_unchecked(mid) });
        base = if cmp == Greater { base } else { mid };
        size -= half;
    }
    // SAFETY: base is always in [0, size) because base &lt;= mid.
    let cmp = f(unsafe { s.get_unchecked(base) });
    if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }
}
<span class="boring">}
</span></code></pre></pre>
<p>既然我们发现这个问题了，很简单，我们在 <code>while</code> 循环中判断 <code>cmp == Equal</code> 不就行了？如果相等就直接返回 <code>Ok</code>，否则继续二分去查找。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while size &gt; 1 {
    let half = size / 2;
    let mid = base + half;
    // SAFETY:
    // mid is always in [0, size), that means mid is &gt;= 0 and &lt; size.
    // mid &gt;= 0: by definition
    // mid &lt; size: mid = size / 2 + size / 4 + size / 8 ...
    let cmp = f(unsafe { s.get_unchecked(mid) });
    if cmp == Equal {
        return Ok(base);
    } else if cmp == Less {
        base = mid
    };
    size -= half;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>为了简洁性，这里（包括后面）都会适当省略重复代码。</p>
</blockquote>
<p>嗯，看起来逻辑上没问题，单测也跑通过了，提交一个 PR，我们暂且叫它<strong>优化(1)</strong>。没过几天 <a href="https://github.com/dtolnay">dtolnay</a> review 了我的 PR 并回复了：<code>Would you be able to put together a benchmark assessing the worst case impact? The new implementation does potentially 50% more conditional branches in the hot loop.</code></p>
<p>确实，Rust 标准库对性能要求非常高，我们必须要有足够多 case 对新旧版本做 benchmark 对比，尽可能避免新的版本导致性能上的 regression。这是当时我做的 benchmark 数据：</p>
<pre><code>// 标准库的实现
test slice::binary_search_l1           ... bench:          59 ns/iter (+/- 4)
test slice::binary_search_l1_with_dups ... bench:          59 ns/iter (+/- 3)
test slice::binary_search_l2           ... bench:          76 ns/iter (+/- 5)
test slice::binary_search_l2_with_dups ... bench:          77 ns/iter (+/- 17)
test slice::binary_search_l3           ... bench:         183 ns/iter (+/- 23)
test slice::binary_search_l3_with_dups ... bench:         185 ns/iter (+/- 19)
</code></pre>
<pre><code>// 新版实现
test slice::binary_search_l1           ... bench:          58 ns/iter (+/- 2)
test slice::binary_search_l1_with_dups ... bench:          37 ns/iter (+/- 4)
test slice::binary_search_l2           ... bench:          76 ns/iter (+/- 3)
test slice::binary_search_l2_with_dups ... bench:          57 ns/iter (+/- 6)
test slice::binary_search_l3           ... bench:         200 ns/iter (+/- 30)
test slice::binary_search_l3_with_dups ... bench:         157 ns/iter (+/- 6)
</code></pre>
<p>可以看出来在 with_dups 模式（即重复元素较多）下，新的实现有很明显的提升，但是 l3 级别的普通模式性能反而要差很多。可能的原因正如 <strong>dtolnay</strong> 所说的 <code>The new implementation does potentially 50% more conditional branches in the hot loop</code>。那 <code>conditional branches</code> 具体是什么？为什么它在热循环中如此关键？这里引入这篇文章的第一个知识点：<strong>分支预测</strong>。</p>
<h2><a class="header" href="#分支预测branch-prediction" id="分支预测branch-prediction">分支预测(Branch prediction)</a></h2>
<p><strong>分支预测</strong> (<code>branch prediction</code>) 是现代 CPU 为了加快指令并行化速度在碰到分支时提前预测下一个可能执行的分支的一种技术。 CPU 中一般都内置专门的分支预测器 (Branch predictor)。强烈推荐先阅读 Stackoverflow 这个高赞回答 <a href="https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array">Why is processing a sorted array faster than processing an unsorted array?</a>，里面比较清晰易懂的解释了分支预测是什么以及对性能带来的影响。关于<strong>分支预测</strong>完全可以写一篇专门的文章介绍了，我这里只把我学到的知识总结一下。</p>
<h3><a class="header" href="#分支" id="分支">分支</a></h3>
<p>首先我们要了解一下<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)"><strong>分支</strong></a>到底是指什么？在高级语言层面，很显然分支就是 <code>if/else/else if</code>，<code>goto</code> 或者 <code>switch/match</code> 这种语句。他们会转换成汇编代码中的 <code>jump</code> 指令。比如 x86 汇编的各种 <code>j</code> 开头的 <code>jump</code> 指令：</p>
<table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody>
<tr><td>jmp</td><td>Always jump</td></tr>
<tr><td>je</td><td>Jump if cmp is equal</td></tr>
<tr><td>jne</td><td>Jump if cmp is not equal</td></tr>
<tr><td>jg</td><td>Signed &gt; (greater)</td></tr>
<tr><td>jge</td><td>Signed &gt;=</td></tr>
<tr><td>jl</td><td>Signed &lt; (less than)</td></tr>
<tr><td>jle</td><td>Signed &lt;=</td></tr>
<tr><td>ja</td><td>Unsigned &gt; (above)</td></tr>
<tr><td>jae</td><td>Unsigned &gt;=</td></tr>
<tr><td>jb</td><td>Unsigned &lt; (below)</td></tr>
<tr><td>jbe</td><td>Unsigned &lt;=</td></tr>
<tr><td>jecxz</td><td>Jump if ecx is 0</td></tr>
<tr><td>jc</td><td>Jump if carry: used for unsigned overflow, or multiprecision add</td></tr>
<tr><td>jo</td><td>Jump if there was signed overflow</td></tr>
</tbody></table>
<p>比如我们随便写一段包含 <code>if/else</code> 逻辑的代码，编译之后的汇编代码中就会包含类似的 <code>jump</code> 指令：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused_assignments)]
pub fn main() {
  // 接收用户从命令行中输入的参数
  let mut a: usize = std::env::args().nth(1).unwrap().parse().unwrap_or_defaul();
  if a &gt; 42 { 
    a = 1;
  } else {
    a = 0;
  }
}
</code></pre></pre>
<p>这段代码逻辑这么写主要是为了保持汇编指令的尽量简单。这里是对应的汇编代码，只保留了跟 <code>if/else</code> 有关的部分，完整的代码链接在这里：<a href="https://rust.godbolt.org/z/ahcKcK1Er">https://rust.godbolt.org/z/ahcKcK1Er</a>。</p>
<pre><code class="language-assembly">.LBB99_7:
        cmp     qword ptr [rsp + 56], 42 ; if a &gt; 42
        jbe     .LBB99_10
        mov     qword ptr [rsp + 56], 1  ; a = 1
        jmp     .LBB99_11
.LBB99_10:
        mov     qword ptr [rsp + 56], 0  ; a = 0
.LBB99_11:
        add     rsp, 200
        ret
</code></pre>
<p>我在代码里面加了几条注释（汇编里面用分号注释）表明了该条指令对应的 Rust 代码，可以看出来 <code>jbe</code> 指令会判断是否跳转到 <code>.LBB99_10</code> 还是不跳转继续执行下面的 <code>mov</code>。</p>
<p>了解了分支是什么之后还不够，我们依然不知道具体是为啥 CPU 需要做分支预测。接下来我们需要了解一下另外一个概念：<strong>指令流水线</strong>。</p>
<h3><a class="header" href="#指令流水线instruction-pipelining" id="指令流水线instruction-pipelining">指令流水线(instruction pipelining)</a></h3>
<p><strong>指令流水线</strong>是从 <strong>instruction pipelining</strong> 翻译过来的一个名词，主要是指为了提高单个处理器指令处理效率的一种技术，早在上个世纪 70 年代的芯片就有这种技术了。</p>
<p>CPU 处理一条指令一般要分为几个步骤：</p>
<ul>
<li>取指令(Instruction Fetch)</li>
<li>解指令(Instruction Decode)</li>
<li>执行指令 (Execute)</li>
<li>回写结果到寄存器 (Register write back)</li>
</ul>
<p>这非常类似工厂生产某件需要多道工序的商品一样。想象一下，如果工厂每次都是完整的按照工序把第一件商品生产出来之后再进行同样的步骤生产下一件商品的话，这个生产速度得多慢！所以 19 世纪人类就诞生了工业化的流水线，把所有这些工序分解并行化。第一件商品在工序(2)的时候，丝毫不影响第二件商品进入工序(1)。指令也完全可以这样，CPU 可以把指令执行过程流水线化，把不同的指令执行步骤分给不同的逻辑门 (<a href="https://en.wikipedia.org/wiki/Logic_gate">logic stage</a>)处理，第一条指令进入<strong>解指令</strong>阶段的时候，第二条指令就可以进入<strong>取指令</strong>阶段了。</p>
<p>Wikipedia 上的这张图可以帮助理解（图中文字颜色为黑色，推荐用 Light 主题查看）。</p>
<p><img src="chapter_4/./image/improve-std-slice/instruction-pipeline.png" alt="" /></p>
<p>了解前面的这些概念之后，我们来看一下为什么 CPU 需要做分支预测？</p>
<h3><a class="header" href="#为什么需要分支预测" id="为什么需要分支预测">为什么需要分支预测？</a></h3>
<p><strong>指令流水线</strong>会按照工厂流水线一样执行指令，这其中也包括前面讲的 <strong>jump</strong> 指令。而 <strong>jump</strong> 指令有一个问题就是它需要知道下一个时钟周期该跳转还是不跳转，而这需要等前面的判断逻辑执行完了之后才知道。比如上面的例子 <strong>cmp</strong> 判断完之后，<code>jump</code> 指令才能决定是跳转到 <code>.LBB99_10</code> 部分，还是不跳转继续执行下去。但是 CPU 指令流水线才不会等，否则白白的浪费一个时钟周期。所以人们发明了一种办法来避免出现这种问题，这就是<strong>分支预测</strong>。</p>
<p>CPU 的分支预测器会提前预测这条 <strong>jump</strong> 指令可能会跳转的到哪个分支，然后把预测的那条分支放到流水线中去执行。如果预测正确，CPU 可以继续执行后面的指令；如果预测失败了(branch misprediction)，那只能丢弃刚刚执行的分支结果，重新切换到正确的分支执行。可以看到，如果出现过多的预测失败，分支预测反而很影响性能。不过现在 CPU 的分支预测器经过这么多年的发展已经越来越先进了，人们会采用各种方式不断提高分支预测器的预测准确率，详细可以查看 Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Branch_predictor">Branch_predictor</a> 了解更多。</p>
<h3><a class="header" href="#热循环中避免分支预测" id="热循环中避免分支预测">热循环中避免分支预测</a></h3>
<p>虽然现代 CPU 都有分支预测器，但我们在软件层面依然要尽量避免发生分支预测，特别是在热循环中。最常用的优化方法就是避免在循环中写 <code>if/else</code> 语句，即 <code>branchless code</code>。标准库中有大量这种 <code>branchless code</code> 的案例来优化性能，比如 <code>std::collection::Filter</code> 的 <code>count()</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Filter&lt;I, P&gt; {
    iter: I,
    predicate: P,
}

impl&lt;I: Iterator, P&gt; Iterator for Filter&lt;I, P&gt;
where
    P: FnMut(&amp;I::Item) -&gt; bool,
{
    type Item = I::Item;

    // this special case allows the compiler to make `.filter(_).count()`
    // branchless. Barring perfect branch prediction (which is unattainable in
    // the general case), this will be much faster in &gt;90% of cases (containing
    // virtually all real workloads) and only a tiny bit slower in the rest.
    //
    // Having this specialization thus allows us to write `.filter(p).count()`
    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is
    // less readable and also less backwards-compatible to Rust before 1.10.
    //
    // Using the branchless version will also simplify the LLVM byte code, thus
    // leaving more budget for LLVM optimizations.
    #[inline]
    fn count(self) -&gt; usize {
        #[inline]
        fn to_usize&lt;T&gt;(mut predicate: impl FnMut(&amp;T) -&gt; bool) -&gt; impl FnMut(T) -&gt; usize {
            move |x| predicate(&amp;x) as usize
        }

        self.iter.map(to_usize(self.predicate)).sum()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>标准库的 <code>Filter</code> 类型在实现 <code>Iterator</code> 的时候重写了 <code>count()</code> 方法。想想如果我们没有意识到分支预测这个问题的情况下可能会这么实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad
#[inline]
fn count(self) -&gt; usize {
    let sum = 0;

    self.iter.for_each(|x| {
        if self.predicate(x) {
            sum += 1;
        }
    });
    
    sum
}
<span class="boring">}
</span></code></pre></pre>
<p>但这种实现在循环中有一个 <code>if</code> 语句，导致 CPU 需要进行大量的分支预测，而这些分支预测几乎都是随机的，CPU 很难根据历史记录提高预测的准确度，导致性能会比较低。而标准库的实现完全是 branchless 的，不仅性能好很多，而且也能方便 LLVM 做更多优化。</p>
<blockquote>
<ul>
<li>
<p>关于怎样写好 <code>branchless code</code> 来优化性能又是另一个值得专门讨论的主题了，网上也有大量资料可以学习。但是 <code>branchless code</code> 会牺牲不少代码可读性，并不建议盲目的使用。</p>
</li>
<li>
<p><code>branchless code</code> 的额外好处是还能帮助避免遭受<strong>旁路攻击</strong>(英文 timing attack 或者 side-channel attack)。参考：<a href="https://en.wikipedia.org/wiki/Timing_attack">https://en.wikipedia.org/wiki/Timing_attack</a>。</p>
</li>
</ul>
</blockquote>
<p>继续回到我们刚才的那个 PR。我们的版本比标准库旧的版本在某些 case 下性能要低确实跟分支预测有关，因为我们的代码多了一种分支需要预测。</p>
<p>为了方便大家对比，我把汇编的截图贴到下面。我们只需要关注我标记文字的那几个颜色就可以。很容易看出来新版实现多了一个 <code>jne</code> 的跳转指令，导致 CPU 需要多做一次分支预测。</p>
<blockquote>
<p>申明：启用 <code>-O</code> 参数之后汇编指令会被优化得更精简，这里没有启用 <code>-O</code> 是为了对应到每一行源码方便对比。</p>
</blockquote>
<ul>
<li>标准库的汇编截图</li>
</ul>
<p><img src="chapter_4/./image/improve-std-slice/branch-compare.png" alt="" /></p>
<ul>
<li>优化(1)的汇编截图</li>
</ul>
<p><img src="chapter_4/./image/improve-std-slice/branch-compare2.png" alt="" /></p>
<blockquote>
<p>需要注意的是 <code>jmp</code> 指令是直接跳转，不需要进行分支预测。感兴趣的朋友可以看一下我在 Godbolt 上的对比：<a href="https://rust.godbolt.org/z/8dGbY8Pe1">https://rust.godbolt.org/z/8dGbY8Pe1</a>。这个网站是神器，强烈推荐！</p>
</blockquote>
<h2><a class="header" href="#优化2" id="优化2">优化（2）</a></h2>
<p>所以我推测原作者实现标准库的 <code>binary_search_by()</code> 的时候不考虑 <code>O(1)</code> 最好时间复杂度的可能原因之一就是为了避免多余的分支预测。因为你要想 <code>O(1)</code> 就避免不了提前 return，要想提前 return 你就避免不了分支判断。那怎么办呢？PR 里面有一个大牛 <a href="https://github.com/tesuji">tesuji</a> 提供了一种思路：既然我们避免不了分支预测，那我们尽量帮助 CPU 更好的做好分支预测吧。于是我采用了他的方案，具体 commit 在<a href="https://github.com/rust-lang/rust/commit/7d078cfb94fa75e5dee699535f3f9781d3a1d47d">这里</a>，我们暂且叫它<strong>优化(2)</strong>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn binary_search_by&lt;'a, F&gt;(&amp;'a self, mut f: F) -&gt; Result&lt;usize, usize&gt;
where
    F: FnMut(&amp;'a T) -&gt; Ordering,
{
    let mut left = 0;
    let mut right = self.len();
    while left &lt; right {
        // never overflow because `slice::len()` max is `isize::MAX`.
        let mid = (left + right) / 2;
        // SAFETY: the call is made safe by the following invariants:
        // - `mid &gt;= 0`
        // - `mid &lt; size`: `mid` is limited by `[left; right)` bound.
        let cmp = f(unsafe { self.get_unchecked(mid) });
        if cmp == Less {
            left = mid + 1;
        } else if cmp == Greater {
            right = mid;
        } else {
            return Ok(mid);
        }
    }
    Err(left)
}
<span class="boring">}
</span></code></pre></pre>
<p>优化(2)的代码明显比标准库和优化(1)的代码更容易理解，再看一下它的生成的汇编代码。</p>
<p><img src="chapter_4/./image/improve-std-slice/branch-compare3.png" alt="" /></p>
<p>可以看出来依然是两条 <code>jne</code> 指令，所以非重复模式下的性能可能还是没有标准库的高，但是确实比优化(1)的性能要好很多。过了几天 libs 组的 <a href="https://github.com/m-ou-se">m-ou-se</a> 回复了<a href="https://github.com/rust-lang/rust/pull/74024#issuecomment-713818146">评论</a>。她也做了 benchmark，发现对于原生类型比如 <strong>u32</strong> 下 l1 级别的数据量依然比标准库慢，但是那些需要更多时间比较的类型（比如 String）的情况下，新的实现在所有 case 下性能都要优于标准库的实现。后面大家又讨论了许多，最终  <strong>m-ou-se</strong> 决定先跑一个 crater 测试，先验证一下这个 PR 对 crates.io 上所有的 crate 影响面大不大。最终 library 团队会议一致同意可以 merge 这个 PR。</p>
<blockquote>
<p>关于 <a href="https://github.com/rust-lang/crater">crater</a> 测试：</p>
<p>crater 大概就是针对整个 crates.io 上所有的 crate 给要测试的编译器版本（比如我的 PR ）跑一次测试，看这个改动对线上所有 crate 影响大不大。crates.io 上超过5万个 crate，一般跑一次 crater 需要将近一周的时间。我的这个 crater 跑完之后就是因为没有对已发布的 crate 造成什么很大的影响，所以官方才愿意合并。</p>
</blockquote>
<blockquote>
<p>From <strong>m-ou-se</strong>:</p>
<p>&quot;We discussed this PR in a recent library team meeting, in which we agreed that the proposed behaviour (stopping on Equal) is preferrable over optimal efficiency in some specific niche cases. Especially considering how small most of the differences are in the benchmarks above.&quot;</p>
<p>&quot;The breakage in the crater report looks reasonably small. Also, now that <code>partition_point</code> is getting stabilized, there's a good alternative for those who want the old behaviour of <code>binary_search_by</code>. So we should go ahead and start on getting this merged. :)&quot;</p>
</blockquote>
<h2><a class="header" href="#整数溢出问题" id="整数溢出问题">整数溢出问题</a></h2>
<p>然而 <a href="https://github.com/scottmcm">scottmcm</a> 又指出了另外一个问题：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// never overflow because `slice::len()` max is `isize::MAX`.
let mid = (left + right) / 2;
<span class="boring">}
</span></code></pre></pre>
<p>这行代码在零大小类型(Zero Sized Type，简称 ZST)下却可能会 overflow! 我们来分析一下为什么。</p>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len()</code></a> 的返回值是 <code>usize</code> 类型，但是对于非零大小的类型(non-ZST)，<code>slice::len()</code> 的值最大也只能是 <code>isize::MAX</code>。所以就像注释上写的那样 <code>(isize::MAX + isize::MAX) / 2</code> 是不能可能超过 <code>usize::MAX</code> 的，所以不会发生 overflow。但是对于 ZST 类型就不一样了，如果 <code>slice</code> 里面所有元素都是零大小的（比如 <code>()</code>），那这个 <code>slice</code> 的长度完全可以达到 <code>usize::MAX</code>。虽然对于 <code>[(); usize::MAX].binary_search(&amp;())</code> 这种情况我们会在 <code>O(1)</code> 的时间复杂度上找到结果并马上返回，但是如果我们这么写 <code>b.binary_search_by(|_| Ordering::Less)</code>，它就发生整数溢出了。</p>
<h3><a class="header" href="#为什么-slicelen-对于-non-zst-最大值是-isize-呢" id="为什么-slicelen-对于-non-zst-最大值是-isize-呢">为什么 <code>slice::len()</code> 对于 non-ZST 最大值是 <code>isize</code> 呢？</a></h3>
<p>最简单直接的原因是我们不能构造一个所有元素都为 non-ZST 并且长度为 <code>usize::MAX</code> 的数组或 <code>slice</code>，编译器在编译阶段直接会报错。比如以最简单的只占 1 个字节的 <code>bool</code> 类型为例，<code>[bool; usize::MAX]</code> 的大小将等于 <code>std::mem::size_of::&lt;bool&gt;() * usize::MAX</code>, 这是一个很大的数字了，整个计算机地址空间都不够。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    assert_eq!(std::mem::size_of::&lt;bool&gt;(), 1);
    // error: values of the type `[bool; 18446744073709551615]` are too big 
    // for the current architecture
    let _s = [true; usize::MAX];
}
</code></pre></pre>
<p>但是对于 ZST 是可以的，因为 <code>std::mem::size_of::&lt;()&gt;() * usize::MAX</code> 依然是零。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    assert_eq!(std::mem::size_of::&lt;()&gt;(), 0);
    let s = [(); usize::MAX];
    assert_eq!(s.len(), usize::MAX);
}
</code></pre></pre>
<p>不过上面的解释依然不够严谨，比如 <code>std::mem::size_of::&lt;bool&gt;() * isize::MAX</code> 也依然是一个很大的数字呀，为啥 <code>isize::MAX</code> 就可以？根本原因在于 Rust 指针寻址最大 offset 只允许 <code>isize::MAX</code>，至于为什么是 <code>isize::MAX</code>，<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset"><code>std::pointer::offset()</code></a> 的文档有解释。另外也可以看一下 <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts()</code></a> 的文档。而对于 ZST 的类型，编译器会做优化，它压根不需要寻址，所以最大大小可以是 <code>usize::MAX</code>。</p>
<h2><a class="header" href="#最终版本" id="最终版本">最终版本</a></h2>
<p>意识到整数溢出的问题之后，解决方式也比较简单，这是我当时的<a href="https://github.com/rust-lang/rust/pull/74024/commits/3eb5bee242fae12c4cf547bfe0665653c20ca0c2">提交</a>，并且还增加了针对 overflow 的单元测试。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn binary_search_by&lt;'a, F&gt;(&amp;'a self, mut f: F) -&gt; Result&lt;usize, usize&gt;
    where
        F: FnMut(&amp;'a T) -&gt; Ordering,
    {
        let mut size = self.len();
        let mut left = 0;
        let mut right = size;
        while left &lt; right {
            let mid = left + size / 2;

            // SAFETY: the call is made safe by the following invariants:
            // - `mid &gt;= 0`
            // - `mid &lt; size`: `mid` is limited by `[left; right)` bound.
            let cmp = f(unsafe { self.get_unchecked(mid) });
            // The reason why we use if/else control flow rather than match
            // is because match reorders comparison operations, which is 
            // perf sensitive.
            // This is x86 asm for u8: https://rust.godbolt.org/z/8Y8Pra.
            if cmp == Less {
                left = mid + 1;
            } else if cmp == Greater {
                right = mid;
            } else {
                return Ok(mid);
            }

            size = right - left;
        }
        Err(left)
    }

#[test]
fn test_binary_search_by_overflow() {
    let b = [(); usize::MAX];
    assert_eq!(b.binary_search_by(|_| Ordering::Equal), Ok(usize::MAX / 2));
    assert_eq!(b.binary_search_by(|_| Ordering::Greater), Err(0));
    assert_eq!(b.binary_search_by(|_| Ordering::Less), Err(usize::MAX));
}
<span class="boring">}
</span></code></pre></pre>
<p>我们确实应该尽量避免写 <code>let mid = (left + right) / 2</code> 这种很容易发生整数溢出的代码，换成 <code>let mid = left + size / 2</code> 这种，可以避免发生 overflow。</p>
<p>另外还有人问为什么这里使用 <code>if/else</code> 而不是 <code>match</code> 语句？我们查看两个版本的汇编指令后发现 <code>match</code> 版本生成的汇编代码不仅指令更多而且还重排了 <code>cmp</code> 指令的顺序，性能似乎更差。理论上这两个版本生成的汇编指令应该可以做到一致的，我暂时没有深究原因为什么 <code>match</code> 版本的汇编会差一些，其他读者感兴趣可以研究一下。</p>
<h2><a class="header" href="#总结-9" id="总结-9">总结</a></h2>
<p>表面波澜不惊，实则暗流涌动。一个看起来十分简单的 PR 里面其实涉及到很多内容。学无止境，笔者通过这个 PR 收获了很多，现在分享出来同时也希望能够激励更多国内开发者参与进来。Rust 社区文化是如此开放和包容，任何人只要发现有可以改进的地方都可以随时给 Rust 仓库提交 PR 或 issue，这样做不仅能帮助 Rust 越来越好，你自己也会得到巨大的成长和收获！</p>
<hr />
<h2><a class="header" href="#关于我" id="关于我">关于我</a></h2>
<p>Id: Folyd，GitHub：<a href="https://github.com/folyd">@folyd</a>。字节跳动飞书 Rust 工程师，<a href="https://rust.extension.sh">Rust Search Extension</a> 作者。</p>
<h2><a class="header" href="#招聘" id="招聘">招聘</a></h2>
<p>字节跳动<a href="https://feishu.cn">飞书</a>团队自 2017 年就开始使用 Rust 开发飞书多端跨平台 SDK，为 Android / iOS / Window / macOS / Linux 等平台提供高质量的底层基础库，同时飞书内部的效率工具和少数后端系统也全部采用 Rust 开发。我们可能是国内 Rust 工程师最多的团队之一！我们长期招聘热爱 Rust、喜欢 Rust、看好 Rust 前景的工程师加入。支持实习、校招、社招。Base 北京，欢迎大家自荐或推荐，请联系 wx: <code>newpants629</code>，或者直接在内推链接投递简历：<a href="https://job.toutiao.com/s/eB1j29f">https://job.toutiao.com/s/eB1j29f</a>。</p>
<h1><a class="header" href="#github-趋势榜" id="github-趋势榜">GitHub 趋势榜</a></h1>
<p>编辑：张汉东</p>
<hr />
<p>盘点一下 本月 <a href="https://github.com/trending/rust?since=daily">GitHub 趋势榜上榜的 Rust 项目</a>。</p>
<p><strong>从趋势榜中看得出来，「Rust 嵌入式/ WebAssembly/ 网络服务/ 性能遥测/ Web/ 云计算/ 游戏/ GUI」是 Rust 相对受关注比较多的领域。</strong></p>
<h2><a class="header" href="#top-1-a-hrefhttpsgithubcomrust-embeddedrust-raspberrypi-os-tutorialsrust-embedded--rust-raspberrypi-os-tutorialsa" id="top-1-a-hrefhttpsgithubcomrust-embeddedrust-raspberrypi-os-tutorialsrust-embedded--rust-raspberrypi-os-tutorialsa">Top 1: <a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">rust-embedded / rust-raspberrypi-OS-tutorials</a></a></h2>
<p>该项目是 Rust 嵌入式工作组维护的一个教程项目，使用 Rust 实现一个基于 树莓派的操作系统。这个月热度很高，是因为最近该项目活跃度又提升了，加了不少更新。</p>
<h2><a class="header" href="#top-2-a-hrefhttpsgithubcomthealgorithmsrustthealgorithmsrusta" id="top-2-a-hrefhttpsgithubcomthealgorithmsrustthealgorithmsrusta">Top 2: <a href="https://github.com/TheAlgorithms/Rust">TheAlgorithms/Rust</a></a></h2>
<p>该项目是教育为目的的 Rust 算法实现库。近两个月更新不太活跃，但是却上了本月的趋势榜，可能在某些技术媒体做了宣传？</p>
<h2><a class="header" href="#top-3-a-hrefhttpsgithubcombytecodealliancewasmtimebytecodealliancewasmtimea" id="top-3-a-hrefhttpsgithubcombytecodealliancewasmtimebytecodealliancewasmtimea">Top 3: <a href="https://github.com/bytecodealliance/wasmtime">bytecodealliance/wasmtime</a></a></h2>
<p>该项目为字节码联盟成员 Fastly 公司的 WebAssembly 的编译器和运行时，基于 Cranelift 。最近字节码联盟比较活跃，成立了新的开源组织，吸收了新成员，所以受关注比较多。</p>
<h2><a class="header" href="#top-4-a-hrefhttpsgithubcomlemmynetlemmylemmynetlemmya" id="top-4-a-hrefhttpsgithubcomlemmynetlemmylemmynetlemmya">Top 4: <a href="https://github.com/LemmyNet/lemmy">LemmyNet/lemmy</a></a></h2>
<p>Lemmy 是基于 actix-web 开发的 仿 reddit 开源论坛。最近发布了新版本。</p>
<h2><a class="header" href="#top-5-a-hrefhttpsgithubcomrustdeskrustdeskrustdeskrustdeska" id="top-5-a-hrefhttpsgithubcomrustdeskrustdeskrustdeskrustdeska">Top 5: <a href="https://github.com/rustdesk/rustdesk">rustdesk/rustdesk</a></a></h2>
<p>RustDesk 是国内一位开发者发布的开源项目，号称最好的远程桌面客户端，基于 Rust 和 <a href="https://sciter.com/">sciter</a>实现。我邀请过 RustDesk 作者写文分享这个产品的开发心得（主要想了解 Windows 开发方面的心得 ），但是遭到作者以不会写文章为由推辞（汗），但是该库代码是完全开源的，想学习的朋友可以看源码学习吧。</p>
<h2><a class="header" href="#top-6-a-hrefhttpsgithubcomfirecracker-microvmfirecrackerfirecracker-microvmfirecrackera" id="top-6-a-hrefhttpsgithubcomfirecracker-microvmfirecrackerfirecracker-microvmfirecrackera">Top 6: <a href="https://github.com/firecracker-microvm/firecracker">firecracker-microvm/firecracker</a></a></h2>
<p>Firecracker 是 AWS 开源的 用于 severless 计算的 microVMs。</p>
<h2><a class="header" href="#top-7-a-hrefhttpsgithubcomyewstackyewyewstackyewa" id="top-7-a-hrefhttpsgithubcomyewstackyewyewstackyewa">Top 7: <a href="https://github.com/yewstack/yew">yewstack/yew</a></a></h2>
<p>允许你使用 Rust 和 WebAssembly 构建 Web App 的客户端。最近又有了活跃的更新。</p>
<h2><a class="header" href="#top-8-a-hrefhttpsgithubcomdani-garciavaultwardendani-garciavaultwardena" id="top-8-a-hrefhttpsgithubcomdani-garciavaultwardendani-garciavaultwardena">Top 8: <a href="https://github.com/dani-garcia/vaultwarden">dani-garcia/vaultwarden</a></a></h2>
<p>用Rust 实现的非官方 Bitwarden 兼容服务器。并且与上游Bitwarden客户端*兼容，非常适合自托管部署，在这种情况下，运行官方资源密集型服务可能不理想。延伸阅读：<a href="https://sspai.com/post/61976">登录信息就该自己掌握：基于私有云的 Bitwarden 迁移指南</a></p>
<h2><a class="header" href="#top-9-a-hrefhttpsgithubcomnovifinancialwinterfellnovifinancialwinterfella" id="top-9-a-hrefhttpsgithubcomnovifinancialwinterfellnovifinancialwinterfella">Top 9: <a href="https://github.com/novifinancial/winterfell">novifinancial/winterfell</a></a></h2>
<p>构建分布式 STARK 证明程序的实验项目。这是和 零知识证明 相关的库。</p>
<p>警告：这是一个研究项目。 它未经审核，可能包含错误和安全漏洞。 此实现尚未准备好用于生产。</p>
<h2><a class="header" href="#top-10-a-hrefhttpsgithubcomkoba789rellykoba789rellya" id="top-10-a-hrefhttpsgithubcomkoba789rellykoba789rellya">Top 10: <a href="https://github.com/KOBA789/relly">KOBA789/relly</a></a></h2>
<p>一个小型的 关系数据库管理系统(RDBMS)  实现，以了解RDBMS的工作方式。</p>
<h2><a class="header" href="#top-11-a-hrefhttpsgithubcomextrawurstgituiextrawurstgituia" id="top-11-a-hrefhttpsgithubcomextrawurstgituiextrawurstgituia">Top 11: <a href="https://github.com/extrawurst/gitui">extrawurst/gitui</a></a></h2>
<p>Rust 实现的高性能终端 Git UI。刚发布了新版本。</p>
<h2><a class="header" href="#top-12-a-hrefhttpsgithubcommozillagleanmozillagleana" id="top-12-a-hrefhttpsgithubcommozillagleanmozillagleana">Top 12: <a href="https://github.com/mozilla/glean">mozilla/glean</a></a></h2>
<p>Mozilla 出的现代高性能跨平台遥测（Telemetry）库，Glean有两种实现，总共支持5种不同的编程语言。 </p>
<p><a href="https://mozilla.github.io/glean/book/index.html">Glean Book</a></p>
<h2><a class="header" href="#top-13-a-hrefhttpsgithubcommeilisearchmeilisearchmeilisearchmeilisearcha" id="top-13-a-hrefhttpsgithubcommeilisearchmeilisearchmeilisearchmeilisearcha">Top 13: <a href="https://github.com/meilisearch/MeiliSearch">meilisearch/MeiliSearch</a></a></h2>
<p>MeiliSearch是功能强大，快速，开源，易于使用和部署的搜索引擎。 搜索和索引编制都是高度可定制的。 开箱即用的功能包括拼写错误，过滤器和同义词。这有一篇 <a href="chapter_4/./meili_search.html">MeiliSearch CEO 访谈</a></p>
<h2><a class="header" href="#top-14-a-hrefhttpsgithubcomtimberiovectortimberiovectora" id="top-14-a-hrefhttpsgithubcomtimberiovectortimberiovectora">Top 14: <a href="https://github.com/timberio/vector">timberio/vector</a></a></h2>
<p>Vector是高性能的端到端（代理和聚合器）可观察性数据管道，可让开发者控制可观察性数据。 开源，并且比其他任何方式快10倍。这也是一个非常优秀的开源项目，国内豆瓣在用它。<a href="https://vector.dev/docs/setup/quickstart/">QuickStart</a>。</p>
<h2><a class="header" href="#top-15-a-hrefhttpsgithubcomserenity-rsserenityserenity-rsserenitya" id="top-15-a-hrefhttpsgithubcomserenity-rsserenityserenity-rsserenitya">Top 15: <a href="https://github.com/serenity-rs/serenity">serenity-rs/serenity</a></a></h2>
<p>这是 Discord API 的 Rust 库，可以用它开发 Discord Bot 。</p>
<h2><a class="header" href="#top-16-a-hrefhttpsgithubcomembarkstudiosrust-gpuembarkstudiosrust-gpua" id="top-16-a-hrefhttpsgithubcomembarkstudiosrust-gpuembarkstudiosrust-gpua">Top 16: <a href="https://github.com/EmbarkStudios/rust-gpu">EmbarkStudios/rust-gpu</a></a></h2>
<p>EmbarkStudios 出品的 GPU 库，目标是让 Rust 成为 GPU 编码的一流语言和生态。EmbarkStudios 公司也是 Rust Game 工作组的成员，为 Rust 游戏领域贡献不少库。最近该公司也加入了字节码联盟。</p>
<h2><a class="header" href="#top-17-a-hrefhttpsgithubcomsolana-labssolanasolana-labssolanaa" id="top-17-a-hrefhttpsgithubcomsolana-labssolanasolana-labssolanaa">Top 17: <a href="https://github.com/solana-labs/solana">solana-labs/solana</a></a></h2>
<p>网络级（Web-Scale）区块链，用于快速，安全，可扩展，去中心化的应用程序和市场。去年 Solana 还赞助了 RustChinaConf。</p>
<h2><a class="header" href="#top-18-a-hrefhttpsgithubcomkethkuneovidekethkuneovidea" id="top-18-a-hrefhttpsgithubcomkethkuneovidekethkuneovidea">Top 18: <a href="https://github.com/Kethku/neovide">Kethku/neovide</a></a></h2>
<p>一个 Neovim 简单图形用户界面。</p>
<h2><a class="header" href="#top-19-a-hrefhttpsgithubcomhyperiumtonichyperiumtonica" id="top-19-a-hrefhttpsgithubcomhyperiumtonichyperiumtonica">Top 19: <a href="https://github.com/hyperium/tonic">hyperium/tonic</a></a></h2>
<p>tonic是基于HTTP/2 的 gRPC 实施，专注于高性能，互操作性和灵活性。 创建该库是为了对async / await提供一流的支持，并充当用Rust编写的生产系统的核心构建块。 最近几天在努力为发新版（0.4.3）做准备。</p>
<h2><a class="header" href="#top-20-a-hrefhttpsgithubcomtonarinoinnernettonarinoinnerneta" id="top-20-a-hrefhttpsgithubcomtonarinoinnernettonarinoinnerneta">Top 20: <a href="https://github.com/tonarino/innernet">tonarino/innernet</a></a></h2>
<p>允许你创建使用 WireGuard 的专用网络系统。 WireGuard 是一款新型虚拟专用网络，旨在替代 IPSec 和 OpenVPN。它的设计目标就是简单而且安全，并且充分利用<a href="https://noiseprotocol.org/">噪声协议框架（Noise Protocol Framework）</a>等新技术。</p>
<p>内部网的目标与Slack的 <a href="https://github.com/slackhq/nebula">nebula</a> 或 <a href="https://tailscale.com/">Tailscale</a> 类似，但采取了不同的方法。它旨在利用现有的网络概念（如CIDR）和WireGuard的安全属性，将计算机的基本IP网络转变为功能更强大的ACL原语。</p>
<p>innernet不是官方的WireGuard项目，WireGuard是Jason A. Donenfeld的注册商标。</p>
<p>该软件尚未接受独立的安全审核，因此应在其生命周期的早期阶段视为试验性软件。</p>
<h2><a class="header" href="#top-21-a-hrefhttpsgithubcomtauri-appstauritauri-appstauria" id="top-21-a-hrefhttpsgithubcomtauri-appstauritauri-appstauria">Top 21: <a href="https://github.com/tauri-apps/tauri">tauri-apps/tauri</a></a></h2>
<p>允许开发者使用Web前端构建更小，更快和更安全的桌面应用程序。最近发布了 1.0-beta 版。<a href="https://www.zhihu.com/question/396199869">知乎：如何评价 tauri？</a></p>
<h2><a class="header" href="#top-22-a-hrefhttpsgithubcomlinebenderdruidlinebenderdruida" id="top-22-a-hrefhttpsgithubcomlinebenderdruidlinebenderdruida">Top 22: <a href="https://github.com/linebender/druid">linebender/druid</a></a></h2>
<p>Druid是一个实验性的Rust-native UI工具箱。 其主要目标是提供完善的用户体验。最近也是开发比较活跃。</p>
<h2><a class="header" href="#top-23-a-hrefhttpsgithubcombevyenginebevybevyenginebevya" id="top-23-a-hrefhttpsgithubcombevyenginebevybevyenginebevya">Top 23: <a href="https://github.com/bevyengine/bevy">bevyengine/bevy</a></a></h2>
<p>Bevy 可以说是当下最火的 Rust 游戏引擎了。最近发布了0.5版本，对其 ecs 引擎升级到了 V2。</p>
<h2><a class="header" href="#top-24-a-hrefhttpsgithubcomgfx-rswgpu-rsgfx-rswgpu-rsa" id="top-24-a-hrefhttpsgithubcomgfx-rswgpu-rsgfx-rswgpu-rsa">Top 24: <a href="https://github.com/gfx-rs/wgpu-rs">gfx-rs/wgpu-rs</a></a></h2>
<p>wgpu 的 Rust 绑定库。 它的设计适合于Rust社区的通用图形和计算需求。wgpu-rs可以直接针对本地支持的后端和WASM。正在准备发布新版(0.8)。</p>
<h1><a class="header" href="#推荐项目--基础工具库" id="推荐项目--基础工具库">推荐项目 ｜ 基础工具库</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#rust-search-extension-v12-发布" id="rust-search-extension-v12-发布">Rust Search Extension v1.2 发布</a></h2>
<ul>
<li>支持使用 <code>//</code> 前缀搜索 rustc 编译器的源码。</li>
<li>支持直接搜索 Rust 版本号，跳转到该版本的 release 界面。</li>
<li>新的源码跳转模式：在关键字前添加 <code>src:</code> 或 <code>s:</code>，搜索结果会跳转到源码页面。</li>
<li>新的 <code>:blog</code> 命令。</li>
</ul>
<p><a href="https://rust.extension.sh/changelog/">https://rust.extension.sh/changelog/</a></p>
<h2><a class="header" href="#ockam用于端到端加密相互身份验证通信的rust库" id="ockam用于端到端加密相互身份验证通信的rust库">Ockam：用于端到端加密、相互身份验证通信的Rust库</a></h2>
<p>用于边缘设备和云服务之间的端到端加密、相互认证通信的Rust和Elixir库。</p>
<p>物联网中的机器通过与云服务和其他联网机器交换信息来进行操作。安全的、私有的和可信的连接应用程序必须保护这些消息不被窃听、篡改和伪造。</p>
<p><a href="https://github.com/ockam-network/ockam/">https://github.com/ockam-network/ockam/</a></p>
<h2><a class="header" href="#himalaya-极简命令行邮件客户端" id="himalaya-极简命令行邮件客户端">Himalaya: 极简命令行邮件客户端</a></h2>
<p><a href="https://github.com/soywod/himalaya">https://github.com/soywod/himalaya</a></p>
<h2><a class="header" href="#amadeus---rust-大数据处理" id="amadeus---rust-大数据处理">Amadeus - Rust 大数据处理</a></h2>
<p>Amadeus 是一组开箱即用、低层可重用构建件，来构造 Rust 分布式计算和大数据生态。 它宣称符合以下原则：</p>
<ul>
<li>无畏：无数据竞争，无 unsafe 代码，无损失数据克隆</li>
<li>无感分布式：分布式运行时和在本地运行时一样简便和高性能</li>
<li>数据递进类型化： 当调度计划已知时可以最大化性能，其他情况则可以保持灵活性</li>
<li>简洁：尽可能地保持接口和实现简单可靠</li>
<li>可靠：尽可能减少不可处理的错误，并且只会抛出内部不可处理的错误</li>
</ul>
<p><a href="https://github.com/constellation-rs/amadeus">https://github.com/constellation-rs/amadeus</a></p>
<h2><a class="header" href="#使用-activex-和-feed-rs-开发的-rss-浏览器" id="使用-activex-和-feed-rs-开发的-rss-浏览器">使用 activex 和 feed-rs 开发的 RSS 浏览器</a></h2>
<p>作者使用actix和feed-rs开发了自己的RSS浏览器。它很简单，作家将尽量保持这种方式，但仍然会添加一些功能。</p>
<ul>
<li>Live: <a href="https://mevlyshkin.xyz/rss">https://mevlyshkin.xyz/rss</a></li>
<li>Repo: <a href="https://git.sr.ht/%7Eleinnan/rust_blog">https://git.sr.ht/~leinnan/rust_blog</a></li>
</ul>
<h2><a class="header" href="#robusta--一个方便生成-jni-交互代码的库" id="robusta--一个方便生成-jni-交互代码的库">robusta ： 一个方便生成 JNI 交互代码的库</a></h2>
<p>有了它就可以避免写那些繁琐冗长的 Java JNI 函数名了！</p>
<p>例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use robusta_jni::bridge;
use robusta_jni::convert::Signature;

#[bridge]
mod jni {
    #[derive(Signature)]
    #[package(com.example.robusta)]
    struct HelloWorld;

    impl HelloWorld {
        pub extern &quot;jni&quot; fn special(mut input1: Vec&lt;i32&gt;, input2: i32) -&gt; Vec&lt;String&gt; {
            input1.push(input2);
            input1.iter().map(ToString::to_string).collect()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-java">package com.example.robusta;

import java.util.*;

class HelloWorld {
    private static native ArrayList&lt;String&gt; special(ArrayList&lt;Integer&gt; input1, int input2);

    static {
        System.loadLibrary(&quot;robusta_example&quot;);
    }

    public static void main(String[] args) {
        ArrayList&lt;String&gt; output = HelloWorld.special(new ArrayList&lt;Integer&gt;(List.of(1, 2, 3)), 4);
        System.out.println(output)
    }
}
</code></pre>
<p><a href="https://github.com/giovanniberti/robusta">https://github.com/giovanniberti/robusta</a></p>
<h2><a class="header" href="#swc--1252-版发布" id="swc--1252-版发布">SWC  1.2.52 版发布</a></h2>
<p>swc 是一个 Rust 编写的 typescript/javascript 编译器, 可以生成兼容老旧浏览器的 javascript 代码.</p>
<p>单核比 babel 快 20倍, 4 核比 babel 快 70 倍.</p>
<p><a href="https://swc.rs/blog/2021/04/11/swc-1.2.52/">https://swc.rs/blog/2021/04/11/swc-1.2.52/</a></p>
<h2><a class="header" href="#dipa---轻松为-rust-数据结构添加增量编码支持" id="dipa---轻松为-rust-数据结构添加增量编码支持">dipa - 轻松为 Rust 数据结构添加增量编码支持</a></h2>
<p>dipa 可以轻松高效地对大型 Rust 数据结构进行增量编码。增量编码技术可以用于确定在数据结构的两个实例之间发生了什么变化，利用此项技术，可以有效减少传输相似数据所耗费的流量和带宽。</p>
<ul>
<li>Github: <a href="https://github.com/chinedufn/dipa">https://github.com/chinedufn/dipa</a></li>
<li>The dipa Book: <a href="https://github.com/chinedufn/dipa">https://chinedufn.github.io/dipa</a></li>
</ul>
<h2><a class="header" href="#static_init-v10-发布---更快的静态变量" id="static_init-v10-发布---更快的静态变量">static_init v1.0 发布 - 更快的静态变量</a></h2>
<p>static_init 支持安全的可变静态量和非常量静态量初始化，与 lazy_static 或 parking_lot::RwLock 相比，具有 200 倍的速度提升。</p>
<p><a href="https://crates.io/crates/static_init">https://crates.io/crates/static_init</a></p>
<h2><a class="header" href="#macchina-快速精简和可定制的系统信息提取器" id="macchina-快速精简和可定制的系统信息提取器">Macchina: 快速，精简和可定制的系统信息提取器</a></h2>
<p>Macchina允许您查看基本的系统信息，例如主机名，内核，正常运行时间，内存使用情况等等。它为您提供方便的功能和广泛的自定义选项，但不会忽略其两个主要优先级，即简约和性能。</p>
<p><a href="https://github.com/Macchina-CLI/macchina">https://github.com/Macchina-CLI/macchina</a></p>
<h2><a class="header" href="#evcxr--rust--jupyter--notebook" id="evcxr--rust--jupyter--notebook">Evcxr : Rust  Jupyter  notebook</a></h2>
<p>本文主要是对 Rust Jupyter 内核的创建者David Lattimore的采访。看完感觉 Rust 用于数据科学领域指日可待。</p>
<p>摘录一些：</p>
<ol>
<li>evcxr的发音是 “e-vix-er” 。</li>
<li>David 之所以做这个，也是因为受他妻子影响。他妻子是数据科学家，常用 Jupyter notebook ，受她影响 David 尝试做了 Jupyter rust 核心，然后把 他之前做的 Rust REPL 工具 集成。</li>
<li>目前 Rust REPL 之类的工具还在维护的就是 evcxr ，以及一个最近几天刚开始的新库 IRust 。像之前的 rusti 之类的库已经停止维护了。</li>
<li>从  syn 改为 使用 rust-analyzer 来获取类型 ：https://github.com/google/evcxr/commit/b82b7eabb9fe5f4fb7de42c686bd52148ad42a24 (将 ra直接当库使用，缺点是编译太慢，另一种作者想到的可以集成的替代方法是实际引入rust-analyzer二进制文件并使用语言服务器协议与其进行对话，但作者还没这么做)</li>
<li>一本新书：《DATA ANALYSIS WITH RUST NOTEBOOKS 》 https://datacrayon.com/shop/product/data-analysis-with-rust-notebooks/
对应 video 介绍：https://www.youtube.com/watch?v=0UEMn3yUoLo</li>
</ol>
<ul>
<li><a href="https://blog.abor.dev/p/evcxr">https://blog.abor.dev/p/evcxr</a></li>
<li><a href="https://github.com/sigmaSd/IRust">https://github.com/sigmaSd/IRust</a></li>
</ul>
<h2><a class="header" href="#rustcommon--twitter-开源的通用-rust-库" id="rustcommon--twitter-开源的通用-rust-库">rustcommon : Twitter 开源的通用 Rust 库</a></h2>
<p>看来 Twitter 内部也用 Rust 。</p>
<p>这是 Twitter 内部 Rust 项目通用库，包含数据结构/ log/ metrics/ timers/ ratelimiting。</p>
<p><a href="https://github.com/twitter/rustcommon">https://github.com/twitter/rustcommon</a></p>
<p>Twitter 的 另外两个 Rust 开源项目：</p>
<ul>
<li><a href="https://github.com/twitter/rpc-perf">https://github.com/twitter/rpc-perf</a></li>
<li><a href="https://github.com/twitter/rezolus">https://github.com/twitter/rezolus</a> （支持  eBPF）</li>
</ul>
<h2><a class="header" href="#vicis允许你用-rust-操作-llvm-ir" id="vicis允许你用-rust-操作-llvm-ir">vicis：允许你用 Rust 操作 LLVM-IR</a></h2>
<p>目前完成度不高</p>
<p><a href="https://github.com/maekawatoshiki/vicis">https://github.com/maekawatoshiki/vicis</a></p>
<h2><a class="header" href="#delay-timer--04-发布" id="delay-timer--04-发布">delay-timer  0.4 发布</a></h2>
<p>delay-timer是一个基于时间轮算法构建的lib，它可以很方便地管理定时任务，或者周期性地执行任意任务。 </p>
<p>轻松打造一个延迟/周期任务的运行容器。可以想象成crontab，但可以处理同步/异步任务，但支持动态添加/取消/删除/更新， 单个任务支持配置任务的最大并行数量，运行时间等。 </p>
<p>底层运行时基于的smol和tokio（可选的feature），你可以用其中一个来构建你的应用程序。</p>
<p>v0.4.0 新功能:</p>
<ol>
<li>支持动态的修改运行中的任务。 </li>
<li>支持了insert任务后获取句柄<code>TaskInstancesChain</code>，可以动态获取运行中的任务实例<code>TaskInstance</code>。 
<ul>
<li>运行中任务的任务实例可以动态取消。</li>
<li>取消分为三种方式：同步阻塞取消、超时限制取消、异步取消。</li>
<li>支持读取运行中任务的运行状态。</li>
</ul>
</li>
<li>支持获取内部异步子任务进程的输出。</li>
<li>更新依赖:
<ul>
<li>替换 waitmap -&gt; dashmap . </li>
<li>升级 cron_clock . </li>
</ul>
</li>
<li>更新examples: 
<ul>
<li>增加，async-std &amp; tokio 使用案例。</li>
<li>增加，动态取消运行中任务实例案例。 </li>
</ul>
</li>
<li>丰富了文档。 </li>
</ol>
<ul>
<li>repo: <a href="https://github.com/BinChengZhao/delay-timer">delay-timer</a></li>
<li>doc: <a href="https://docs.rs/delay_timer">delay-timer-doc</a></li>
<li>crates: <a href="https://crates.io/crates/delay_timer">delay-timer-crates</a></li>
</ul>
<h2><a class="header" href="#perf-monitor-rs-飞书-rust-团队最近开源的一个跨平台的性能数据采集库" id="perf-monitor-rs-飞书-rust-团队最近开源的一个跨平台的性能数据采集库">perf-monitor-rs： 飞书 Rust 团队最近开源的一个跨平台的性能数据采集库</a></h2>
<p>目前可以对cpu、内存、io和fd的相关数据进行采集。</p>
<p><a href="https://github.com/larksuite/perf-monitor-rs">https://github.com/larksuite/perf-monitor-rs</a></p>
<h2><a class="header" href="#zellij-rust编写的新终端复用工具" id="zellij-rust编写的新终端复用工具">Zellij: Rust编写的新终端复用工具</a></h2>
<p><img src="https://raw.githubusercontent.com/zellij-org/zellij/main/assets/demo.gif" alt="img" /></p>
<ul>
<li><a href="https://zellij.dev/">https://zellij.dev/</a></li>
<li><a href="https://github.com/zellij-org/zellij">https://github.com/zellij-org/zellij</a></li>
</ul>
<h1><a class="header" href="#推荐项目---框架引擎" id="推荐项目---框架引擎">推荐项目 |  框架引擎</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#bevy-05-发布" id="bevy-05-发布">Bevy 0.5 发布</a></h2>
<p>此版本更新较多, 包括：渲染时使用PBR着色器、GLTF 加载器改进、ECS core 重写等</p>
<p><a href="https://bevyengine.org/news/bevy-0-5/">https://bevyengine.org/news/bevy-0-5/</a></p>
<h2><a class="header" href="#rust-gpu---推动-rust成为一流的gpu代码语言和生态系统" id="rust-gpu---推动-rust成为一流的gpu代码语言和生态系统">rust-gpu :  推动 Rust成为一流的GPU代码语言和生态系统</a></h2>
<p>Embark Studios 公司出品</p>
<p>https://github.com/EmbarkStudios/rust-gpu</p>
<h2><a class="header" href="#sixtyfps--用于桌面应用程序和嵌入式设备的全新的图形工具包" id="sixtyfps--用于桌面应用程序和嵌入式设备的全新的图形工具包">SixtyFPS : 用于桌面应用程序和嵌入式设备的全新的图形工具包</a></h2>
<p>工具包包含以下关键组件：</p>
<ul>
<li>对 UI元素 设计友好的 标记语言</li>
<li>具有C ++，Rust和JavaScript的API的运行时库</li>
<li>一个优化的编译器，可将设计编译为本地C ++ / Rust</li>
</ul>
<p>支持编译到 WebAssembly 。GitHub 仓库 Readme 中有在线demo，看着不错。</p>
<ul>
<li><a href="https://github.com/sixtyfpsui/sixtyfps">https://github.com/sixtyfpsui/sixtyfps</a></li>
<li><a href="https://sixtyfps.io/blog/v0.0.6-now-with-ide-support">https://sixtyfps.io/blog/v0.0.6-now-with-ide-support</a></li>
</ul>
<h1><a class="header" href="#开源产品--tensorbase基于rust的现代化开源数据仓库" id="开源产品--tensorbase基于rust的现代化开源数据仓库">开源产品 | TensorBase，基于Rust的现代化开源数据仓库</a></h1>
<p>作者：金明剑 / 后期编辑：张汉东</p>
<blockquote>
<p>编者按：</p>
<p>在当前国产替代背景下，国产开源软件层出不穷。</p>
<p>数据库领域作为占据IT基础架构软件的 20%，目前也有很多国产数据库。比如 国内阿里的 OceanBase、腾讯的 TBase、PingCAP的 TiDB 等。</p>
<p>而作为基础架构软件领域开发难度最大的三个部分，替代周期非常长，因此国产数据库会有很大替代的机会。</p>
<p>TensorBase 是金明剑博士的创业项目，使用 Rust 实现的现代化开源数据仓库，也开始迈出了这艰难的一步。据悉，TensorBase 项目目前已获得世界知名创业投资加速机构的天使轮投资，期待 TensorBase 生态繁荣。</p>
</blockquote>
<hr />
<h2><a class="header" href="#tensorbase是什么" id="tensorbase是什么">TensorBase是什么</a></h2>
<p>这是一个数据以海量方式产生的时代，但我们这个时代的个体和绝大多数企业并没有很好基础设施来发掘这些正在海量产生的数据的价值。TensorBase，从一个现代的全新视角出发，用开源的文化和方式，重新构建一个Rust下的实时数据仓库，服务于这个海量数据时代的数据存储和分析。</p>
<h2><a class="header" href="#tensorbase的优势" id="tensorbase的优势">TensorBase的优势</a></h2>
<ol>
<li>
<p>All in Rust。Rust的优点已经被Rust月刊中的各种文章所反复“安利”，不多赘述。TensorBase认为，Rust是一次系统工程的编程范式革命。范式的革命为我们提供了利用新的工具和方法去构建新的基础设施平台的契机。作为系统语言“试金石”的数据库类软件，Rust不应缺席。TensorBase已经在日常测试中经历数十TB的数据注入锤炼，是目前Rust社区中，面向用户特别是中小企业实际场景深度优化的、生产完成度最高的通用数据仓库类项目。</p>
</li>
<li>
<p>开箱即用。TensorBase已经支持从数据插入或导入到查询完整数据仓库流程，具备了较高的早期完成度。从您看到本文的这一刻开始，就可以从TensorBase的Release页下载相关Linux环境下的二进制文件，进行尝试。（Windows 10的WSL2目前应该也是能用的，欢迎反馈！）</p>
</li>
<li>
<p>ClickHouse协议兼容。ClickHouse作为一个C++编写的数据仓库，已经为国内外的很多企业所使用。TensorBase则使用Rust语言从头开始实现了一个高性能的ClickHouse SQL方言解析器和TCP通讯协议栈。ClickHouse TCP客户端可以无缝连接TensorBase。所以，如果你有ClickHouse的使用经验，你可以零学习成本地使用TensorBase。即使没有用过ClickHouse，你也很容易找到相关学习资料，这令你能轻松进入TensorBase。</p>
</li>
<li>
<p>性能为先。TensorBase期望通过新的软件和系统设计将现代硬件的所有潜力发挥出来。TensorBase首次在核心链路代码上实现了“F4”：Copy-free，Lock-free，Async-free，Dyn-free（无动态对象分发）。<a href="https://github.com/tensorbase/tensorbase#benchmarks">初步的性能评估</a>显示：在14.7亿行的纽约出租车数据集上，TensorBase的简单查询的性能上已经领先ClickHouse。当然，在复杂的查询上，TensorBase离ClickHouse还有一定差距，但这正是我们开源社区所想要推进的。</p>
</li>
<li>
<p>化繁为简。目前的大数据系统使用非常复杂，即使想运行一个最简单的系统，都需要配置大量难以理解的参数或者安装大量第三方依赖。</p>
<ul>
<li>对于用户，除了现在已经达成的开箱即用，TensorBase希望系统在运行时能在自治运行，而不是依赖运维管理员。</li>
<li>对于开发者，TensorBase希望将贡献门槛降低。整个项目架构设计简洁高效（更多信息参见后文），项目外依赖很少，完全重新编译（cargo clean到cargo build）的单机时间在1分钟之内。（大数据系统或者C++数据库的完整构建时间往往以小时计。）</li>
</ul>
</li>
<li>
<p>互联未来。TensorBase在核心上改造了Apache Arrow和DataFusion，无缝支持Arrow格式查询、分析和传输。Arrow格式作为越来越广泛采用的大数据交换中间格式，已经被多个数据库及大数据生态平台所支持。TensorBase在引擎上兼容Arrow，未来可以同时支持云原生和云中立场景下的数据仓库体验，提供存储中立的数据湖服务。</p>
</li>
</ol>
<h2><a class="header" href="#tensorbase的架构" id="tensorbase的架构">TensorBase的架构</a></h2>
<p><img src="chapter_4/./image/tensorbase/base_arch.jpg" alt="base_demo" />
TensorBase整体架构</p>
<ul>
<li>
<p>Base Server</p>
<p>TensorBase服务接口层。对外提供数据的接口服务，比如数据的写入和查询入口。TensorBase创造性的实现了世界上第一个非C++的ClickHouse TCP协议服务栈，可以支持ClickHouse客户端（clickhouse-client命令行）以及native协议语言驱动的直接连接。同时，Base Server是第一个async中立的Rust高性能服务器。Base Server基于改造的Actix事件循环，在服务的实现中完全不使用async，在提供绝佳的可调试性的同时，评测性能也大幅超过基于tokio默认async表达层的实现。未来可以引入非tokio的网络io层实现。</p>
</li>
<li>
<p>Base Meta/Runtime/Storage</p>
<p>TensorBase的元数据层、运行时层和存储层。在存储层，TensorBase非经典的列式存储。这其中最重要的，我们给出了一个反重力设计：No LSM。我们不再使用在目前开源数据库及大数据平台流行的LSM Tree（Log Structured Merge Tree）数据结构。而是使用一种我们自己称之为Partition Tree的数据结构，数据直接写入分区文件，在保持append only写入性能的同时，避免了LSM结构的后续compact开销。得益于现代Linux内核的支持和巧妙的写入设计，我们在用户态（User-space）核心读写链路上不使用任何锁（Lock-free），最大程度的发挥了高并发网络服务层所提供的能力，可以提供超高速数据写入服务。</p>
</li>
<li>
<p>Base Engine</p>
<p>TensorBase的引擎层。TensorBase使用改造过的Apache Arrow和DataFusion，并创造性的将底层存储适配到Arrow格式，实现了Zero Copy的数据查询。当然，目前的适配性存储策略，还只算是一个现在进行中的次优解，TensorBase未来会对存储层进行持续迭代，提供更多与时俱进的优化。同时，TensorBase也将进一步地优化帮助Arrow/DataFusion社区优化其查询引擎的性能，和社区一起成长。</p>
</li>
<li>
<p>其他</p>
<p>TensorBase还有一些基础性的组件，比如：</p>
<ul>
<li>base，通用工具库；</li>
<li>lang，语言层（目前主要实现一个ClickHouse兼容解析和表示层）。</li>
<li>lightjit，类表达式JIT引擎，未来可扩展至高性能和安全可控的用户定义函数UDF（User Defined Functions）层。
TensorBase未来将进一步开发和开放自己的高性能基础件，为Rust社区贡献一些独特的高性能可复用基础设施。</li>
</ul>
<p>最后，架构图中的虚线连接尚未实现，放在这里提供给大家一个全景式的架构蓝图。</p>
</li>
</ul>
<h2><a class="header" href="#tensorbase的进展" id="tensorbase的进展">TensorBase的进展</a></h2>
<p><img src="chapter_4/./image/tensorbase/base_demo.gif" alt="base_demo" />
<em>TensorBase开箱即用演示</em></p>
<p>如上图所示，TensorBase已经能提供开箱即用的单机数据仓库服务，欢迎试用反馈。</p>
<p>在未来的几天内，我们将完成通过TPC-H评测所需的存储层支持（主要是String类型的存储支持），并提供初步的TPC-H测试结果。</p>
<p>近期线路图包括如下几个有趣的方向：</p>
<ol>
<li>分布式集群。
基于DataFusion的Ballista，很容易实现一个类ClickHouse的简易（半人工）分布式集群方案。然而，我们将这作为开始，TensorBase希望提供新的思维和方向，让分布式查询这件事能做的简单高效、易于开发和维护。</li>
<li>存储层增强。引入主键等高级选项。</li>
<li>Arrow和Data Fusion查询内核性能改进。</li>
<li>ClickHouse HTTP通讯协议及其他查询前端增强。</li>
<li>单机可靠性加固。</li>
</ol>
<h2><a class="header" href="#加入社区" id="加入社区">加入社区</a></h2>
<p>TensorBase相信，一个能适应时代的基础设施，如同Rust语言本身一样，一定是开源和创新的。欢迎大家到TensorBase社区来分享自己的观点和代码，见证对未来数据仓库的思考和迭代。</p>
<ul>
<li>项目地址：https://github.com/tensorbase/tensorbase</li>
<li>Discord服务器：https://discord.gg/E72n2jzgKD</li>
<li>Slack频道：https://join.slack.com/t/tensorbase/shared_invite/zt-ntwmjvpu-TQ9drOdUwNJWmUTXvxMumA</li>
<li>微信群</li>
</ul>
<p>扫码加微信群：</p>
<p><img src="chapter_4/./image/tensorbase/base_wechat.png" alt="扫码加入微信群" /></p>
<p>TensorBase将推出更多的系列文章，以期让大家更深入的理解项目以及Rust语言在项目中的使用，也欢迎所有有兴趣的小伙伴参与到整个开源工程当中。</p>
<p>加入TensorBase社区，一起构建Rust大数据生态的下一个五年！</p>
<hr />
<h3><a class="header" href="#作者简介-1" id="作者简介-1">作者简介：</a></h3>
<p>金明剑，TensorBase项目创建人，中国科学院大学博士，17年商业和高性能软件开发经验，Eclipse平台先锋，Scala语言先锋，Scala基金会2010年首次入选谷歌编程之夏的项目完成人，阿里云天池工程系列赛多项赛事记录的保持者。在大数据基础设施、语言和高性能系统等方面长期保持系统性地思考及研究。</p>
<h1><a class="header" href="#开源产品--eclipse-zenoh-助力雾计算和边缘计算" id="开源产品--eclipse-zenoh-助力雾计算和边缘计算">开源产品 | eclipse zenoh 助力雾计算和边缘计算</a></h1>
<p>原作者：Angelo @ adlinktech.com  / 编辑整理：张汉东</p>
<blockquote>
<p>编者按：</p>
<p>凌华科技（AdlinkTech）公司总部位于台湾，并在美国、新家坡、北京、深圳、上海等40多个国家和地区设立分支机构。</p>
<p>在 2020年7月，凌华科技(ROS 2技术指导委员会成员)推动 Eclipse Cyclone DDS (OMG数据分发服务规范的实现) 成为 ROS Tier-1  中间件，将要书写机器人和IoT系统的未来。而 eclipse zenoh 正是 CychoneDDS 的姊妹项目。</p>
</blockquote>
<hr />
<p><a href="https://projects.eclipse.org/proposals/eclipse-zenoh">eclipse zenoh （读： /zeno/ ）</a> ，提供了零开销的Pub/Sub、Store/Query 和 计算。</p>
<p>zenoh 统一了 动态/静止/使用中的数据并提供计算结果。它颇有分寸地将传统的Pub/Sub与地理分布的存储、查询和计算融合在一起，同时保留了远远超出任何主流协议栈的时间和空间效率水平。</p>
<p>官网是 <a href="http://zenoh.io/">zenoh.io</a> 。</p>
<p>GitHub代码仓库 <a href="https://github.com/eclipse-zenoh/zenoh">eclipse-zenoh/zenoh</a> 。</p>
<p>2020 年 12 月 <a href="https://edgenative.eclipse.org/">Eclipse Edge Native</a> 工作组启动，并将 Zenoh 引入 Eclipse 。并用 Rust 对 zenoh 进行重写。</p>
<h4><a class="header" href="#why-rust" id="why-rust">Why Rust</a></h4>
<p>zenoh的第一个版本是用<code>OCaml</code>（一种纯的 ML 函数式编程语言）编写的。 OCaml 使开发者能够非常快速地进行实验并具有良好的性能。 但是，zenoh 团队从社区收到的主要反馈之一是，很少有人知道这种编程语言，这限制了人们的贡献。 此外，zenoh团队还希望使zenoh更快更小。 一个显而易见的选择是用<code>C / C ++</code>编写新版本，但是zenoh团队不想失去的是使用<code>OCaml</code>所享有的安全性。 另外，如果不得不离开心爱的<code>OCaml</code>，也不想完全放弃高级抽象。 zenoh团队还想避免运行时间长和垃圾回收器过多的语言。 早在2015年，zenoh团队就已经看过Rust了，但那时他们并不觉得对他们而言是正确的选择。 2018 Edition 在编程语言中引入的改进以及异步的引入使 Rust 成为了 zenoh 的理想选择。在使用 Rust 重写以后，性能得到了很大的提升。</p>
<h1><a class="header" href="#概述-1" id="概述-1">概述</a></h1>
<p>zenoh 将动态数据、使用中数据、静态数据与计算整合。它巧妙地将传统的发布/订阅与地理上分散的储存、查询和计算融合，同时保有远胜任何主流堆栈的时间和空间效率。</p>
<p>随着连网设备的数量稳定增加，业界在计算、储存和通信能力方面遇到前所未有的异质性，并且在产生数据以及必须交付和使用数据的规模方面面临新的挑战。</p>
<p>此外，基于性能、效率和隐私考虑，人们越来越希望使数据处理尽可能靠近来源，同时方便存取远距离的应用程序。换句话说，我们正经历主流<a href="https://perspectives.tech/2019/12/10/architectural-liberum-arbitrium/">架构转换</a>，从以云端为中心的模式（从云端到雾端储存、处理和采集数据）变成<a href="https://edgenative.eclipse.org/">以边缘为中心</a>的模式（在对性能、能源效率和安全性最有意义的位置储存和处理数据）。</p>
<p><strong>zenoh</strong> 的目的在于满足必须以可扩展、高效率且位置透明化的数据方式处理动态数据、静态数据和计算的应用程序的需求。</p>
<p><strong>zenoh</strong> 的目的在于：</p>
<ul>
<li>提供小型原语集合以处理动态数据、静态数据和计算。</li>
<li>全面控制储存位置和后端技术整合。</li>
<li>将网络负担最小化 – 数据信息的最小线路负担为 4 字节。</li>
<li>支持极度受限的装置 – 在 Arduino Uno 上的占用空间为 300 字节。</li>
<li>允许数据交换模式和排程交涉以支持低工作周期装置。</li>
<li>提供丰富的抽象化集合，在整个系统中分配、查询和储存数据。</li>
<li>提供极低延迟和高传输量。我们也提供 zenoh 的效率相对于 MQTT 等主流协议的分析与实证比较。</li>
<li>提供称为 zenoh-net 的低端 API，让您全面控制 zenoh 原语。</li>
</ul>
<h1><a class="header" href="#zenoh-关键概念" id="zenoh-关键概念">zenoh 关键概念</a></h1>
<h2><a class="header" href="#部署单元" id="部署单元">部署单元</a></h2>
<p>zenoh 提供三种部署单元：</p>
<ul>
<li>对等方（peers）。用于在 对等网络（peer-to-peer）、网状（mesh）拓扑网络和其他节点通信，也可以通过路由器与广泛的系统通信。</li>
<li>客户（clients）。用于连接单个路由器（或点）来和系统其他部分通信。</li>
<li>路由器（routers）。用于在 client和peers之间、集团拓扑和网状拓扑网络之间路由数据。</li>
</ul>
<h2><a class="header" href="#用户-api" id="用户-api">用户 API</a></h2>
<p>zenoh 提供 两级 API 。</p>
<p><img src="chapter_4/./image/zenoh/zenoh-stack.png" alt="zenoh-stack" /></p>
<h3><a class="header" href="#zenoh-net" id="zenoh-net">zenoh-net</a></h3>
<p>实现能够在数据链路，网络或传输层之上运行的网络层。</p>
<p>zenoh-net支持点对点和路由通信，提供了允许Pub/Sub（Push）通信以及 Query/Reply (Pull) 通信的关键原语。它支持分段和有序可靠交付，并为 <a href="https://docs.ros.org/en/foxy/Tutorials/Discovery-Server/Discovery-Server.html">Discovery( ROS2 Discovery Service )</a>提供了可插入的侦查抽象。</p>
<p>zenoh-net定义并建立在会话协议的基础上，该会话协议为有序尽力而为（ best effort）和具有不受限制的 MTU 的可靠信道提供了抽象，而 MTU 与底层无关。</p>
<p>zenoh-net层仅关心数据传输，不关心数据内容或存储数据。</p>
<p>提供的原语：</p>
<ul>
<li><strong>Write</strong>：将实时数据推送给相对应的订阅者。</li>
<li><strong>Subscribe</strong>：订阅实时数据。</li>
<li><strong>Query</strong>：从匹配的查询对象中查询数据。</li>
<li><strong>Queryable</strong>：能够响应查询的实体。</li>
</ul>
<h3><a class="header" href="#zenoh" id="zenoh">zenoh</a></h3>
<p>zenoh 层为 Pub/Sub 和分布式查询提供了高级API，以更简单和更面向数据的方式提供与zenoh-net API相同的抽象，并提供所有构建块来创建分布式存储。 zenoh层知道数据内容，并且可以应用基于内容的过滤和代码转换。</p>
<p>它处理数据表示编码和代码转换，并提供地理分布式存储和分布式计算值的实现。 zenoh原生支持一系列数据编码，例如JSON，Properties，Relational，Raw等，以及跨支持格式的转码。 它还基于URI语法定义了规范的查询语法。 zenoh层还提供了存储后端插件API，以简化第三方存储技术的集成。 当前支持的存储后端是Memory，MySQL，MariaDB，PostgreSQL，SQLite和InfluxDB。默认情况下，地理分布式存储在最终一致性下工作。 用户可以利用仲裁（<em>Quorum</em>）机制实现更强的一致性。</p>
<p>提供的原语：</p>
<ul>
<li><strong>Put</strong>：将实时数据推送到匹配的订阅者和存储。 （相当于zenoh-net write）</li>
<li><strong>Subscribe</strong>：实时数据的订阅者。 （相当于zenoh-net订阅）</li>
<li><strong>Get</strong>：从匹配的存储和演算中获取数据。 （相当于zenoh-net查询）</li>
<li><strong>Storage</strong>：一个zenoh-net 订阅者侦听要存储的实时数据，以及一个zenoh-net 可查询以响应匹配的get请求的组合。</li>
<li><strong>eval</strong>：能够响应请求的实体。 通常用于按需提供数据或构建RPC系统。 （相当于zenoh-net可查询）</li>
</ul>
<h2><a class="header" href="#zenoh-目前的一些特性" id="zenoh-目前的一些特性">zenoh 目前的一些特性</a></h2>
<p><strong>更好的协议支持</strong>。在利用网络特定功能的同时将 zenoh 移植到不同类型的网络非常简单。用户提供的附件与数据和查询可以一起携带。 zenoh应用程序可以使用这些附件来扩展协议，或例如增加用户级别的安全性。</p>
<p><strong>通用的点对点和客户通信</strong>。应用程序可以在运行时决定其行为类似于 对等方（peer） 还是 客户（client）。对等方在彼此之间路由信息，也可以代表客户进行路由，换句话说，对等方的行为类似于路由器。对等网络通信支持任意连接图，并在特殊情况下支持集团。</p>
<p><strong>基于Closure的发现</strong>。侦察（<strong>scouting</strong>）协议支持zenoh中的发现，以便简化想要利用集团（clique）连接性的系统的部署，在多播不可用或不希望使用多播的情况下，现在支持基于Closure的发现。换句话说，从单个对等方开始，可以发现其 Closure，或者换句话说，可以从此起点直接或间接地到达对等点。</p>
<p><strong>基于区域（Region）的路由</strong>。这实际上意味着两件事：（1）建立和维护路由表随区域大小缩放所需的路由信息，以及（2）每个区域都可以决定是否要在任意连接图上进行路由的集团。通过允许在区域内使用最合适的路由技术，这种路由方法将极大地提高可伸缩性和性能。</p>
<p>目前，Zenon 发布了 代号为 Aithusa 的版本，提供了<a href="https://github.com/eclipse-zenoh/zenoh-plugin-dds"> DDS Plugin</a> 和 <a href="https://docs.ros.org/en/foxy/index.html">ROS2</a> 的集成。</p>
<h3><a class="header" href="#参考-2" id="参考-2">参考</a></h3>
<ul>
<li>
<p><a href="http://zenoh.io/docs/overview/">http://zenoh.io/docs/overview/</a></p>
</li>
<li>
<p><a href="http://zenoh.io/blog/2020-06-29-zenoh-tidings">http://zenoh.io/blog/2020-06-29-zenoh-tidings</a></p>
</li>
<li>
<p><a href="http://zenoh.io/blog/2020-10-08-aithusa/">http://zenoh.io/blog/2020-10-08-aithusa/</a></p>
</li>
<li>
<p><a href="https://support.huawei.com/view/contentview!getFileStream.action?mid=SUPE_DOC&amp;viewNid=EDOC0000605284&amp;nid=EDOC0000605284&amp;partNo=j00d&amp;type=htm#term151">术语参考</a></p>
</li>
</ul>
<h1><a class="header" href="#unsafe-rust-编码技巧--01" id="unsafe-rust-编码技巧--01">Unsafe Rust 编码技巧 | 01</a></h1>
<p>编辑：张汉东</p>
<blockquote>
<p>汇总一些 Unsafe Rust 编码技巧，欢迎补充。</p>
</blockquote>
<hr />
<h2><a class="header" href="#编写-unsafe-rust-的标准规范" id="编写-unsafe-rust-的标准规范">编写 Unsafe Rust 的标准规范</a></h2>
<p>来源：<a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/func/typed.rs">wasmtime</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Invokes this WebAssembly function with the specified parameters.
    ///
    /// Returns either the results of the call, or a [`Trap`] if one happened.
    ///
    /// For more information, see the [`Func::typed`] and [`Func::call`]
    /// documentation.
    ///
    /// # Panics
    ///
    /// This function will panic if it is called when the underlying [`Func`] is
    /// connected to an asynchronous store.
    pub fn call(&amp;self, params: Params) -&gt; Result&lt;Results, Trap&gt; {
        assert!(
            !cfg!(feature = &quot;async&quot;) || !self.func.store().async_support(),
            &quot;must use `call_async` with async stores&quot;
        );
        unsafe { self._call(params) }
    }

<span class="boring">}
</span></code></pre></pre>
<p>当函数中调用了 Unsafe 函数，必须对其进行安全抽象。</p>
<p>上面代码示例中，使用 <code>assert!</code> 宏，将 <code>_call</code>调用控制在了安全边界内，所以函数 <code>call</code> 目前是一个安全的函数，所以不需要在 <code>fn</code> 前面增加 <code>unsafe</code> 标签。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    unsafe fn _call(&amp;self, params: Params) -&gt; Result&lt;Results, Trap&gt; {
        // Validate that all runtime values flowing into this store indeed
        // belong within this store, otherwise it would be unsafe for store
        // values to cross each other.
        if !params.compatible_with_store(&amp;self.func.instance.store) {
            return Err(Trap::new(
                &quot;attempt to pass cross-`Store` value to Wasm as function argument&quot;,
            ));
        }

        // ...
        // ignore others codes
        // ...

        // This can happen if we early-trap due to interrupts or other
        // pre-flight checks, so we need to be sure the parameters are at least
        // dropped at some point.
        if !called {
            drop(params.assume_init());
        }
        debug_assert_eq!(result.is_ok(), returned);
        result?;

        Ok(ret.assume_init())
    }
<span class="boring">}
</span></code></pre></pre>
<p>对于 <code>_call</code> 函数来说，因为无法在函数内验证所有传入的运行时值是否在合法的安全边界，所以需要将其标记为 Unsafe 函数，即在 <code>fn</code> 前面加上 <code>unsafe</code> 标签。除此之外，还必须在函数内脆弱的地方，加上必须的注释来说明什么情况下会突破安全边界。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trait implemented for types which can be arguments and results for
/// closures passed to [`Func::wrap`] as well as parameters to [`Func::typed`].
///
/// This trait should not be implemented by user types. This trait may change at
/// any time internally. The types which implement this trait, however, are
/// stable over time.
///
/// For more information see [`Func::wrap`] and [`Func::typed`]
pub unsafe trait WasmTy {
    #[doc(hidden)]
    type Abi: Copy;
    #[doc(hidden)]
    #[inline]
    fn typecheck(ty: crate::ValType) -&gt; Result&lt;()&gt; {
        if ty == Self::valtype() {
            Ok(())
        } else {
            bail!(&quot;expected {} found {}&quot;, Self::valtype(), ty)
        }
    }
    #[doc(hidden)]
    fn valtype() -&gt; ValType;
    #[doc(hidden)]
    fn compatible_with_store(&amp;self, store: &amp;Store) -&gt; bool;
    #[doc(hidden)]
    fn into_abi(self, store: &amp;Store) -&gt; Self::Abi;
    #[doc(hidden)]
    unsafe fn from_abi(abi: Self::Abi, store: &amp;Store) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>对于上面的 trait ，因为是内部使用，随时可能发生改变。所以标记为 Unsafe ，并加上注释提示该 trait 不该又库用户自己实现，而是由维护者在内部为指定类型实现，这些类型应该是稳定的。如果用户想自己实现，那么要明白它是 Unsafe 的。</p>
<p>所以，不一定是出于内存安全才指定 Unsafe ，也可以作为一种和库用户的约定。</p>
<h2><a class="header" href="#在-ffi-时方便调用-rust-闭包" id="在-ffi-时方便调用-rust-闭包">在 FFi 时方便调用 Rust 闭包</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::os::raw::c_void;

pub type Callback = unsafe extern &quot;C&quot; fn(user_data: *mut c_void, arg: i32) -&gt; i32;

pub unsafe extern &quot;C&quot; fn execute_a_closure(arg: i32, cb: Callback, user_data: *mut c_void) -&gt; i32 {
    cb(user_data, arg)
}

/// 获取一个可以用作[`Callback`]的函数指针，该函数指针将指向闭包的指针作为其`user_data`。
pub fn raw_callback&lt;F&gt;(_closure: &amp;F) -&gt; Callback
where
    F: FnMut(i32) -&gt; i32,
{
    unsafe extern &quot;C&quot; fn wrapper&lt;P&gt;(user_data: *mut c_void, arg: i32) -&gt; i32
    where
        P: FnMut(i32) -&gt; i32,
    {
        let cb = &amp;mut *(user_data as *mut P);

        cb(arg)
    }

    wrapper::&lt;F&gt;
}

fn main() {
    let mut calls = 0;
    let mut closure = |arg: i32| {
        calls += 1;
        arg
    };

    unsafe {
        let func = raw_callback(&amp;closure);

        let got = execute_a_closure(42, func, &amp;mut closure as *mut _ as *mut c_void);

        assert_eq!(got, 42);
        assert_eq!(calls, 1);
    }
}
</code></pre></pre>
<p>经过 Miri 检测没有 UB。</p>
<h1><a class="header" href="#五月刊" id="五月刊">五月刊</a></h1>
<p><img src="chapter_5/../image/rust_magazine3.png" alt="logo" /></p>
<p>目录顺序排名不分先后！</p>
<h2><a class="header" href="#发刊通告-5" id="发刊通告-5">发刊通告</a></h2>
<ul>
<li><a href="chapter_5/./announce.html">发刊通告</a></li>
</ul>
<h2><a class="header" href="#rust-资讯-1" id="rust-资讯-1">Rust 资讯</a></h2>
<ul>
<li><a href="chapter_5/./lang.html">官方动态</a></li>
<li><a href="chapter_5/./hots.html">社区热点</a></li>
<li><a href="chapter_5/./events.html">活动回顾</a></li>
<li><a href="chapter_5/./jobs.html">本月招聘</a></li>
<li><a href="chapter_5/./six-years-of-rust.html">官方 | Rust 发布六周年</a></li>
<li><a href="chapter_5/./rusts-most-unrecognized-contributor.html">Rust 贡献名单上的无名英雄</a></li>
</ul>
<h2><a class="header" href="#rust-与-学术-1" id="rust-与-学术-1">Rust 与 学术</a></h2>
<ul>
<li><a href="chapter_5/./pl.html">漫谈编程语言的设计和实现</a></li>
</ul>
<h2><a class="header" href="#rust-in-production-4" id="rust-in-production-4">Rust in Production</a></h2>
<ul>
<li><a href="chapter_5/./hw_StratoVirt_vcpu.html">华为 | StratoVirt VCPU管理-Rust线程同步的实现</a></li>
<li><a href="chapter_5/./rust-memory-troubleshootting.html">蚂蚁集团 ｜ 如何在生产环境排查 Rust 内存占用过高问题</a></li>
<li><a href="chapter_5/./rust-epoll-rdma.html">Datenlord | Rust实现RDMA异步编程（一）：基于<code>epoll</code>实现RDMA 异步操作</a></li>
<li><a href="chapter_5/./facebook_with_rust.html">Facebook | 应用 Rust 简史</a></li>
<li><a href="chapter_5/./rust_grpc_load_balancing.html">Truelayer | Rust 中的 gRPC 负载均衡</a></li>
</ul>
<h2><a class="header" href="#学习园地-4" id="学习园地-4">学习园地</a></h2>
<h3><a class="header" href="#新手入门-1" id="新手入门-1">新手入门</a></h3>
<ul>
<li><a href="chapter_5/./learn.html">学习资源</a></li>
<li><a href="chapter_5/./Things_you_can_not_do_in_Rust.html">Rust 中无法办到的事情(以及如何替代)</a></li>
<li><a href="chapter_5/./proc_macro_workshop_guide_for_builder_project.html">Rust过程宏系列教程 | Proc Macro Workshop 之 Builder 实现</a></li>
<li><a href="chapter_5/./running_rust_on_android.html">在 Android 中运行 Rust </a></li>
<li><a href="chapter_5/./ink_01.html">Rust 与 区块链 | <code>ink!</code> 编程实战（一）: 初识 <code>ink!</code></a></li>
</ul>
<h3><a class="header" href="#语言特性与技巧-1" id="语言特性与技巧-1">语言特性与技巧</a></h3>
<ul>
<li><a href="chapter_5/./faq.html">常见问题汇总</a></li>
<li><a href="chapter_5/./tips.html">语言技巧</a></li>
<li><a href="chapter_5/./rust-gat.html">了解一点关于泛型关联类型(GAT)的事</a></li>
<li><a href="chapter_5/./rust-runtime-and-ABI.html">Rust Runtime 与 ABI</a></li>
</ul>
<h3><a class="header" href="#算法" id="算法">算法</a></h3>
<ul>
<li><a href="chapter_5/./cache_and_recursion_memoization.html">借鉴数据库缓存解决动态规划难题</a></li>
</ul>
<h3><a class="header" href="#rust-与-操作系统" id="rust-与-操作系统">Rust 与 操作系统</a></h3>
<ul>
<li><a href="chapter_5/./kernel_huge_page_subsystem.html">一种有效的页表系统抽象设计</a></li>
<li><a href="chapter_5/./rpi_os.html">学习笔记 ｜ 树莓派 Rust 嵌入式操作系统 之 驱动：GPIO 和 UART</a></li>
</ul>
<h3><a class="header" href="#主题专栏rust-探索系统本原-1" id="主题专栏rust-探索系统本原-1">【主题专栏】Rust 探索系统本原</a></h3>
<ul>
<li><a href="chapter_5/./rust-to-system-essence-lang-generic.html">透过 Rust 探索系统的本原：泛型</a></li>
</ul>
<h2><a class="header" href="#开源项目巡礼-1" id="开源项目巡礼-1">开源项目巡礼</a></h2>
<ul>
<li><a href="chapter_5/./github_trending.html">GitHub 趋势榜</a></li>
<li><a href="chapter_5/./tool_libs.html">推荐项目 ｜ 基础工具库</a></li>
<li><a href="chapter_5/./frameworks.html">推荐项目 |  框架引擎</a></li>
</ul>
<h2><a class="header" href="#rust-vs-security-1" id="rust-vs-security-1">Rust vs Security</a></h2>
<ul>
<li><a href="chapter_5/./rust-security-part-2.html">Rust生态安全漏洞总结系列 | Part 2</a></li>
<li><a href="chapter_5/./rust-makes-malware-stronger.html">Rust 与 安全 | Rust 让恶意软件也变强了</a></li>
</ul>
<h1><a class="header" href="#发刊通告-6" id="发刊通告-6">发刊通告</a></h1>
<p>编辑：张汉东</p>
<h3><a class="header" href="#五月发刊通告" id="五月发刊通告">五月发刊通告</a></h3>
<p>匆忙的五月即将过去，《 RustMagazine 中文精选 》2021 年第五期发布了! </p>
<p>随着五月刊的发布，时光也马上步入六月，意味着2021年半年即将过去。</p>
<p>祝大家抓紧每一份时光，活在当下。无论如何，加油吧！</p>
<p>本期遗憾的是，Rust 六周年社区征文无一响应，也许大家都很忙，但期望遇到你与 Rust 的故事。欢迎随时投稿。</p>
<h3><a class="header" href="#本刊动态-1" id="本刊动态-1">本刊动态</a></h3>
<p><strong>（GitHub Page）现在已经支持 Rss 订阅</strong></p>
<ol>
<li>
<p>订阅地址：<a href="https://rustmagazine.github.io/rust_magazine_2021/rss.xml">https://rustmagazine.github.io/rust_magazine_2021/rss.xml</a></p>
</li>
<li>
<p>复制订阅地址到你最喜欢的订阅工具开始订阅。</p>
</li>
</ol>
<p>语雀平台自动支持邮件订阅。</p>
<h3><a class="header" href="#上期四月刊访问数据统计小结" id="上期四月刊访问数据统计小结">上期（四月刊）访问数据统计小结</a></h3>
<p><strong>用户数</strong></p>
<ul>
<li>新用户新增 2017</li>
</ul>
<p><strong>浏览量：</strong></p>
<ul>
<li>网页浏览量 ： 14,008</li>
</ul>
<p><strong>读者分布地区排名：</strong></p>
<ul>
<li>亚洲，新用户增加 1,809</li>
<li>美国，新用户增加 132</li>
<li>欧洲，新用户增加 52</li>
</ul>
<p><strong>四月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/improve-std-slice-binary-search.html">《优化 Rust 标准库的 binary_search》</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_async_os_opt.html">蚂蚁集团 | 异步化OS：利用 async/await 带来 10 倍性能提升</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_trait.html">蚂蚁集团 | Trait 使用及实现分析</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/hw_bin_opt.html">华为 | Rust 编译后二进制大小和常用优化方式</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/tensorbase.html">开源产品 | TensorBase，基于Rust的现代化开源数据仓库</a></li>
</ul>
<p><strong>三月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li>《华为 | 基于 Rust 的下一代虚拟化平台 StratoVirt》</li>
<li>《华为 ｜ 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型》</li>
<li>《透过 Rust 探索系统本原 : 并发篇》</li>
<li>《蚂蚁集团 | Rust CPU Affinity 初探》</li>
<li>《Rust 中使用 MySql》</li>
</ul>
<p><strong>二月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<p>注： 一月刊的 《图解 Rust 所有权》文章依旧最受欢迎，作者：肖猛 </p>
<ul>
<li>《 前端入门 ｜ Rust 和 WebAssembly》，作者: 陈鑫(lencx)</li>
<li>《 实践案例 | 使用 Bevy 游戏引擎制作炸弹人》，作者：Cupnfish</li>
<li>《 蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考 》， 作者：evenyag</li>
<li>《 华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景》，作者：俞一峻等三位</li>
<li>《 DatenLord ｜ Linux 全新异步接口 io_uring 的 Rust 生态盘点》，作者：施继成</li>
</ul>
<p>后续也期待大家投稿。欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！</p>
<h1><a class="header" href="#rust-官方动态" id="rust-官方动态">Rust 官方动态</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#rust基金会成员开放申请了" id="rust基金会成员开放申请了">Rust基金会成员开放申请了：</a></h2>
<p><a href="https://foundation.rust-lang.org/info/become-a-member/">https://foundation.rust-lang.org/info/become-a-member/</a></p>
<h2><a class="header" href="#rust-152-稳定版发布" id="rust-152-稳定版发布">Rust 1.52 稳定版发布</a></h2>
<p>要点：</p>
<ol>
<li>unsafe_op_in_unsafe_fn lint 稳定。当前 Rust 把 unsafe 函数本身当作一个 unsafe block，该lint的出现就是为来改变这种行为： 现在要求，unsafe函数中调用unsafe函数，必须再加一个 unsafe block。 该lint现在是 allow-by-default ，就是说，默认不会更改 当前行为，只有你用 #[deny(unsafe_op_in_unsafe_fn)] 或 #[warn(unsafe_op_in_unsafe_fn)] 才会允许更改当前行为。 </li>
<li>允许可变数组引用直接转换为可变/不可变原生指针。</li>
<li>编译器后端升级到 LLVM12</li>
<li>现在所有的整数除法和余数操作都是 const fn 了</li>
<li>稳定了 str/slice/char 类型的多个 API ，并且部分 API 都是 const fn 都了</li>
<li>Rustdoc markdown 现在支持 task list 了</li>
<li>cargo test 支持传入多个文件</li>
</ol>
<p>兼容性变更：</p>
<ol>
<li>RUSTC_BOOTSTRAP 已经在 build.rs 中被禁止设置</li>
<li>代码中要使用了 proc-macro-hack  可能会导致 panic，需要执行 cargo unpdate -p proc-macro-hack 解决此问题</li>
</ol>
<p><a href="https://blog.rust-lang.org/2021/05/06/Rust-1.52.0.html">https://blog.rust-lang.org/2021/05/06/Rust-1.52.0.html</a></p>
<h2><a class="header" href="#rust-1521-发布" id="rust-1521-发布">Rust 1.52.1 发布</a></h2>
<p>此版本主要解决增量编译中的一个错误，该错误在1.52.0中变成了编译器错误。</p>
<p>建议所有Rust用户，包括当前使用1.52.0之前的稳定版本的用户，升级到1.52.1或禁用增量编译。</p>
<p>目前只是一个临时的修复计划，目前此错误还未被完全修复，毕竟增量编译功能是刚需。主要是修复 verify-ich 相关 issues，目前还有很多 ：<a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+unstable+fingerprints">https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+unstable+fingerprints</a></p>
<p>目前官方正在积极修复此错误。 Rust团队还将制定计划，以确保在将来有更好的bug跟踪系统，既可以防止此类情况再次发生，也可以通过更准确地跟踪bug来进一步提高我们版本的稳定性。 </p>
<p><a href="https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html">https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html</a></p>
<h2><a class="header" href="#官方宣布--rust-2021-edition-plan" id="官方宣布--rust-2021-edition-plan">官方宣布  Rust 2021 edition plan</a></h2>
<p><a href="https://blog.rust-lang.org/2021/05/11/edition-2021.html">https://blog.rust-lang.org/2021/05/11/edition-2021.html</a></p>
<p>之前翻译版本 ：<a href="https://mp.weixin.qq.com/s/C36k7_ZEcgpesAYmqDdV-w">https://mp.weixin.qq.com/s/C36k7_ZEcgpesAYmqDdV-w</a></p>
<p>P.S 大家要不要听听 Rust Edition 之歌:</p>
<p><a href="https://smallcultfollowing.com/babysteps/blog/2021/05/26/edition-the-song/">https://smallcultfollowing.com/babysteps/blog/2021/05/26/edition-the-song/</a></p>
<h2><a class="header" href="#新的-rfc-被合并-const-ub" id="新的-rfc-被合并-const-ub">新的 RFC 被合并： const-ub</a></h2>
<p>为了在 CTFE 的时候进行  UB-checking</p>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md">https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md</a></p>
<h2><a class="header" href="#rustc-从-146-到--151--性能提升不少" id="rustc-从-146-到--151--性能提升不少">rustc 从 1.46 到  1.51  性能提升不少</a></h2>
<p>有人在reddit上发帖，说他在 OpenBSD 平台上将 Rust 从1.46更新到1.51，发现他的项目编译时间减少了30％。</p>
<p><a href="https://www.reddit.com/r/rust/comments/n2lh7z/rustc_performance_improvement_from_rust_146_to_151/">https://www.reddit.com/r/rust/comments/n2lh7z/rustc_performance_improvement_from_rust_146_to_151/</a></p>
<h1><a class="header" href="#社区热点-2" id="社区热点-2">社区热点</a></h1>
<p>编辑：李冬杰</p>
<hr />
<h2><a class="header" href="#rust-核心团队进展" id="rust-核心团队进展">Rust 核心团队进展</a></h2>
<p>早在去年8月，核心团队就写了一篇题为《为 Rust的未来奠定基础》的博客文章，从那时起，核心团队一直在做大量的工作来帮助打下基础，并为项目上因这些事件而发生的变化做好准备。这种工作主要集中在内部，而不是真正从外部可见的东西，即使您在 Rust 团队中也是如此。 由于这些努力，Rust 基金会现在已经存在，并开始致力于其使命，这也意味着核心团队是时候转移工作重点了。</p>
<p>除了基金会的努力之外，Rust核心团队还开展了一些您可能知道也可能不知道的举措。</p>
<p><strong><a href="https://github.com/rust-lang/rfcs/pull/3037">The 2021 Roadmap</a></strong></p>
<p>2021年 Roadmap RFC 于1月合并，这为今年的核心团队设定了目标，与往年有些不同，Rust为整个项目制定了目标，2021年决定将重点放在 Rust Core 上，并为团队设定自己的目标留出空间，而我们则专注于总体组织健康。</p>
<p>今年晚些时候，Rust也将启动明年的流程，目前还没有积极考虑这个问题，但理想情况下年度 Roadmap 将在12月合并，而不是在1月，因此团队希望能尽早开始，以便在 2022 年按时完成目标。</p>
<p><strong><a href="https://github.com/rust-lang/rfcs/blob/master/text/1068-rust-governance.md">Team Charters</a></strong></p>
<p>作为该工作的一部分，Rust项目已经开始了为每个团队提供正式章程的流程的第一步。 早在 RFC 1068 中，初始团队的范围就已经列出。 虽然多年来这对Rust很有帮助，但随着团队的组建、关闭和变化，Rust项目在明确每个团队的责任界限方面并不总是做得很好。 Rust 治理结构的神奇之处在于，每个团队都被赋予了重要的权力，可以按照他们认为合适的方式做事，但这也意味着Rust项目必须意识到范围。 随着该过程的继续展开将有更多关于此过程的报告，但最终目标已在路线图中说明：</p>
<blockquote>
<p>Rust 团队将与核心团队合作，在一年中为每个 Rust 团队制定章程，目的是定义，特别是目的和成员要求。我们的目标是，到 2022 年，Rust 项目中的所有活跃团体都将拥有明确定义的章程和成员资格。</p>
</blockquote>
<p><strong>Audit of packages owned by the project</strong></p>
<p>Rust核心团队一直在努力澄清Rust团队在crates.io拥有的包的状态，目前核心团队正在对这些程序包进行全面审核，以确保它们是项目应该拥有的东西，确保它们有适当的权限，并确保有人维护它们。</p>
<p><a href="https://blog.rust-lang.org/inside-rust/2021/05/04/core-team-update.html">Read More</a></p>
<h2><a class="header" href="#在安卓上运行-rust" id="在安卓上运行-rust">在安卓上运行 Rust</a></h2>
<p>作者决定对目前一个客户的产品使用Rust，这个决定背后有两个原因，除了技术优点之外，还有一个无可争辩的事实，即 Rust 仍然是一种相对较新的语言，花哨和时髦。当你是一家初创公司时，使用前十年出现的任何技术只会让自己失败，如果不使用创新技术，公司如何进行创新呢？最快的成功方式是搭乘炒作列车。因此作者开始研究如何让Rust在安卓上运行起来，并提供了一个最小运行程序的模板。</p>
<p><a href="https://blog.svgames.pl/article/running-rust-on-android">Read More</a>
<a href="https://github.com/suve/rust-on-android/">MVP template Repo</a></p>
<h2><a class="header" href="#rust-for-windows-v09" id="rust-for-windows-v09">Rust for Windows v0.9</a></h2>
<p>Rust for Windows v0.9最近已发布，其中包括全面的消费支持以及其他几个更新！有了完整的使用支持，您现在可以使用Rust语言来调用任何Windows API（过去，现在和将来）。 Rust开发人员可以以一种惯用的语言访问整个Windows API接口，从而使他们可以轻松利用 Windows 开发的强大功能和广度。</p>
<p><a href="https://blogs.windows.com/windowsdeveloper/2021/05/06/announcing-rust-for-windows-v0-9/">Read More</a></p>
<h2><a class="header" href="#一个-rust-的新-aws-sdkalpha-发布" id="一个-rust-的新-aws-sdkalpha-发布">一个 Rust 的新 AWS SDK：alpha 发布</a></h2>
<p>我们很兴奋地宣布 Rust 的新 AWS SDK 的 alpha 版本发布。在 Rust 中开发的 AWS 客户想要一个本地的 Rust SDK，这样他们就可以使用他们习惯的语言结构，而 Rust 的新客户想要一个与他们在其他语言环境中使用的 SDK 行为类似的 SDK。在这个 alpha 版本中，客户可以在客户端试用7种AWS服务，并提供可用性方面的反馈。</p>
<p><a href="https://aws.amazon.com/cn/blogs/developer/a-new-aws-sdk-for-rust-alpha-launch/">Read More</a></p>
<h2><a class="header" href="#rust-六周年-" id="rust-六周年-">Rust 六周年 🎉</a></h2>
<p>2021年5月15日是 Rust 六岁生日（从2015年 1.0 版本算起），在这过去的六年里发生了许多变化，但 Rust 项目没有什么不同，依然没有基金会，没有 Const 泛型，许多组织仍然怀疑 Rust 是否已经准备好投入生产环境。</p>
<p>这篇文章将会回顾一下过去一年中的一些重大改进，社区如何在生产中使用Rust，最后展望目前正在进行的一些改进工作，这些改进和改进了Rust在小型和小型企业中的使用。明年的大型项目，让我们开始用Rust吧！</p>
<p><a href="https://blog.rust-lang.org/2021/05/15/six-years-of-rust.html">Read More</a></p>
<h2><a class="header" href="#spacex-开始使用-rust-了" id="spacex-开始使用-rust-了">SpaceX 开始使用 Rust 了</a></h2>
<p>考虑到 Rust 的安全性、高性能、现代化的工具集，SpaceX 可以在嵌入式系统、模拟器、工具集、web开发使用统一的语言，SpaceX 已经在开发一些原型工具，这仅仅是这个长途旅行的开始！</p>
<p><img src="chapter_5/./image/spacex-use-rust.jpeg" alt="space use Rust" /></p>
<p><a href="https://www.reddit.com/r/rust/comments/ndm4ne/spacex_about_the_rust_programming_language/">Read More</a></p>
<h2><a class="header" href="#rust-安全案例-rust-的安全并不是指能写出-0-bug-代码" id="rust-安全案例-rust-的安全并不是指能写出-0-bug-代码">【Rust 安全案例】 Rust 的安全并不是指能写出 0 Bug 代码</a></h2>
<blockquote>
<p>题外话： 之前看到知乎上有人说 Rust 2021 年光 CVE 就有近百个。那咱们今天就捡个热乎的 CVE  看看到底是咋回事。</p>
</blockquote>
<p>2021-05-18 ，openSUSE 邮件列表里收到一份安全报告，主题如下：</p>
<p>[oss-security] please: CVE-2021-31153，CVE-2021-31154，CVE-2021-31155: local root exploit and further</p>
<p>please 是一个 Rust 实现的替代 sudo 的工具，该库作者向 SUSE 团队提出 setuid-root 的代码安全审核，然后就被发现存在很多安全问题，并且包含一个比较严重的本地 root 漏洞，允许执行命令。</p>
<p>报告摘录如下：</p>
<ul>
<li>可以进行任意文件存在测试，并且可以以root用户身份打开任意文件</li>
<li>通过search_path（）函数进行任意文件存在性测试</li>
<li>通过-d开关进行任意文件存在性测试</li>
<li>使用不可信的umask创建令牌目录“ / var / run / pleaser / token”</li>
<li>允许通过pleaseedit编辑任何文件，允许任意文件覆盖和所有权更改</li>
</ul>
<p>结论：</p>
<ul>
<li>哪怕是 Rust 这样的现代语言，要实现 setuid-root 二进制文件也是一个很大的挑战。</li>
<li>please库中几乎没有unsafe（只有几行 libc/nix调用），所以基本已经不存在内存安全类的漏洞了，但是像这种逻辑漏洞是无法避免的，除非你不写代码。</li>
<li>setuid 二进制文件是在非 root 用户 shell 程序中运行的 root 权限二进制文件</li>
</ul>
<p><a href="https://marc.info/?l=oss-security&amp;m=162133298513412&amp;w=2">Read More</a>
<a href="https://bugzilla.suse.com/show_bug.cgi?id=1183669">Read More</a></p>
<h2><a class="header" href="#rust-for-windows-v09最近已发布" id="rust-for-windows-v09最近已发布">Rust for Windows v0.9最近已发布</a></h2>
<p>意味着你可以用 Rust 调用任意 Windows API</p>
<p>(目测一大波 Rust 实现的恶意软件即将来袭 。。。)</p>
<ul>
<li><a href="https://blogs.windows.com/windowsdeveloper/2021/05/06/announcing-rust-for-windows-v0-9/">https://blogs.windows.com/windowsdeveloper/2021/05/06/announcing-rust-for-windows-v0-9/</a></li>
<li><a href="https://github.com/microsoft/windows-rs">https://github.com/microsoft/windows-rs</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/dev-environment/rust/">https://docs.microsoft.com/en-us/windows/dev-environment/rust/</a></li>
</ul>
<p><strong>观点：对 Windows-rs 的 看法</strong></p>
<p>来自：Tony Huang </p>
<p>仔细看了一下winrt的设计，还是很不错的，集微软技术大成。</p>
<p>Windows技术栈中很重要的一个技术是COM。它的作用就是定义了一个语言无关的abi，让不同的语言可以无压力的互相交互。</p>
<p>举个例子，以前我们用VB6的时候可以使用COM调用ActiveX控件，然后到了.Net，还可以在.Net中直接使用COM组件，甚至可以把自己包装成COM组件来提供服务。</p>
<p>然后，我们再来看Windows在应用程序接口方面，和Linux有什么本质的不同。</p>
<p>在Linux中，所有对内核的调用，最终都是syscall，这个实际上是在每个arch上，通过一个syscall的number做的绑定，还是比较简陋的。操作系统只能提供很有限的syscall，其它的要嘛通过第三方库，要嘛通过ioctl里面的魔幻处理来实现。</p>
<p>而Windows完全不同，它的操作系统API是通过动态链接库的形式提供的。典型的就是那3个dll：KERNEL32.dll, USER32.dll, 和 GDI32.dll。那么它具体怎么跟内核交互，或者如何与系统的其它服务协作为应用程序提供这些功能，就是由操作系统的发行版决定的。从用户程序的视角来说，我只是调用了一个函数。如果使用了新的API，但是跑在老的系统上，只是会动态链接错误，找不到指定的symbol就好了。甚至可以通过API动态的检测是否存在某个接口。</p>
<p>而WinRT的技术基础就是基于COM技术，把这个功能变得更加强大了。</p>
<p>首先所有的操作系统组件（甚至你自己的组件），都可以通过COM把接口暴露出来，提供一份winmd文件，描述了你提供的接口。</p>
<p>然后针对不同的语言，微软官方提供了一个工具，依据这个winmd文件自动生成binding。</p>
<p>比如C++/WinRT，就是提供了一个编译器，在编译你自己的程序之前，根据你的依赖和windows sdk中的winmd文件生成c++的header，给你调用。然后运行时再使用COM把具体的dll和接口注入进来。</p>
<p>而windows-rs（Rust for Windows）干的事情是一样的，但是它很巧妙的利用了cargo的 build.rs 机制，在编译时做这个binding的生成工作 （具体参考 readme： https://github.com/microsoft/windows-rs/blob/master/readme.md）。</p>
<p>所以对于微软来说，由于操作系统的abi是语言无关的，通过winmd（从com的idl编译而来）描述的。那么对于新的语言的支持，只需要2个事情：</p>
<ol>
<li>针对legacy的win32 api做一下手动的binding</li>
<li>针对新的WinRT API写一个对应的binding生成器</li>
</ol>
<p>理论上来说，只要你用的api范围够小，rust for windows是能支持rust编译器支持的最低版本的windows的。</p>
<h2><a class="header" href="#用于rust的新-aws-开发工具包-alpha-版发布" id="用于rust的新-aws-开发工具包-alpha-版发布">用于Rust的新 AWS 开发工具包– Alpha 版发布</a></h2>
<ul>
<li><a href="https://aws.amazon.com/blogs/developer/a-new-aws-sdk-for-rust-alpha-launch/">https://aws.amazon.com/blogs/developer/a-new-aws-sdk-for-rust-alpha-launch/</a></li>
<li><a href="https://github.com/awslabs/aws-sdk-rust">https://github.com/awslabs/aws-sdk-rust</a></li>
</ul>
<h2><a class="header" href="#intellij-rust-提交了展开属性宏的-pr" id="intellij-rust-提交了展开属性宏的-pr">intellij-rust 提交了展开属性宏的 PR</a></h2>
<p><a href="https://github.com/intellij-rust/intellij-rust/pull/7194">https://github.com/intellij-rust/intellij-rust/pull/7194</a></p>
<h2><a class="header" href="#1password-宣布登陆-linux-平台" id="1password-宣布登陆-linux-平台">1password 宣布登陆 Linux 平台</a></h2>
<p>摘录：</p>
<ol>
<li>Linux 1Password的后端和底层逻辑是用Rust 编写的。 由于其强大的安全性，Rust已在企业中得到广泛采用，甚至被提议作为Linux内核的官方语言。</li>
<li>Linux 1Password 的数据加密使用 <a href="https://github.com/briansmith/ring">ring库</a></li>
<li>用户界面使用 React+neon（Node.js 模块的 Rust 绑定）+Rust</li>
<li>1Password 公司为了回馈开源社区，赞助了 tokio 和   rust-analyzer，并且也开源了自己的一些项目。</li>
</ol>
<p><a href="https://blog.1password.com/welcoming-linux-to-the-1password-family/?utm_medium=social&amp;utm_source=twitter&amp;utm_campaign=linuxblog&amp;utm_ref=social">https://blog.1password.com/welcoming-linux-to-the-1password-family/?utm_medium=social&amp;utm_source=twitter&amp;utm_campaign=linuxblog&amp;utm_ref=social</a></p>
<h2><a class="header" href="#fuchsia-os-发布reddit-网友讨论-rust-等代码所占比例" id="fuchsia-os-发布reddit-网友讨论-rust-等代码所占比例">Fuchsia OS 发布，reddit 网友讨论 Rust 等代码所占比例</a></h2>
<ul>
<li>Rust 22%,</li>
<li>C++ 18%,</li>
<li>C 4%,</li>
<li>Go 2%,</li>
<li>Python 1%,</li>
<li>Dart 1%</li>
</ul>
<p>其余 52% 都是 json 相关的，不算os内主流语言。 单独算这几门语言，Rust 的占比接近 50% 了</p>
<p><a href="https://www.reddit.com/r/rust/comments/nldg5c/fuchsia_os_partially_written_in_rust_has_shipped/">https://www.reddit.com/r/rust/comments/nldg5c/fuchsia_os_partially_written_in_rust_has_shipped/</a></p>
<h2><a class="header" href="#rust-binary-search-pr-导致-polkadot-线上事故的缘由" id="rust-binary-search-pr-导致-polkadot-线上事故的缘由">Rust binary search PR 导致 Polkadot 线上事故的缘由</a></h2>
<p>知名公链波卡 (Polkadot) 5 月 24 号某个节点发生了一次比较大的线上事故(Out Of Memory)，是因为 Rust 标准库 binary search 一个优化 PR 导致的。</p>
<p>该PR 跑了将近一周时间的 crater 测试，也没有发现对线上 5 万多个 crate 有什么大影响。Rust 1.52 发布之后，没想到依然有人中招了，而且还是价值几十亿美金的项目。</p>
<p>@brson 特意发了 issue 说到这件事，但是 Rust 社区的人都认为这件事跟这个 PR 没有关系，因为 binary search 碰到多个重复的元素的时候确实是返回任意一个，文档上也说得很清楚了（所以这种情况下不会保证两个版本返回的位置一致，这也是 Polkadot 出现线上事故的原因)。</p>
<p>该 PR 作者(Folyd)说 ：</p>
<blockquote>
<p>不管怎样，这件事给我的触动还是蛮大的。软件开发是复杂的，其本质原因在于现实生活就是复杂的。软件工程师只能尽可能规避发生这种情况的风险，但是没有办法做到万无一失吧。就像这位工程师说的我这是中了 Hyrum 定律（Google 一个叫 Hyrum 的工程师提的定律，可以理解为 API 领域的墨菲定律）。</p>
</blockquote>
<p>Polkadot 的事故后复盘：<a href="https://polkadot.network/a-polkadot-postmortem-24-05-2021/">https://polkadot.network/a-polkadot-postmortem-24-05-2021/</a></p>
<p>@brson 的 issue: <a href="https://github.com/rust-lang/rust/issues/85773">https://github.com/rust-lang/rust/issues/85773</a></p>
<p>binary search优化 PR：<a href="https://github.com/rust-lang/rust/pull/74024">https://github.com/rust-lang/rust/pull/74024</a></p>
<p>关于 PR 的文章：<a href="https://zhuanlan.zhihu.com/p/371460665">https://zhuanlan.zhihu.com/p/371460665</a></p>
<p>Hyrum 定律：<a href="https://www.hyrumslaw.com/">https://www.hyrumslaw.com/</a></p>
<h2><a class="header" href="#rustc_codegen_gcc-gcc-rs-的一个简单替代项目" id="rustc_codegen_gcc-gcc-rs-的一个简单替代项目">rustc_codegen_gcc: GCC-rs 的一个简单替代项目</a></h2>
<p>GCC-rs  是 用 Cpp 重新实现 Rustc 的一个 GCC 前端。</p>
<p>为什么有 GCC-rs 这个项目？</p>
<ol>
<li>想要支持更多的 CPU 架构</li>
<li>跨语言 LTO。GCC-RS FAQ将Linux列为激励示例。 具有讽刺意味的是，Linux支持ltvm但不是gcc！</li>
<li>Rust 自举（Bootstrap）链很长，因为需要从C到OCAML，然后编译预发布 Rust 以编译 Rust 1.0编译 Rust 1.1 、1.2等，直到捕获最多1.53（或者最新版本）。 因此，如果您可以用C++中编写的 Rust 编译器直接编译1.53，则可以节省一些时间。</li>
<li>复用 GCC 插件</li>
</ol>
<p>但 rustc_codegen_gcc  作者认为 GCC-rs 其实没有很好的解决这些问题。</p>
<p>rustc_codegen_gcc 项目只需将GCC插入现有的Rust编译器作为代码生成后端，就可以简单的达成这些目标。</p>
<p>该项目的主要目标是能够在LLVM不支持的平台上编译 Rust 代码。 次要目标是检查使用GCC后端是否提供任何编译速度改进。</p>
<p>当前 rustc_codegen_gcc 还是 WIP。</p>
<p><a href="https://github.com/antoyo/rustc_codegen_gcc">https://github.com/antoyo/rustc_codegen_gcc</a></p>
<p><a href="https://github.com/Rust-GCC/gccrs">https://github.com/Rust-GCC/gccrs</a></p>
<p>文章：<a href="https://shnatsel.medium.com/the-simpler-alternative-to-gcc-rs-90da2b3685d3">https://shnatsel.medium.com/the-simpler-alternative-to-gcc-rs-90da2b3685d3</a></p>
<h1><a class="header" href="#活动回顾-1" id="活动回顾-1">活动回顾</a></h1>
<p>后期编辑：张汉东</p>
<blockquote>
<p>编者按：</p>
<p>总结了本月的活动，包括线上和线下。</p>
<ul>
<li>线上：《Rust 唠嗑室》和 《RustFriday 飞书群线上沙龙》</li>
<li>线下: WebAssembly meetup 北京站</li>
</ul>
</blockquote>
<hr />
<h1><a class="header" href="#线上rust-唠嗑室本月汇总-1" id="线上rust-唠嗑室本月汇总-1">【线上】Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598/video">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
<li>后期编辑：高宪凤</li>
</ul>
<h3><a class="header" href="#rust-唠嗑室第-24-期---大家一起来闲聊一下最近使用-rust-的心得和遇到的坑" id="rust-唠嗑室第-24-期---大家一起来闲聊一下最近使用-rust-的心得和遇到的坑">《Rust 唠嗑室》第 24 期 - 大家一起来闲聊一下最近使用 Rust 的心得和遇到的坑</a></h3>
<p><strong>时间</strong>: 2021/05/11 20:30-21:30</p>
<p><strong>主讲人</strong>：无</p>
<p><strong>内容</strong>：大家一起来闲聊一下最近使用 Rust 的心得和遇到的坑</p>
<p>顺便也约了金明剑老师来谈谈 TensorBase 项目的最新的一些进展。</p>
<p>其它几个可能的话题：</p>
<ul>
<li>
<p>1.52 编译器的增量编译 bug。紧急修复版本 1.52.1</p>
</li>
<li>
<p>bevy 0.5 及其它 Rust 游戏框架等</p>
</li>
<li>
<p>Rust 在嵌入式领域的实践</p>
</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1uo4y1m7vp">查看回放</a></p>
<h3><a class="header" href="#rust-唠嗑室第-25-期---使用-rust-快速开发基于-raft-共识算法的分布式应用" id="rust-唠嗑室第-25-期---使用-rust-快速开发基于-raft-共识算法的分布式应用">《Rust 唠嗑室》第 25 期 - 使用 Rust 快速开发基于 Raft 共识算法的分布式应用</a></h3>
<p><strong>时间</strong>: 2021/05/25 20:30-21:30</p>
<p><strong>主讲人</strong>：PsiACE</p>
<p><strong>内容</strong>：介绍如何基于流行的 raft-rs 开发分布式应用以及 raft-frp/RiteRaft 设计思路</p>
<ul>
<li>
<p>回顾 raft 共识算法的一些基本内容</p>
</li>
<li>
<p>如何使用 raft-rs 开发分布式应用</p>
</li>
<li>
<p>降低重复劳动, 160 行代码实现一个简单的分布式键值服务</p>
</li>
<li>
<p>目前项目进展</p>
</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1ZK4y1G7GR">查看回放</a></p>
<p>参考资料：</p>
<ol>
<li>https://www.cnblogs.com/yanglang/p/10141583.html</li>
<li>https://www.jianshu.com/p/81fe3e4f51a5</li>
<li>https://zzjw.cc/post/raft-build</li>
<li>https://github.com/erikgrinaker/toydb/blob/master/docs/architecture.md</li>
<li>https://github.com/MarinPostma/raft-frp</li>
<li>https://github.com/canonical/raft</li>
<li>https://github.com/blackredscarf/raftfwk</li>
<li>https://github.com/tikv/raft-rs</li>
</ol>
<hr />
<center> 🔥🔥🔥🔥 <strong>RustFriday 飞书群线上沙龙</strong> 🔥🔥🔥🔥 </center>
<h1><a class="header" href="#线上rustfriday-飞书群线上沙龙-1" id="线上rustfriday-飞书群线上沙龙-1">【线上】RustFriday 飞书群线上沙龙</a></h1>
<p>每周五晚八点，限定两个主题：语言特性和开源项目，在线讨论。</p>
<p>Rust 中文社群 飞书群 邀请你加入：</p>
<p>对话群： <a href="https://applink.feishu.cn/TeLAcbDR">https://applink.feishu.cn/TeLAcbDR</a></p>
<p>话题群：<a href="https://applink.feishu.cn/TeLD868w">https://applink.feishu.cn/TeLD868w</a></p>
<p>视频来源：<a href="https://space.bilibili.com/24917186">https://space.bilibili.com/24917186</a></p>
<h2><a class="header" href="#第六期讨论主题" id="第六期讨论主题">第六期讨论主题：</a></h2>
<ol>
<li>领域项目：eclipse zenoh ，一个零开销的 Pub/sub, Store/Query 和 Compute 平台</li>
<li>语言特性：Rust 中的 高阶类型 GAT (Generic Associated Types)</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://rustmagazine.github.io/rust_magazine_2021/chapter_4/zenoh.html</li>
<li>https://github.com/eclipse-zenoh/zenoh</li>
<li>https://github.com/autocore-ai/SDV</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1Hf4y1p7Pi">查看回放</a></p>
<h2><a class="header" href="#第七期-讨论主题" id="第七期-讨论主题">第七期 讨论主题：</a></h2>
<ol>
<li>语言特性：实现 RFC : Allow a re-export for main</li>
<li>领域项目： makepad， cloud9 ide 作者新的项目，支持 VR 开发的基于 WebAssembly 的 IDE/ 框架</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://github.com/rust-lang/rfcs/blob/master/text/1260-main-reexport.md</li>
<li>https://github.com/rust-lang/rust/pull/84217</li>
<li>https://github.com/rust-lang/rust/pull/84401</li>
<li>https://github.com/rust-lang/rust/pull/84507</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1264y1C7cu">查看回放</a></p>
<h2><a class="header" href="#第八期-讨论主题" id="第八期-讨论主题">第八期 讨论主题：</a></h2>
<ol>
<li>语言特性： 聊聊 Rust 泛型特化功能现状</li>
<li>领域项目： 介绍一下 WAGI 项目及其进展</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://github.com/deislabs/wagi</li>
<li>https://deislabs.io/posts/introducing-wagi-easiest-way-to-build-webassembly-microservices/</li>
<li>https://github.com/deislabs/hello-wagi-grain</li>
<li>https://radu-matei.com/blog/wagi-updates/</li>
<li>https://github.com/engineerd/wasm-to-oci</li>
<li>https://github.com/WebAssembly/WASI</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1m64y1C73P">查看回放</a></p>
<h2><a class="header" href="#第九期-讨论主题webassembly-专题课堂上" id="第九期-讨论主题webassembly-专题课堂上">第九期 讨论主题：WebAssembly 专题课堂（上）</a></h2>
<p>《 WebAssembly Actors: From Cloud to Edge》这套课程简洁精炼，虽然着墨不多，但是把 WebAssembly 及其在 Server Side 的应用关键概念都涉及，并且通过简单的示例展现清楚了。</p>
<p>参考资料：</p>
<ol>
<li>https://www.edx.org/course/webassembly-actors-from-cloud-to-edge</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1B44y1r7HA">查看回放</a></p>
<h1><a class="header" href="#线下webassembly-meetup-20210515-北京站" id="线下webassembly-meetup-20210515-北京站">【线下】WebAssembly meetup 20210515 北京站</a></h1>
<p>活动 PPT : <a href="https://github.com/alabulei1/WebAssembly-meetups/tree/main/meetup-beijing-20210515">https://github.com/alabulei1/WebAssembly-meetups/tree/main/meetup-beijing-20210515</a></p>
<ol>
<li>基于WebAssembly的人像分割技术在RTC领域的应用</li>
</ol>
<p>分享人：声网 Agora-高纯</p>
<p>B 站回放：<a href="https://www.bilibili.com/video/BV1u54y1V79y">https://www.bilibili.com/video/BV1u54y1V79y</a></p>
<ol start="2">
<li>用 Serverless WebAssembly 解决 SaaS 平台的定制化难题</li>
</ol>
<p>分享人：WasmEdge-Michael Yuan</p>
<p>B 站回放：<a href="https://www.bilibili.com/video/BV17v411L7Zg?from=search&amp;seid=14369338767741516201">https://www.bilibili.com/video/BV17v411L7Zg?from=search&amp;seid=14369338767741516201</a></p>
<ol start="3">
<li>基于WebAssembly 的ServiceMesh</li>
</ol>
<p>分享人：旷视-王续</p>
<p>B 站回放：<a href="https://www.bilibili.com/video/BV1yy4y1W7FE?from=search&amp;seid=101009679390055518">https://www.bilibili.com/video/BV1yy4y1W7FE?from=search&amp;seid=101009679390055518</a></p>
<ol start="4">
<li>WebAssembly 在浏览器端的实践</li>
</ol>
<p>分享人：金山软件-黄烈锦</p>
<p>B 站回放：<a href="https://www.bilibili.com/video/BV1f5411u7v7?from=search&amp;seid=16899798704041782034">https://www.bilibili.com/video/BV1f5411u7v7?from=search&amp;seid=16899798704041782034</a></p>
<h1><a class="header" href="#本月招聘-1" id="本月招聘-1">本月招聘</a></h1>
<h2><a class="header" href="#中国科学院软件研究所-plct-lab" id="中国科学院软件研究所-plct-lab">中国科学院软件研究所 PLCT Lab</a></h2>
<h3><a class="header" href="#bj46-rust-工具链开发实习生" id="bj46-rust-工具链开发实习生">BJ46 Rust 工具链开发实习生</a></h3>
<p>主要就是做 Rust for RISC-V 的工作，这是 Firefox on RISC-V 的一部分。确保 Rust 工具链和软件在 RV64GC 平台和 RV32GC 上可以跑起来，并进行功能的完善和性能的提升。</p>
<p>入职要求： LV3+，能进行英语交流，对编译技术有很好的了解。对 LLVM 工具链和 Rust 有浓厚的兴趣。 远程实习，不需要坐班。</p>
<h3><a class="header" href="#bj33-firefoxspidermonkey-开发实习生名额2-名" id="bj33-firefoxspidermonkey-开发实习生名额2-名">BJ33 Firefox/Spidermonkey 开发实习生（名额：2 名）</a></h3>
<p>工作内容： 就像将 V8 移植到 RISC-V 平台一样，将 Spidermonkey 移植到 RISC-V 平台。跟 mentor 一起将工作提交到 Mozilla upstream。最好能明白 Rust 相关的编译流程。</p>
<p>入职要求： LV3+ 级别。能够进行英文的交流。 远程实习，不需要坐班。</p>
<p>更多岗位参见 <a href="https://github.com/MATRIXKOO/weloveinterns">这里</a></p>
<p><strong>联系方式</strong>
有意者请投递简历至： 吴老师 wuwei2016@iscas.ac.cn
邮件标题请注明： 实习生 - 岗位编号 - 姓名 - 手机号码 - 学校</p>
<hr />
<h2><a class="header" href="#量化方向juniorsenior-rust-algo-developer" id="量化方向juniorsenior-rust-algo-developer">【量化方向】Junior/Senior Rust Algo Developer</a></h2>
<p>应聘者学校要求 C9 或者同级别的海外学校。</p>
<p><strong>About Injective Protocol</strong></p>
<p>Injective is building a decentralized exchange that provides limitless access to all financial markets. Injective Protocol enables fully decentralized trading without any restrictions, allowing individuals to trade on any derivative market of their
choosing. Injective Protocol is backed by a prominent group of stakeholders including Pantera Capital, Binance, Mark Cuban, Hashed, and many others.</p>
<p>We have offices in New York City and Hong Kong. Injective is valued at over $1 Billion and has been dubbed the &quot;DeFi Robinhood&quot; by the likes of TechCrunch.</p>
<p>**Job Description **</p>
<p>We can accept remote working, working language is Chinese
and/or English) Algorithm developers are responsible for building and maintaining the models that drive our trading. A typical day involves applying rigorous statistical analysis to vast quantities of market and financial data to produce provably predictive trading
models. Working in close collaboration with fellow algo developers and core developers, you will research, develop, and test novel order execution and model training methods to increase trading efficiency.</p>
<p><strong>Required Background and Skills</strong></p>
<p>Candidates must have at least a bachelor's degree from prestigious universities in CS, Physics, Math, and are capable of working independently as well as part of a team. Great experience with Rust. Previous exposure in trading strategy implementation in a production environment will be a plus.
We provide working visa sponsorship in the US / HK for any qualified candidates. Also, we provide US green card sponsorship. </p>
<p>Free free send your resume to <strong>maxim.shen@injectiveprotocol.com</strong></p>
<h2><a class="header" href="#rust-远程工作并且有瑞典移民的机会" id="rust-远程工作并且有瑞典移民的机会">Rust 远程工作，并且有瑞典移民的机会</a></h2>
<p>要求： Rust/ Graphql/ Typescript</p>
<p>The role can optionally be temporarily remote due to the ongoing COVID-19 situation, with the goal of you joining us in Gothenburg, Sweden. We can help with your move and immigration.</p>
<p><a href="https://technocreatives.homerun.co/senior-rust-full-stack-developer/en">https://technocreatives.homerun.co/senior-rust-full-stack-developer/en</a></p>
<p>Rust Remote 工作挺多</p>
<p><img src="chapter_5/./image/jobs.jpg" alt="jobs" /></p>
<p>不过有些公司限制在本土远程，有些公司限制必须在本土时间范围内工作，有些比较自由。</p>
<h1><a class="header" href="#rust-发布六周年" id="rust-发布六周年">Rust 发布六周年</a></h1>
<p>作者：The Rust Team / 译者：杨楚天</p>
<hr />
<p>今天是 <a href="https://www.rust-lang.org">Rust</a> 自 2015 年发布 1.0 以来的诞生日六周年。六年以来发生了许多事情，去年尤其如是，Rust 也不例外。2020 年伊始，我们还没有 Rust 基金会，没有常量泛型。许多组织依然对在生产环境中使用 Rust 保持观望态度。</p>
<p>在新冠病毒爆发时期，分散在世界各地的上百名 Rust 的组织成员和志愿者为我们带来了 9 个 Rust 稳定版本，以及若干个 bug 修复版本。如今，我们不会再质疑 Rust 是否适用于生产环境。新成立的 Rust 基金会包含许多成员，不仅重视在实际产品中使用 Rust，也在持续地为 Rust 开源生态做出支持与贡献。</p>
<p>现在，我们来总结一下去年发生的各种重大进展，回顾社区是如何在生产环境中使用 Rust 的，并展望 Rust 社区当下的工作，会如何在未来一年继续提升这门语言的使用体验。</p>
<h2><a class="header" href="#近期工作" id="近期工作">近期工作</a></h2>
<p>Rust 语言在去年取得了非常大的进展，带来了许多新的特性。这些功能谈不上给语言带来了质变，却也让我们能在更多领域方便地使用和维护 Rust。</p>
<ul>
<li>
<p>Rust 1.52.0 升级到了 LLVM 12，许多和 forward progress 有关的安全问题（例如无限循环的处理）得到了解决。这是 Rust 团队和 LLVM 长期以来合作的结果，也是 Rust 可以为更广阔的编程语言生态带来进步的例证。</p>
</li>
<li>
<p>Rust 为更多生态系统提供了支持，包括 Tier 1 中对 64 位 ARM Linux 的支持，Tier 2 中对 ARM macOS 和 ARM Windows 的支持等。这使得我们可以在更多的架构中使用 Rust 构建自己的项目。</p>
</li>
<li>
<p>Rust 在编译期的表达能力也获得了极大的提升。基础类型作为常量泛型的特性进入了稳定版本，同时 <code>const fn</code> 中也能更宽松地使用控制流，过程宏也能被用于更多的情景当中，这些都让我们能构造出更强力的 API，写出更好的 crate。</p>
</li>
</ul>
<p>除了 rustc 以外，以下工具也有巨大的改进：</p>
<ul>
<li>
<p>Cargo 稳定化了最新的特性分解机制，让我们可以在不同的 target 中更方便地管理依赖。</p>
</li>
<li>
<p>Rustdoc 稳定化了 &quot;文档内部链接&quot; 的功能，使得文档里的文本能自动地链接对应的类型或函数。</p>
</li>
<li>
<p>Clippy 现在使用单独的缓存，不再与 Cargo 共享，使其行为更加稳定。</p>
</li>
</ul>
<h2><a class="header" href="#生产环境中的-rust" id="生产环境中的-rust">生产环境中的 Rust</a></h2>
<p>Rust 每年都能以难以置信的速度获得社区与业界的接纳，去年也不例外。2020 年 Rust 再一次成为了 StackOverflow 年度<a href="https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/">最受喜爱的编程语言</a>。感谢社区里所有人的支持，是你们才有 Rust 的今天。</p>
<p>随着<a href="https://foundation.rust-lang.org/posts/2021-02-08-hello-world/">基金会</a>的成立，Rust 社区得以在一个更合适的位置上，构建出一个可持续的开源生态系统，帮助我们构建高效可靠的软件。许多公司成立了专门维护和促进 Rust 项目的小组，包括 <a href="https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/">AWS</a>、<a href="https://engineering.fb.com/2021/04/29/developer-tools/rust/">Facebook</a> 和微软等。</p>
<p>不仅 Rust 自身正在进步，许多大公司也开始允许在自己的产品中使用 Rust，或提供 Rust API 的官方支持。</p>
<ul>
<li>
<p>微软和亚马逊分别发布了 <a href="https://github.com/microsoft/windows-rs">Windows</a> 和 <a href="https://github.com/awslabs/aws-sdk-rust">AWS</a> 的官方 Rust 库。官方的海量 API 支持让 Rust 用户更能在项目中开发出想要的功能。</p>
</li>
<li>
<p>在 cURL 项目发布的新版本中，默认采用了由 Rust 实现的库，用于处理 <a href="https://daniel.haxx.se/blog/2020/10/09/rust-in-curl-with-hyper/">HTTP/s</a> 和 <a href="https://daniel.haxx.se/blog/2021/02/09/curl-supports-rustls/">TLS</a> 通信。ISRG、Hyper &amp; Rustls 团队以及 cURL 项目团队之间密切地跨社区合作，为 cURL 这个被广泛使用的工具打造出了一个内存安全的后端。</p>
</li>
<li>
<p>Tokio （一个 rust 的异步运行时）发布了 <a href="https://tokio.rs/blog/2020-12-tokio-1-0">1.0 版本</a> ，并承诺了三年的稳定维护。这个项目可以为我们实现可靠且高效的网络应用提供了坚实的基础。</p>
</li>
</ul>
<h2><a class="header" href="#未来工作" id="未来工作">未来工作</a></h2>
<p>当然，这一切仅仅是开始，我们可以看到现在很多组织在开展各种开创性的工作，尝试将 Rust 带入全新的领域。</p>
<ul>
<li>Critical Section 公司旗下的 Ferrous Systems 启动了 <a href="https://ferrous-systems.com/ferrocene">Ferrocene</a> 项目，让 Rust 得以用于安全系统和关键业务系统中。</li>
<li>Embark Studios 发布了一个 <a href="https://github.com/EmbarkStudios/rust-gpu"><code>rust-gpu</code></a> 的原型，借助于这个编译器后端，Rust 也可以用于实现 GPU 中的图形着色器。</li>
<li>Linux 社区正在围绕是否<a href="https://lore.kernel.org/lkml/CANiq72khBa2GcB6-PHM3A44Y90d6vzYAS=BVpk3nT4B6u+NVDw@mail.gmail.com/T/#mb5e524dae9d5a5815c6e68eb36b9bde4e87c861d">将 Rust 作为内核开发的另一选择</a>做出讨论，Rust 可以帮助 Linux 社区写出更安全的驱动以及内核代码。</li>
<li>Google 宣布<a href="https://security.googleblog.com/2021/04/rust-in-android-platform.html">已在 Android OS 中支持采用 Rust 开发底层组件</a>，并正在着手使用 Rust 重写其中的蓝牙模块。</li>
</ul>
<p>Right now the Rust teams are planning and coordinating the 2021 edition of Rust. Much like this past year, a lot of themes of the changes are around improving quality of life. You can check out our recent post about <a href="https://blog.rust-lang.org/2021/05/11/edition-2021.html">&quot;The Plan for the Rust 2021 Edition&quot;</a> to see what the changes the teams are planning.</p>
<p>目前 Rust 团队正在围绕新版本 Rust 2021 进行相关的计划与协调工作。和去年一样，我们很多的改动还是聚焦在改善开发体验上。大家可以看一下我们最近的<a href="https://blog.rust-lang.org/2021/05/11/edition-2021.html">一篇文章</a>，讲述 Rust 团队当前的工作计划。</p>
<p>这些只是冰山一角，当今的 Rust 社区，每时每刻在发生新的变化，每天都有激动人心的项目诞生。我们迫不及待地想看到新的一年，大家又用 Rust 打造出了什么样的创作。</p>
<hr />
<p>过去一年 Rust 的那项改进最让你感到振奋？哪个项目最让你激动？是刚准备尝试使用 Rust 么？还是想参与 2021 版本的工作？欢迎大家来到我们的 <a href="https://users.rust-lang.org/">Discourse</a> 论坛和 <a href="https://rust-lang.zulipchat.com/">Zulip</a> 聊天室，随意介绍自己，然后加入我们的讨论吧。这里有安全友好的环境，无论你的性别取向身体状况宗教信仰如何，我们都欢迎你的到来。</p>
<h1><a class="header" href="#造就-rust-的无名英雄" id="造就-rust-的无名英雄">造就 Rust 的无名英雄</a></h1>
<p>作者：Brian / 译者&amp;&amp;编辑：张汉东</p>
<blockquote>
<p>原文： https://brson.github.io/2021/05/02/rusts-most-unrecognized-contributor</p>
<p>Brian Anderson 之前是 Mozilla Research 的资深研究工程师，Rust 核心团队成员。从事 Rust 编程语言方面的工作 6 年，维护运行时和标准库，构建验证语言及其子系统的基础设施。Servo 浏览器的主要作者之一。Rust 以稳定著称，而 Brian 的使命就是让 Rust 成为最可靠的平台。于 2018 年加入了 PingCAP。</p>
</blockquote>
<hr />
<p>我认为 Rust 语言目前取得了巨大的成功。当我回想这一切发生的过往时，敬畏之心油然而生。因为必须做很多正确的事才能达到现在这个状态，在整个过程中，其实犯错的机会太多了。Rust 语言靠着一个又一个微小的奇迹，逐渐变成了它应该成为的样子。这些奇迹并不是偶然发生的，而是靠每一个真实的人创造的。这些真实的人，通过精心地策划来早就伟大。</p>
<p>有很多人为 Rust 的成长做出了贡献。这其中有一些对 Rust 的成功保驾护航的人，却几乎不被人所知。</p>
<h2><a class="header" href="#开端mozilla-研究所" id="开端mozilla-研究所">开端：Mozilla 研究所</a></h2>
<p>到2009年，Mozilla 通过与 Google 合作的搜索交易中积累了可观的资金储备。以我的理解，管理层认为是时候投资这笔钱了，公司进入了一个快速扩张的时期。</p>
<p>作为扩展的一部分，Mozilla 创建了一个新部门 Mozilla 研究所（Mozilla Research)。该部门的使命是，独立于 Firefox 产品之外，去尝试一些目标远大的想法，同时与计算机科学学术界建立联系。</p>
<p>Mozilla 研究所的第一个重要构想就是 <a href="http://venge.net/graydon/talks/intro-talk-2.pdf">Servo</a>。然后就是 Rust 。</p>
<p>戴夫·赫尔曼（Dave Herman）是当时被任命领导该部门的人之一。</p>
<h2><a class="header" href="#戴夫赫尔曼dave-herman何许人也" id="戴夫赫尔曼dave-herman何许人也">戴夫·赫尔曼（Dave Herman）何许人也？</a></h2>
<p>戴夫·赫尔曼 是一名编程语言理论学者，也是一名宏专家（macrologist，超级喜欢宏的人），并且是 Mozilla 在ECMAScript 委员会上的代表之一。 </p>
<p>他 和 创建 Rust 的工程师 格雷顿·霍尔（ Graydon Hoare） 曾经在 <a href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_(abandoned)">ECMAScript 4</a> 标准（已废弃）上合作过。</p>
<p>他俩都对创建编程语言有强烈的爱好。</p>
<p>除了 Servo，Rust 和 戴夫·赫尔曼之外，Mozilla 研究所的工作还有很多，但这在我们的故事之外。</p>
<p>我们要讲的是，戴夫·赫尔曼（Dave Herman）如何默默塑造 Rust 项目成果的故事。</p>
<h2><a class="header" href="#戴夫对-rust-的贡献" id="戴夫对-rust-的贡献">戴夫对 Rust 的贡献</a></h2>
<p>Rust 于 2010 年 6 月发布，但实际上它在 2009 年末就开始在 Mozilla 内部开发。关于这段 Rust 开发过往的唯一公开记录是在 <a href="https://github.com/graydon/rust-prehistory">graydon/rust-prehistory</a> 仓库中。</p>
<p>Rust 从开发之初到 2010 年 6 月呈现给公众，只经历了短短六个月的冲刺。而 戴夫 就是攻克这项任务的成员之一。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>~/rust-prehistory $ git shortlog -sn
  1156  Graydon Hoare
   163  Andreas Gal
   104  Dave Herman
    59  graydon@pobox.com
    55  Patrick Walton
    37  Graydon Hoare ext:(%22)
    13  Roy Frostig
     9  graydon@mozilla.com
     6  Brendan Eich
     5  Michael Bebenita
     1  Brian Campbell
<span class="boring">}
</span></code></pre></pre>
<p>此后，他将编码工作交给了 格雷顿 领导的成长中的 Rust 团队。但在接下来的这几年中，戴夫一直在办公室里。</p>
<p>那是，大多数为 Rust 工作的人都在同一间办公室。而 Rust 另一个重要人物 格雷顿 则是远程。戴夫 和 少数几名全职员工，以及一些轮换的实习生会定期聚集在Mozilla Mountain View 总部的某个小会议室的一张桌子旁。</p>
<p>我想象得到，他就像一个导师一样，依赖自己在 ECMAScript 上的经验以及基于自己对语言设计的兴趣，推动着团队到富有成效的方向前进。他从来没有以任何方式行使自己的权威，直到今天，也没有在 Rust 上为自己争取任何声望。</p>
<p>他几乎完全在幕后做出了自己的贡献，默默地发挥着他的影响力。</p>
<p>在那个会议室里发生的很多早期的争论，都是一些基础性争论。这些争论今天看过去似乎已经无关紧要了，诸如 “从函数返回的关键字是什么？” ，或，“如何安全地持有结构体字段的指针” 等琐碎事情。这些问题在今天来看显得太过遥远且无关紧要，但是，正因为他们这样的争论，让 Rust 语言不断地反复塑造和重塑，直到所有小问题都被解决成一个一致的整体。</p>
<p>戴夫 是会议室中少数几个具有真正的生产编程语言设计经验的人之一，如果没有他带领团队克服琐碎的语言设计障碍，Rust 肯定会一团糟。戴夫 的品味塑造了团队的品味，从而塑造了 Rust 语言。并且，大多数情况下，戴夫 对团队的决定感到满意。</p>
<p>尽管 戴夫 在所有早期的 Rust 设计主题中都有发言权，但是有一些主题深深捕获着他对 Rust 语言的兴趣，如果你完全了解 Rust，我猜你会熟悉这些主题：</p>
<ul>
<li>
<p><strong>教学法（Pedagogy）</strong>。即，教学的方法。</p>
<p>戴夫 具有学术背景，并且始终根据如何教授和理解设计的每一个决定来考虑。</p>
</li>
<li>
<p><strong>治理（Governance）</strong>。即，社区管理。</p>
<p>Rust 从一开始就被设计为社区项目，我认为这在很大程度上受到 戴夫在语言标准机构工作经验的影响。 一直都存在这种设想，最成功的语言不是被谁拥有的，而是由一大批个人和公司合作设计的，所有这些都是各自兴趣和动机的叠加。</p>
<p>因此，Rust 开发时所依据的流程在当时总是要尽可能地做到包容。 举一个例子，Rust最早的许多发展都记录在<a href="https://github.com/rust-lang/meeting-minutes">公开的会议记录</a>中。 我几乎完全将这归因于 戴夫 的自律，并且要知道其中许多记录都是由他个人录制的。</p>
<p>戴夫 最重要的 Rust 遗产可能就是培养一种语言社区。</p>
</li>
<li>
<p><strong>宏（Macro）</strong>。</p>
<p>如前所说，戴夫 是一名宏专家。他在宏（Macro）方面颇有造诣，并且有 <a href="https://racket-lang.org/">Racket</a> 语言背景。</p>
<p>尽管主要由实习生（特别是 <a href="https://github.com/paulstansifer">Paul Stansifer</a>）实现，并得到 <a href="https://github.com/jbclements">John Clements</a> 的一些关键贡献，但由于 戴夫 的缘故，Rust 拥有强大而卫生的声明宏（<code>macro_rules!</code>）。</p>
<p>尽管这并不是我所涉及的领域，但我记得他和保罗（Paul）花了很多时间讨论如何将传统 Lisp 式的卫生宏系统设计为Rust所在的类 C 的世界。</p>
</li>
</ul>
<p><strong>戴夫 参与的其他关键决策包括：</strong></p>
<ul>
<li>将 Rust 语言从 语句式（statement）语言 转换为 表达式（expression）语言。</li>
<li>聘请 Niko 设计 Rust 所有权系统。</li>
<li>雇佣 Yehuda Katz 设计 Cargo。</li>
</ul>
<p>除了这些明显的贡献之外，戴夫 在 Rust 中还扮演者另一个关键角色：在管理层极力拥护 Rust 。</p>
<p>在造就 Rust 的所有奇迹中，最伟大的也许是 Mozilla 的诸多付出。在 Rust 存在于 Mozilla 的整个时期（译注：现在已经移交 Rust 基金会），团队内部明显有一种该项目随时可能被取消的感觉。坚守 Rust 团队的 Brendan Eich离开Mozilla之后，尤其如此。这就是为什么必须围绕该语言建立一个强大的社区的原因之一。</p>
<p>戴夫 是公司内职位最高的 Rust 信徒。而且，他竭尽所能提倡 Rust 对公司使命的重要性，并且满足 Rust 的人员配备和资源。的确，我不清楚 戴夫 在管理角色上所要面对的一切，但这绝对是关键：他做到了让团队专注于 Rust 。</p>
<p>无论如何， Rust 总是人手不足。我记得当时对此很生气：我们如何在如此少的全职工程师的情况下与 Google 和 Apple 竞争？这个问题的答案，一半肯定是培养投资多元化的贡献者社区，但这是一个缓慢且不确定的过程。而这个问题答案的另一半要归功于 戴夫：实习生。Rust 通常拥有比全职员工更多的实习生，并且它们都是由 戴夫 雇佣的，戴夫 可以凭借他在学术界的诚信轻松招募 PL 人才。</p>
<p>一个值得赞赏的事实：Rust 主要由学生创建，其中许多人在 Mozilla 实习。</p>
<h2><a class="header" href="#关于-rust-设计的轶事" id="关于-rust-设计的轶事">关于 Rust 设计的轶事</a></h2>
<p>我想我应该说一些 戴夫 对 Rust 设计贡献的一些轶事，而第一个想到的就是他不同意团队的那些决定。这不是一个关于 戴夫 所作贡献的很好的案例，但也许仍然值得分享，并且是他如何在指导团队的同时也信任他们决定的一个例子。</p>
<p>至今仍难以记住确切的细节，但我印象最深的一幕：当我们引入了可变变量和不可变变量绑定之间的区别时，戴夫坚决不同意团队所做的决定。我们只是在决定要为每种语法使用什么语法，这很简单。 争论结束时，对于不可变和可变绑定分别有两个明显的选择：</p>
<ul>
<li><code>let</code> 和 <code>let mut</code></li>
<li><code>let</code> 和 <code>var</code></li>
</ul>
<p>第一个是我们目前已经采用的语法，第二个是直接从 JavaScript 中借鉴的，两者都有充分的理由。 当时的主要问题是，从 “较难” 还是 “较丑” 中选择一个更加合适的语法。语言设计师 强迫 程序员 键入两个关键字来创建可变绑定，潜移默化地去影响程序员，使得他们对引入可变性去做更多思考。</p>
<p>我记得 戴夫 不同意团队在这一方面的决定。 回想起来，我认为他不同意「严格限制用户选择编码模式」的原则，但我不确定。 我也仍然认为团队对此是正确的：额外的 <code>mut</code>注释不仅增加了一些额外的工作以增加变量的可变性，而且<code>mut</code>注释自然地扩展到 Rust 类型系统的其他区域，例如<code>＆mut</code>引用。 而且，可变性的识别和管理已成为该语言的本质特征。</p>
<h2><a class="header" href="#为成功奠定基础" id="为成功奠定基础">为成功奠定基础</a></h2>
<p>我猜 戴夫 直接参与了Rust的设计于 2014 或 2015 年结束，Rust 社区中的大多数人甚至都没有意识到他的存在。</p>
<p>戴夫 没有创造出 Rust。</p>
<p>他仅向公共 Rust 仓库贡献了六次提交。他只在邮件列表上讲话了四次。</p>
<p>他所做的就是创建一个他认为可以为世界带来独特愿景的团队，并在该团队中巧妙地植入了一套价值观，这些价值观将使 Rust 能够超越 Mozilla 的边界，超越任何单独个体的参与和个性。</p>
<p>事实正是如此。</p>
<p>Rust 的成功有很多原因，其中有成千上万的贡献者，成千上万的微小奇迹汇聚成一个连贯的整体。</p>
<p>但是，微小的奇迹不会偶然变成大奇迹。</p>
<h1><a class="header" href="#漫谈编程语言的设计和实现" id="漫谈编程语言的设计和实现">漫谈编程语言的设计和实现</a></h1>
<p>作者：柴杰 </p>
<hr />
<h2><a class="header" href="#编程语言教育" id="编程语言教育">编程语言教育</a></h2>
<p>编程语言虽然复杂，但是其设计是遵循着一些基本规则的。不同语言的语法语义虽然有所不同，但一些基本的核是相似的（例如基于表达式扩展的语法和对基本数据类型的抽象）。编程语言可以顺着这些核一点点展开，根据语言的设计初衷添加规则（即类型系统）和语言特性（例如是否支持多线程、异步编程）。这些规则特性与编程语言之核的组合，造就了琳琅满目的编程语言。</p>
<p>然而，绝大多数国内编程课侧重于某一门具体语言的语法讲解，不解释语言特性与编程语言的本质关系。学生对编程语言普遍缺乏一种抓得住的“全局观”和举一反三的能力，看到的都是被“糖化”后的语法和复杂的语用环境，所以感觉编程语言学起来复杂、枯燥。如此一来，以下情形便容易解释了，例如：</p>
<ul>
<li>
<p>你经常对编译器和解释器报出的错误毫无头绪；</p>
</li>
<li>
<p>无法从技术层面判断一门编程语言设计的好坏，人云亦云；</p>
</li>
<li>
<p>对开发任务应该使用什么样的编程语言，或者应该使用哪些语言特性，无法做出独立的判断；</p>
</li>
<li>
<p>无法理解为什么一些framework或library的用法是这样的，对于背后的原理一无所知，只能靠着例子和pattern来编程，遇到问题却难以找出原因，只能google或去问别人；</p>
</li>
<li>
<p>不能对问题简洁的抽象与建模，难以写出简洁、高效、可维护的代码。</p>
</li>
</ul>
<p>理想的编程语言课程应该是语言特性与编程语言理论的融合。因为理论需要实践来解释how，实践需要理论来支撑why，两者相互促进，方能做到知其然知其所以然。如果不把握编程语言的本质，就好比学人体素描不识人体骨骼，学中医不讲阴阳，学音乐不知乐理。如此一来，知识的理解受限且无法融会贯通，不可深究亦不能长远[1]。</p>
<p>编程语言素养是每个人编程知识树的主干（这种结构性很强的知识体系是很难通过经验自我摸索的），每一次的编程经历都是对编程语言抽象表达能力的一次运用和锻炼。日积月累，你会更容易理解新的编程语言和软件框架，建模与抽象的能力越来越好，写出的代码自然简洁、高效、可维护，进而能够构建出复杂的软件系统。</p>
<p>2021年5月18日，冯新宇老师在浙江大学做了讲座：漫谈编程语言的设计和实现[2]。冯新宇老师的讲座向大家介绍了编程语言的设计和实现中一些关键因素以及它们之间的联系，刚好弥补了一些当前编程语言教育的不足。下文是我的讲座笔记，希望对大家学习和理解编程语言（尤其是Rust）有所助益。</p>
<p>（长文预警，下文图片均选自讲座slides～）</p>
<h2><a class="header" href="#编程语言设计和实现关注什么" id="编程语言设计和实现关注什么">编程语言设计和实现：关注什么</a></h2>
<h3><a class="header" href="#关注什么" id="关注什么">关注什么</a></h3>
<img src="chapter_5/./image/pl/1-pl.png" alt="img" style="zoom:50%;" />
<p>编程语言是人机接口，指令集是软硬件接口，编译器将编程语言翻译成适用于特定指令集的指令序列。</p>
<img src="chapter_5/./image/pl/2-pl.png" alt="img" style="zoom:48%;" />
<p>在软件开发活动中，哪些需要程序员说，哪些不用说就可以实现。即编程语言的处理分为静态和动态两个阶段。静态阶段包括 parsing 和type-checking，以确保程序是well-formed；动态阶段是该well-formed程序的执行过程。如果一个well-formed的程序在执行时是well-behaved的，那么就说这个语言是安全的[3]。抽象语义和类型系统是编程语言的核心。</p>
<p>编程语言设计和实现的过程，就是确定两者边界的过程。边界如何确定，答案并不唯一。例如对于释放堆空间，在C语言中，需要在代码中显示的表达出来；在Java中，堆空间的释放不需要在代码中显示的表达出来，Java有垃圾回收机制，堆空间会在运行时自动回收。</p>
<img src="chapter_5/./image/pl/3-pl.png" alt="img" style="zoom:50%;" />
<p>开发态是针对软件开发者而言的，开发者希望编程语言能简单、高效、正确的表达计算任务。运行态是针对计算机而言的，希望用尽量少的时间和硬件资源完成计算任务。编程语言面对的是多样化的应用场景、运行环境和开发者群体，众口难调，并不存在一统天下的语言。</p>
<img src="chapter_5/./image/pl/4-pl.png" alt="img" style="zoom:60%;" />
<p>在编程语言设计的设计和实现中，易用性、安全性和性能三者难以兼顾，常常是改善了其中一个指标，同时也恶化另一个指标。所以需要根据应用场景做平衡和折衷。</p>
<img src="chapter_5/./image/pl/5-pl.png" alt="img" style="zoom:55%;" />
<p>JavaScript、Python、Lua属于动态脚本语言，易用性较高，但性能和可维护性差。适用于代码量小，Run过即抛的小型项目。Java、Go 、Dart 、C# 、Swift 、Kotlin 在安全性、易用性和性能三个方面表现比较均衡，适用于大中型的应用软件开发。C和C++为了追求性能，舍弃了安全性，产生了很多陷阱，造成debug和维护困难。Rust 是目前很受欢迎的一门系统编程语言，它在安全性和性能上做的很好，但上手门槛较高，对使用者的素质有一定要求。</p>
<h3><a class="header" href="#易用性" id="易用性">易用性</a></h3>
<img src="chapter_5/./image/pl/6-pl.png" alt="img" style="zoom:35%;" />
<p>不标注类型的代码更易写。但带有类型标注的代码更易读、更易维护，因为类型标注提供了额外信息，比如fun f(g: int -&gt; int, x: int): int, 从类型标注可知f的第一个参数g是个函数，第二个输入参数x是个整数，函数返回一个整数。</p>
<img src="chapter_5/./image/pl/7-pl.png" alt="img" style="zoom:32%;" />
<p>不同的开发者群体对易用性的诉求是不一样的。应用开发人员希望语言特性精简，这样简单易学还容易维护，不要搞那么多稀奇古怪的语法特性，很难掌握，平时做应用开发也用不到。而库、框架和DSL的开发者，希望语言易复用、易扩展，希望编程语言具有泛型、运算符重载、宏等特性。</p>
<img src="chapter_5/./image/pl/8-pl.png" alt="img" style="zoom:33%;" />
<p>上述代码自定义了运算符+*-，这对DSL的使用者或许非常有用。但普通开发者却非常讨厌这种自定义运算符，因为它严重降低了程序的可读性。</p>
<h3><a class="header" href="#易用性-vs-安全性" id="易用性-vs-安全性">易用性 vs. 安全性</a></h3>
<img src="chapter_5/./image/pl/9-pl.png" alt="img" style="zoom:40%;" />
<p>易用性和安全性需要折衷，为了提升安全性，对开发者设置更多约束。这种约束主要体现在两个方面。第一个方面，在语法上禁止某些容易出错的语言特性。比如，Dijkstra 认为go to语句是有害的，所以现代编程语言就没有实现这个语言特性了。第二个方面，通过类型系统禁止可能出错的写法。这些约束虽然提升了安全性，但也降低了语言的易用性，编写代码时总感觉束手束脚。总之，安全性和易用性也是矛盾的，需要折衷和平衡。</p>
<img src="chapter_5/./image/pl/10-pl.png" alt="img" style="zoom:40%;" />
<p>根据是否允许自由类型转换，类型系统可以分为弱类型系统和强类型系统。JavaScript就是典型的弱类型系统，允许自由的类型转换，所以会出现各种各样、五花八门的坑。</p>
<img src="chapter_5/./image/pl/11-pl.png" alt="img" style="zoom:40%;" />
<p>C/C++也是弱类型系统，带来很多坑：悬空指针、double free、下标越界、缓冲区溢出等等。Rust是强类型的，它通过静态类型系统增强和动态检查来保证安全性，但 Rust 学习门槛较高。由于弱类型难以保证安全性，近年来新设计的编程语言已经很少采用弱类型系统了。</p>
<p>根据何时检查约束规则，类型系统又有静态和动态之分。如果全部或几乎全部的类型检查是在编译期进行的，那么就称为静态类型系统。如果全部或几乎全部的类型检查是在运行时进行的，那么就称为动态类型系统。两者各有优劣，有时候只有在运行时才能确定程序的执行流，所以在运行时做类型检查会更准确，但运行时类型检查会降低程序性能。如果采用静态类型检查，它的原则是宁杀错，不放过，有时会产生一些误判。</p>
<img src="chapter_5/./image/pl/12-pl.png" alt="img" style="zoom:35%;" />
<p>动态和静态类型各有优缺点，我们能否兼得两者的优点呢？Gradual type的目标正是兼顾两者优点，也是目前学术界的热门研究方向。</p>
<h3><a class="header" href="#易用性-vs-性能" id="易用性-vs-性能">易用性 vs. 性能</a></h3>
<img src="chapter_5/./image/pl/13-pl.png" alt="img" style="zoom:40%;" />
<p>在易用性和性能之间也需要权衡。虽然动态派遣的易用性高，但性能不如静态派遣。</p>
<img src="chapter_5/./image/pl/14-pl.png" alt="img" style="zoom:40%;" />
<p>语言特性越接近底层、越具体，开发者对细节会更有掌控，有利于性能的提高。而抽象会隐藏细节，易用性好，但性能往往不好。最近Intel推出了oneAPI，声称可以对程序员抽象掉具体硬件细节（CPU 、GPU、 AI加速器与FPGA），同时又不损失性能。至于真实效果如何，还有待验证。</p>
<h3><a class="header" href="#安全性-vs-性能" id="安全性-vs-性能">安全性 vs. 性能</a></h3>
<img src="chapter_5/./image/pl/15-pl.png" alt="img" style="zoom:40%;" />
<p>采用复杂的静态类型检查，虽然可以提升安全性，但也增加了学习和开发成本。所以会把一些安全机制（动态类型检查、垃圾回收等）放在运行时来做，但这样做会损失一些性能。这种动态保证安全性的机制集中体现在非系统编程语言中，如Java、Golang等。</p>
<h2><a class="header" href="#总结-10" id="总结-10">总结</a></h2>
<p>由于国内编程语言教育的缺陷，学生对编程语言普遍缺乏一种抓得住的“全局观”和举一反三的能力。编程语言是软件开发的基本工具，它一方面直接影响开发效率和开发体验，另一方面也影响软件运行时的表现，如性能和可靠性等。编程语言的设计和实现需要考虑三个关键因素：易用性、安全性和性能。三者难以兼顾，需要平衡和折衷。</p>
<h2><a class="header" href="#参考资料-5" id="参考资料-5">参考资料</a></h2>
<p>[1] <a href="https://zhuanlan.zhihu.com/p/43914842">浅谈国内高效编程语言教育</a></p>
<p>[2] <a href="https://www.bilibili.com/video/BV15V41177vF?from=search&amp;seid=4586480071230860986">漫谈编程语言的设计与实现, 冯新宇</a></p>
<p>[3] Robert Harper, Practical Foundations for Programming Languages, Second Edition, Cambridge University Press, 2016.</p>
<h1><a class="header" href="#华为--stratovirt-vcpu管理-rust线程同步的实现" id="华为--stratovirt-vcpu管理-rust线程同步的实现">华为 | StratoVirt VCPU管理-Rust线程同步的实现</a></h1>
<p>作者： 高炜 / 后期编辑：张汉东</p>
<hr />
<p>StratoVirt是开源在openEuler社区的轻量级虚拟化平台，具备轻量低噪、强安全性的行业竞争力。</p>
<p>StratoVirt进程运行在用户态，在虚拟机启动之前，StratoVirt会完成启动之前的准备工作，包括虚拟机内存的初始化、CPU寄存器初始化、设备初始化等，启动，CPU寄存器初始化和虚拟机在运行过程中VCPU陷出事件的处理，都是由StratoVirt的VCPU管理模块<code>CPU</code>完成。如下是StratoVirt中VCPU管理模块的组成，以及其在StratoVirt中的位置。</p>
<pre><code>stratovirt
├── address_space
├── boot_loader
├── Cargo.lock
├── Cargo.toml
├── cpu
│   ├── Cargo.toml
│   └── src
│       ├── aarch64
│       │   └── mod.rs
│       ├── lib.rs
│       └── x86_64
│           ├── cpuid.rs
│           └── mod.rs
├── devices
├── machine_manager
├── micro_vm
├── src
│   └── main.rs
├── sysbus
├── util
└── virtio
</code></pre>
<h2><a class="header" href="#stratovirt-vcpu模块的整体设计" id="stratovirt-vcpu模块的整体设计">StratoVirt VCPU模块的整体设计</a></h2>
<p>StratoVirt的虚拟化解决方案也是一套软硬结合的硬件辅助虚拟化解决方案，它的运作依赖于硬件辅助虚拟化的能力（如VT-X或Kunpeng-V）。VCPU模块的实现也是紧密依赖于这一套硬件辅助虚拟化的解决方案的。</p>
<p>对于物理机的CPU而言，硬件辅助虚拟化为CPU增加了一种新的模式：Non-Root模式，在该模式下，CPU执行的并不是物理机的指令，而是虚拟机的指令。这种指令执行方式消除了大部分性能开销，非常高效。但是特权指令（如I/O指令）不能通过这种方式执行，还是会强制将CPU退出到普通模式（即ROOT模式）下交给内核KVM模块和用户态StratoVirt去处理，处理完再重新回到Non-Root模式下执行下一条指令。</p>
<p>而StratoVirt中的VCPU模块主要围绕着KVM模块中对VCPU的模拟来实现，为了支持KVM模块中对CPU的模拟，CPU子系统主要负责处理退出到普通模式的事件，以及根据在GuestOS内核开始运行前对VCPU寄存器等虚拟硬件状态的初始化。整个VCPU模块的设计模型如下图所示：</p>
<p><img src="chapter_5/./image/hw/cpu-thread.png" alt="cpu" /></p>
<p>StratoVirt通过第三方库<code>kvm_ioctls</code>来完成和KVM模块的交互，通过匹配<code>vcpu_fd.run()</code>函数的返回值来处理退出到ROOT模式的事件，该函数的返回值是一个名为<code>VcpuExit</code>的枚举，定义了退出到ROOT模式的事件类型，包括I/O的下发、系统关机事件、系统异常事件等，根据事件的类型VCPU将对不同的事件作出各自的处理。以上的整个过程都被包含在一个独立的VCPU线程中，用户可以自己通过对VCPU线程进行绑核等方式让虚拟机的VCPU获取物理机CPU近似百分之百的性能。</p>
<p>同时，对VCPU寄存器虚拟硬件状态信息的初始化则是和StratoVirt的另一个模块BootLoader相互结合，在BootLoader中实现了一种根据Linux启动协议快速引导启动Linux内核镜像的方法，在这套启动流程中，BootLoader将主动完成传统BIOS对一些硬件信息的获取，将对应的硬件表保存在虚拟机内存中，同时将提供一定的寄存器设置信息，这些寄存器设置信息将传输给VCPU模块，通过设置VCPU结构中的寄存器值，让虚拟机CPU跳过实模式直接进入保护模式运行，这样Linux内核就能直接从保护模式的入口开始运行，这种方式让StratoVirt的启动流程变得轻量快速。</p>
<p>在整个VCPU模块中，因为涉及到内核的KVM模块，少不了与C语言代码做交互。作为系统编程语言，Rust对FFI有非常完善的支持，让VCPU中和KVM模块交互的部分高效且安全。</p>
<h2><a class="header" href="#vcpu线程模型同步" id="vcpu线程模型同步">VCPU线程模型同步</a></h2>
<p>VCPU模块还有一大职责就是管理VCPU的生命周期，包括new（创建），realize（使能），run（运行），pause（暂停），resume（恢复），destroy（销毁）。New和realize的过程就是结构体创建和寄存器初始化的流程，run的过程即是实现KVM中VCPU运作和<code>VCPU_EXIT</code>退出事件处理的流程。</p>
<p>另外的三种生命周期的实现则涉及到对线程同步的精密控制，例如在虚拟机destroy的过程中，一般只有某一个VCPU接收到<code>VCPU_EXIT</code>中的<code>SHUTDOWN</code>事件，该VCPU线程需要把该事件传递到所有的VCPU线程，同步所有VCPU线程的状态，完成虚拟机的优雅关机。在这种场景下，我们就需要考虑在Rust中如何实现在多线程中进行状态同步。</p>
<h3><a class="header" href="#rust中通过条件变量来实现同步" id="rust中通过条件变量来实现同步">Rust中通过条件变量来实现同步</a></h3>
<p>Rust多线程编程中，有一类用于同步的机制叫做屏障（Barrier），用于让多线程来同步一些流程开始的位置，它相当于一个闸口，使用wait方法，将该线程放进临界区并阻塞住，只有每个Barrier都到达wait方法调用的点，闸口才会打开，所有的线程同步往下运行。</p>
<p>而在比较复杂的同步场景中，Rust还提供了另一个同步机制条件变量（Condition Variable）来支持更复杂的同步场景，它和屏障的功能类似，但是它并不阻塞全部进程，而是在满足指定的条件之前阻塞某个得到互斥锁的进程。也就是说，通过条件变量，我们可以在达到某种条件之前阻塞某个线程，这个特性可以让我们很好得对线程进行同步。</p>
<p>为了支持各种场景的同步控制，条件变量还提供了三个方法：</p>
<ul>
<li>notify_one(): 用来通知一次阻塞线程，如果有复数个线程被阻塞住，<code>notify_one</code>会被一个阻塞的线程所消耗，不会传递到别的阻塞线程去。</li>
<li>notify_all(): 用来通知所有的阻塞线程。</li>
<li>wait_timeout(): 将当前线程置入临界区阻塞住并等待通知，可以设定一个<code>timeout</code>来设置阻塞的最大时间，以免造成永久的阻塞导致程序卡死。</li>
</ul>
<p>需要注意的一点是条件变量需要和锁一起使用，而在程序运行中，每个条件变量每次只能和一个互斥体（被Mutex等锁包裹都可称为互斥体）进行使用。</p>
<h3><a class="header" href="#vcpu生命周期控制和线程同步" id="vcpu生命周期控制和线程同步">VCPU生命周期控制和线程同步</a></h3>
<p>在<code>CPU</code>数据结构初始化时，创建一个互斥的生命周期枚举(<code>CpuLifecycleState</code>)和一个条件变量。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(
        vcpu_fd: Arc&lt;VcpuFd&gt;,
        id: u8,
        arch_cpu: Arc&lt;Mutex&lt;ArchCPU&gt;&gt;,
        vm: Arc&lt;Mutex&lt;dyn MachineInterface + Send + Sync&gt;&gt;,
    ) -&gt; Self {
        CPU {
            id,
            fd: vcpu_fd,
            arch_cpu,
            state: Arc::new((Mutex::new(CpuLifecycleState::Created), Condvar::new())),
            work_queue: Arc::new((Mutex::new(0), Condvar::new())),
            task: Arc::new(Mutex::new(None)),
            tid: Arc::new(Mutex::new(None)),
            vm: Arc::downgrade(&amp;vm),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>以destory生命周期为例，在<code>x86_64</code>架构下，当某个VCPU线程接收到<code>VcpuExit::Shutdown</code>事件后，会将该线程的<code>CpuLifecycleState</code>修改为<code>Stopped</code>，并调用保存在<code>CPU</code>数据结构中一个指向上层结构的虚拟机<code>destroy</code>方法，该方法能遍历一个保存着所有<code>CPU</code>数据结构的数组，执行数组中每一个<code>CPU</code>的<code>destory()</code>方法，该函数的实现如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn destory(&amp;self) -&gt; Result&lt;()&gt; {
    let (cpu_state, cvar) = &amp;*self.state;
    if *cpu_state.lock().unwrap() == CpuLifecycleState::Running {
        *cpu_state.lock().unwrap() = CpuLifecycleState::Stopping;
    } else {
        *cpu_state.lock().unwrap() = CpuLifecycleState::Stopped;
    }
    
    /* 省略具体的关机逻辑 */
    
    let mut cpu_state = cpu_state.lock().unwrap();
    cpu_state = cvar
            .wait_timeout(cpu_state, Duration::from_millis(32))
            .unwrap()
            .0;

    if *cpu_state == CpuLifecycleState::Stopped {
        *cpu_state = CpuLifecycleState::Nothing;
        Ok(())
    } else {
        Err(ErrorKind::DestroyVcpu(format!(&quot;VCPU still in {:?} state&quot;, *cpu_state)).into())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>作为<code>CPU</code>的成员方法，<code>destory</code>函数能获取到每个<code>CPU</code>数据结构的互斥状态和条件变量，此时将除触发VCPU外所有的<code>CPU</code>数据的互斥状态解锁，并将状态从运行时的<code>Running</code>修改为VCPU关机时的<code>Stopping</code>。这里要注意一点，此时所有<code>CPU</code>的<code>destroy</code>函数都是在触发关机事件的VCPU进程中进行的，而不是在每个VCPU各自的进程中进行。</p>
<p>紧接着进入<code>Stopping</code>状态后，<code>destroy</code>函数会执行每个VCPU各自的关机逻辑，包括触发VCPU，这部分主要还是与KVM模块进行交互，进行一些退出状态的变更等。在执行完VCPU的关机逻辑后，条件变量会进入到<code>wait_timeout</code>的等待状态，它的参数为每个VCPU的<code>CpuLifecycleState</code>生命周期状态枚举和等待超时时间，也就是说在该生命周期枚举状态变化前，该线程都会进入阻塞状态。</p>
<p>此时除触发VCPU外的VCPU线程中，<code>CpuLifecycleState</code>都已经进入了<code>Stopping</code>状态，在所有VCPU线程中，VCPU的指令模拟函数<code>kvm_vcpu_exec()</code>都运行在一个循环中，对于每次循环的入口，都会执行<code>ready_for_running()</code>函数进入是否继续模拟的判断，在该函数中会对每个VCPU对应的<code>CpuLifecycleState</code>进行监控，当发现<code>CpuLifecycleState</code>已经变成<code>Stopping</code>时，VCPU将会退出循环，不继续进行VCPU的模拟，退出模拟的循环后，将会修改<code>CpuLifecycleState</code>为<code>Stopped</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The vcpu thread is about to exit, marking the state of the CPU state as Stopped.
let (cpu_state, _) = &amp;*self.thread_cpu.state;
*cpu_state.lock().unwrap() = CpuLifecycleState::Stopped;
<span class="boring">}
</span></code></pre></pre>
<p>修改VCPU线程中互斥的生命周期状态枚举后，将会触发阻塞线程中对应的<code>wait_timeout()</code>函数，同时，该VCPU线程的生命周期结束。而对于阻塞线程，当其余VCPU线程的状态都已经变成<code>Stopped</code>后，阻塞解除，此时，所有的VCPU线程都已经状态都已经同步到了<code>Stopped</code>，线程状态同步成功。</p>
<p>用类似思路也可以实现pause（暂停）和resume（恢复）的生命周期控制。</p>
<h2><a class="header" href="#关注我们-2" id="关注我们-2">关注我们</a></h2>
<p>StratoVirt当前已经在openEuler社区（openEuler是一个开源、免费的Linux发行版平台，将通过开放的社区形式与全球的开发者共同构建一个开放、多元和架构包容的软件生态体系）开源。在未来的一段时间我们将开展一系列主题的分享，让大家更加详细的了解StratoVirt实现，非常期待您的围观和加入！</p>
<p>项目地址：https://gitee.com/openeuler/stratovirt</p>
<p>项目wiki：https://gitee.com/openeuler/stratovirt/wikis</p>
<p>项目交流：<a href="https://mailweb.openeuler.org/postorius/lists/virt.openeuler.org/">virt邮件列表</a>或是提交一个<a href="https://gitee.com/openeuler/stratovirt/issues">issue</a>。</p>
<h1><a class="header" href="#蚂蚁集团--如何在生产环境排查-rust-内存占用过高问题" id="蚂蚁集团--如何在生产环境排查-rust-内存占用过高问题">蚂蚁集团 ｜ 如何在生产环境排查 Rust 内存占用过高问题</a></h1>
<p>作者：ShiKaiWi / 后期编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#背景-1" id="背景-1">背景</a></h2>
<p>内存安全的 Rust，虽然基本不会出现内存泄漏，但如何合理分配内存，是每个复杂应用都要面临的问题。往往随着业务的不同，相同的代码可能会产生不同的内存占用，因此，有不小的概率会出现内存使用过多、内存逐渐增长不释放的问题。</p>
<p>在本文中，我想分享一下，我们在实践过程中，遇到的关于内存占用过高的问题，对于这些内存问题，在本文中，会做出简单的分类以及我们在生产环境下进行排查定位的方法。</p>
<h2><a class="header" href="#内存分配器" id="内存分配器">内存分配器</a></h2>
<p>首先在生产环境，我们往往不会选择默认的内存分配器（malloc），而是会选择 jemalloc，可以提供更好的多核性能以及更好的避免内存碎片（详细原因可以参考[1]），而在 Rust 的生态中，对于 jemalloc 的封装有很多优秀的库，这里我们就不纠结于哪一个库更好，我们更关心如何使用 jemalloc 提供的分析能力，帮助我们诊断内存问题。</p>
<p>阅读 jemalloc 的<a href="http://jemalloc.net/jemalloc.3.html#tuning">使用文档</a>，可以知道其提供了基于采样方式的内存 profile 能力，而且可以通过 <code>mallctl</code> 可以设置 <code>prof.active</code> 和 <code>prof.dump</code> 这两个选项，来达到动态控制内存 profile 的开关和输出内存 profile 信息的效果。</p>
<h2><a class="header" href="#内存快速增长直至-oom" id="内存快速增长直至-oom">内存快速增长直至 oom</a></h2>
<p>这样的情况一般是相同的代码在面对不同的业务场景时会出现，因为某种特定的输入（往往是大量的数据）引起程序的内存快速增长。</p>
<p>不过有了上面提到的 memory profiling 功能，快速的内存增长其实一个非常容易解决的情况，因为我们可以在快速增长的过程中打开 profile 开关，一段时间后，输出 profile 结果，通过相应的工具进行可视化，就可以清楚地了解到哪些函数调用进行了哪些结构的内存分配。</p>
<p>不过这里分为两种情况：可以复现以及难以复现，对于两种情况的处理手段是不一样的，下面对于这两种情况分别给出可操作的方案。</p>
<h3><a class="header" href="#可以复现" id="可以复现">可以复现</a></h3>
<p>可以复现的场景其实是最容易的解决的问题，因为我们可以在复现期间采用动态打开 profile，在短时间内的获得大量的内存分配信息即可。</p>
<p>下面给出一个完整的 demo，展示一下在 Rust 应用中如何进行动态的内存 profile。</p>
<p>本文章，我会采用 <code>jemalloc-sys</code> <code>jemallocator</code> <code>jemalloc-ctl</code> 这三个 Rust 库来进行内存的 profile，这三个库的功能主要是：</p>
<ul>
<li><code>jemalloc-sys</code>: 封装 jemalloc。</li>
<li><code>jemallocator</code>: 实现了 Rust 的 <code>GlobalAlloc</code>，用来替换默认的内存分配器。</li>
<li><code>jemalloc-ctl</code>: 提供了对于 mallctl 的封装，可以用来进行 tuning、动态配置分配器的配置、以及获取分配器的统计信息等。</li>
</ul>
<p>下面是 demo 工程的依赖：</p>
<pre><code class="language-toml">[dependencies]
jemallocator = &quot;0.3.2&quot;
jemalloc-ctl = &quot;0.3.2&quot;

[dependencies.jemalloc-sys]
version = &quot;0.3.2&quot;
features = [&quot;stats&quot;, &quot;profiling&quot;, &quot;unprefixed_malloc_on_supported_platforms&quot;]

[profile.release]
debug = true
</code></pre>
<p>其中比较关键的是 <code>jemalloc-sys</code> 的几个 features 需要打开，否则后续的 profile 会遇到失败的情况，另外需要强调的是 demo 的运行环境是在 Linux 环境下运行的。</p>
<p>然后 demo 的 src/main.rs 的代码如下：</p>
<pre><code class="language-Rust">use jemallocator;
use jemalloc_ctl::{AsName, Access};
use std::collections::HashMap;

#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;

const PROF_ACTIVE: &amp;'static [u8] = b&quot;prof.active\0&quot;;
const PROF_DUMP: &amp;'static [u8] = b&quot;prof.dump\0&quot;;
const PROFILE_OUTPUT: &amp;'static [u8] = b&quot;profile.out\0&quot;;

fn set_prof_active(active: bool) {
    let name = PROF_ACTIVE.name();
    name.write(active).expect(&quot;Should succeed to set prof&quot;);
}

fn dump_profile() {
    let name = PROF_DUMP.name();
    name.write(PROFILE_OUTPUT).expect(&quot;Should succeed to dump profile&quot;)
}

fn main() {
    set_prof_active(true);

    let mut buffers: Vec&lt;HashMap&lt;i32, i32&gt;&gt; = Vec::new();
    for _ in 0..100 {
		buffers.push(HashMap::with_capacity(1024));
    }

    set_prof_active(false);
    dump_profile();
}
</code></pre>
<p>demo 已经是非常简化的测试用例了，主要做如下的说明：</p>
<ul>
<li><code>set_prof_active</code> 和 <code>dump_profile</code> 都是通过 jemalloc-ctl 来调用 jemalloc 提供的 mallctl 函数，通过给相应的 key 设置 value 即可，比如这里就是给 <code>prof.active</code> 设置布尔值，给 <code>profile.dump</code> 设置 dump 的文件路径。</li>
</ul>
<p>编译完成之后，直接运行程序是不行的，需要设置好环境变量（开启内存 profile 功能）：</p>
<pre><code>export MALLOC_CONF=prof:true
</code></pre>
<p>然后再运行程序，就会输出一份 memory profile 文件，demo 中文件名字已经写死 —— <code>profile.out</code>，这个是一份文本文件，不利于直接观察（没有直观的 symbol）。</p>
<p>通过 jeprof 等工具，可以直接将其转化成可视化的图形：</p>
<pre><code>jeprof --show_bytes --pdf &lt;path_to_binary&gt; ./profile.out &gt; ./profile.pdf
</code></pre>
<p>这样就可以将其可视化，从下图中，我们可以清晰地看到所有的内存来源：</p>
<p><img src="chapter_5/./image/ant/1.png" alt="mem-profile" /> </p>
<p>这个 demo 的整体流程就完成了，距离应用到生产的话，只差一些 trivial 的工作，下面是我们在生产的实践：</p>
<ul>
<li>将其封装成 http 服务，可以通过 curl 命令直接触发，将结果通过 http response 返回。</li>
<li>支持设置 profile 时长。</li>
<li>处理并发触发 profile 的情况。</li>
</ul>
<p>说到这里，这个方案其实有一个好处一直没有提到，就是它的动态性，因为开启内存 profile 功能，势必是会对性能产生一定的影响（虽然这里开启的影响并不是特别大），我们自然是希望在没有问题的时候，避免开启这个 profile 功能，因此这个动态开关还是非常实用的。</p>
<h3><a class="header" href="#难以复现" id="难以复现">难以复现</a></h3>
<p>事实上，可以稳定复现的问题都不是问题，生产上，最麻烦的问题是难以复现的问题，难以复现的问题就像是一个定时炸弹，复现条件很苛刻导致难以精准定位问题，但是问题又会冷不丁地出现，很是让人头疼。</p>
<p>一般对于难以复现的问题，主要的思路是提前准备好保留现场，在问题发生的时候，虽然服务出了问题，但是我们保存了出问题的现场，比如这里的内存占用过多的问题，有一个很不错的思路就是：在 oom 的时候，产生 coredump。</p>
<p>不过我们在生产的实践并没有采用 coredump 这个方法，主要原因是生产环境的服务器节点内存往往较大，产生的 coredump 也非常大，光是产生 coredump 就需要花费不少时间，会影响立刻重启的速度，此外分析、传输、存储都不太方便。</p>
<p>这里介绍一下我们在生产环境下采用的方案，实际上也是非常简单的方法，通过 jemalloc 提供的功能，可以很简单的进行间接性地输出内存 profile 结果。</p>
<p>在启动使用了 jemalloc 的、准备长期运行的程序，使用环境变量设置 jemalloc 参数：</p>
<pre><code>export MALLOC_CONF=prof:true,lg_prof_interval:30
</code></pre>
<p>这里的参数增加了一个 <code>lg_prof_interval:30</code>，其含义是内存每增加 1GB（2^30，可以根据需要修改，这里只是一个例子），就输出一份内存 profile，这样随着时间的推移，如果发生了内存的突然增长（超过设置的阈值），那么相应的 profile 一定会产生，那么我们就可以在发生问题的时候，根据文件的创建日期，定位到出问题的时刻，内存究竟发生了什么样的分配。</p>
<h2><a class="header" href="#内存缓慢增长不释放" id="内存缓慢增长不释放">内存缓慢增长不释放</a></h2>
<p>不同于内存的急速增长，内存整体的使用处于一个稳定的状态，但是随着时间的推移，内存又在稳定地、缓慢的增长，通过上面所说的方法，很难发现内存究竟在哪里使用了。</p>
<p>这个问题也是我们在生产碰到的非常棘手的问题之一，相较于此前的剧烈变化，我们不再关心发生了哪些分配事件，我们更关心的是当前的内存分布情况，但是在没有 GC 的 Rust 中，观察当前程序的内存分布情况，并不是一件很简单的事情（尤其是在不影响生产运行的情况下）。</p>
<p>针对这个情况，我们在生产环境中的实践是这样的：</p>
<ul>
<li>手动释放部分结构（往往是缓存）内存</li>
<li>然后观察前后的内存变化（释放了多少内存），确定各个模块的内存大小</li>
</ul>
<p>而借助 jemalloc 的统计功能，可以获取到当前的内存使用量，我们完全可以重复进行 <strong>释放制定模块的内存+计算释放大小</strong>，来确定内存的分布情况。</p>
<p>这个方案的缺陷也是很明显的，就是参与内存占用检测的模块是先验的（你无法发现你认知以外的内存占用模块），不过这个缺陷还是可以接受的，因为一个程序中可能的占用内存过大的地方，我们往往都是知道的。</p>
<p>下面给出一个 demo 工程，可以根据这个 demo 工程，应用到生产。</p>
<p>下面是 demo 工程的依赖:</p>
<pre><code class="language-toml">[dependencies]
jemallocator = &quot;0.3.2&quot;
jemalloc-ctl = &quot;0.3.2&quot;

[dependencies.jemalloc-sys]
version = &quot;0.3.2&quot;
features = [&quot;stats&quot;, &quot;profiling&quot;, &quot;unprefixed_malloc_on_supported_platforms&quot;]

[profile.release]
debug = true
</code></pre>
<p>demo 的 src/main.rs 的代码：</p>
<pre><code class="language-Rust">use jemallocator;
use jemalloc_ctl::{epoch, stats};

#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;

fn alloc_cache() -&gt; Vec&lt;i8&gt; {
    let mut v = Vec::with_capacity(1024 * 1024);
    v.push(0i8);
    v
}

fn main() {
    let cache_0 = alloc_cache();
    let cache_1 = alloc_cache();

    let e = epoch::mib().unwrap();
    let allocated_stats = stats::allocated::mib().unwrap();
    let mut heap_size = allocated_stats.read().unwrap();

    drop(cache_0);
    e.advance().unwrap();
    let new_heap_size = allocated_stats.read().unwrap();
    println!(&quot;cache_0 size:{}B&quot;, heap_size - new_heap_size);
    heap_size = new_heap_size;

    drop(cache_1);
    e.advance().unwrap();
    let new_heap_size = allocated_stats.read().unwrap();
    println!(&quot;cache_1 size:{}B&quot;, heap_size - new_heap_size);
    heap_size = new_heap_size;

    println!(&quot;current heap size:{}B&quot;, heap_size);
}
</code></pre>
<p>比起上一个 demo 长了一点，但是思路非常简单，只要简单说明一下 jemalloc-ctl 的一个使用注意点即可，在获取新的统计信息之前，必须先调用一下 <code>epoch.advance()</code> 。</p>
<p>下面是我的编译后运行的输出信息：</p>
<pre><code class="language-bash">cache_0 size:1048576B
cache_1 size:1038336B
current heap size:80488B
</code></pre>
<p>这里可以发现，cache_1 的 size 并不是严格的 1MB，这个可以说是正常的，一般来说（不针对这个 demo）主要有两个原因：</p>
<ul>
<li>在进行内存统计的时候，还有其他的内存变化在发生。</li>
<li>jemalloc 提供的 stats 数据不一定是完全准确的，因为他为了更好的多核性能，不可能使用全局的统计，因此实际上是为了性能，放弃了统计信息的一致性。</li>
</ul>
<p>不过这个信息的不精确，并不会给定位内存占用过高的问题带来阻碍，因为释放的内存往往是巨大的，微小的扰动并不会影响到最终的结果。</p>
<p>另外，其实还有更简单的方案，就是通过释放缓存，直接观察机器的内存变化，不过需要知道的是内存不一定是立即还给 OS 的，而且靠眼睛观察也比较累，更好的方案还是将这样的内存分布检查功能集成到自己的 Rust 应用之中。</p>
<h2><a class="header" href="#其他通用方案" id="其他通用方案">其他通用方案</a></h2>
<h3><a class="header" href="#metrics" id="metrics">metrics</a></h3>
<p>另外还有一个非常有效、我们一直都在使用的方案，就是在产生大量内存分配的时候，将分配的内存大小记录成指标，供后续采集、观察。</p>
<p>整体的方案如下：</p>
<ul>
<li>使用 Prometheus Client 记录分配的内存（应用层统计）。</li>
<li>暴露出 metrics 接口。</li>
<li>配置 Promethues server，进行 metrics 拉取。</li>
<li>配置 Grafana，连接 Prometheus server，进行可视化展示。</li>
</ul>
<h3><a class="header" href="#内存排查工具" id="内存排查工具">内存排查工具</a></h3>
<p>在内存占用过高的排查过程中，也尝试过其他的强大工具，比如 heaptrack、valgrind 等工具，但是这些工具有一个巨大的弊端，就是会带来非常大的 overhead，一般来说，使用这类工具的话，基本上应用程序是不可能在生产运行的。</p>
<p>也正因如此，在生产的环境下，我们很少使用这类工具排查内存的问题。</p>
<h2><a class="header" href="#总结-11" id="总结-11">总结</a></h2>
<p>虽然 Rust 已经帮我们避免掉了内存泄漏的问题，但是内存占用过高的问题，我想不少在生产长期运行的程序还是会有非常大的概率出现的。本文主要分享了我们在生产环境中遇到的几种内存占用过高的问题场景，以及目前我们在不影响生产正常服务的情况下，一些常用的、快速定位问题的排查方案，希望能给大家带来一些启发和帮助。</p>
<p>当然可以肯定的是，还有其他我们没有遇到过的内存问题，也还有更好的、更方便的方案去做内存问题的定位和排查，希望知道的同学可以一起多多交流。</p>
<h2><a class="header" href="#参考-3" id="参考-3">参考</a></h2>
<p>[1] <a href="http://www.adms-conf.org/2019-camera-ready/durner_adms19.pdf">Experimental Study of Memory Allocation forHigh-Performance Query Processing</a></p>
<p>[2] <a href="http://jemalloc.net/jemalloc.3.html">jemalloc 使用文档</a></p>
<p>[3] <a href="https://github.com/gnzlbg/jemallocator">jemallocator</a></p>
<h2><a class="header" href="#关于我们-3" id="关于我们-3">关于我们</a></h2>
<p>我们是蚂蚁智能监控技术中台的时序存储团队，我们正在使用 Rust 构建高性能、低成本并具备实时分析能力的新一代时序数据库，欢迎加入或者推荐，请联系：jiachun.fjc@antgroup.com</p>
<h1><a class="header" href="#datenlord--rust实现rdma异步编程一基于epoll实现rdma-异步操作" id="datenlord--rust实现rdma异步编程一基于epoll实现rdma-异步操作">Datenlord | Rust实现RDMA异步编程（一）：基于<code>epoll</code>实现RDMA 异步操作</a></h1>
<p>作者：王璞 / 后期编辑： 张汉东</p>
<hr />
<p>RDMA是一套高性能网络协议栈，多用于高性能计算、高性能存储领域。RDMA的library是用C实现的，但是没有很好用的Rust的binding，不方便Rust开发者使用。于是我们正在封装一层符合Rust风格、便于Rust开发者使用的<a href="https://github.com/datenlord/async-rdma">RDMA Rust binding</a>。特别的，异步编程是近几年很受关注的编程方式，用Rust异步编程来实现IO操作，可以避免操作系统的进程上下文切换，提高性能，而且Rust的异步编程框架也在逐步成熟和完善。本系列文章探讨下如何用异步的方式实现RDMA的操作。本文先讨论下如何基于Linux的<code>epoll</code>机制实现RDMA异步操作，后续的文章再探讨如何用Rust异步编程来实现RDMA异步操作。</p>
<h2><a class="header" href="#rdma操作简介" id="rdma操作简介">RDMA操作简介</a></h2>
<p>RDMA的编程模型是基于消息的方式来实现网络传输，并且用队列来管理待发送的消息和接收到的消息。RDMA的网络传输相关操作基本上都是跟队列相关的操作：比如把要发送的消息放入发送队列，消息发送完成后在完成队列里放一个发送完成消息，以供用户程序查询消息发送状态；再比如接收队列里收到消息，也要在完成队列里放个接收完成消息，以供用户程序查询有新消息要处理。</p>
<p><img src="chapter_5/./image/datenlord/QP.png" alt="RDMA QP" /></p>
<p>由上面的描述可以看出RDMA的队列分为几种：发送队列Send Queue (SQ)，接收队列Receive Queue(RQ)，和完成队列Completion Queue (CQ)。其中SQ和RQ统称工作队列Work Queue (WQ)，也称为Queue Pair (QP)。此外，RDMA提供了两个接口，<code>ibv_post_send</code>和<code>ibv_post_recv</code>，由用户程序调用，分别用于发送消息和接收消息：</p>
<ul>
<li>用户程序调用<code>ibv_post_send</code>把发送请求Send Request (SR)插入SQ，成为发送队列的一个新的元素Send Queue Element (SQE)；</li>
<li>用户程序调用<code>ibv_post_recv</code>把接收请求Receive Request (RR)插入RQ，成为接收队列的一个新元素Receive Queue Element (RQE)。</li>
</ul>
<p>SQE和RQE也统称工作队列元素Work Queue Element (WQE)。</p>
<p>当SQ里有消息发送完成，或RQ有接收到新消息，RDMA会在CQ里放入一个新的完成队列元素Completion Queue Element (CQE)，用以通知用户程序。用户程序有两种同步的方式来查询CQ：</p>
<ul>
<li>用户程序调用<code>ibv_cq_poll</code>来轮询CQ，一旦有新的CQE就可以及时得到通知，但是这种轮询方式很消耗CPU资源；</li>
<li>用户程序在创建CQ的时候，指定一个完成事件通道<code>ibv_comp_channel</code>，然后调用<code>ibv_get_cq_event</code>接口等待该完成事件通道来通知有新的CQE，如果没有新的CQE，则调用<code>ibv_get_cq_event</code>时发生阻塞，这种方法比轮询要节省CPU资源，但是阻塞会降低程序性能。</li>
</ul>
<p>关于RDMA的CQE，有个需要注意的地方：对于RDMA的Send和Receive这种双边操作，发送端在发送完成后能收到CQE，接收端在接收完成后也能收到CQE；对于RDMA的Read和Write这种单边操作，比如节点A从节点B读数据，或节点A往节点B写数据，只有发起Read和Write操作的一端，即节点A在操作结束后能收到CQE，另一端节点B完全不会感知到节点A发起的Read或Write操作，节点B也不会收到CQE。</p>
<h2><a class="header" href="#linux-epoll异步机制简介" id="linux-epoll异步机制简介">Linux <code>epoll</code>异步机制简介</a></h2>
<p>Linux的<code>epoll</code>机制是Linux提供的异步编程机制。<code>epoll</code>专门用于处理有大量IO操作请求的场景，检查哪些IO操作就绪，使得用户程序不必阻塞在未就绪IO操作上，而只处理就绪IO操作。<code>epoll</code>比Linux之前的<code>select</code>和<code>poll</code>这两种异步机制要强大，<code>epoll</code>特别适合有大量IO操作的场景，比如RDMA的场景，每个RDMA节点同时有很多队列，用于大量传输数据，那么就可以用<code>epoll</code>来查询每个CQ，及时获得RDMA消息的发送和接收情况，同时避免同步方式查询CQ的缺点，要么用户程序消耗大量CPU资源，要么用户程序被阻塞。</p>
<p>Linux的<code>epoll</code>机制提供了三个API接口:</p>
<ul>
<li><code>epoll_create</code>用于创建<code>epoll</code>实例，返回<code>epoll</code>实例的句柄；</li>
<li><code>epoll_ctl</code>用于给<code>epoll</code>实例增加、修改、删除待检查的IO操作事件；</li>
<li><code>epoll_wait</code>用于检查每个通过<code>epoll_ctl</code>注册到<code>epoll</code>实例的IO操作，看每个IO操作是否就绪/有期望的事件发生。</li>
</ul>
<p>具体的<code>epoll</code>这三个接口的使用，后面结合代码示例来讲解。这里先解释下<code>epoll</code>的IO事件检查规则。如下图所示，<code>epoll</code>有两种检查规则：边沿触发Edge Trigger (ET)，和电平触发Level Trigger (LT)。边沿触发和电平触发源自信号处理领域。边沿触发指信号一发生变化就触发事件，比如从0变到1就触发事件、或者从1到0就触发事件；电平触发指只要信号的状态处于特定状态就触发事件，比如高电平就一直触发事件，而低电平不触发事件。</p>
<p><img src="chapter_5/./image/datenlord/trigger.png" alt="Edge Trigger v.s. Level Trigger" /></p>
<p>对应到<code>epoll</code>，电平触发指的是，只要IO操作处于特定的状态，就会一直通知用户程序。比如当<code>socket</code>有数据可读时，用户程序调用<code>epoll_wait</code>查询到该<code>socket</code>有收到数据，只要用户程序没有把该<code>socket</code>上次收到的数据读完，每次调用<code>epoll_wait</code>都会通知用户程序该<code>socket</code>有数据可读；即当<code>socket</code>处于有数据可读的状态，就会一直通知用户程序。而<code>epoll</code>的边沿触发指的是<code>epoll</code>只会在IO操作的特定事件发生后通知一次。比如<code>socket</code>有收到数据，用户程序<code>epoll_wait</code>查询到该<code>socket</code>有数据可读，不管用户程序有没有读完该<code>socket</code>这次收到的数据，用户程序下次调用<code>epoll_wait</code>都不会再通知该<code>socket</code>有数据可读，除非这个<code>socket</code>再次收到了新的数据；即仅当<code>socket</code>每次收到新数据才通知用户程序，并不关心<code>socket</code>当前是否有数据可读。</p>
<h2><a class="header" href="#rdma完成队列cq读取cqe的同步和异步方法" id="rdma完成队列cq读取cqe的同步和异步方法">RDMA完成队列CQ读取CQE的同步和异步方法</a></h2>
<p>本节用RDMA读取CQ的操作为例展示如何基于<code>epoll</code>实现异步操作。先介绍下RDMA用轮询和阻塞的方式读取CQ，再介绍基于<code>epoll</code>的异步读取CQ的方法。下文的代码仅作为示例，并不能编译通过。</p>
<h3><a class="header" href="#rdma轮询方式读取cqe" id="rdma轮询方式读取cqe">RDMA轮询方式读取CQE</a></h3>
<p>RDMA轮询方式读取CQ非常简单，就是不停调用<code>ibv_poll_cq</code>来读取CQ里的CQE。这种方式能够最快获得新的CQE，直接用户程序轮询CQ，而且也不需要内核参与，但是缺点也很明显，用户程序轮询消耗大量CPU资源。</p>
<pre><code class="language-Rust">loop {
    // 尝试读取一个CQE
    poll_result = ibv_poll_cq(cq, 1, &amp;mut cqe);
    if poll_result != 0 {
        // 处理CQE
    }
}
</code></pre>
<h3><a class="header" href="#rdma完成事件通道方式读取cqe" id="rdma完成事件通道方式读取cqe">RDMA完成事件通道方式读取CQE</a></h3>
<p>RDMA用完成事件通道读取CQE的方式如下：</p>
<ul>
<li>用户程序通过调用<code>ibv_create_comp_channel</code>创建完成事件通道；</li>
<li>接着在调用<code>ibv_create_cq</code>创建CQ时关联该完成事件通道；</li>
<li>再通过调用<code>ibv_req_notify_cq</code>来告诉CQ当有新的CQE产生时从完成事件通道来通知用户程序；</li>
<li>然后通过调用<code>ibv_get_cq_event</code>查询该完成事件通道，没有新的CQE时阻塞，有新的CQE时返回；</li>
<li>接下来用户程序从<code>ibv_get_cq_event</code>返回之后，还要再调用<code>ibv_poll_cq</code>从CQ里读取新的CQE，此时调用<code>ibv_poll_cq</code>一次就好，不需要轮询。</li>
</ul>
<p>RDMA用完成事件通道读取CQE的代码示例如下：</p>
<pre><code class="language-Rust">// 创建完成事件通道
let completion_event_channel = ibv_create_comp_channel(...);
// 创建完成队列，并关联完成事件通道
let cq = ibv_create_cq(completion_event_channel, ...);

loop {
    // 设置CQ从完成事件通道来通知下一个新CQE的产生
    ibv_req_notify_cq(cq, ...);
    // 通过完成事件通道查询CQ，有新的CQE就返回，没有新的CQE则阻塞
    ibv_get_cq_event(completion_event_channel, &amp;mut cq, ...);
    // 读取一个CQE
    poll_result = ibv_poll_cq(cq, 1, &amp;mut cqe);
    if poll_result != 0 {
        // 处理CQE
    }
    // 确认一个CQE
    ibv_ack_cq_events(cq, 1);
}
</code></pre>
<p>用RDMA完成事件通道的方式来读取CQE，本质是RDMA通过内核来通知用户程序CQ里有新的CQE。事件队列是通过一个设备文件，<code>/dev/infiniband/uverbs0</code>（如果有多个RDMA网卡，则每个网卡对应一个设备文件，序号从0开始递增），来让内核通过该设备文件通知用户程序有事件发生。用户程序调用<code>ibv_create_comp_channel</code>创建完成事件通道，其实就是打开上述设备文件；用户程序调用<code>ibv_get_cq_event</code>查询该完成事件通道，其实就是读取打开的设备文件。但是这个设备文件只用于做事件通知，通知用户程序有新的CQE可读，但并不能通过该设备文件读取CQE，用户程序还要是调用<code>ibv_poll_cq</code>来从CQ读取CQE。</p>
<p>用完成事件通道的方式来读取CQE，比轮询的方法要节省CPU资源，但是调用<code>ibv_get_cq_event</code>读取完成事件通道会发生阻塞，进而影响用户程序性能。</p>
<h3><a class="header" href="#基于epoll异步读取cqe" id="基于epoll异步读取cqe">基于epoll异步读取CQE</a></h3>
<p>上面提到用RDMA完成事件通道的方式来读取CQE，本质是用户程序通过事件队列打开<code>/dev/infiniband/uverbs0</code>设备文件，并读取内核产生的关于新CQE的事件通知。从完成事件通道<code>ibv_comp_channel</code>的定义可以看出，里面包含了一个Linux文件描述符，指向打开的设备文件：</p>
<pre><code class="language-Rust">pub struct ibv_comp_channel {
    ...
    pub fd: RawFd,
    ...
}
</code></pre>
<p>于是可以借助<code>epoll</code>机制来检查该设备文件是否有新的事件产生，避免用户程序调用<code>ibv_get_cq_event</code>读取完成事件通道时（即读取该设备文件时）发生阻塞。</p>
<p>首先，用<code>fcntl</code>来修改完成事件通道里设备文件描述符的IO方式为非阻塞：</p>
<pre><code class="language-Rust">// 创建完成事件通道
let completion_event_channel = ibv_create_comp_channel(...);
// 创建完成队列，并关联完成事件通道
let cq = ibv_create_cq(completion_event_channel, ...);
// 获取设备文件描述符当前打开方式
let flags =
    libc::fcntl((*completion_event_channel).fd, libc::F_GETFL);
// 为设备文件描述符增加非阻塞IO方式
libc::fcntl(
    (*completion_event_channel).fd,
    libc::F_SETFL,
    flags | libc::O_NONBLOCK
);
</code></pre>
<p>接着，创建<code>epoll</code>实例，并把要检查的事件注册给<code>epoll</code>实例：</p>
<pre><code class="language-Rust">use nix::sys::epoll;

// 创建epoll实例
let epoll_fd = epoll::epoll_create()?;
// 完成事件通道里的设备文件描述符
let channel_dev_fd = (*completion_event_channel).fd;
// 创建epoll事件实例，并关联设备文件描述符，
// 当该设备文件有新数据可读时，用边沿触发的方式通知用户程序
let mut epoll_ev = epoll::EpollEvent::new(
    epoll::EpollFlags::EPOLLIN | epoll::EpollFlags::EPOLLET,
    channel_dev_fd
);
// 把创建好的epoll事件实例，注册到之前创建的epoll实例
epoll::epoll_ctl(
    epoll_fd,
    epoll::EpollOp::EpollCtlAdd,
    channel_dev_fd,
    &amp;mut epoll_ev,
)
</code></pre>
<p>上面代码有两个注意的地方：</p>
<ul>
<li><code>EPOLLIN</code>指的是要检查设备文件是否有新数据/事件可读；</li>
<li><code>EPOLLET</code>指的是epoll用边沿触发的方式来通知。</li>
</ul>
<p>然后，循环调用<code>epoll_wait</code>检查设备文件是否有新数据可读，有新数据可读说明有新的CQE产生，再调用<code>ibv_poll_cq</code>来读取CQE：</p>
<pre><code class="language-Rust">let timeout_ms = 10;
// 创建用于epoll_wait检查的事件列表
let mut event_list = [epoll_ev];
loop {
    // 设置CQ从完成事件通道来通知下一个新CQE的产生
    ibv_req_notify_cq(cq, ...);
    // 调用epoll_wait检查是否有期望的事件发生
    let nfds = epoll::epoll_wait(epoll_fd, &amp;mut event_list, timeout_ms)?;
    // 有期望的事件发生
    if nfds &gt; 0 {
        // 通过完成事件通道查询CQ，有新的CQE就返回，没有新的CQE则阻塞
        ibv_get_cq_event(completion_event_channel, &amp;mut cq, ...);
        // 循环读取CQE，直到CQ读空
        loop {
            // 读取一个CQE
            poll_result = ibv_poll_cq(cq, 1, &amp;mut cqe);
            if poll_result != 0 {
                // 处理CQE
                ...
                // 确认一个CQE
                ibv_ack_cq_events(cq, 1);
            } else {
                break;
            }
        }
    }
}
</code></pre>
<p>上面代码有个要注意的地方，因为<code>epoll</code>是用边沿触发，所以每次有新CQE产生时，都要调用<code>ibv_poll_cq</code>把CQ队列读空。考虑如下场景，同时有多个新的CQE产生，但是<code>epoll</code>边沿触发只通知一次，如果用户程序收到通知后没有读空CQ，那<code>epoll</code>也不会再产生新的通知，除非再有新的CQE产生，<code>epoll</code>才会再次通知用户程序。</p>
<p>总之，本文用<code>epoll</code>机制实现RDMA异步读取CQE的例子，展示了如何实现RDMA的异步操作。RDMA还有类似的操作，都可以基于<code>epoll</code>机制实现异步操作。</p>
<p>对Rust和RDMA感兴趣的朋友，可以关注我们的开源项目<a href="https://github.com/datenlord/async-rdma/">https://github.com/datenlord/async-rdma/</a></p>
<h1><a class="header" href="#facebook-应用-rust-简史" id="facebook-应用-rust-简史">Facebook 应用 Rust 简史</a></h1>
<p>编辑整理：张汉东</p>
<blockquote>
<p>原文： <a href="https://engineering.fb.com/2021/04/29/developer-tools/rust/">https://engineering.fb.com/2021/04/29/developer-tools/rust/</a></p>
</blockquote>
<hr />
<p>Facebook正在拥抱Rust，这是当今最受喜爱和增长最快的编程语言之一。 除了为其Rust团队带来新的人才外，Facebook还宣布将正式加入非营利组织Rust Foundation。 与Mozilla（Rust的创建者），AWS，Microsoft和Google、华为 等成员一样，Facebook将致力于维持和发展该语言的开源生态系统。</p>
<p>如今，Facebook上有数百名开发人员编写了数百万行Rust代码。 尽管很明显，Facebook在这种语言的未来上投入了越来越多的资金，但重要的是要了解 Facebook 如何发展到这一点。</p>
<h2><a class="header" href="#20162017-rust-最早应用于-源码版本控制系统" id="20162017-rust-最早应用于-源码版本控制系统">2016–2017： Rust 最早应用于 源码版本控制系统。</a></h2>
<p>Facebook的 Source Control团队启动了一个名为Mononoke的重写项目，目的是将Mercurial的提交率再提高几个数量级，以服务于Facebook的成千上万的开发人员和自动化流程。首先，用C ++开发Mononoke是显而易见的选择。 当时，Facebook的后端代码库非常C ++，这意味着Mononoke默认情况下将用C ++实现。 但是源控制团队需要考虑源控制后端的可靠性需求。 当损坏或停机可能导致服务中断时，可靠性是重中之重。 这就是为什么团队选择在C ++上 使用Rust的原因。</p>
<p>Facebook 在  <a href="https://www.youtube.com/watch?v=kylqq8pEgRs&amp;list=PL85XCvVPmGQhDOUIZBe6u388GydeACbTt&amp;index=7">RustConf 2019 上描述了相关体验</a>。</p>
<p>效果很好，Mononoke自2019年以来一直是monorepo的生产后端，多年来成功扩展了规模。</p>
<h2><a class="header" href="#20172019-各个项目陆续采用-rust" id="20172019-各个项目陆续采用-rust">2017–2019： 各个项目陆续采用 Rust</a></h2>
<p>随着Mononoke作为其可行性和实践的证明，随着时间的推移，其他项目也考虑并采用了Rust。 首先，这些通常是开发人员工具项目，不需要与更广泛的服务基础架构集成，或者是小型服务/守护程序，可以仅使用一些围绕C ++客户端库的手写包装来完成其工作。</p>
<p>Facebook上许多采用Rust的工程师都来自Python和Javascript背景。 他们赞赏Rust的高性能与编译时错误检测的结合。 随着公司内部流传着更多的成功案例（例如将性能提高2到4个数量级），人们越来越有兴趣将Rust用于后端服务代码，并探索其在移动应用程序中的使用。</p>
<h2><a class="header" href="#20192020--专门支持-rust" id="20192020--专门支持-rust">2019–2020:  专门支持 Rust</a></h2>
<p>从2017年到2019年，Source Control团队的人数增加了一倍，成为Facebook内非官方的Rust支持团队。但是到2019年，Facebook的Rust开发人员数量呈指数增长，超过了100个。</p>
<p>作为这种增长的一个重要例子，Rust是Diem（以前称为Libra）区块链开发中的领先语言，由独立的Diem协会监督。 Facebook通过其数字钱包Novi，成为Diem协会的会员。 Diem区块链主要是用Rust编写的，覆盖了94％的开源代码库。 此外，与Rust一起开发了Move，一种用于区块链的新型安全编程语言。</p>
<p>鉴于需求的增长，源代码控制团队的兼职帮助不足以支持有能力从中受益的团队数量。</p>
<p>我们创建了一个小的Rust开发人员经验小组，专门致力于工具和集成方面的挑战，例如建立在非Cargo生产版本中使用该语言的开源软件包注册中心生态系统的机制。 该团队为整个公司的Rust开发人员建立了一个中心联系点，优先考虑短期开发人员体验问题，改进核心库，并在新的Rust代码库通过百万行大关时为其成功奠定了基础。</p>
<h2><a class="header" href="#未来-2021-年及-以后" id="未来-2021-年及-以后">未来： 2021 年及 以后</a></h2>
<p>在2020年底，在fb内部编程语言组织中成立了一个Rust团队来重新履行承诺，该团队由负责Facebook的C ++标准工作和工具链的同一组织负责。</p>
<p>在我们的代码库中，该团队的重点是长期的工作，而不仅仅是开发人员的即时优先经验。 尤其是，为使Rust成为一种健壮，生产力的语言和社区而发展和维持的所有贡献现在都包括在内。</p>
<p>从短期来看，这个新团队专注于四个领域：</p>
<ul>
<li>从语言和工具链的角度为内部用户提供支持：这包括工具链的推出，跨领域迁移，代码审查/审核，最佳实践，并充当语言和工具链问题的联系点。</li>
<li>在Facebook以外的社区中做出积极贡献：该团队对标准库和编译器进行代码审查，并为Rust社区的优先事项提供开发人员资源。</li>
<li>Rust与C++的轻松，安全的互操作性：我们有大量的C ++代码，用于与构建服务的后端系统进行通信。 我们需要开发人员能够安全，轻松地使用这些库，而又不牺牲Rust提供的好处。 相反，如果我们想将Rust组件与更大的C ++二进制文件集成在一起，则需要异步代码中的智能运行时互操作性。 Facebook的服务器分布高度且线程密集。 Rust任务需要在C ++线程池上很好地发挥作用，并安全地共享同步原语和I / O资源。 我们已经在C ++领域完成了大量工作，以改善异步性，已经支持并迅速采用了C ++ 20的协程。 将Rust引入游戏将是对它的扩展，并将基于Rust异步库堆栈中已经发生的出色工作。</li>
<li>积极支持和与Rust基金会互动：自2016年以来，Facebook一直致力于Rust社区并通过Rust扩展其发展。我们通过以Rust白金会员身份加入Rust Foundation来进一步履行这一承诺，我们希望在此方面继续努力 以积极主动和有影响力的方式推动进步和采用。</li>
</ul>
<p>Rust在Facebook上的旅程还远远没有结束。 这个团队很小，但是随着支持需求的扩展，它会随着时间的增长而增长。 FB 对Rust在Facebook以及整个行业中的发展轨迹感到兴奋和乐观。 </p>
<h1><a class="header" href="#rust-中的-grpc-负载均衡" id="rust-中的-grpc-负载均衡">Rust 中的 gRPC 负载均衡</a></h1>
<p>译者: iamazy </p>
<hr />
<blockquote>
<p><a href="https://truelayer.com/blog/grpc-load-balancing-in-rust">原文</a> </p>
</blockquote>
<p><strong>在我们的开源系列的第一篇文章中，我们分享了 gRPC 客户端侧负载均衡的解决方案：使用 ginepro。</strong></p>
<p>我们希望对广大的开发者社区做出回馈。我们开源系列的每篇文章都将带你了解 TrueLayer 工程团队面临的挑战 - 我们在 OSS 许可下发布了解决这些问题的代码。</p>
<p>在本文中，我们将会解析我们是如何处理 Rust 中 gRPC 负载均衡的挑战的。</p>
<p>我们的解决方案是<code>ginepro</code>，一个崭新的用于<code>tonic</code>的 gRPC channel 实现。<code>ginepro</code>(<a href="http://github.com/truelayer/ginepro">github</a>)通过带有周期性 (periodic) 服务发现的丰富的<code>tonic</code>通道来提供客户端侧 gRPC 负载均衡。</p>
<h2><a class="header" href="#背景-2" id="背景-2">背景</a></h2>
<p>TrueLayer 最近开始<a href="https://truelayer.com/blog/engineering-paydirect/">适配 Rust 作为后台开发语言</a>。随着我们越来越多的服务部署到生产中，我们必须不断改进我们的应用程序，以便它们能够处理更多负载以及实现所需的可靠性 SLA。</p>
<p>gRPC 请求的负载均衡一直是一个挑战：我们不使用 Service Mesh，并且 Rust 生态系统中也没有任何 gRPC 客户端可以满足我们的所有要求。</p>
<p>为了弥补这个问题，我们构建了<code>ginepro</code> - 一个<code>tonic</code> channel 的插件，它提供了服务发现功能以便执行客户端侧的 gRPC 负载均衡。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using the `LoadBalancedChannel`.
use ginepro::LoadBalancedChannel;
use ginepro::pb::tester_client::TesterClient;

// Build a load-balanced channel given a service name and a port.
let load_balanced_channel = LoadBalancedChannel::builder(
    (&quot;my_hostname&quot;, 5000)
  )
  .await
  .expect(&quot;Failed to initialise the DNS resolver.&quot;)
  .channel();

// Initialise a new gRPC client for the `Test` service
// using the load-balanced channel as transport
let grpc_client = TestClient::new(load_balanced_channel);
<span class="boring">}
</span></code></pre></pre>
<p><code>LoadBalanceChannel</code>是<code>tonic</code>的<code>Channel</code>的替代品：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using `tonic::Channel`
use tonic::endpoint::Channel;
use ginepro::pb::tester_client::TesterClient;

let channel = Channel::from_static(&quot;my_hostname:5000&quot;);
let grpc_client = TestClient::new(channel);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#问题-1" id="问题-1">问题</a></h2>
<p>gRPC 使用 HTTP/2 协议在单个 TCP 连接中实现请求与响应的多路复用。</p>
<p>这使得 gRPC 更加高效：你只需付出建立一次连接的成本并且可以更好的利用底层传输的能力。</p>
<p>但是，多路复用在负载均衡方面会有一些影响。</p>
<h3><a class="header" href="#http2-负载均衡" id="http2-负载均衡">HTTP/2 负载均衡</a></h3>
<p>HTTP/2 连接是持久的：客户端(或负载均衡器)和特定服务器之间的直连应尽可能长时间保持打开状态。</p>
<p>当我们要请求时，不会重新与服务端建立一个新的连接。</p>
<p>在这里我们可以说负载均衡是基于每个请求完成的：对于每个请求，客户端将选择一个新服务器并通过现有连接发出该请求。</p>
<p>但是如果客户端移除负载均衡会发生什么呢？</p>
<p>客户端将保持与负载均衡器的连接，所有的请求都将通过这单个连接。然而，传统的网络负载均衡器无法区分应用请求。</p>
<p>由于网络负载均衡器在 OSI 栈的第四层（传输层）起作用，因此它们只能推断 TCP 和 UDP 连接。因此，它们只能将流量从一台客户端转发到一台固定的服务器（记住，连接是持久的）。</p>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-2.webp" alt="load-balancing-in-rust-2" /></p>
<p>为了解决这个问题，HTTP/2 负载均衡器必须能够检查应用程序的流量。这就是应用程序负载均衡器的用途：它们可以区分请求，并为每个传入请求选择一个新的服务器。</p>
<h3><a class="header" href="#负载倾斜" id="负载倾斜">负载倾斜</a></h3>
<p>让我们看一个场景，未能执行 HTTP/2-aware 负载均衡会导致服务器使用不均匀 (unevenly)。</p>
<p>让我们对一个玩具系统进行思考：一个客户端和两个服务器，在 HTTP/2 之上讨论 gRPC。</p>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-3.webp" alt="load-balancing-in-rust-3" /></p>
<p>当客户端启动时，它执行<strong>服务发现</strong>(如 DNS 请求)：我可以将请求发往哪些 IP？</p>
<p>答案是包含服务器 A 和服务器 B 的集合。与它们中的每一个都建立了 HTTP/2 连接。</p>
<p>每当客户端需要执行请求时，它会在两个连接之间随机选择 (round-robin)。</p>
<p>当服务器 A 崩溃时会发生什么？</p>
<p>在大多数 gRPC 实现中，客户端不会再次执行服务发现。</p>
<p>客户端开始将其所有请求路由到服务器 B，即使生成服务器 C 来替换服务器 A。</p>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-4.webp" alt="load-balancing-in-rust-4" /></p>
<p>服务器 C 完全未使用，浪费资源并恶化系统的性能 (服务器 B 过载)。</p>
<h2><a class="header" href="#grpc-负载均衡方法概述" id="grpc-负载均衡方法概述">gRPC 负载均衡方法概述</a></h2>
<p>我们可以采取几种方法来避免我们刚刚描述的场景：</p>
<ol>
<li>服务器周期性强制客户端重连</li>
<li>客户端周期性执行服务发现</li>
<li>引入应用级负载均衡</li>
</ol>
<p>所有这些选项有什么共同点？</p>
<p>某些内容会周期性或在重连时刷新可用服务器列表。</p>
<p>前两个选项相当简单，所以让我们深入研究第三个选项，看看有哪些类型的 gRPC 应用级负载均衡器。</p>
<p>本文中，我们将 gRPC 负载均衡器分为两大类：客户端侧和外部进程。</p>
<h3><a class="header" href="#客户端侧" id="客户端侧">客户端侧</a></h3>
<p>所有的负载均衡逻辑都存在客户端侧：服务器选择，服务发现，健康检查(可选)。</p>
<p>因此，客户端维护 N 个连接，每个服务器一个连接，并且为每个请求选择一个连接发送请求。</p>
<p>所有的逻辑都在客户端：它更容易测试，并且你可以消除与通过网络或外部线程通信的负载均衡器相关的任何开销。</p>
<p>相反，这也增加了很多复杂性，并且你无法在不同语言中重用该实现。</p>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-5.webp" alt="load-balancing-in-rust-5" /></p>
<h3><a class="header" href="#外部线程" id="外部线程">外部线程</a></h3>
<p>在此类中，负载均衡的复杂性(全部或部分)从客户端转移到一个或多个专用的进程中。</p>
<p>这些进程可以与应用部署在一起(如 sidecar 容器)，也可以作为独立服务运行。</p>
<p>通常，gRPC 外部线程的负载均衡器有两种形式：</p>
<ol>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md">Look-aside</a> 服务告诉客户端应该请求哪台服务器</li>
<li>对应用完全透明的独立服务，可以执行负载均衡，健康检查，上报负载及服务发现等(如 Envoy)。</li>
</ol>
<h3><a class="header" href="#look-aside" id="look-aside">Look-aside</a></h3>
<p>对于 Look-aside 负载均衡器，我们可以将其归类为 hybird 解决方案，大多数的逻辑都从客户端移除：健康检查，服务发现等。</p>
<p>客户端只需要：</p>
<ul>
<li>维护与 look-aside 进程的连接 (我应该请求哪一台服务器)</li>
<li>在后台与所有健康的服务器建立并维护开放连接</li>
</ul>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-6.webp" alt="load-balancing-in-rust-6" /></p>
<h3><a class="header" href="#代理" id="代理">代理</a></h3>
<p>使用代理，将所有逻辑从客户端移除。</p>
<p>这让客户端非常简洁，它只需与代理之间维护一个连接即可。</p>
<p>有几种方法可以将代理整合进你的软件架构中：</p>
<ul>
<li><strong>Service Mesh</strong>：专用基础架构层，用于控制服务到服务的通信(如 Istio 和 Linkerd)，作为 sidecar 进行部署。</li>
</ul>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-7.webp" alt="load-balancing-in-rust-7" /></p>
<ul>
<li><strong>Service Proxy</strong>：所有客户端都需要连接的单个独立服务，并为每个 gRPC 服务做配置。</li>
</ul>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-8.webp" alt="load-balancing-in-rust-8" /></p>
<ul>
<li><strong>Sidecar 代理</strong>：sidecar 代理与每个客户端部署在一起，并全部通过相同的 gRPC 服务配置代理。</li>
</ul>
<p><img src="chapter_5/./image/grpc/load-balancing-in-rust-9.webp" alt="load-balancing-in-rust-9" /></p>
<p>然而，没有任何一种方案是完美的，它们之间总有一个权衡：</p>
<ul>
<li>hot path 中移动部件越多，越影响系统的延迟</li>
<li>service mesh 和独立代理都为你的设置增加了很多复杂性，并具有新型的故障模式。它们需要被设置，监控和维护。</li>
</ul>
<h2><a class="header" href="#truelayer-的方案" id="truelayer-的方案">TrueLayer 的方案</a></h2>
<p>TrueLayer 利用 gRPC 在各种编程语言 (C#，Rust，TypeScript，Python)编写的应用程序之间建立强类型契约。</p>
<p>我们目前没有在 Kubernetes 集群中运行 service mesh，因此我们没有开箱即用的 gRPC 负载均衡。</p>
<h3><a class="header" href="#历史先例c使用-envoy-sidecar" id="历史先例c使用-envoy-sidecar">历史先例，C#：使用 Envoy sidecar</a></h3>
<p>我们大多数早期的 gRPC 服务端和客户端是使用 C# 编写的。</p>
<p>这里我们使用的是 sidecar 方案 - 一个手动配置的 Envoy 代理。</p>
<p>使用 Envoy sidecar，你可以获得一个生产强化解决方案，周边有很多社区。这是当时让 gRPC 负载均衡工作的最快方法。</p>
<p>独立的 sidecar 代理增加了系统整体的负载性：它是另一个需要配置，操作，理解的组件。</p>
<p>特别是，随着服务数量的增加，配置管理的扩展性很差，而在本地或 CI 上测试和重现故障模式相当困难。</p>
<h3><a class="header" href="#rust-机遇" id="rust-机遇">Rust 机遇</a></h3>
<p>Rust 的 gRPC 生态如何呢？支持客户端负载均衡吗？</p>
<p>让我们看下 Rust 中最受欢迎的 gRPC 库：</p>
<ul>
<li><a href="https://tikv.org/">TiKV</a> 编写的 <a href="https://github.com/tikv/grpc-rs">grpc-rs</a> - 实现了负载均衡但是无法更新服务 IP。</li>
<li><a href="https://github.com/stepancheg/grpc-rust">grpc-rust</a> 没有实现负载均衡</li>
<li><a href="https://github.com/hyperium/tonic">tonic</a> 实现了负载均衡并具有用于动态更新终结点的构建块。</li>
</ul>
<p><code>tonic</code>是最合适的候选人：一切开箱即用，<strong>除了周期性服务发现</strong>。</p>
<p>这已足够，<code>tonic</code>暴露了我们需要扩展该功能的 API：它在<code>Channel</code>原语中提供了动态添加和移除 gRPC 终结点的支持。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tonic::transport::{Endpoint, Channel};

// Create a Channel. 
// This returns the sender half of a multi-producer single-consumer channel.
let (channel, sender) = Channel::balance_endpoint(1024);

// Add a new Endpoint.
sender.send(
  Change::Insert(
    &quot;localhost:8080&quot;,
    Endpoint::from_static(&quot;localhost:8080&quot;)
  )
);

// Remove the Endpoint from the list of healthy targets.
sender.send(Change::Remove(&quot;localhost:8080&quot;));
<span class="boring">}
</span></code></pre></pre>
<p><code>tonic</code>还有一个好处：它基于<code>tower</code>构建，这是一个灵活且使用广泛的网络应用程序的中间件框架。</p>
<p>特别是，它基于<code>tower::balance</code>实现<a href="https://docs.rs/tower/0.4.6/tower/balance/index.html">负载均衡逻辑</a>。<a href="https://github.com/linkerd/linkerd2-proxy/blob/63ad2eca32b7a06ac3c1270269ad6bb3bf0b169b/linkerd/proxy/http/src/balance.rs#L7">Linkerd 的数据平面代理</a>使用了相同的组件：我们构建在一堆生产强化组件之上。</p>
<h3><a class="header" href="#构建一个基于tonic的解决方案" id="构建一个基于tonic的解决方案">构建一个基于<code>tonic</code>的解决方案</a></h3>
<p>我们决定尝试一下<code>tonic</code>，并投入一些时间来探索功能完备的客户端负载均衡 channel 会是什么样子。结果就是我们开源的<code>ginepro</code>库。</p>
<p>本节将更深入的研究实现细节。</p>
<p>在<code>tonic</code>中我们需要弥补的功能是服务发现：我们想要在后台周期性刷新健康的服务器 - 我们可以发送请求的 IP 列表。</p>
<p>我们假设每个服务名都映射到一个或多个 IP 地址中(及服务器的副本)。</p>
<p>解析服务名称的逻辑可以通过<code>LookupService</code>特征与 channel 实现分离：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Interface that provides functionality to
/// acquire a list of ips given a valid host name.
#[async_trait::async_trait]
pub trait LookupService {
    /// Return a list of unique `SockAddr` associated with the provided
    /// `ServiceDefinition` containing the `hostname` `port` of the service.
    /// If no ip addresses were resolved, an empty `HashSet` is returned.
    async fn resolve_service_endpoints(
        &amp;self,
        definition: &amp;ServiceDefinition,
    ) -&gt; Result&lt;HashSet&lt;SocketAddr&gt;, anyhow::Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>这个契约为我们提供了三个属性：我们可以通过模拟实现轻松诸如故障以测试不满意的场景，我们不限制 IP 的解析方式，我们可以隐藏协议特定的细微差别，如 DNS 记录超时。</p>
<p>例如，在 TrueLayer，我们将服务名称解析为 IP 列表时有两种选择：我们可以查询 Kubernetes 的 DNS 或直接查询 Kubernetes 的 API(<code>端点</code>资源)。</p>
<p><code>LookupService</code>是如何适应客户端逻辑的呢？</p>
<p>这里有一个在后台运行的事件循环，由我们的<code>LoadBalancedChannel</code>管理。</p>
<p><code>LoadBalancedChannel</code>在一个定时触发的服务发现上保留了一个已知终结点集合。</p>
<p>然后我们移除已经消失的终结点，并添加新发现的终结点。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
      let discovered_endpoints = self
          .lookup_service
          .resolve_service_endpoints(service_definition).await;
    
      let changeset = self.create_changeset(&amp;discovered_endpoints).await;
      // Report the changeset to `tonic` to update the list of available server IPs.
      self.report_and_commit(changeset, endpoints).await?;    
      
      // Wait until the next interval.
      tokio::time::sleep(self.probe_interval).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>需要指出当终结点启动失败时 gRPC 客户端不会移除终结点：它将会一直尝试连接直到我们显式的告诉客户端将它移除(如服务端未通过健康检查探测并被 Kubernetes 移除)。</p>
<h2><a class="header" href="#结论-8" id="结论-8">结论</a></h2>
<p>我们能够在部署之前在 CI 中对<code>ginepro</code>进行广泛的测试 - 这是在同一服务栈中编写客户端解决方案的好处。</p>
<p>测试发现了<code>tonic</code>中的一些 bug (关于传输和 TLS) - 我们因此提交了补丁 (<a href="https://github.com/hyperium/tonic/pull/536">1</a>和<a href="https://github.com/hyperium/tonic/pull/493">2</a>)</p>
<p><code>ginepro</code>在五个月前在多个 gRPC 客户端上进行了生产部署。</p>
<p>目前我们还没有遇到 gRPC 负载均衡引发的问题。</p>
<p>有一个问题：它仅适用于我们的 Rust 服务。</p>
<p>这可能不是 TrueLayer 关于 gRPC 负载均衡的最后一篇文章。</p>
<p>未来会使用 service mesh 吗，我们拭目以待。</p>
<p>尽管如此，这个解决方案还是有价值的 - 这也是我们向整个 Rust 生态开放的原因。我们希望其他开发人员可以在我们的工作基础上继续推进 Rust 生态中 gRPC 栈的状态。</p>
<p><code>ginepro</code>只是我们开源之旅的开端 - 下一期我们将介绍为扩展支持中间件的 <a href="https://docs.rs/reqwest/0.11.3/reqwest/index.html">reqwest</a> 而构建的机制。</p>
<h1><a class="header" href="#学习资源-1" id="学习资源-1">学习资源</a></h1>
<p>编辑: Matrixtang</p>
<hr />
<h2><a class="header" href="#restful-api-in-sync--async-rust" id="restful-api-in-sync--async-rust">RESTful API in Sync &amp; Async Rust</a></h2>
<p><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/restful-api-in-sync-and-async-rust.md">原文</a>
来源是 github 上的 <code>pretzelhammer</code>, 他在 github 上开源了自己的 rust 博客, 上面的文章质量很高。
本文介绍了如何在 Rust 中为一个虚构的看板风格的项目管理应用程序实现一个 RESTful API 服务器。</p>
<h2><a class="header" href="#the-rust-borrow-checkera-deep-dive" id="the-rust-borrow-checkera-deep-dive">The Rust Borrow Checker—A Deep Dive</a></h2>
<p><a href="https://www.youtube.com/watch?v=Ys7ma3au5m0">视频链接</a>
本视频由 <code>MS</code> 的工程师 <code> Nell Shamrell-Harrington</code> 带来。对 <code>Borrow Checker</code> 工作方式感兴趣的同学可以看一下这个视频。</p>
<p>##　 Naming Your Lifetimes
<a href="https://www.possiblerust.com/pattern/naming-your-lifetimes">原文</a></p>
<p>有效地命名生命周期可以提高代码的可读性，本文对此进行了详细介绍。</p>
<h2><a class="header" href="#rust-中最让我讨厌的东西" id="rust-中最让我讨厌的东西">Rust 中最让我讨厌的东西</a></h2>
<p><a href="https://blog.yossarian.net/2020/05/20/Things-I-hate-about-rust">原文</a></p>
<p>Rust 是作者最喜欢的语言，但是其中一些东西也让作者喜欢不起来：比如太多的字符串类型 <code>(&amp;str, String, &amp;OsStr, OsString, AsRef)</code>，再比如 <code>impl&lt;T&gt; for Trait for T where T: OtherTrait</code> 这样的写法太过麻烦等</p>
<h2><a class="header" href="#oxidizing-the-technical-interview" id="oxidizing-the-technical-interview">Oxidizing the technical interview</a></h2>
<p><a href="https://blog.mgattozzi.dev/oxidizing-the-technical-interview/">原文</a></p>
<p>为 Rust 面试提供了一些新思路</p>
<h2><a class="header" href="#rucredstash-release--rust-experience-from-a-haskeller" id="rucredstash-release--rust-experience-from-a-haskeller">Rucredstash release &amp; Rust experience from a Haskeller</a></h2>
<p><a href="https://psibi.in/posts/2021-05-22-credstash.html">原文</a></p>
<p>Rust 身上有函数式编程的影子, 因此也吸引了不少喜欢函数式爱好者的关注。本文讲述了一个 Haskell 程序员的 Rust 学习之路。</p>
<h2><a class="header" href="#why-and-how-we-wrote-a-compiler-in-rust---blog-post-series-1x-the-context" id="why-and-how-we-wrote-a-compiler-in-rust---blog-post-series-1x-the-context">Why and how we wrote a compiler in Rust - (blog post series 1/X): the context</a></h2>
<p><a href="https://bnjjj.medium.com/why-and-how-we-wrote-a-compiler-in-rust-blog-post-series-1-x-the-context-e2f83b10edb9">原文</a></p>
<p>这篇博客文章是该系列的第一篇文章，讲述了为何要使用 Rust 来编写编译器, 以及如何实现 一个用 Rust 编写的编译器 demo。</p>
<h2><a class="header" href="#scylla-developer-hackathon-rust-driver" id="scylla-developer-hackathon-rust-driver">Scylla Developer Hackathon: Rust Driver</a></h2>
<p><a href="https://www.scylladb.com/2021/02/17/scylla-developer-hackathon-rust-driver/">原文</a></p>
<p>Scylla 的开发者们在黑客马拉松上使用 Rust 来编写驱动,一起来看看他们是如何使用 Rust 的吧。</p>
<h2><a class="header" href="#how-we-utilized-fuzzing-to-improve-security-in-the-tezedge-node-and-created-an-open-source-ci-tool-for-rust-code-fuzzing" id="how-we-utilized-fuzzing-to-improve-security-in-the-tezedge-node-and-created-an-open-source-ci-tool-for-rust-code-fuzzing">How we utilized fuzzing to improve security in the TezEdge node and created an open-source CI tool for Rust code fuzzing.</a></h2>
<p><a href="https://medium.com/tezedge/how-we-utilized-fuzzing-to-improve-security-in-the-tezedge-node-and-created-an-open-source-ci-tool-92ffbd804db1">原文</a></p>
<p>本文讲述了作者使用 Fuzz 工具和开源 CI 工具来提高项目安全性的经历。 Fuzz 已经成为开源基础设施的必选项了。</p>
<h2><a class="header" href="#verifying-vectorized-rust-revisited" id="verifying-vectorized-rust-revisited">Verifying vectorized Rust revisited</a></h2>
<p><a href="https://project-oak.github.io/rust-verification-tools/2021/05/15/verifying-vectorized-code2.html">原文</a></p>
<p>实践出真知, 作者将带领读者一探 rustc 如何处理 <code>vector instructions</code></p>
<h2><a class="header" href="#writing-pythonic-rust" id="writing-pythonic-rust">Writing Pythonic Rust</a></h2>
<p><a href="https://www.cmyr.net/blog/rust-python-learnings.html">原文</a></p>
<p>想必大家对 Python 都不会陌生, Python 语法简单, 其风格被成为 <code>Pythonic</code>。在 Rust 中也可以写出 Pythonic 的代码。</p>
<h2><a class="header" href="#routes-to-discovering-rust" id="routes-to-discovering-rust">Routes to Discovering Rust</a></h2>
<p><a href="https://blog.abor.dev/p/timclicks">原文</a></p>
<p>作者在文中讲述了自己的 Rust 探索之路。</p>
<h2><a class="header" href="#rust-verification-workshop-2021" id="rust-verification-workshop-2021">Rust Verification Workshop 2021</a></h2>
<p><a href="https://youtu.be/iAs0gZ8o0oQ">video</a> Rust Verification Workshop 2021 - Ferrite: A Rust EDSL for Message-passing Protocol Verification</p>
<p><a href="https://www.youtube.com/watch?v=iAs0gZ8o0oQ">video</a> Rust Verification Workshop 2021 - RustBelt: A Quick Dive into the Abyss</p>
<p><a href="https://www.youtube.com/watch?v=H54VDCuT0J0">video</a> Rust Verification Workshop 2021 - Polonius</p>
<p><a href="https://youtu.be/_DM36e2A9dg">video</a> Rust Verification Workshop 2021 - Rust Interest in safety- and mission-critical environments</p>
<p><a href="https://youtu.be/0DcIn7kiNxM">video</a> Rust Verification Workshop 2021 - Leveraging Compiler Intermediate Representation for Multi- and Cross-Language Verification</p>
<p>Rust Verification Workshop 2021 年的技术分享</p>
<h2><a class="header" href="#宏小本的最新中文翻译" id="宏小本的最新中文翻译">宏小本的最新中文翻译</a></h2>
<p><a href="https://zjp-cn.github.io/tlborm/">GitHub page</a></p>
<p>这是对 Daniel Keep 撰写的书 的续写， 自 2016 年初夏以来，那本书就一直没再更新。本书的续写者为 Veykril。译者是 zjp-cn。</p>
<h2><a class="header" href="#an-incomplete-explanation-of-the-proc-macro-that-saved-me-4000-lines-of-rust" id="an-incomplete-explanation-of-the-proc-macro-that-saved-me-4000-lines-of-rust">An Incomplete Explanation of the Proc Macro That Saved Me 4000 Lines of Rust</a></h2>
<p><a href="https://mbuffett.com/posts/incomplete-macro-walkthrough/">原文</a></p>
<p>本文中作者使用了 Proc Macro 解决了代码复用问题。</p>
<h2><a class="header" href="#the-most-underrated-but-useful-rust-standard-library-type" id="the-most-underrated-but-useful-rust-standard-library-type">The most underrated but useful Rust standard library type</a></h2>
<p><a href="https://dev.to/thepuzzlemaker/the-most-underrated-but-useful-rust-standard-library-type-59b1">原文</a></p>
<p>Rust 标准库充满了许多有用的类型，特征和抽象。 作者介绍了一个被我们经常忽略的一个类型 <code>Cow</code></p>
<h2><a class="header" href="#compilers-as-teachers" id="compilers-as-teachers">Compilers as Teachers</a></h2>
<p><a href="https://ferrous-systems.com/blog/compilers-as-teachers/">原文</a></p>
<p>Rust 程序员经常被编译器 &quot;折磨&quot; 的失去活来, 其实不妨把编译器看作一个教导自己的导师。</p>
<p>##　 Is it possible to write overhead-free cyclic data-structures in safe, stable Rust?
<a href="https://www.reddit.com/r/rust/comments/n420cg/is_it_possible_to_write_overheadfree_cyclic/">原讨论地址 readdit</a></p>
<p>是否可以在稳定的 Rust 中编写无开销的循环数据结构？</p>
<h2><a class="header" href="#构建-rust-异步-graphql-服务基于-tide--async-graphql--mongodb" id="构建-rust-异步-graphql-服务基于-tide--async-graphql--mongodb">构建 Rust 异步 GraphQL 服务：基于 tide + async-graphql + mongodb</a></h2>
<p><a href="https://blog.budshome.com/budshome/gou-jian-rust-yi-bu-graphql-fu-wu-:ji-yu-tide-+-async-graphql-+-mongodb(3)--zhong-gou">原文</a></p>
<p>基于 actix-web + async-graphql + rbatis + postgresql / mysql 构建异步 Rust GraphQL 服务, 本文是系列文章。</p>
<h2><a class="header" href="#crust-of-rust-dispatch-and-fat-pointers" id="crust-of-rust-dispatch-and-fat-pointers">Crust of Rust: Dispatch and Fat Pointers</a></h2>
<p><a href="https://www.youtube.com/watch?v=xcygqF5LVmM">video</a></p>
<p>视频来源于 Youtube 上一个著名的 Youtuber, <code>Jon Gjengset</code>。对静态分发和动态分发背后感兴趣的同学可以参考一下。</p>
<h2><a class="header" href="#using-gdb-and-defmt-to-debug-embedded-programs" id="using-gdb-and-defmt-to-debug-embedded-programs">Using GDB and defmt to debug embedded programs</a></h2>
<p><a href="https://ferrous-systems.com/blog/gdb-and-defmt/">原文</a></p>
<p>能直接在嵌入式系统中使用 gdb 当然是 &quot;坠&quot; 好的了。</p>
<h2><a class="header" href="#how-rust-makes-rayons-data-parallelism-magical" id="how-rust-makes-rayons-data-parallelism-magical">How Rust makes Rayon's data parallelism magical</a></h2>
<p><a href="https://developers.redhat.com/blog/2021/04/30/how-rust-makes-rayons-data-parallelism-magical">原文</a></p>
<p><code>Rayon</code> 是用于 Rust 编程语言的数据并行性库。使用 <code>Rayon</code> 在 Rust 中开启并行之路。</p>
<h2><a class="header" href="#linux-基金会提供的免费-webassembly-课程" id="linux-基金会提供的免费-webassembly-课程">Linux 基金会提供的免费 WebAssembly 课程</a></h2>
<p>此在线课程是为已经在构建微服务和云本机应用程序开发方面有经验的开发人员设计的。 简而言之，这不是WebAssembly的介绍。 但是，如果您准备在本地构建，试验和测试功能即服务（FaaS），则该类适合您。</p>
<p>具体来说，您将学习如何使用Rust创建和托管WebAssembly模块。 您还将学习如何将JavaScript WebAssembly API用于浏览器，以及有关WebAssembly的替代性非Web主机运行时的信息。</p>
<p>您将了解到可以使用社区工具和开源项目添加到基本WebAssembly规范中。 学完这些，您将清楚地了解如何构建基于WebAssembly的应用程序以及它们的实际工作方式。</p>
<p><a href="https://www.zdnet.com/article/linux-foundation-offers-free-webassembly-online-class/">https://www.zdnet.com/article/linux-foundation-offers-free-webassembly-online-class/</a></p>
<h1><a class="header" href="#rust-中无法办到的事情以及如何替代" id="rust-中无法办到的事情以及如何替代">Rust 中无法办到的事情(以及如何替代)</a></h1>
<p>译者：Matrixtang</p>
<blockquote>
<p><a href="https://blog.logrocket.com/what-you-cant-do-in-rust-and-what-to-do-instead/">原文</a> </p>
</blockquote>
<hr />
<p>作为 <a href="https://www.reddit.com/r/rust/">Rust subreddit</a>的主持人，我经常发布有关开发人员试图将其各自的语言范例转换为 Rust 的帖子，结果不一而足，取得了不同程度的成功。 在本指南中，我将描述开发人员在将其他语言范例转换为 Rust 时遇到的一些问题，并提出一些替代解决方案来帮助你客服 Rust 的局限性。</p>
<h2><a class="header" href="#rust-中的继承" id="rust-中的继承">Rust 中的继承</a></h2>
<p>可以说，继承是在面向对象语言中被问到最多的缺失特性。为什么 Rust 不让一个结构 (<code>struct</code>) 继承另一个结构呢？</p>
<p>你可以肯定地说，即使在 OO 世界中，继承的名声也没好到哪里去，而且实践者通常尽可能地喜欢组合(<code>composition</code> )。但是你也可以认为，允许类型以不同的方式执行方法可能会提高性能，因此对于那些特定的实例来说是可取的。</p>
<p>这是一个来自 Java 的经典示例：</p>
<pre><code class="language-java">interface Animal {
    void tell();
    void pet();
    void feed(Food food);
}class Cat implements Animal {
    public void tell() { System.out.println(&quot;Meow&quot;); }
    public void pet() { System.out.println(&quot;purr&quot;); }
    public void feed(Food food) { System.out.println(&quot;lick&quot;); }
}// this implementation is probably too optimistic...
class Lion extends Cat {
    public void tell() { System.out.println(&quot;Roar&quot;); }
}
</code></pre>
<p>对于 Rust，第一部分可以用 traits 实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Animal {
    fn tell(&amp;self);
    fn pet(&amp;mut self);
    fn feed(&amp;mut self, food: Food);
}struct Cat;impl Animal for Cat {
    fn tell(&amp;self) { println!(&quot;Meow&quot;); }
    fn pet(&amp;mut self) { println!(&quot;purr&quot;);
    fn feed(&amp;mut self, food: Food) { println!(&quot;lick&quot;); }
}
<span class="boring">}
</span></code></pre></pre>
<p>但第二部分并没用这么容易：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lion;impl Animal for Lion {
    fn tell(&amp;self) { println!(&quot;Roar&quot;); }
    // Error: Missing methods pet and feed
    // 错误: 缺少 `pet` 和 `feed` 方法
}
<span class="boring">}
</span></code></pre></pre>
<p>显然，最简单的方法是复制这些方法。是的，重复是不好的。这样也会使得代码更加复杂。如果你需要代码复用的话, 不妨把这些方法抽出来, 在 <code>Cat</code> 和 <code>Lion</code> 中调用它们。</p>
<p>但是，你也许会察觉到,如何实现 OO 中的多态性部分呢？这就是复杂的地方。面向对象语言通常给你提供动态转发，而 Rust 让你在静态和动态分发中做出选择，不管选择哪一种都有失有得。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// static dispatch
// 静态分发
let cat = Cat;
cat.tell();let lion = Lion;
lion.tell();// dynamic dispatch via enum // 通过enum 进行动态分发
enum AnyAnimal {
   Cat(Cat),
   Lion(Lion),
}// `impl Animal for AnyAnimal` left as an exercise for the readerlet animals = [AnyAnimal::Cat(cat), AnyAnimal::Lion(lion)];
for animal in animals.iter() {
   animal.tell();
}// dynamic dispatch via &quot;fat&quot; pointer including vtable
// 动态分发通过`胖` 指针来实现
let animals = [&amp;cat as &amp;dyn Animal, &amp;lion as &amp;dyn Animal];
for animal in animals.iter() {
   animal.tell();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>译者注: 动态分发参见 https://juejin.cn/post/6872898487244029960 以及 https://alschwalm.com/blog/static/2017/03/07/exploring-dynamic-dispatch-in-rust/</p>
</blockquote>
<p>注意，与垃圾收集语言不同的是，在 ( Rust 中) 每个变量在编译时必须有一个具体的类型。此外，对于 <code>enum</code> 的情况，使用进行委托 <code>trait</code> 的实现是冗长乏味的，但是像 <code>ambassador</code>[1] 这样的 crates 可以提供帮助。</p>
<p>将函数委托给成员的一种相当 <code>hacky</code> 的方法是使用 <a href="https://rust-unofficial.github.io/patterns/anti_patterns/deref.html">Deref trait for polymorphism</a><code>，这样在 </code>derefee<code> 上可以直接调用</code>Deref` 目标定义的函数。但是请注意，这通常被认为是一种反模式。</p>
<p>最后，可以为所有实现许多其他特性之一的类实现一个 <code>trait</code>，但它需要专门化，这是目前的一个 <code>nightly</code> 特性（尽管有一个可用的解决方案 <code>workaround</code>[2]，如果你不想写出所需的所有样板代码，可以把他们打包在一个<code>macro crate</code> 中）。<code>trait</code> 很可能是相互继承的，尽管它们只规定行为，而不是数据。</p>
<h2><a class="header" href="#链表或者其他基于指针的数据结构" id="链表或者其他基于指针的数据结构">链表或者其他基于指针的数据结构</a></h2>
<p>许多从 C++ 来到 Rust 的人一开始会想实现一个 “简单的” 双向链表，但很快就会发现它远非 简单。这是因为 Rust 想要明确所有权，因此双向列表需要对指针和引用进行相当复杂的处理。</p>
<p>一个新手可能会尝试写下面的 struct：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyLinkedList&lt;T&gt; {
    value: T
    previous_node: Option&lt;Box&lt;MyLinkedList&lt;T&gt;&gt;&gt;,
    next_node: Option&lt;Box&lt;MyLinkedList&lt;T&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>当他们注意到这个方法失败时，他们会添加 <code>Option</code> 和 <code>Box</code>。但是一旦他们尝试实现插入，他们就会感到很惊讶：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; MyLinkedList&lt;T&gt; {
    fn insert(&amp;mut self, value: T) {
        let next_node = self.next_node.take();
        self.next_node = Some(Box::new(MyLinkedList {
            value,
            previous_node: Some(Box::new(*self)), // Ouch
            next_node,
        }));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当然，borrow checker[3] 不会允许这样做。值的所有权完全是混乱的。<code>Box</code> 拥有它所包含的数据，因此列表中每个节点都将由列表中的上一个和下一个节点拥有。Rust 中的每个数据只允许有一个所有者，所以这将至少需要一个 <code>Rc</code> 或 <code>Arc</code> 才能工作。但是即使这样做也会很快变得麻烦，更不用说引用计数带来的开销了。</p>
<p>幸运的是，你不需要自己编写双向链表，因为标准库已经包含了一个（<code>std::collections::LinkedList</code>）。而且，与简单的 Vecs 相比，这种方法可能并不能给你带来好的性能，因此你可能需要相应地进行测试。</p>
<p>如果你真的想写一个双向链表列表，你可以参考<a href="https://rust-unofficial.github.io/too-many-lists/">Learning Rust With Entirely Too Many Linked Lists</a>][4] ，它会教会你写链表，并在这个过程中学到很多关于 <code>Unsafe Rust</code> 的知识。</p>
<p>（此外：单列表完全可以用一连串的 <code>box</code> 来构建。实际上，Rust 编译器包含一个<a href="https://github.com/rust-lang/rust/blob/f811f14006fa46030f1af714f7d640580d3ad822/compiler/rustc_data_structures/src/tiny_list.rs">实现</a>。）</p>
<p>同样的情况也适用于图结构，尽管你可能需要一个依赖项来处理图数据结构。Petgraph[5] 是目前最流行的，它提供了数据结构和一些图算法。</p>
<h2><a class="header" href="#自引用类型" id="自引用类型">自引用类型</a></h2>
<p>当面对自引用类型的概念时，很容易会问出: “谁拥有它？”同样，这也是 <code>borrow checker</code> 不乐意听到的关于 <code>ownership</code>的事情。</p>
<p>当你具有所有权关系并希望在一个结构中同时存储所有权对象和被所有的对象时，就会遇到这个问题。<code>天真地</code>尝试一下这个方法，你会有一段艰难的时期去尝试生命周期 (<code>lifetime</code>)。</p>
<p>我们只能猜测，许多 <code>rustacean</code> 已经转向 <code>Unsafe Rust</code>，这很微妙的，并且很容易出错。当然，使用普通指针而不是引用会消除生命周期烦恼，因为指针不会有生命周期(<code>lifetime</code>)的烦恼。但是，这需要手动承担管理生命周期的责任。</p>
<p>幸运的是，有一些 crate 可以采用这种解决方案并提供一个安全的接口，比如 <code>ouroboros</code>[6], <code>self_cell</code>[7] 和 <code>one_self_cell</code>[8] 等 crates。</p>
<h2><a class="header" href="#全局可变状态" id="全局可变状态">全局可变状态</a></h2>
<p>来自 C 或 C++ (或是来自动态语言) 的开发者，有时习惯于在他们的代码中创建和修改全局状态( <code>global state</code> )。例如，一位 reddit 用户说：“这是完全安全的，但 Rust 不让你这么做。”</p>
<p>下面是一个稍微简化的例子：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
int i = 1;int main() {
    std::cout &lt;&lt; i;
    i = 2;
    std::cout &lt;&lt; i;
}
</code></pre>
<p>在 Rust 中，这大致可以理解为：</p>
<pre><pre class="playground"><code class="language-rust">static I: u32 = 1;fn main() {
    print!(&quot;{}&quot;, I);
    I = 2; // &lt;- Error: Cannot mutate global state
    print!(&quot;{}&quot;, I);
}
</code></pre></pre>
<p>许多 <code>Rustacean</code> 会告诉你，你并不需要这种全局的状态。当然，在这样一个简单的例子中，这是正确的。但是对于大量的用例，确实需要全局可变状态的时候，例如，在一些嵌入式应用程序中。</p>
<p>当然，有一种方法可以做到这一点，使用 <code>Unsafe Rust</code>。但是在这之前，根据场景的不同，你可能只想使用互斥对象（<code>Mutex</code>）即可。或者，如果可变只需要在初始化时使用一次，那么 <code>OnceCell</code> 或 <code>lazy_static</code> 就可以巧妙地解决这个问题。或者，如果你真的只需要整数，那么 <code>std::sync::Atomic*</code> 类型也可以使用。</p>
<p>话虽如此，尤其是在每个字节数和资源通常映射到内存的嵌入式世界中, 拥有一个可变的静态变量通常是首选的解决方案。因此，如果你真的必须这么做，写起来像这样：</p>
<pre><pre class="playground"><code class="language-rust">static mut DATA_RACE_COUNTER: u32 = 1;fn main() {
    print!(&quot;{}&quot;, DATA_RACE_COUNTER);
    // I solemny swear that I'm up to no good, and also single threaded.
    // 我发誓即使是单线程,依然跑不了
    unsafe {
        DATA_RACE_COUNTER = 2;
    }
    print!(&quot;{}&quot;, DATA_RACE_COUNTER);
}
</code></pre></pre>
<p>再次强调，除非真的需要，否则你不应该这样做。如果你想问这是不是一个好主意，答案是否定的。</p>
<h2><a class="header" href="#直接初始化一个数组" id="直接初始化一个数组">直接初始化一个数组</a></h2>
<p>新手可能会倾向于声明如下数组：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [usize; 512];for i in 0..512 {
    array[i] = i;
}
<span class="boring">}
</span></code></pre></pre>
<p>这会报错，因为数组从未初始化。然后我们尝试给它赋值，但是没有告诉编译器，它甚至不会为我们在堆栈上保留一个写入的位置。Rust 是这样挑剔，它根据数组的内容来区分数组。此外，在我们读取它们之前，需要对它们进行初始化。</p>
<p>通过初始化 <code>let array = [0usize; 512] ;</code> ，我们以双重初始化为代价来解决这个问题，双重初始化可能会也可能不会得到优化——或者，根据类型的不同，甚至可能是无法实现的。参见 Unsafe Rust: How and when not to use it[9] 的解决方案。</p>
<h2><a class="header" href="#总结-12" id="总结-12">总结</a></h2>
<h3><a class="header" href="#参考资料-6" id="参考资料-6">参考资料</a></h3>
<p>[1]ambassador: https://docs.rs/ambassador/0.2.1</p>
<p>[2]workaround: https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md</p>
<p>[3]borrow checker: https://blog.logrocket.com/introducing-the-rust-borrow-checker/</p>
<p>[4] Learn Rust With Entirely Too Many Linked Lists : https://rust-unofficial.github.io/too-many-lists/</p>
<p>[5]Petgraph: https://crates.io/crates/petgraph</p>
<p>[6]<code>oeuroboros</code>: https://docs.rs/ouroboros/0.9.2/ouroboros/</p>
<p>[7]<code>self_cell</code>: https://docs.rs/self_cell/0.8.0/self_cell/</p>
<p>[8]<code>one_self_cell</code>: https://docs.rs/once_self_cell/0.6.3/once_self_cell/</p>
<p>[9]Unsafe Rust: How and when not to use it: https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/</p>
<h1><a class="header" href="#rust过程宏系列教程--proc-macro-workshop-之-builder-实现" id="rust过程宏系列教程--proc-macro-workshop-之-builder-实现">Rust过程宏系列教程 | Proc Macro Workshop 之 Builder 实现</a></h1>
<p>作者：米明恒 / 后期编辑：张汉东</p>
<blockquote>
<p>文字版首发：<a href="https://blog.ideawand.com/2021/03/24/rust_procedural_macro/rust_proc_marco_workshop_guide-02/">https://blog.ideawand.com/2021/03/24/rust_procedural_macro/rust_proc_marco_workshop_guide-02/</a></p>
<p>视频版本首发：<a href="https://space.bilibili.com/500416539">https://space.bilibili.com/500416539</a></p>
<p>了解过程宏开发环境并熟悉基本原理请阅读：<a href="https://blog.ideawand.com/2021/02/27/rust_procedural_macro/rust_proc_marco_workshop_guide-01/">https://blog.ideawand.com/2021/02/27/rust_procedural_macro/rust_proc_marco_workshop_guide-01/</a></p>
</blockquote>
<hr />
<p>本文以戴维·托尔奈（David Tolnay，也就是<code>syn</code>和<code>quote</code>这两个库的作者）的教学项目<code>proc-macro-workshop</code>出发，带领大家实战几个Rust过程宏的编写。</p>
<p><code>proc-macro-workshop</code>是一个包含5个过程宏的“解题游戏”，每一个过程宏都是有实际应用价值的案例，通过一系列由简到繁的测试用例，指导你去完成每一个过程宏的开发，而我们要做的，就是编写代码，像闯关游戏一样依次通过每一个测试用例，在这个过程中，我们会学到不同类型的过程宏的开发方法。</p>
<p>好了，不废话了，准备好一台电脑，我们从第一个过程宏挑战任务<code>builder</code>开始，每一关对应的视频教程我也放在下面了。</p>
<p>序言视频版：</p>
<iframe src="//player.bilibili.com/player.html?aid=332284630&bvid=BV16A411N7m2&cid=316964888&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<p>首先克隆https://github.com/dtolnay/proc-macro-workshop这个项目到本地，我们将在这个项目中进行开发</p>
<pre><code class="language-shell">cd ~/blog.ideawand.com  # 进入我的工作目录
git clone https://github.com/dtolnay/proc-macro-workshop.git
</code></pre>
<p>克隆项目后，我们会得到下面这样的目录结构。回忆我们上一篇文章中提到的，声明过程宏的crate需要和使用过程宏的crate独立开，这个项目也不例外，其中，5个题目分别独立存放在5个文件夹中。而目录的最顶层定义了一个bin类型的crate，可以使用我们定义的过程宏。我们后续的一些调试工作会借助外层crate的<code>main.rs</code>来进行。每一个题目所在的crate目录中都有一个tests文件夹，里面有通过数字编号命名的测试用例，以及一个<code>progress.rs</code>文件，<code>progress.rs</code>控制了哪些测试用例是生效的，在解题闯关的过程中，每当你通过一个测试用例，你就要到<code>progress.rs</code>中开启下一个测试用例，直到通过所有的测试用例。当然啦，解题过程中每一步的提示信息，都在以数字编号开头的测试用例中。</p>
<pre><code>└── blog.ideawand.com           -- 我们的工作目录
    └── proc-macro-workshop
        ├── bitfield            -- 虽然排在第一个，却是最难的一个，我们在最后一篇文章再去讨论它
        │   ├── impl
        │   ├── src
        │   ├── tests
        │   │   ├── &lt;省略这里的内容。。。&gt;
        │   └── Cargo.toml
        ├── builder             -- builder项目，我们今天的主角
        │   ├── src
        │   ├── tests
        │   │   ├── 01-parse.rs
        │   │   ├── 02-create-builder.rs
        │   │   ├── 03-call-setters.rs
        │   │   ├── 04-call-build.rs
        │   │   ├── 05-method-chaining.rs
        │   │   ├── 06-optional-field.rs
        │   │   ├── 07-repeated-field.rs
        │   │   ├── 08-unrecognized-attribute.rs
        │   │   ├── 08-unrecognized-attribute.stderr
        │   │   ├── 09-redefined-prelude-types.rs
        │   │   └── progress.rs  -- 闯关进度控制文件，在里面决定开启哪些测试用例
        │   └── Cargo.toml
        ├── debug               
        │   ├── src
        │   ├── tests
        │   │   ├── &lt;省略这里的内容。。。&gt;
        │   └── Cargo.toml
        ├── seq
        │   ├── src
        │   ├── tests
        │   │   ├── &lt;省略这里的内容。。。&gt;
        │   └── Cargo.toml
        ├── sorted
        │   ├── src
        │   ├── tests
        │   │   ├── &lt;省略这里的内容。。。&gt;
        │   └── Cargo.toml
        ├── Cargo.toml
        ├── LICENSE-APACHE
        ├── LICENSE-MIT
        ├── README.md
        └── main.rs            -- 外层Crate，可以在这里使用上面定义的各个过程宏，我们将通过这个文件来查看过程宏展开后生成的代码
</code></pre>
<p>以上信息主要来自于<code>proc-macro-workshop</code>项目的readme文档，如果大家的英文水平还可以的话，建议阅读一下原始的文档。</p>
<p>了解完整体项目的结构后，我们开始正式挑战<code>builder</code>项目！ 首先我们需要看一下<code>builder</code>题目要实现什么功能，每一个挑战题目到实现的目标都写在了<code>proc-macro-workshop</code>的readme文档中，下面我来把和<code>builder</code>项目相关的部分大致转述一下：</p>
<ul>
<li>我们要实现一个派生宏<code>derive(Builder)</code></li>
<li>这个宏提供了一个初始化结构体的方式，其使用效果大致如下,将<code>derive(Builder)</code>宏作用于<code>Command</code>结构体以后，会根据结构体的字段，自动生成一系列方法，来为我们提供初始化结构体中每个字段的方法：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use derive_builder::Builder;

#[derive(Builder)]
pub struct Command {
    executable: String,
    #[builder(each = &quot;arg&quot;)]
    args: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .arg(&quot;build&quot;.to_owned())
        .arg(&quot;--release&quot;.to_owned())
        .build()
        .unwrap();

    assert_eq!(command.executable, &quot;cargo&quot;);
}
</code></pre></pre>
<p>了解完任务目标以后，我们可以开始解题了。首先进入<code>builder</code>目录下的<code>tests</code>目录，并编辑<code>progress.rs</code>文件，将其中<code>t.pass(&quot;tests/01-parse.rs&quot;);</code>这一行的注释去掉，表示我们要检验第一个测试用例的结果是否正确。然后，我们打开<code>tests/01-parse.rs</code>这个文件，查看第一题的解题提示。</p>
<h3><a class="header" href="#第一关" id="第一关">第一关</a></h3>
<p>第一关视频版：</p>
<iframe src="//player.bilibili.com/player.html?aid=587300512&bvid=BV1TB4y1P7ak&cid=317585480&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<blockquote>
<ul>
<li>这个测试检测是否定义了一个名为<code>Builder</code>的派生宏，也就是说，只要我们定义了这个宏，什么都不用做，就可以通过这一关</li>
<li>什么都不做，意味着我们只需要返回空的TokenStream即可，但是，考官建议我们额外多做一些尝试：
<ul>
<li>尝试把输入的TokenStream解析为<code>syn::DeriveInput</code>这个语法树节点类型</li>
<li>阅读官方文档中关于<code>syn::DeriveInput</code>这个结构体的说明，看看其中的字段分别包含了哪些信息，对我们后续解题有什么用处。
<ul>
<li>对于这个结构体的描述，我们会在第二关的闯关过程中再介绍，当然你也可以提前阅读文档</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>通过这一关的技能我们在上一篇文章中已经遇到过了，因此这一关不难，直接上代码。我们编写代码的位置是<code>builder/src/lib.rs</code>这个文件，代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;
use syn;

#[proc_macro_derive(Builder)] // 注意，这里和第一篇文章里的 #[proc_macro_attribute]不同
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let st = syn::parse_macro_input!(input as syn::DeriveInput);
    TokenStream::new()
}
<span class="boring">}
</span></code></pre></pre>
<p>上述代码中，我们使用了<code>syn</code>包的<code>parse_macro_input!</code>宏将类型为<code>proc_macro::TokenStream</code>的input解析成了<code>syn::DeriveInput</code>类型的语法树节点<code>st</code>，然后产生一个空的<code>TokenStream</code>对象，返回给编译器。</p>
<p>这里需要额外注意的一点是，上一篇入门文章中我们给出的示例是一个属性样式的过程宏，属性样式的过程宏使用<code>#[proc_macro_attribute]</code>来定义，而本篇我们编写的是一个派生样式的过程宏，派生样式的过程宏用<code>#[proc_macro_derive(XXX)]</code>的形式来定义，除此之外，还有：</p>
<ul>
<li>派生样式的过程宏，其名字不是由函数名来定义的，而是由<code>#[proc_macro_derive(XXX)]</code>中的<code>XXX</code>来定义的</li>
<li>派生样式的过程宏，其定义的函数签名只包含一个<code>TokenStream</code>输入，相当于上篇文章介绍的属性式过程宏的<code>item</code>入参，也就是说派生式的过程宏相比于属性式的过程宏，少了<code>attr</code>这个入参</li>
<li>开发派生式过程宏时，通常将输入的<code>TokenStream</code>解析为<code>syn::DeriveInput</code>，这是派生宏定义对应的语法树节点</li>
</ul>
<blockquote>
<p>其实，大家可以把派生过程宏认为是一种特殊的属性式过程宏，把属性式过程宏看成是派生式的扩展版本，能用派生式过程宏实现的，用属性式过程宏也可以实现。另外从发展时间线上来说，属性式过程宏是在2018版本中新加入的，所以它和派生式过程宏有功能重叠也是有历史原因的。</p>
</blockquote>
<blockquote>
<p>上述代码直接返回了空的<code>TokenStream</code>，而上一篇文章我们在定义属性式过程宏时曾经提到，最简单的过程宏就是对输入不做修改，原封不动返回给编译器，可是这里为什么你返回了一个空的<code>TokenStream</code>呢？这样做不是就把输入给修改了吗？ 这其实是派生式过程宏和属性式过程宏的另外一个区别，先存疑，我们会在稍后的第二关详细介绍这个问题。</p>
</blockquote>
<p>由于我们引用了<code>syn</code>和<code>quote</code>两个包，我们还需要修改一下<code>builder/cargo.toml</code>文件，将<code>dependencies</code>小节下的<code># TODO</code>替换为如下的依赖声明,<code>proc-macro2</code>包我们后面会用到，这里也先引用过来：</p>
<pre><code class="language-toml">syn = {version=&quot;1.0&quot;, features=[&quot;extra-traits&quot;]}
proc-macro2 = {version=&quot;1.0&quot;}
quote = {version=&quot;1.0&quot;}
</code></pre>
<p>上述<code>syn</code>包额外加入的<code>extra-traits</code>特性是为了后续调试的方便。接下来，我们在<code>builder</code>目录下运行<code>cargo test</code>，不出意外，我们应该顺利通过了第一关测试。现在可以修改<code>builder/tests/progress.rs</code>文件,开启第二关的测试。</p>
<h3><a class="header" href="#第二关" id="第二关">第二关</a></h3>
<p>第二关视频版：</p>
<iframe src="//player.bilibili.com/player.html?aid=802590935&bvid=BV1uy4y147zG&cid=322449371&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<blockquote>
<p>我们要生成一个辅助的结构体，他的命名格式为<code>&lt;结构体名称&gt;+Builder</code>，同时，我们要为原始结构体生成生成一个<code>builder</code>方法，让他返回一个辅助结构体的实例。最终要生成的代码样式如下。：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Option&lt;Vec&lt;String&gt;&gt;,
    env: Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: Option&lt;String&gt;,
}
   
impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder {
            executable: None,
            args: None,
            env: None,
            current_dir: None,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>为了实现上面的功能，我们要用到几个个知识点，这些个知识点的其他介绍可以参考官方文档：</p>
<ul>
<li>标识符使用<code>syn::Ident</code>类型来表示</li>
<li>从<code>syn::DeriveInput</code>类型中获取原始输入结构体的标识符</li>
<li>构建出<code>CommandBuilder</code>这个新的标识符</li>
<li>从<code>syn::DeriveInput</code>类型中获取原始输入结构体各个字段的信息，比如字段名、字段的类型等信息</li>
<li>使用<code>quote</code>包中提供的<code>quote!</code>宏来按照模板生成<code>TokenStream</code>的方法</li>
</ul>
<p>首先是关于标识符的获取与构建:</p>
<ul>
<li><code>syn::DeriveInput</code>类型提供了<code>ident</code>属性，可以获取到被过程宏修饰的原始结构体的标识符对象</li>
<li><code>syn::Ident</code>类型提供了<code>to_string()</code>方法，可以将标识符转换为字符串</li>
<li><code>syn::Ident::new()</code>方法可以创建一个新的<code>syn::Ident</code>类型的变量
因此，我们通过下面几行代码可以构建出新的辅助结构体的名称标识符：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!(&quot;{}Builder&quot;, struct_name_literal);
    let builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());
<span class="boring">}
</span></code></pre></pre>
<p>在上面的代码中，有几点说明：</p>
<ul>
<li>注意区分<code>_literal</code>和<code>_ident</code>这两类变量的命名，这是我个人的习惯，大家也可以用其他的命名方式，但要注意区分，字符串和标识符不是一种类型</li>
<li>标识符除了名字的字符串之外，还携带了它在源代码中的位置信息，也就是<code>span</code></li>
<li>上述的第三行中，在创建新的<code>Ident</code>时，将<code>st</code>的span作为新创建标识符的span，是出于这样的原因：
<ul>
<li><code>span</code>信息主要用于发生编译错误时，编译器给用户指示出错误的位置</li>
<li>编译器报错时，不会展示过程宏生成的代码，而只会展示用户编写的原始文件代码</li>
<li>因此，对于我们通过过程宏产生出来的代码，应该指向用户原始代码文件中的某个位置，而不是凭空指向一个不存在的位置，否则后续一旦产生编译器报错，将会产生令人难以理解的错误提示</li>
<li>由于我们后续要生成的代码都是由用户输入的原始结构体产生的，所以将原始输入结构体的位置信息当做虚构出的标识符的位置信息，后续一旦报错，编译器显示的错误提示将指向用户原始的结构体，从而引导用户有效排查问题</li>
</ul>
</li>
</ul>
<p>构建出新的标识符后，我们就可以生成一些简单的代码了，整体的代码如下所示，在下面会详细解释：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;
use syn::{self, spanned::Spanned};
use quote::{ToTokens, quote};

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let st = syn::parse_macro_input!(input as syn::DeriveInput);
    match do_expand(&amp;st) {
        Ok(token_stream) =&gt; token_stream.into(),
        Err(e) =&gt; e.to_compile_error().into(),
    }
}

fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!(&quot;{}Builder&quot;, struct_name_literal);
    let builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());

    let struct_ident = &amp;st.ident;  // 模板代码中不可以使用`.`来访问结构体成员，所以要在模板代码外面将标识符放到一个独立的变量中

    let ret = quote! {     // ----------------------------------+
        pub struct #builder_name_ident {                   //   |
            // TODO                                             |
        }                                                  //   |
        impl #struct_ident {                               //   |
            pub fn builder() -&gt; #builder_name_ident {      //  被quote!宏包裹的是模板代码
<span class="boring">                builder_name_ident{                       //   |
</span>                    // TODO                                     | 
                }                                          //   |
            }                                              //   |
        }                                                  //   |
    };                     // ----------------------------------+

    return Ok(ret);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>划重点:
首先观察上面代码的骨架，分为了两个函数，宏定义本身将TokenStream转换为语法树对象后，交给另一个函数去完成主要功能，并处理其返回结果；<code>do_expand</code>函数返回一个<code>syn::Result</code>类型的结果。这种框架模式可以使得我们在后续书写代码时方便的进行错误处理，后续的几个实验项目我们也会使用类似的骨架。</p>
</blockquote>
<p>对上面代码几个重点的说明：</p>
<ul>
<li><code>to_compile_error</code>方法是<code>syn</code>包提供的一个返回错误的方式，它会产生一个包含错误信息的<code>proc_macro2::TokenStream</code>类型的结果，将其返回给编译器后，我们就可以在编译器的输出日志中看到用波浪线标注出的错误位置以及上下文代码了。我们在后面会介绍如何产生错误信息。</li>
<li><code>quote!</code>宏可以通过模板的形式生成TokenStream,在上一篇文章中我们已经了解到，所谓的过程宏，就是返回一个加工修改后的TokenStream，而TokenStream的结构很复杂，手工来生成一层层的嵌套结构太痛苦了，所以我们就有了<code>quote!</code>宏这个工具来帮助我们把和rust语言很相近的模板语言转换为TokenStream，在模板中我们可以做变量替换。
<ul>
<li><code>quote!</code>宏内部形如<code>#xxxx</code>的部分会被替换为<code>quote!</code>宏外面定义的变量所表达的语法树元素</li>
<li><code>quote!</code>宏的用法与rust内置的<code>macro_rules!</code>宏很类似，也支持重复替换等功能，区别是<code>quote!</code>里面用<code>#</code>而<code>macro_rules!</code>里面用<code>$</code></li>
</ul>
</li>
<li>代码中两个地方使用到了<code>.into()</code>，这些都是为了在<code>proc_macro::TokenStream</code>和<code>proc_macro2::TokenStream</code>类型之间转换，基本上<code>syn</code>和<code>quote</code>包产生的结果都是<code>proc_macro2::TokenStream</code>，我们的大原则就是在中间环节都用<code>proc_macro2</code>包的，只有在最终返回编译器的时候再转换成<code>proc_macro</code>包的。</li>
</ul>
<p>上述代码写完以后，我们就可以看看我们的过程宏生成的结果是什么样的了，这里我们要借助<code>cargo expand</code>这个命令来查看展开的结果，如果没有安装过这个工具，可以通过<code>cargo install cargo-expand</code>命令来安装。</p>
<p>目前我们关心的是我们编写的过程宏在第二关的测试用例中使用时，会产生什么样的效果，因此我们就以第二关的测试用例来查看展开效果，将<code>blog.ideawand.com/proc-macro-workshop/builder/tests/02-create-builder.rs</code>文件中的内容全部拷贝到<code>blog.ideawand.com/proc-macro-workshop/main.rs</code>中，覆盖原来<code>main.rs</code>中的全部内容即可，然后在<code>proc-macro-workshop</code>目录下执行<code>cargo expand</code>命令，应该可以看到下面的输出,我将过程宏生成的代码用注释标记了出来：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
use derive_builder::Builder;
pub struct Command {                 // --------------------+
    executable: String,                                  // |
    args: Vec&lt;String&gt;,                                   // 用户原始的代码
    env: Vec&lt;String&gt;,                                    // |
    current_dir: String,                                 // |
}                                    // --------------------+
pub struct CommandBuilder {}         // -----------------+
impl Command {                                        // |
    pub fn builder() -&gt; CommandBuilder {              // 由过程宏生成的代码片段
        CommandBuilder {}                             // | 
    }                                                 // |
}                                    // -----------------+
fn main() {
    let builder = Command::builder();
    let _ = builder;
}
</code></pre></pre>
<blockquote>
<p>可以看出，派生式过程宏会保留用户的原始输入的代码，然后把我们返回的TokenStream追加在用户原始代码的下方。它的行为和属性式过程宏是不一样的，属性式过程宏允许你修改用户的原始代码。所以，这里可以稍微纠正一下我们之前对于过程宏的描述，之前我们一直说，过程宏是把用户输入的代码做一顿处理之后，把加工处理后的代码给到编译器继续编译，但实际上，更准确的说法应该是，依照用户输入的代码信息，修改用户原始代码，<code>或生成全新的代码</code>，把修改后或<code>新生成</code>的代码返回给编译器继续编译。不同类型的过程宏赋予你操作用户代码的范围是不一样的。</p>
</blockquote>
<p>好了，开始下一步操作。我们已经生成出了新的结构体定义，但是结构体中的字段还没有定义出来，下面我们要开始遍历原始输入结构体的各个字段，获取这些字段的信息。</p>
<p>我们现在手头的输入信息只有一个类型为<code>syn::DeriveInput</code>类型的语法树节点，看起来所有的信息系都要从它里面挖掘了，为了获取输入结构体的信息，我们先看看<code>syn::DeriveInput</code>这个语法树节点是怎么定义的，它的定义如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct DeriveInput {
        /// Attributes tagged on the whole struct or enum.
        pub attrs: Vec&lt;Attribute&gt;,

        /// Visibility of the struct or enum.
        pub vis: Visibility,

        /// Name of the struct or enum.
        pub ident: Ident,

        /// Generics required to complete the definition.
        pub generics: Generics,

        /// Data within the struct or enum.
        pub data: Data,
    }
<span class="boring">}
</span></code></pre></pre>
<p>首先尝试自己看一下<code>syn::DeriveInput</code>的各个字段，然后尝试把他和结构体的定义联系起来。假设我们有下面这样一个结构定义,那么这里的各个语法元素和<code>syn::DeriveInput</code>中各个字段的映射关系可以用下图来表示</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Builder)]
#[blog.ideawand.com]
#[geek_kindergarten]
pub struct Foo &lt;T&gt; {
    foo: T,
    bar: i64,
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="chapter_5/./image/derive_macro/derive_input_mapping.png" alt="deriveInput类型和结构体的对应关系" /></p>
<blockquote>
<p>划重点： 通过上面的例子，要建立起一种认知，rust中各个语法元素，都可以被不同的数据结构(也就是<code>syn</code>包提供的语法树节点类型)来表示。我们上面的例子是带领大家分析了<code>syn::DeriveInput</code>结构和struct定义之间的对应关系，后续我们还会遇到各种各样的语法元素，我们不能一一给大家作图展示对应关系，这就要求大家能够自己阅读<code>syn</code>包的文档，并逐步掌握rust语言中常见语法元素与<code>syn</code>包中对应的各种数据结构。方法都是一样的，并不困难，学会多看文档。</p>
</blockquote>
<blockquote>
<p>从上面<code>DeriveInput</code>结构源代码的注释中，我们可以看到很多地方都写了<code>struct or enum</code>，也就是说，派生样式的过程宏不仅可以用在<code>struct</code>上，也可以用在<code>enum</code>上</p>
</blockquote>
<p>知道了语法树节点的结构，接下来我们就可以开始从中抽取数据了。我们现在要处理的输入结构比较简单，<code>attrs</code>和<code>generics</code>暂时都用不到，看来只要搞清楚<code>data</code>字段里的结构就行了，但是<code>data</code>节点里有什么呢？大家需要继续去继续阅读<code>syn::Data</code>数据类型的源码，一层一层去查看语法树中各种节点之间是怎样嵌套的，但语法树的嵌套层级非常灵活，你极有可能不知道写出的一段代码究竟会被解析成什么样的语法树，因此，我们可以回忆一下上一篇文章中的重点知识：</p>
<blockquote>
<ul>
<li>遇到不熟悉的语法树节点，就打印出来看看，回忆一下我们在上一篇文章中提到的重点内容：<code>print大法是开发调试rust过程宏的利器</code></li>
<li>print大法和阅读文档，要交替使用！</li>
</ul>
</blockquote>
<p>为了看看我们的原始输入结构体被解析成了什么样的语法树，我们在上述代码的<code>do_expand</code>函数开头加入一行打印语句如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    eprintln!(&quot;{:#?}&quot;, st.data);
    // 其他代码保持不变，省略。。。
}
<span class="boring">}
</span></code></pre></pre>
<p>然后依然在<code>proc-macro-workshop</code>目录下,这次执行<code>cargo check</code>命令（这个命令在上一篇文章中介绍过），因为我们不需要打印过程宏展开的代码，我们只是想通过<code>check</code>命令触发宏展开的过程，执行我们的调试打印代码，这次应该会在终端中看到很长的输出，我把关键结构放在这里,删掉了一些暂时不用的字段：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Struct(
    DataStruct {
        fields: Named(
            FieldsNamed {
                named: [
                    Field {
                        ident: Some(
                            Ident {
                                ident: &quot;executable&quot;,
                                span: #0 bytes(1388..1398),
                            },
                        ),
                        ty: Path(
                           // ...
                        ),
                    },
                    Comma,
                    // 下面开始第二个字段的定义了，我们省略不写了
                ],
            },
        ),
        semi_token: None,
    },
)
<span class="boring">}
</span></code></pre></pre>
<p>阅读上面的代码，我们可以看到<code>DeriveInput</code>的<code>data</code>字段是一个枚举类型，从<code>data</code>字段开始，到我们想要得到的字段列表，也就是上面结构中<code>Field</code>结构体构成的列表，中间还间隔了很多层不同的语法树节点，因此我们的下一步就是通过一顿模式匹配操作，拿到结构体字段的列表。</p>
<p>为了代码结构清晰，我们将其定义为一个独立的函数吧，像下面这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type StructFields = syn::punctuated::Punctuated&lt;syn::Field,syn::Token!(,)&gt;;

fn get_fields_from_derive_input(d: &amp;syn::DeriveInput) -&gt; syn::Result&lt;&amp;StructFields&gt; {
    if let syn::Data::Struct(syn::DataStruct {
        fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
        ..
    }) = d.data{
        return Ok(named)
    }
    Err(syn::Error::new_spanned(d, &quot;Must define on a Struct, not Enum&quot;.to_string()))
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面这段代码中，语法树各个层级的嵌套关系、枚举类到底是哪一个成员等信息，是通过print大法得到的，而解析后数据类型的泛型参数，则是通过翻<code>syn</code>包的文档或者代码得到的，这里大家要Get的重点不是代码现在写成的这个样子，而是怎样去综合使用各种手段来找到解析语法树各式各样节点的方法，注意这里是<code>授之以渔</code>，不是<code>授之以鱼</code>。说实话，我在完成这些挑战的时候，有相当多的时间是在翻文档和打印调试信息，从而捋清楚如何操作这些语法树节点。如果大家观看视频版本，就可以看到我是如何一层层阅读文档源码、找出类型定义的过程了。</p>
<p>关于错误信息，我们使用了<code>syn::Error::new_spanned()</code>方法，其第一个参数用于指定错误对应的span信息，也就是编译器在打印错误信息时，要显示用户源代码中的哪一段上下文，我们在这里直接将输入的原始信息放在了这里，这样报错的时候，就会显示出有问题的结构体定义了。我们这里出于演示目的，如果上面的模式匹配和解构流程失败，就返回一个&quot;该过程宏只能作用在结构体上`的错误，如果做得完善一些，上面的代码中其实有两个枚举类型的匹配，应该分别返回不同的错误信息，有兴趣的同学可以完善一下</p>
<p>拿到输入结构体中的字段以后，就可以开始产生<code>Builder</code>结构体的字段定义了，其实产生字段定义的方法有很多种，rust过程宏的机制就是，你最后能拼出来有效的TokenStream就行，至于你是模块化的拼接，还是流水账式的拼接，都可以。我们只能给大家演示一种写法，大家如果自己写，可以随意发挥。我们这里要给大家顺带展示一下<code>quote!</code>宏里面重复展开的用法，代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_builder_struct_fields_def(fields: &amp;StructFields) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt;{
    let idents:Vec&lt;_&gt; = fields.iter().map(|f| {&amp;f.ident}).collect();
    let types:Vec&lt;_&gt; = fields.iter().map(|f| {&amp;f.ty}).collect();

    let token_stream = quote!{
<span class="boring">        (#idents: std::option::Option&lt;#types&gt;),*
</span>    };
    Ok(token_stream)
}
<span class="boring">}
</span></code></pre></pre>
<p>上述代码中：</p>
<ul>
<li>首先通过两次迭代输入的字段列表，分别得到<code>idents</code>和<code>types</code>这两个列表变量，由于迭代过程是保序的，所以这两个列表的长度是相等的，并且列表中相同下标位置的元素恰好是<code>(标识符，类型)</code>的一对儿数据。
<ul>
<li><code>types</code>里面的每一个元素都是一个<code>&amp;syn::Type</code>类型的枚举，里面还有很深的嵌套层级，但我们现在可以把它当做一个整体（也就是一个语法树节点）来用，没必要去解析里面。</li>
</ul>
</li>
<li>在<code>quote!</code>宏中，可以使用<code>#(#var1 #var2 ... #varN ),*</code>的形式，来把一个列表中的内容展开成一组类似的代码，模板语言的详细说明请大家参阅官方文档</li>
<li><code>quote!</code>宏返回的是一个<code>proc_macro2::TokenStream</code>类型数据，<code>quote!</code>宏里面可以再次加入其它<code>quote!</code>宏产生的结果，这个用法我们马上就会看到。</li>
</ul>
<blockquote>
<p>划重点： </p>
<ul>
<li>上述代码中用到了非常常见的<code>Option</code>枚举类型，但这里使用了<code>std::option::Option</code>这种完整路径的写法。这是由于你无法预料到过程宏在什么场景下被使用，有可能过程宏展开的上下文中，用户定义了其他的<code>Option</code>类型，因此，为了保证过程宏的稳定性，请大家尽量使用绝对路径。</li>
<li>如果你在看B站视频，请一键三连，或者，至少点个赞吧~，如果你在看文字版，请关注我的微信公众号：极客幼稚园</li>
</ul>
</blockquote>
<p>上述代码在第二关的测试用例中执行后，预期会生成如下的代码片段,注意这四行代码周围并没有括号等其他语法元素的包围，它们仅仅是一些片段，后面我们要把这些片段插入到其他片段中，来组成更加复杂的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    executable: std::option::Option&lt;String&gt;,
    args: std::option::Option&lt;Vec&lt;String&gt;&gt;,
    env: std::option::Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: std::option::Option&lt;String&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>准备好上述两个函数以后，我们可以修改一下之前的<code>do_expand</code>函数了，修改后的函数如下所示，新增代码在注释中标出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!(&quot;{}Builder&quot;, struct_name_literal);
    let builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());

    let struct_ident = &amp;st.ident;

    // 以下两行代码是新增的，调用上述新定义的两个函数
    let fields = get_fields_from_derive_input(st)?;
    let builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;

    let ret = quote! {
        pub struct #builder_name_ident {
            // 下面这行代码是增增的，注意这里的用法：
            // 在当前这个`quote!`宏中，引用了其他`quote!`宏返回的结果
            // 在这里把不同的代码碎片拼接起来，就像搭积木一样
<span class="boring">            builder_struct_fields_def
</span>        }
        impl #struct_ident {
            pub fn builder() -&gt; #builder_name_ident {
<span class="boring">                builder_name_ident{
</span>                    // TODO 后面会再写一个函数，生成这里需要的代码片段
                }
            }
        }
    };

    return Ok(ret);
}
<span class="boring">}
</span></code></pre></pre>
<p>修改完代码后，我们再在<code>proc-macro-workshop</code>目录下执行以下<code>cargo expand</code>，查看一下现在过程宏展开得到的代码，应该是下面这个样子,重点关注一下我们拼接出的<code>CommandBuilder</code>结构体的成员定义部分：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
use derive_builder::Builder;
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    env: Vec&lt;String&gt;,
    current_dir: String,
}
struct CommandBuilder {
    executable: std::option::Option&lt;String&gt;,
    args: std::option::Option&lt;Vec&lt;String&gt;&gt;,
    env: std::option::Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: std::option::Option&lt;String&gt;,
}
impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder {}
    }
}
fn main() {
    let builder = Command::builder();
    let _ = builder;
}
</code></pre></pre>
<p>让我们来继续产生其他代码片段，我们现在需要生成<code>builder()</code>方法中，结构体初始化的相关代码，最简单的做法就是把上面的代码简单修改一下即可，但我们前面提到过，rust过程宏的实现方法非常灵活，只要你能拼出正确的TokenStream就行，所以，这里我们采用了另外一种写法，下面的函数返回的是一个由TokenStream组成的列表，重复展开的工作留到<code>do_expand</code>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_builder_struct_factory_init_clauses(fields: &amp;StructFields) -&gt; syn::Result&lt;Vec&lt;proc_macro2::TokenStream&gt;&gt;{
    let init_clauses: Vec&lt;_&gt; = fields.iter().map(|f| {
        let ident = &amp;f.ident;
        quote!{
<span class="boring">            ident: std::option::Option::None
</span>        }
    }).collect();

    Ok(init_clauses)
}
<span class="boring">}
</span></code></pre></pre>
<p>相应的，我们修改一下<code>do_expand</code>函数，改动部分用注释标出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!(&quot;{}Builder&quot;, struct_name_literal);
    let builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());

    let struct_ident = &amp;st.ident;

    let fields = get_fields_from_derive_input(st)?;
    let builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;
    // 下面这一行是新加的 
    let builder_struct_factory_init_clauses = generate_builder_struct_factory_init_clauses(fields)?;

    let ret = quote! {
        pub struct #builder_name_ident {
<span class="boring">            builder_struct_fields_def
</span>        }
        impl #struct_ident {
            pub fn builder() -&gt; #builder_name_ident {
<span class="boring">                builder_name_ident{
</span>                    // 下面这一行是新加的，注意我们在这里重复展开了每一个字段
<span class="boring">                    (#builder_struct_factory_init_clauses),*
</span>                }
            }
        }
    };

    return Ok(ret);
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来大家可以再运行一下<code>cargo expand</code>来观察一下过程宏展开的结果，我们就不再列出来了。现在，我们看看第二关能不能通过了，确保<code>proc-macro-workshop/builder/tests/progress.rs</code>文件中对第二关的注释已经去掉,然后进入到<code>proc-macro-workshop/builder</code>目录下，执行<code>cargo test</code>，不出意外的话，第二关应该顺利通过！</p>
<h3><a class="header" href="#第三关" id="第三关">第三关</a></h3>
<p>第三关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=290008560&bvid=BV1Sf4y1W7He&cid=322455034&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<p>请阅读<code>proc-macro-workshop/builder/tests/03-call-setters.rs</code>文件中的说明,主要就是要产生一组类似下面这种形式的代码，我们要把其中的<code>executable</code>和<code>String</code>全部动态替换掉：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn executable(&amp;mut self, executable: String) -&gt; &amp;mut Self {
    self.executable = Some(executable);
    self
}
<span class="boring">}
</span></code></pre></pre>
<p>这一关要实现的功能与第二关几乎完全一样，因此我就不再做其他解释了。大家可以先尝试自己编码之后，再看看我下面给出的一个参考实现。</p>
<p>在这个参考实现中，我再给大家展示一种代码片段拼接的方式，即直接通过<code>proc_macro2::TokenStream</code>类型提供的<code>extend</code>方法，把多个TokenStream串接在一起，就像字符串拼接一样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_setter_functions(fields: &amp;StructFields) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt;{
    let idents:Vec&lt;_&gt; = fields.iter().map(|f| {&amp;f.ident}).collect();
    let types:Vec&lt;_&gt; = fields.iter().map(|f| {&amp;f.ty}).collect();

    // 创建一个空的TokenStream
    let mut final_tokenstream = proc_macro2::TokenStream::new();

    for (ident, type_) in idents.iter().zip(types.iter()) {
        let tokenstream_piece = quote!{
            fn #ident(&amp;mut self, #ident: #type_) -&gt; &amp;mut Self {
                self.#ident = std::option::Option::Some(#ident);
                self
            }
        };
        // 不断追加新的TokenStream片段到一个公共的TokenStream上
        final_tokenstream.extend(tokenstream_piece);
    }

    Ok(final_tokenstream)
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!(&quot;{}Builder&quot;, struct_name_literal);
    let builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());

    let struct_ident = &amp;st.ident;

    let fields = get_fields_from_derive_input(st)?;
    let builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;
    let builder_struct_factory_init_clauses = generate_builder_struct_factory_init_clauses(fields)?;

    // 下面这一行是第三关新加的
    let setter_functions = generate_setter_functions(fields)?;

    let ret = quote! {
        pub struct #builder_name_ident {
<span class="boring">            builder_struct_fields_def
</span>        }
        impl #struct_ident {
            pub fn builder() -&gt; #builder_name_ident {
<span class="boring">                builder_name_ident{
</span><span class="boring">                    (#builder_struct_factory_init_clauses),*
</span>                }
            }
        }

        // 下面这三行是第三关新加的
        impl #builder_name_ident {
<span class="boring">            setter_functions
</span>        }
    };

    return Ok(ret);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第四关" id="第四关">第四关</a></h3>
<p>第四、五关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=205229090&bvid=BV1bh411S7zV&cid=325369691&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<p>这一关要生成的代码比之前的复杂了不少，需要由宏来产生出一些判断逻辑，错误信息等，但是换汤不换药，本质还是生成代码片段后进行拼接。大家可以在本关中继续尝试各种写法。</p>
<p>接下来我要给出的写法中，采用了先将各个片段放入一个Vec中，然后再展开的做法，这是因为这样写以后，对于后面关卡的实现会比较容易，大家完全可以尝试其他的方式来写。</p>
<p>产生<code>build()</code>方法代码片段的示例代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_build_function(fields: &amp;StructFields, origin_struct_ident: &amp;syn::Ident) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt;{
    let idents:Vec&lt;_&gt; = fields.iter().map(|f| {&amp;f.ident}).collect();

    let mut checker_code_pieces = Vec::new();
    for idx in 0..idents.len() {
        let ident = idents[idx];
        checker_code_pieces.push(quote!{
            if self.#ident.is_none() {
                let err = format!(&quot;{} field missing&quot;, stringify!(#ident));
                return std::result::Result::Err(err.into())
            }
        });
    }

    let mut fill_result_clauses = Vec::new();
    for idx in 0..idents.len() {
        let ident = idents[idx];
        fill_result_clauses.push(quote!{
<span class="boring">            ident: self.#ident.clone().unwrap()
</span>        });
    }


    let token_stream = quote!{
        pub fn build(&amp;mut self) -&gt; std::result::Result&lt;#origin_struct_ident, std::boxed::Box&lt;dyn std::error::Error&gt;&gt; {
<span class="boring">            (#checker_code_pieces)*
</span>                               //  ^--注意，由于我们要重复的是一组if判断代码块，它们之间不需要用逗号分隔，所以这里的重复模式是`*`，而不是之前重复结构体字段时用到的`,*`
            let ret = #origin_struct_ident{
<span class="boring">                (#fill_result_clauses),*
</span>            };
            std::result::Result::Ok(ret)
        }
    };
    Ok(token_stream)
}
<span class="boring">}
</span></code></pre></pre>
<p>对do_expand()的修改如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let struct_name_literal = st.ident.to_string();
    let builder_name_literal = format!(&quot;{}Builder&quot;, struct_name_literal);
    let builder_name_ident = syn::Ident::new(&amp;builder_name_literal, st.span());

    let struct_ident = &amp;st.ident;

    let fields = get_fields_from_derive_input(st)?;
    let builder_struct_fields_def = generate_builder_struct_fields_def(fields)?;
    let builder_struct_factory_init_clauses = generate_builder_struct_factory_init_clauses(fields)?;
    let setter_functions = generate_setter_functions(fields)?;
    // 下面这一行是第四关新加的
    let generated_builder_functions = generate_build_function(fields,struct_ident)?;

    let ret = quote! {
        pub struct #builder_name_ident {
<span class="boring">            builder_struct_fields_def
</span>        }
        impl #struct_ident {
            pub fn builder() -&gt; #builder_name_ident {
<span class="boring">                builder_name_ident{
</span><span class="boring">                    (#builder_struct_factory_init_clauses),*
</span>                }
            }
        }
        impl #builder_name_ident {
<span class="boring">            setter_functions
</span>            // 下面这1行是第四关新加的
<span class="boring">            generated_builder_functions
</span>        }
    };

    return Ok(ret);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第五关" id="第五关">第五关</a></h3>
<p>看一下题目要求，好开心，我们的代码已经实现了第五关的所有功能，什么都不用做了~</p>
<h3><a class="header" href="#第六关" id="第六关">第六关</a></h3>
<p>第六关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=545152453&bvid=BV1hi4y1A79p&cid=328346252&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<p>这一关的题目要求比较长，在其中介绍了一个rust过程宏机制的缺陷：rust的引用消解，或者说是符号解析，是在宏展开之后进行的，这也就是说，例如有如下代码：</p>
<pre><pre class="playground"><code class="language-rust">use std::any::TypeId;

pub mod blog {
    pub mod ideawand {
        pub mod com {
            pub struct GeekKindergarten{}
        }
    }
}

use blog::ideawand::com::GeekKindergarten;
use blog::ideawand::com::GeekKindergarten as MyPersonalBlog;

fn main() {
    assert!(TypeId::of::&lt;GeekKindergarten&gt;() == TypeId::of::&lt;blog::ideawand::com::GeekKindergarten&gt;());
    assert!(TypeId::of::&lt;MyPersonalBlog&gt;() == TypeId::of::&lt;blog::ideawand::com::GeekKindergarten&gt;());
}
</code></pre></pre>
<p>正常来说，上面代码中的<code>GeekKindergarten</code>类型，可以用完整的路径名来表示，也可以通过<code>use</code>关键字将其导入到当前上下文中，使用短名字来表示,还可以通过<code>as</code>关键字为其重命名，但它们都是同一个类型；然而在过程宏中，我们看到的TokenStream也好，还是TokenStream解析出的<code>syn</code>包中定义的语法树节点类型也好，它们都还没有经过引用消解，所以在rust的过程宏中，<code>GeekKindergarten</code>和<code>blog::ideawand::com::GeekKindergarten</code>以及<code>MyPersonalBlog</code>是不同的，或者说，我们无法判断他们是不是相同的类型。</p>
<p>第六关的题目是说，我们要识别出用户给出的结构体中，类型为<code>Option</code>类型的字段，对于这些字段，我们允许他们为None，也就是说要放宽第四关中<code>builder</code>方法的校验规则。为了简化这个题目，题目要求我们只要识别<code>Option</code>类型即可，不考虑通过<code>as</code>关键词重命名导致的不可识别问题，也不考虑其他同名的<code>Option</code>的情况。同时，第六关的提示中给出了我们要匹配<code>Option</code>枚举和泛型时可能用到的模式，如下所示,我们要查看结构体的某个字段是不是满足这个这个模式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Type::Path(             // ------------------------------------------- 这个节点表示形如 `std::option::Option&lt;Vec&lt;String&gt;&gt;`这个整体
    TypePath {  
        qself: None,
        path: Path {        // --------------------------------------- 到这个节点其实也还是表示 `std::option::Option&lt;Vec&lt;String&gt;&gt;`这个整体
            segments: [           // --------------------------------- 这个列表表示 [std, option, Option&lt;Vec&lt;String&gt;&gt;]  这三个独立的段
                PathSegment {           // --------------------------- 这个结构体表示每一段的具体内容，我们以最后一段`Option&lt;Vec&lt;String&gt;&gt;`为例
                    ident: &quot;Option&quot;,           // -------------------- 这里表示Option这个标识符
                    arguments: PathArguments::AngleBracketed(       // 这个节点表示&lt;Vec&lt;String&gt;&gt;
                        AngleBracketedGenericArguments {
                            args: [                                 // 由于泛型参数可能是&lt;T,U,V&gt;等多个，所以这里是一个列表
                                GenericArgument::Type(              // 在上面的例子中，这个节点表示`Vec&lt;String&gt;`
                                    ...                             // 这里可以将`Vec&lt;String&gt;`按照上面的套路继续展开。。。
                                ),
                            ],
                        },
                    ),
                },
            ],
        },
    },
)
<span class="boring">}
</span></code></pre></pre>
<p>有了上面的模式参考，我们来写一个新的函数，用来识别上面的模式，如果一个type能匹配上面的模式，就把Option里面的泛型参数返回出来，否则返回一个None</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_optional_inner_type(ty: &amp;syn::Type) -&gt; Option&lt;&amp;syn::Type&gt; {
    if let syn::Type::Path(syn::TypePath { ref path, .. }) = ty {
        // 这里我们取segments的最后一节来判断是不是`Option&lt;T&gt;`，这样如果用户写的是`std:option:Option&lt;T&gt;`我们也能识别出最后的`Option&lt;T&gt;`
        if let Some(seg) = path.segments.last() {
            if seg.ident == &quot;Option&quot; {
                if let syn::PathArguments::AngleBracketed(syn::AngleBracketedGenericArguments {
                    ref args,
                    ..
                }) = seg.arguments
                {
                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.first() {
                        return Some(inner_ty);
                    }
                }
            }
        }
    }
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>在能够判断一个field是否为<code>Option</code>以后，我们还需要对之前的几个函数都做出相应的调整，因此想通过这一关，改动还是比较大的，主要的改动包括：</p>
<ul>
<li>在创建builder对应的结构体时，<code>Option</code>类型字段要特殊处理，如果还按照原来的模板来生成，就会产生出<code>Option&lt;Option&lt;T&gt;&gt;</code>这种类型</li>
<li><code>Option&lt;T&gt;</code>类型字段的setter接受的类型应该是<code>T</code>，如果使用原来的模板，会拼接出来<code>Option&lt;T&gt;</code></li>
<li><code>builder</code>方法对于<code>Option&lt;T&gt;</code>字段的校验规则和其他字段不同</li>
</ul>
<p>下面我们来一个个修改，首先是修改<code>generate_builder_struct_fields_def()</code>这个函数，修改后如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_builder_struct_fields_def(
    fields: &amp;StructFields,
) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let idents: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();
    // 第六关，对types 变量的构建逻辑进行了调整
    let types: Vec&lt;_&gt; = fields
        .iter()
        .map(|f| {
            // 针对是否为`Option`类型字段，产生不同的结果
            if let Some(inner_ty) = get_optional_inner_type(&amp;f.ty) {
                quote!(std::option::Option&lt;#inner_ty&gt;)
            } else {
                let origin_ty = &amp;f.ty;
                quote!(std::option::Option&lt;#origin_ty&gt;)
            }
        })
        .collect();

    let token_stream = quote! {
        // 下面这一行，也做了修改
<span class="boring">        (#idents: #types),*
</span>    };
    Ok(token_stream)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后修改<code>generate_setter_functions()</code>函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_setter_functions(fields: &amp;StructFields) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let idents: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();
    let types: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();

    let mut final_tokenstream = proc_macro2::TokenStream::new();

    for (ident, type_) in idents.iter().zip(types.iter()) {
        let tokenstream_piece;
        // 第六关，对tokenstream_piece 变量的构建逻辑进行了调整
        if let Some(inner_ty) = get_optional_inner_type(type_) {
            tokenstream_piece = quote! {
                fn #ident(&amp;mut self, #ident: #inner_ty) -&gt; &amp;mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            };
        } else {
            tokenstream_piece = quote! {
                fn #ident(&amp;mut self, #ident: #type_) -&gt; &amp;mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            };
        }
        final_tokenstream.extend(tokenstream_piece);
    }

    Ok(final_tokenstream)
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，我们对<code>generate_build_function()</code>函数进行修改：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_build_function(
    fields: &amp;StructFields,
    origin_struct_ident: &amp;syn::Ident,
) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let idents: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();
    // 下面这一行是第六关新加的，之前没用到type相关信息，就没写下面这一行
    let types: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();

    let mut checker_code_pieces = Vec::new();
    for idx in 0..idents.len() {
        let ident = idents[idx];
        // 第六关修改，只对不是`Option`类型的字段生成校验逻辑
        if get_optional_inner_type(&amp;types[idx]).is_none() {
            checker_code_pieces.push(quote! {
                if self.#ident.is_none() {
                    let err = format!(&quot;{} field missing&quot;, stringify!(#ident));
                    return std::result::Result::Err(err.into())
                }
            });
        }
    }

    let mut fill_result_clauses = Vec::new();
    for idx in 0..idents.len() {
        let ident = idents[idx];
        // 这里需要区分`Option`类型字段和非`Option`类型字段
        if get_optional_inner_type(&amp;types[idx]).is_none() {
            fill_result_clauses.push(quote! {
<span class="boring">                ident: self.#ident.clone().unwrap()
</span>            });
        }else {
            fill_result_clauses.push(quote! {
<span class="boring">                ident: self.#ident.clone()
</span>            });
        }
    }

    let token_stream = quote! {
        pub fn build(&amp;mut self) -&gt; std::result::Result&lt;#origin_struct_ident, std::boxed::Box&lt;dyn std::error::Error&gt;&gt; {
<span class="boring">            (#checker_code_pieces)*
</span>            let ret = #origin_struct_ident{
<span class="boring">                (#fill_result_clauses),*
</span>            };
            std::result::Result::Ok(ret)
        }
    };
    Ok(token_stream)
}
     
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第七关" id="第七关">第七关</a></h3>
<p>第七关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=715287871&bvid=BV1eQ4y1Z7h9&cid=331167283&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<p>这一关会涉及到如何解析结构体中字段附加的属性信息(field attribute)，例如下面这个结构体</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Builder)]
struct ArticleAuthor {
    Blog String,
    #[geek_kindergarten(foo=bar)]
    IdeaWand String,
    Com String,
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个结构体中，<code>#[geek_kindergarten(foo=bar)]</code>这一行就是附加在<code>IdeaWand</code>这个字段上的属性，属性的名字是<code>geek_kindergarten</code>，这里需要注意的一个重点是：</p>
<blockquote>
<ul>
<li>在派生宏中，上面这样的属性称为<code>惰性属性</code>（inert attributes），惰性属性必须指定关联一个派生过程宏，限定这个惰性属性只能在这个过程宏内使用。
那么，如何向编译器注册一个惰性属性的名字呢？在第七关的指导文档里有说明，简单来说，就是要在<code>#[proc_macro_derive(Builder)]</code>这个标签中添加上属性的名字，加入我们要加入一个名为<code>geek_kindergarten</code>的属性，那么就要这样写：<code>#[proc_macro_derive(Builder, attributes(geek_kindergarten))]</code></li>
</ul>
</blockquote>
<p>接下来的操作，和前几关大致一样，我们先来把要做的事情列一下：</p>
<ul>
<li>解析每个field的<code>attrs</code>字段，它是一个<code>Vec&lt;Attribute&gt;</code>类型，<code>Attribute</code>是一个我们前面没遇到过的语法树节点，我们的处理思路还是一样的，需要通过文档 + Print大法来搞清楚里面的结构</li>
<li>第六关中我们识别了<code>Option&lt;T&gt;</code>这种模式的代码，本关我们要识别<code>Vec&lt;T&gt;</code>，稍微调整一下，复用之前代码即可</li>
<li>针对是不是<code>Vec&lt;T&gt;</code>类型,以及是不是有属性标签，我们要用不同的模板来产生代码</li>
</ul>
<p>下面，我们先来看看怎么解析<code>Attribute</code>类型的语法树节点，由于这个属性标签是一个挺通用的解析需求，而且还比较灵活复杂，所以我们就多花点时间来介绍一下。为了探索他的行为，我们创建另一个极简版本的派生宏，专门用来打印<code>Attribute</code>结构的信息。同时，<code>Attribute</code>不一定是要写在结构体字段上的，我们也可以用一个属性来装饰整个结构体，所以<code>DeriveInput</code>语法树节点中就有<code>attrs</code>属性，因此我在接下来的小实验中，就不再去层层解析寻找字段上的属性了，直接用结构体的属性标签来做实验，效果都是一样的。下面，我们来搭建这个小的实验环境:</p>
<ul>
<li>在<code>proc-macro-workshop/builder/src/lib.rs</code>中，添加如下代码：
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(ExploreAttribute)]
pub fn attribute_explore(input: TokenStream) -&gt; TokenStream {
    let st = syn::parse_macro_input!(input as syn::DeriveInput);
    let attr = st.attrs.first().unwrap();
    eprintln!(&quot;{:#?}&quot;, attr);
    proc_macro2::TokenStream::new().into()
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>将<code>proc-macro-workshop/main.rs</code>中的内容清空，替换为下面的代码：
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use derive_builder::ExploreAttribute;

#[derive(ExploreAttribute)]
#[blog::ideawand::com(Bar)]
pub struct Foo{}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<p>在<code>proc-macro-workshop</code>目录下执行<code>cargo check</code>,观察输出结果，对于上面的例子，我们得到的输出为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Attribute {
    pound_token: Pound,
    style: Outer,
    bracket_token: Bracket,
    path: Path {
        leading_colon: None,
        segments: [
            PathSegment {
                ident: Ident {
                    ident: &quot;blog&quot;,
                    span: #0 bytes(1383..1387),
                },
                arguments: None,
            },
            Colon2,
            PathSegment {
                ident: Ident {
                    ident: &quot;ideawand&quot;,
                    span: #0 bytes(1389..1397),
                },
                arguments: None,
            },
            Colon2,
            PathSegment {
                ident: Ident {
                    ident: &quot;com&quot;,
                    span: #0 bytes(1399..1402),
                },
                arguments: None,
            },
        ],
    },
    tokens: TokenStream [
        Group {
            delimiter: Parenthesis,
            stream: TokenStream [
                Ident {
                    ident: &quot;Bar&quot;,
                    span: #0 bytes(1403..1406),
                },
            ],
            span: #0 bytes(1402..1407),
        },
    ],
}
<span class="boring">}
</span></code></pre></pre>
<p>简单解释一下，就是这样的：</p>
<pre><code>#[blog::ideawand::com(Bar)]
^ ^^^^^^^^^^^^^^^^^^^ ^^^
|         |            |
|         |            +--这里对应的是`syn::Attribute`节点的`tokens`属性,它的类型是`proc_macro2::TokenStream`
|         +--这里对应的是`syn::Attribute`节点的`path`属性,它的类型是`syn::Path`,这个语法树节点我们在前面已经见到过了
+--这里对应`syn::Attribute`节点的`style`属性，`#`现在对应到的是`outer`,如果是`#!`对应处的就是`inner`
</code></pre>
<p>上面的<code>style</code>和<code>path</code>两个字段都没什么要说的，好玩并且复杂的事情是<code>tokens</code>这个属性，我们可以看到，这个属性的类型并没有在<code>syn</code>包中定义对应的语法树节点，这是为什么呢？查看官方文档，我们可以了解到其背后的原因是：</p>
<ul>
<li>Rust 属性的书写语法非常灵活，甚至可以不是有效的Rust标准语法，例如包含用户自定义的语法规则，因此，<code>syn</code>包没法通过有限的语法树节点类型来表示它的内容</li>
<li>之所以要为<code>syn::Attribute</code>节点设置一个<code>path</code>部分，是可以把<code>path</code>作为一个类型提示，过程宏或者编译器可以根据<code>path</code>来决定如何解析后面的<code>token</code>部分</li>
<li>如果在你的自定义属性中，要求属性是符合标准Rust语法的，那么<code>syn::Attribute</code>节点提供了一个<code>parse_meta()</code>方法，可以将整个属性（也就是<code>path</code>和<code>token</code>两部分）中的内容解析为<code>syn::Meta</code>枚举类型，而这个枚举类型的内容又十分丰富。</li>
</ul>
<p><code>syn::Meta</code>枚举各个成员的含义：</p>
<ul>
<li><code>syn::Meta::Path</code>表示一个路径，下面这些形式的都可以认为是路径：
<ul>
<li><code>#[A]</code>中的<code>A</code>,它只有一个小节，没有<code>::</code>分割的多个小节，但它也是一个Path</li>
<li><code>#[A::B::C]</code>中的<code>A::B::C</code></li>
</ul>
</li>
<li><code>syn::Meta::List</code>表示一个列表，这个列表必须由一个前置路径和一个括号标记组成，括号里面通过逗号分隔为多个条目，组成一个列表，列表中的每一个条目又是一个<code>syn::Meta</code>枚举
<ul>
<li><code>#[Foo(AAA,BBB,CCC)]</code>中的<code>Foo</code>是前置路径，后面的<code>AAA</code>、<code>BBB</code>、<code>CCC</code>就是三个列表项，它们三个都是<code>syn::Meta</code>类型的枚举
<ul>
<li>从形式上可以看出，这三个枚举类型实际上存放的又是三个<code>syn::Path</code>类型的数据</li>
</ul>
</li>
<li><code>#[Foo(AAA,BBB(CCC,DDD))]</code> 这种形式，演示了列表中每个项目是可以嵌套的，其中的<code>BBB</code>是嵌套内层<code>syn::Meta::List</code>的前置路径，而<code>CCC</code>和<code>DDD</code>是内层的列表项</li>
</ul>
</li>
<li><code>syn::Meta::NameValue</code>表示一个kv对，其中key部分是一个<code>syn::Path</code>,而value部分是一个字符串字面量
<ul>
<li><code>#[xxx = &quot;yyy&quot;]</code>就是一个典型的例子</li>
</ul>
</li>
</ul>
<p>通过上面的嵌套规则可以看出，Rust允许你书写的属性规则是非常灵活的，例如你可以书写这样的一个属性，你可以尝试解释一下下面这个属性的嵌套层级：</p>
<pre><code>#[Foo::Bar(A1::A2(B1::B2=&quot;C&quot;,D=&quot;E&quot;,F1::F2,G,H(I,J)))]
</code></pre>
<p>大家可以通过修改<code>proc-macro-workshop/main.rs</code>中的代码来尝试各种不同形式的Attribute是如何被解析为<code>syn::Meta</code>类型的枚举的，当然，需要修改一下<code>proc-macro-workshop/builder/src/lib.rs</code>的测试派生宏的定义代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(ExploreAttribute)]
pub fn attribute_explore(input: TokenStream) -&gt; TokenStream {
    let st = syn::parse_macro_input!(input as syn::DeriveInput);
    let attr = st.attrs.first().unwrap();
    let meta = attr.parse_meta(); // 解析为`sny::Meta`对象
    eprintln!(&quot;{:#?}&quot;, meta);
    proc_macro2::TokenStream::new().into()
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们回归正题，看一下第七关的题目，我们要解析形如<code>#[builder(each = &quot;arg&quot;)]</code>的惰性属性，分解一下，首先这是一个<code>syn::Meta::List</code>枚举成员，它的前置路径是<code>builder</code>，后面的列表里有一个<code>syn::Meta::NameValue</code>枚举成员，在这个kv对中，<code>each</code>是固定的，而后面的值，我们要把它当做一个ident来使用，拼接到生成的代码中。开始撸代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_user_specified_ident_for_vec(field: &amp;syn::Field) -&gt; Option&lt;syn::Ident&gt; {
    for attr in &amp;field.attrs {
        if let Ok(syn::Meta::List(syn::MetaList {
            ref path,
            ref nested,
            ..
        })) = attr.parse_meta()
        {
            if let Some(p) = path.segments.first() {
                if p.ident == &quot;builder&quot; {
                    if let Some(syn::NestedMeta::Meta(syn::Meta::NameValue(kv))) = nested.first() {
                        if kv.path.is_ident(&quot;each&quot;) {
                            if let syn::Lit::Str(ref ident_str) = kv.lit {
                                return Some(syn::Ident::new(
                                    ident_str.value().as_str(),
                                    attr.span(),
                                ));
                            }
                        }
                    }
                }
            }
        }
    }
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>解析Attribute的工作完成了，但为了使用上面的函数我们还得费一番脑筋，做出不少修改，让我们来仔细看看第七关题目给出的要求：</p>
<ul>
<li>
<p>我们需要兼容指定了each属性的字段和没有指定each属性的字段：</p>
<ul>
<li>如果指定了each属性，又分为两种情况：
<ul>
<li>如果each指定的名字和原始字段名一致，则只产生出每次追加一个值的setter函数</li>
<li>如果each指定的名字和原始字段名不一致，则需要产生两个版本的函数：
<ul>
<li>与原始字段名同名的函数用于接收一个完整列表</li>
<li>用户指定名称的setter，每次只接收一个条目</li>
</ul>
</li>
<li>Vec字段和Option字段一样，不需要做为空的检查，对于Vec字段，我们要将其自动初始化</li>
</ul>
</li>
<li>如果没指定each属性，则可以把这个字段看做一个普通类型对待，前六关的测试用例还得通过才行</li>
</ul>
</li>
<li>
<p>为了实现上面的需求，我们之前每一个函数几乎都要修改。在前四关中，我给出了三种拼接<code>TokenStream</code>的方法，在这次大改造中你会发现：</p>
<ul>
<li>对于一些简单的拼接，使用迭代器和<code>quote!</code>宏的重复展开功能，几行简短的代码就可以优雅地实现拼接（第一关和第二关的写法），但对于复杂的需求，写起来就会很别扭</li>
<li>对于有比较复杂逻辑的生成业务，自己维护一个<code>Vec&lt;TokenStream&gt;</code>数组，或者自己去extend一个<code>TokenStream</code>会更加灵活顺手（也就是第三关和第四关的写法）</li>
</ul>
</li>
</ul>
<p>有了上面的大方向，我们开始继续撸代码。</p>
<p>第一个修改点是，因为我们这次不仅要获取<code>Option&lt;T&gt;</code>的内部类型，还有处理<code>Vec&lt;T&gt;</code>,所以我们来修改一下之前的<code>get_optional_inner_type()</code>函数，使其能够被复用，我们将其重命名为<code>get_generic_inner_type()</code>,新的定义如下，修改完成后，需要调整一下之前调用它的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_generic_inner_type&lt;'a&gt;(ty: &amp;'a syn::Type, outer_ident_name: &amp;str) -&gt; Option&lt;&amp;'a syn::Type&gt; {
    if let syn::Type::Path(syn::TypePath { ref path, .. }) = ty {
        // 这里我们取segments的最后一节来判断是不是`T&lt;U&gt;`，这样如果用户写的是`foo:bar::T&lt;U&gt;`我们也能识别出最后的`T&lt;U&gt;`
        if let Some(seg) = path.segments.last() {
            if seg.ident == outer_ident_name {
                if let syn::PathArguments::AngleBracketed(syn::AngleBracketedGenericArguments {
                    ref args,
                    ..
                }) = seg.arguments
                {
                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.first() {
                        return Some(inner_ty);
                    }
                }
            }
        }
    }
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来一个个调整之前编写的函数，首先是<code>generate_builder_struct_fields_def()</code>函数，修改点在注释中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_builder_struct_fields_def(
    fields: &amp;StructFields,
) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let idents: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();
    let types: Vec&lt;_&gt; = fields
        .iter()
        .map(|f| {
            if let Some(inner_ty) = get_generic_inner_type(&amp;f.ty,&quot;Option&quot;) {
                quote!(std::option::Option&lt;#inner_ty&gt;)
            // 以下三行是第七关新加入的
            } else if get_user_specified_ident_for_vec(f).is_some() {
                let origin_ty = &amp;f.ty;
                quote!(#origin_ty)  // 题目中设定，如果用户指定了each属性，我们就可以认为它一定是作用在一个Vec字段上

            } else {
                let origin_ty = &amp;f.ty;
                quote!(std::option::Option&lt;#origin_ty&gt;)
            }
        })
        .collect();

    let token_stream = quote! {
<span class="boring">        (#idents: #types),*
</span>    };
    Ok(token_stream)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后是初始化函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_builder_struct_factory_init_clauses(fields: &amp;StructFields) -&gt; syn::Result&lt;Vec&lt;proc_macro2::TokenStream&gt;&gt;{
    let init_clauses: Vec&lt;_&gt; = fields.iter().map(|f| {
        let ident = &amp;f.ident;
        // 下面这个if分支是第七关加入的，在第六关的时候只有else分支里的代码
        if get_user_specified_ident_for_vec(f).is_some() {
            quote!{
<span class="boring">                ident: std::vec::Vec::new()  //指定了each属性的Vec需要初始化
</span>            }
        } else {
            quote!{
<span class="boring">                ident: std::option::Option::None
</span>            }
        }
    }).collect();

    Ok(init_clauses)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后是setter的生成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_setter_functions(fields: &amp;StructFields) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let idents: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();
    let types: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();

    let mut final_tokenstream = proc_macro2::TokenStream::new();

    // 第七关修改，这里之前用了zip串联了两个迭代器，现在需要拿到对应的原始field，所以又加了一层`enumerate()`迭代器
    // 这里写成 for idx in 0..fields.len() {let ident = &amp;fields[idx].ident; let type_ = &amp;fields[idx].ty;...} 这种写法或许更优雅一些
    for (idx,(ident, type_)) in idents.iter().zip(types.iter()).enumerate() {
        let mut tokenstream_piece;
        if let Some(inner_ty) = get_generic_inner_type(type_,&quot;Option&quot;) {
            tokenstream_piece = quote! {
                fn #ident(&amp;mut self, #ident: #inner_ty) -&gt; &amp;mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            };
        
        // 下面这个分支是第七关加入的
        } else if let Some(ref user_specified_ident) = get_user_specified_ident_for_vec(&amp;fields[idx]) {
            let inner_ty = get_generic_inner_type(type_,&quot;Vec&quot;).ok_or(syn::Error::new(fields[idx].span(),&quot;each field must be specified with Vec field&quot;))?;
            tokenstream_piece = quote! {
                fn #user_specified_ident(&amp;mut self, #user_specified_ident: #inner_ty) -&gt; &amp;mut Self {
                    self.#ident.push(#user_specified_ident);
                    self
                }
            };
            // 如果用户指定的setter名字和原始字段的名字不一样，那么产生另一个setter，这个setter是一次性传入一个列表的
            if user_specified_ident != ident.as_ref().unwrap() {
                tokenstream_piece.extend(
                    quote! {
                        fn #ident(&amp;mut self, #ident: #type_) -&gt; &amp;mut Self {
                            self.#ident = #ident.clone();
                            self
                        }
                    }
                );
            }
        } else {
            tokenstream_piece = quote! {
                fn #ident(&amp;mut self, #ident: #type_) -&gt; &amp;mut Self {
                    self.#ident = std::option::Option::Some(#ident);
                    self
                }
            };
        }
        final_tokenstream.extend(tokenstream_piece);
    }

    Ok(final_tokenstream)
}
<span class="boring">}
</span></code></pre></pre>
<p>最后是我们的<code>build()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_build_function(
    fields: &amp;StructFields,
    origin_struct_ident: &amp;syn::Ident,
) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let idents: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();
    let types: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ty).collect();

    let mut checker_code_pieces = Vec::new();
    for idx in 0..idents.len() {
        let ident = idents[idx];
        // 第七关修改，只对不是`Option`类型且没有指定each属性的字段生成校验逻辑
        if get_generic_inner_type(&amp;types[idx],&quot;Option&quot;).is_none() &amp;&amp; get_user_specified_ident_for_vec(&amp;fields[idx]).is_none() {
            checker_code_pieces.push(quote! {
                if self.#ident.is_none() {
                    let err = format!(&quot;{} field missing&quot;, stringify!(#ident));
                    return std::result::Result::Err(err.into())
                }
            });
        }
    }

    let mut fill_result_clauses = Vec::new();
    for idx in 0..idents.len() {
        let ident = idents[idx];
        // 第七关，这里需要判断是否有each属性。第一个分支是本关加入的。注意这里几个分支的先后判断顺序
        // 看我写在这里的代码可能没什么感觉，但如果是自己写的话，这几个分支的判断先后顺序是很重要的，否则可能生成出有问题的代码
        // 这里主要的问题是梳理清楚【是否有each属性】和【是否为Option类型】这两个条件的覆盖范围
        if get_user_specified_ident_for_vec(&amp;fields[idx]).is_some() {
            fill_result_clauses.push(quote! {
<span class="boring">                ident: self.#ident.clone()
</span>            });
        } else if get_generic_inner_type(&amp;types[idx],&quot;Option&quot;).is_none() {
            fill_result_clauses.push(quote! {
<span class="boring">                ident: self.#ident.clone().unwrap()
</span>            });
        } else {
            fill_result_clauses.push(quote! {
<span class="boring">                ident: self.#ident.clone()
</span>            });
        }
    }

    let token_stream = quote! {
        pub fn build(&amp;mut self) -&gt; std::result::Result&lt;#origin_struct_ident, std::boxed::Box&lt;dyn std::error::Error&gt;&gt; {
<span class="boring">            (#checker_code_pieces)*
</span>            let ret = #origin_struct_ident{
<span class="boring">                (#fill_result_clauses),*
</span>            };
            std::result::Result::Ok(ret)
        }
    };
    Ok(token_stream)
}
<span class="boring">}
</span></code></pre></pre>
<p>大功告成</p>
<h3><a class="header" href="#第八关" id="第八关">第八关</a></h3>
<p>第八、九关视频版本：</p>
<iframe src="//player.bilibili.com/player.html?aid=247776475&bvid=BV1vv411L7XQ&cid=331683140&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<p>这一关是一个如何打印友好错误信息的挑战，完成这个挑战时，因为会拿编译器输出的结果做字符串匹配比较，所以我们要保证代码的干净，清除掉所有的未引入引用等Warning</p>
<p>首先把错误产生出来，我们需要修改<code>get_user_specified_ident_for_vec()</code>函数，让他返回一个<code>syn::Result</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_user_specified_ident_for_vec(field: &amp;syn::Field) -&gt; syn::Result&lt;Option&lt;syn::Ident&gt;&gt; {
    for attr in &amp;field.attrs {
        if let Ok(syn::Meta::List(syn::MetaList {
            ref path,
            ref nested,
            ..
        })) = attr.parse_meta()
        {
            if let Some(p) = path.segments.first() {
                if p.ident == &quot;builder&quot; {
                    if let Some(syn::NestedMeta::Meta(syn::Meta::NameValue(kv))) = nested.first() {
                        if kv.path.is_ident(&quot;each&quot;) {
                            if let syn::Lit::Str(ref ident_str) = kv.lit {
                                return Ok(Some(syn::Ident::new(
                                    ident_str.value().as_str(),
                                    attr.span(),
                                )));
                            }
                        } else {
                            // 第八关加入，注意这里new_spanned函数的参数，我们需要在语法树中找到一个合适的节点来获取它的span，如果这个语法树节点找的不对，产生出的错误信息就会不一样
                            if let Ok(syn::Meta::List(ref list)) = attr.parse_meta() {
                                return Err(syn::Error::new_spanned(list, r#&quot;expected `builder(each = &quot;...&quot;)`&quot;#))
                            }
                        }
                    }
                } 
            }
        }
    }
    Ok(None)
}
<span class="boring">}
</span></code></pre></pre>
<p>注意上面的代码，我们需要找到一个合适的语法树节点来产生错误的位置，例如，上面代码我们使用了语法树中的<code>syn::MetaList</code>节点，产生的报错信息是这样的：</p>
<pre><code>error: expected `builder(each = &quot;...&quot;)`
  --&gt; $DIR/08-unrecognized-attribute.rs:22:7
   |
22 |     #[builder(eac = &quot;arg&quot;)]
   |       ^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>而如果将上面<code>new_spanned</code>函数的第一个传入参数从<code>list</code>改为<code>attr</code>，即我们使用了<code>syn::Attribute</code>这个语法树节点的时候，给出的错误信息就会是这样的，注意其中<code>^</code>符号数量和位置的变化：</p>
<pre><code>error: expected `builder(each = &quot;...&quot;)`
  --&gt; $DIR/08-unrecognized-attribute.rs:22:5
   |
22 |     #[builder(eac = &quot;arg&quot;)]
   |     ^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>可以返回Result以后，对这个函数的调用部分也需要改一下，对于普通的调用，我们直接在后面加一个<code>?</code>就好了，但是有两个函数是在迭代器map的闭包里调用了，这样改起来就有些麻烦了，这也再一次印证了上面的观点：对于复杂的过程宏，少用迭代器的map方法，自己构建循环展开可控性更好！</p>
<p>首先是<code>generate_builder_struct_fields_def()</code>函数，可以参考注释：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_builder_struct_fields_def(
    fields: &amp;StructFields,
) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let idents: Vec&lt;_&gt; = fields.iter().map(|f| &amp;f.ident).collect();
    // 第八关修改，从这里又可以看出，对于复杂的过程宏，采用迭代器比较麻烦，返回一个错误要费一些周折
    // 这里修改了map中闭包的返回值，使其返回一个syn::Result&lt;T&gt;
    let types: syn::Result&lt;Vec&lt;proc_macro2::TokenStream&gt;&gt; = fields
        .iter()
        .map(|f| {
            if let Some(inner_ty) = get_generic_inner_type(&amp;f.ty,&quot;Option&quot;) {
                Ok(quote!(std::option::Option&lt;#inner_ty&gt;))
            } else if get_user_specified_ident_for_vec(f)?.is_some() {
                let origin_ty = &amp;f.ty;
                Ok(quote!(#origin_ty)) 

            } else {
                let origin_ty = &amp;f.ty;
               Ok(quote!(std::option::Option&lt;#origin_ty&gt;))
            }
        })
        .collect();
    
    let types = types?;
    let token_stream = quote! {
<span class="boring">        (#idents: #types),*
</span>    };
    Ok(token_stream)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后是<code>generate_builder_struct_factory_init_clauses()</code>函数:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_builder_struct_factory_init_clauses(fields: &amp;StructFields) -&gt; syn::Result&lt;Vec&lt;proc_macro2::TokenStream&gt;&gt;{
    // 第八关修改，从闭包中返回错误信息
    let init_clauses: syn::Result&lt;Vec&lt;proc_macro2::TokenStream&gt;&gt; = fields.iter().map(|f| {
        let ident = &amp;f.ident;
        if get_user_specified_ident_for_vec(f)?.is_some() {
            Ok(quote!{
<span class="boring">                ident: std::vec::Vec::new()  
</span>            })
        } else {
            Ok(quote!{
<span class="boring">                ident: std::option::Option::None
</span>            })
        }
    }).collect();

    Ok(init_clauses?)
}
<span class="boring">}
</span></code></pre></pre>
<p>终于，大功告成！</p>
<h3><a class="header" href="#第九关" id="第九关">第九关</a></h3>
<p>哈哈哈，由于我们之前已经严格遵守了规定，第九关自然就通过了。不过，关于第九关的知识点，我还是要给大家再明确一下：</p>
<ul>
<li>我们说的要使用绝对路径，是在生成的代码中要使用绝对路径</li>
<li>过程宏本身的代码，也就是我们用来生成代码的代码，里面还是可以直接使用短名字的</li>
<li>过程宏代码，和过程宏生成的代码，编译和运行在两个完全独立的时间以及空间上，请大家一定要想清楚~</li>
</ul>
<hr />
<p>作者简介：</p>
<p>米明恒，高级Golang、Python开发工程师，初级架构师，业余无线电爱好者（呼号BG2CCF），Rust业余爱好者。业余时间各种不务正业，研究奇怪的东西。</p>
<ul>
<li>个人博客： http://blog.ideawand.com</li>
<li>微信公众号： 【极客幼稚园】</li>
</ul>
<h1><a class="header" href="#在-android-中运行-rust" id="在-android-中运行-rust">在 Android 中运行 Rust</a></h1>
<p>译者：iamazy</p>
<hr />
<blockquote>
<p><a href="https://blog.svgames.pl/article/running-rust-on-android">原文</a> / </p>
</blockquote>
<p>为了我目前的一位客户，我们决定将 Rust 作为我们主要的编程语言。做出这个决定的原因有很多：除了技术优势外，还有一个无可争议的事实就是：Rust 仍然是一门相对较新的语言，花哨且时髦 - 当你是一家初创公司时，使用十几年前的技术可能会让你陷入困境。我的意思是 - 不使用创新的技术如何进行创新？最快的成功方式就是对其大肆宣传。</p>
<p>”用户持有自己的数据“应该是产品的一个卖点，它不能是一个完全通过浏览器访问的服务，而应该是一种可以分发给用户，并让其运行在用户设备上的某个东西。我们在内部已经运行了一些 headless (一种无界面的软件运行模式) 实例，只要再完成一些琐碎的工作，就可以为 Windows 和 Linux 系统制作可重新分发的程序包。但是我们知道如果程序包只能运行在桌面操作系统中时，将会严重阻碍应用的普及 - 如果我们想让它脱颖而出，则需要该应用程序的移动版本。这意味着我们必须要知道如何让我们的程序运行在 Android 或者 iOS 系统中。因为我对交叉编译与自动化构建已经有了一些经验，因此我主动的研究了这个主题。</p>
<h2><a class="header" href="#获取工具" id="获取工具">获取工具</a></h2>
<p>先从基础开始，我需要获取 Rust 交叉编译器。幸运的是，Rust 让此操作变得十分简单，因为只需要调用以下命令：</p>
<pre><code class="language-console">$ rustup target add armv7-linux-androideabi  # For 32-bit ARM.
$ rustup target add aarch64-linux-android    # For 64-bit ARM.

# x86_64 is mainly useful for running your app in the emulator.
# Speaking of hardware, there are some commercial x86-based tablets,
# and there's also hobbyists running Android-x86 on their laptops.
$ rustup target add x86_64-linux-android
</code></pre>
<p><em>（注意：以后只会显示 aarch64 架构的所有示例）</em></p>
<p>我还需要 Android 的构建工具。在经过一番调研之后，我来到 <a href="https://developer.android.com/studio#command-tools">Android Studio 的下载页面</a> 并抓取了归档的命令行工具。尽管 SDK 包有 80+ MiB 大小，却依然只有所需工具的最小子集，所以我听从了互联网的建议并使用<code>sdkmanager</code>来安装额外的部件。</p>
<pre><code class="language-console">$ cd ~/android/sdk/cmdline-tools/bin/
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'build-tools;29.0.2'
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'cmdline-tools;latest'
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'platform-tools'
$ ./sdkmanager --sdk_root=&quot;${HOME}/android/sdk&quot; --install 'platforms;android-29'
</code></pre>
<p>尽管 Android 支持运行 native 代码，但是大多数应用还是采用 Java 或者 Kotlin 来编写，SDK 反应了这一点。为了能够使用 native 代码，我还需要一个工具 - 原生开发工具套件 (Native Development kit)。<a href="https://developer.android.com/ndk/downloads">NDK 下载页面</a> 提供了几个版本以供选择 - 在经过一段深思熟虑后，我决定使用 LTS 版本：r21e。</p>
<h2><a class="header" href="#足够简单或想太多" id="足够简单或想太多">足够简单！或想太多？</a></h2>
<p>搞定了开发工具之后，我决定试着直接编译项目。</p>
<pre><code class="language-console">$ cargo build --target=aarch64-linux-android
</code></pre>
<p>和预期的一样，构建失败了，并且错误信息占满了整个屏幕。经过筛选后，显示存在一个链接错误：</p>
<pre><code class="language-console">error: linking with `cc` failed: exit code: 1
/usr/bin/ld: startup.48656c6c6f20546865726521.o: Relocations in generic ELF (EM: 183)
/usr/bin/ld: startup.48656c6c6f20546865726521.o: error adding symbols: file in wrong format
collect2: error: ld returned 1 exit status
</code></pre>
<p>我认为这(错误提示)足够简单 - Cargo 试图使用系统的链接器而不是 Android NDK 的链接器。我可以使用<code>CC</code>和<code>LD</code>环境变量让 Cargo 指向正确的链接器。</p>
<pre><code class="language-console">$ export ANDROID_NDK_ROOT=&quot;${HOME}/android/ndk&quot;
$ export TOOLCHAIN=&quot;${ANDROID_NDK_ROOT}/toolchains/llvm/prebuilt/linux-x86_64&quot;
$ export CC=&quot;${TOOLCHAIN}/bin/aarch64-linux-android29-clang&quot;
$ export LD=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ld&quot;
$ cargo build --target=aarch64-linux-android
</code></pre>
<p>让我失望的是，这并没有起作用。我不愿意花费一天的时间来和 Cargo 纠缠，因此我决定寻找是否有其他人给出了解决方案 - 很快，我便找到看似十分完美的工具。</p>
<h2><a class="header" href="#cargo-apk" id="cargo-apk">cargo-apk</a></h2>
<p><a href="https://crates.io/crates/cargo-apk">cargo-apk</a> 是一个可以简单的将 Cargo 项目构建成<code>.apk</code>的工具。你所需要做得就是安装这个工具，在<code>Cargo.toml</code>文件中添加一些配置，然后你就可以继续了。</p>
<pre><code class="language-toml"># cargo-apk compiles your code to an .so file,
# which is then loaded by the Android runtime
[lib]
path = &quot;src/main.rs&quot;
crate-type = [&quot;cdylib&quot;]
 
# Android-specic configuration follows.
[package.metadata.android]
# Name of your APK as shown in the app drawer and in the app switcher
apk_label = &quot;Hip Startup&quot;
 
# The target Android API level.
target_sdk_version = 29
min_sdk_version = 26
 
# See: https://developer.android.com/guide/topics/manifest/activity-element#screen
orientation = &quot;portrait&quot;
</code></pre>
<p>有了上面添加的配置，我试图使用<code>cargo-apk</code>来构建项目。</p>
<pre><code class="language-console">$ cargo install cargo-apk
$ export ANDROID_SDK_ROOT=&quot;${HOME}/android/sdk&quot;
$ export ANDROID_NDK_ROOT=&quot;${HOME}/android/ndk&quot;
$ cargo apk build --target aarch64-linux-android
</code></pre>
<p>令人惊奇的是，它成功了！(等等) 额，好吧，我再一次遇到了链接错误。但是这一次，它不是关于重定位和文件格式的神秘错误，而是一个缺少链接库的错误提示：</p>
<pre><code class="language-console">error: linking with `aarch64-linux-android29-clang` failed: exit code: 1
    aarch64-linux-android/bin/ld: cannot find -lsqlite3
    clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<h2><a class="header" href="#依赖依赖依赖" id="依赖依赖依赖">依赖，依赖，依赖</a></h2>
<p>我们的项目使用 <a href="https://sqlite.org/">SQLite</a>，这是一个 C 库。尽管 Rust 社区在每个可能的场合都吹捧”用 Rust 重写“在某种程度上是臭名昭著的，但是实际上某些与流行库一起使用的 crate 并不需要重新实现，因为这需要大量的工作。相反，它们仅提供在 Rust 代码中调用库的方式，既可以作为 C 函数重新导出，也可以提供更加友好的 API 并稍微抽象化 FFI 调用。我们使用的 <a href="https://crates.io/crates/rusqlite">rusqlite</a> 并没有什么不同，意味着我们也需要构建 SQLite。</p>
<p>SQLite 使用 GNU Autotool 进行构建。在对环境变量和用于配置的选项有了一些了解之后，我仔细浏览了 NDK 的文档 - 我找到了一个在各种构建系统(<a href="https://developer.android.com/ndk/guides/other_build_systems#autoconf">包括 Autotools</a>) 中使用 NDK 的文档页面。尽管 Google 提供了 LTS 版本的 NDK，以及最新版本的文档，但在 r21 LTS 和最新的 r22 之间发生了变化，事情变得稍微有点棘手。幸运的是，Wayback 机器具有该页面的<a href="http://web.archive.org/web/20200531051836/https://developer.android.com/ndk/guides/other_build_systems#autoconf">历史版本</a>，让我能够找到合适的 NDK r21 的说明。</p>
<pre><code class="language-console">$ ANDROID_API=29
$ TOOLCHAIN=&quot;${ANDROID_NDK_ROOT}/toolchains/llvm/prebuilt/linux-x86_64&quot;i
$ export CC=&quot;${TOOLCHAIN}/bin/aarch64-linux-android${ANDROID_API}-clang&quot;
$ export CXX=&quot;${TOOLCHAIN}/bin/aarch64-linux-android${ANDROID_API}-clang++&quot;
$ export AR=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ar&quot;
$ export AS=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-as&quot;
$ export LD=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ld&quot;
$ export RANLIB=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-ranlib&quot;
$ export STRIP=&quot;${TOOLCHAIN}/bin/aarch64-linux-android-strip&quot;
$ ./configure --host=aarch64-linux-android --with-pic
$ make -j $(nproc)
</code></pre>
<h2><a class="header" href="#pick-me-up-scotty" id="pick-me-up-scotty">Pick me up, Scotty</a></h2>
<p>使用上述方法，成功构建了 SQLite，生成了<code>libsqlite3.so</code>。现在只需要知道如何让 Cargo 使用它即可。在浏览 Cargo Book 时，我遇到了讲述<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html">环境变量</a>的一个章节，它提及了<code>RUSTFLAGS</code>。和 Make 或 CMake 对待<code>CFLAGS</code>和<code>CXXFLAGS</code>一样，<code>RUSTFLAGS</code>的内容被 Cargo 传递给<code>rustc</code>编译器，允许它影响编译器的行为。</p>
<p>尽管这种方式十分简单，但是对我来说不是很优雅，因此我进一步深入研究了其他选项。继续浏览 Cargo Book，我遇到了描述项目配置的章节，可以肯定的是，<a href="https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags">有一种方法可以指定 RUSTFLAGS</a>。然而，无论我如何尝试，我始终都会收到来自 Cargo 的提示，告诉我关于未使用的 manifest 键的信息。</p>
<pre><code class="language-console">warning: unused manifest key: target.aarch64-linux-android.rustflags
</code></pre>
<p>浏览 Cargo Book 的更多章节，我遇到了关于<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">构建脚本</a>的章节。它们毫无疑问是一个强大的工具，但是我已经花费了很多时间学习 Cargo 的配置，不想再花更多的时间阅读关于如何编写构建脚本的内容，因此，最终我选择了环境变量的解决方案，<del>并且可能会在之后尝试使用构建脚本的方式</del>(不可能)。</p>
<p>我在终端中输入命令，并焦急的观察它的执行过程。</p>
<pre><code class="language-console">$ RUSTFLAGS=&quot;-L $(pwd)/sqlite-autoconf-3340000/.libs/&quot; cargo apk build --target aarch64-linux-android
</code></pre>
<p>再一次，它。。。在某种程度上成功了。虽然链接器不再将错误解释成缺失链接库，但是<code>cargo-apk</code>无法找到该链接器并将其添加到最终的 APK 文件中。</p>
<pre><code class="language-console"> 'lib/arm64-v8a/libstartup.so'...
Shared library &quot;libsqlite3.so&quot; not found.
Verifying alignment of target/debug/apk/statup.apk (4)...
      49 AndroidManifest.xml (OK - compressed)
     997 lib/arm64-v8a/libstartup.so (OK - compressed)
Verification succesful
</code></pre>
<p>当我还没有编译<code>libsqlite3.so</code>时，我返回上一步仔细阅读了链接器产生的错误信息。链接器组合了很多的目标文件，这些目标文件都位于<code>target/aarch64-linux-android/debug/deps</code>目录下。如果我将<code>.so</code>文件放在这里会发生什么？</p>
<pre><code class="language-console">$ cp sqlite-autoconf-3340000/.libs/sqlite3.so target/aarch64-linux-android/debug/deps
$ cargo apk build --target aarch64-linux-android
</code></pre>
<p>让我惊讶的是，它成功了！</p>
<pre><code class="language-console"> 'lib/arm64-v8a/libstartup.so'...
 'lib/arm64-v8a/libsqlite3.so'...
Verifying alignment of target/debug/apk/startup.apk (4)...
      49 AndroidManifest.xml (OK - compressed)
     997 lib/arm64-v8a/libstatup.so (OK - compressed)
15881608 lib/arm64-v8a/libsqlite3.so (OK - compressed)
Verification succesful
</code></pre>
<p>我现在有了一个可以安装在 Android 手机上的<code>.apk</code>文件。真是个巨大的成功！</p>
<h2><a class="header" href="#应用-和-activity" id="应用-和-activity">应用 和 Activity</a></h2>
<p>将 Rust 代码编译进<code>.apk</code>中后，我们剩下要做的就是要搞清楚如何将 Rust 代码与编写 UI 的 Java 代码合并。我天真的在 DuckDuckGo 中输入“如何组合 APK”。在阅读顶层几个结果后，明白了这明显是不可能的，至少在对 Android 应用的工作原理没有更深的了解的情况下是不可能的。但是，并不是说没有其他的方法，因为文章提出了另一种方法 - 将 <a href="https://developer.android.com/reference/android/app/Activity">Activity</a> 组合到一个应用程序里。</p>
<p>如果你像我一样，之前从未开发过 Android，可能会疑惑“什么是 Activity”：当你设计一个应用时，它就是所谓的“界面”或者“视图”。例如，在购物应用中：</p>
<ul>
<li>登陆页面是一个 Activity</li>
<li>产品搜索页面是一个 Activity</li>
<li>所选产品的详情页面是一个 Activity</li>
<li>购物车页面是一个 Activity</li>
<li>结账页面是一个 Activity</li>
</ul>
<p>这里的每个页面可能都包含一些交互元素，如无处不在的汉堡包菜单。如果你愿意，从理论上来讲，你可以将整个应用程序放在一个单独的 Activity 中，但是开发难度比较大。当然，关于 Activity 还有很多内容可以介绍，但是目前和我们要讲的内容关系不大。</p>
<p>让我们继续介绍有关 Rust 的内容。虽然我的问题的解决方案是将 Activity 组合到一个应用程序中，但是我不确定用 Rust 构建的<code>.apk</code>文件是如何与所有这些联系在一起的。在仔细研究了 <a href="https://github.com/rust-windowing/android-ndk-rs/blob/b430a5e274dea8fd7c45e176d5d19c31b73a20ac/ndk-glue/src/lib.rs#L132">cargo-apk</a> 代码之后，我意识到它本质是将我的代码封装进一些胶水代码中，并为 Android 的运行创建 <a href="https://developer.android.com/reference/android/app/NativeActivity">NativeActivity</a>。</p>
<p>为了将 Activity 组合进一个应用中，我需要修改应用程序的<code>AndroidManifest.xml</code>文件，在文档中添加合适的 <a href="https://developer.android.com/guide/topics/manifest/activity-element">Activity 节点</a>。但是我应该如何知道<code>cargo-apk</code>生成的 NativeActivity 的属性呢？幸运的是，当<code>cargo-apk</code>工作时，它会生成一个最小版的<code>AndroidManifest.xml</code>文件，并将其放在生成的<code>.apk</code>旁边。其中 NativeActivity 的声明如下所示：</p>
<pre><code class="language-xml">&lt;activity
    android:name=&quot;android.app.NativeActivity&quot;
    android:label=&quot;startup&quot;
    android:screenOrientation=&quot;portrait&quot;
    android:launchMode=&quot;standard&quot;
    android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;&gt;
    &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;startup&quot; /&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>我要做的就是将上面的代码片段复制并粘贴到 Java 应用程序的 manifest 中。</p>
<p>当然，这只是在应用的 manifest 中添加了一条语句，告诉应用将要包含哪些 Activity。Java 应用程序的构建过程不会知道<code>libstartup.so</code>文件的位置，并自动的将其包含在内。幸运的是，我只需要将<a href="https://developer.android.com/studio/projects/gradle-external-native-builds#jniLibs">库文件复制到指定的文件夹下</a>即可，Gradle (Android 应用的构建工具) 会自动将它们采集起来。</p>
<pre><code class="language-console">$ mkdir -p android/app/src/main/jniLibs/arm64-v8a
$ cp sqlite-autoconf-3340000/.libs/libsqlite3.so android/app/src/main/jniLibs/arm64-v8a/
$ cp target/aarch64-linux-android/debug/libstatup.so android/app/src/main/jniLibs/arm64-v8a/
$ cd android/ &amp;&amp; ./gradlew &amp;&amp; ./gradlew build
</code></pre>
<p>这些都完成后，我启动了构建，它成功了！我将<code>.apk</code>安装在我闲置的 Android 设备中，但是...好像有哪里不太对劲呢！</p>
<p><img src="chapter_5/./image/android/two-launcher-activities.png" alt="two-launcher-activities" /></p>
<p>我的应用一旦安装成功后，会在应用的启动界面产生两个快捷方式。其中一个启动 Java 的 UI 界面，而另一个启动包含 Rust 代码的 NativeActivity。在阅读了更多关于 Activity 和 AndroidManifest 的内容后，我了解到，造成此问题的部分是 NativeActivity 的 <a href="https://developer.android.com/guide/topics/manifest/intent-filter-element"><intent-filter>
</a> - 即 <a href="https://developer.android.com/reference/android/content/Intent#CATEGORY_LAUNCHER">category</a> 节点声明应在启动器中显示它。一旦我将它移除，一切就会恢复正常，NativeActivity 不再显示在启动器中。</p>
<p>但是，仍然存在一个问题：我如何让 Java 的 Activity 要求 Rust 的 Activity 为其工作？</p>
<h2><a class="header" href="#恶意的-intent" id="恶意的-intent">恶意的 Intent</a></h2>
<p>Android 中的 Activity 可以毫无问题的相互启动 - 如果这不可能，则无法真正在两者之间传递用户信息。调用另一个 Activity 的标准方法是通过 <a href="https://developer.android.com/reference/android/app/Activity#starting-activities-and-getting-results">startActivity()</a> 方法，该方法接收一个参数：<a href="https://developer.android.com/reference/android/content/Intent.html">Intent</a> 类实例。</p>
<p>尽管 Intent 类的名称是不言而喻的，但是起初它的用法可能有点不直观。在它最基本的形式中，它仅包含对调用 Activity 实例的引用，以及我们要调用的 Activity 的类句柄。(确切的说，一个 Intent 需要调用一个 <a href="https://developer.android.com/reference/android/content/Context.html">Context</a>。Activity 只是 Context 的一种类型)。</p>
<p>但是，Intent 也可以用于传达为什么一个 Activity 会调用另一个 Activity 的信息(例如 <a href="https://developer.android.com/reference/android/content/Intent#standard-activity-actions">action</a>)，可以用来区分例如“显示某些内容”和“编辑某些内容”；或要操作的数据 URI 及其 MIME 类型。除了 get/set 方法，Intent 还可以容纳几乎任何数量的“额外”数据，这些数据通常作为键值对存储。</p>
<p>Intent 提供了一种在 Activity 之间传递信息的标准化方式。调用者向被调用者提供处理其请求所需的一切信息，并且它可以接收包含所有请求信息的另一个 Intent 作为返回值。使用 Java 编写代码时，没有什么问题，但是，将 Rust 代码放入 NativeActivity 会发生什么？</p>
<p>如果你查看继承树，你可以看到 NativeActivity 继承了 Activity - 这意味着它可以访问 Activity 所有非私有方法。我可以调用<code>getIntent()</code>并从调用者中获取数据。除此之外，由于这是 Java 方法，并且我是在 native 代码中运行，因此需要使用 JNI (Java Native Interface) 执行函数调用。不幸的是，NativeActivity 没有任何其他的机制来传递信息或使用 Intent。这让我十分沮丧，因为这意味着我必须要与 JNI 一起工作。</p>
<h2><a class="header" href="#jni-之旅" id="jni-之旅">JNI 之旅</a></h2>
<p>在这一点上，我花了太多时间却没有取得明显的成果，这让我感到十分沮丧。另一方面，我意识到使用 JNI 带来了一些新的可能 - 不必使用 Activity 和 Intent，我可以将代码粘贴在函数中，并通过调用参数和返回值进行通信。有了这个新思路，我开始了对 JNI 的研究。</p>
<p>因为在 Java 中，万物皆对象，并且代码不能存在于类之外的部分 - native 代码也必须是类的一部分。因为我不需要持久化，因此使用静态方法即可。</p>
<pre><code class="language-java">package com.startup.hip;
 
public class RustCode {
    public static native void doStuff();
}
</code></pre>
<p>上面是一个 Java 类的最小示例，其中带有一个标记为<code>native</code>的静态方法。有了这个，我需要实现相应的功能。但是我应该如何正确的使用函数签名呢？</p>
<p>幸运的是，Java 具有为 JNI 生成 C 语言头文件的功能。在 Java SE9 之前，它是一个独立的工具 - <a href="https://docs.oracle.com/javase/9/tools/javah.htm">javah</a>；后来，它作为<code>-h</code>选项合并到了主要的<code>javac</code>编译器可执行文件中。该选项需要一个目录参数，用来放置生成的<code>.h</code>文件。用法十分简单。</p>
<pre><code class="language-console">$ javac -h ./ RustCode.java
</code></pre>
<p>调用上面的命令将创建一个<code>com_startup_hip_RustCode.h</code>文件，其中包含函数定义。</p>
<pre><code class="language-cpp">#include &lt;jni.h&gt;
JNIEXPORT void JNICALL Java_com_startup_hip_RustCode_doStuff(JNIEnv *, jclass);
</code></pre>
<p>有了这些知识，我就可以继续在 Rust 中创建适当的函数了。</p>
<h2><a class="header" href="#c-闪回" id="c-闪回">C++ 闪回</a></h2>
<p>当处理外部代码时，Rust 和 C 很像，主要是使用 <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">extern 块</a>。此外，与 C++ 一样，Rust 可以使用 <a href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a> - 这不足为奇，因为这门语言对范型和宏提供了强大的支持。幸运的是，Rust 提供了一种简单的方式来禁用 name mangling - 使用 [#[no mangle]](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#calling-rust-functions-from-other-languages) 注解。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jni::{objects::JClass, JNIEnv};
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff(
    _env: JNIEnv,
    _class: JClass,
) {}
<span class="boring">}
</span></code></pre></pre>
<p>创建了函数声明之后，接下来我需要编写对应的实现。</p>
<h2><a class="header" href="#接收参数" id="接收参数">接收参数</a></h2>
<p>通常，native 函数需要接收一些参数。在本例中，它是一个包含代码的字符串，该代码随后将被传递给服务端。</p>
<pre><code class="language-java">package com.startup.hip;
 
public class RustCode {
    public static native void doStuff(String code);
}
</code></pre>
<p>修改 Java 代码之后，我重新生成了 C 语言的头文件并据此编辑了 Rust 代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jni::{objects::JClass, JNIEnv};
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff(
    _env: JNIEnv,
    _class: JClass,
    code: JString,
) {}
<span class="boring">}
</span></code></pre></pre>
<p>这很简单。现在我需要从 Java 字符串中提取文本并将其传递给 Rust 代码。这比我预期要复杂的多。问题在于，JVM 内部使用 <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/types.html#modified-utf-8-strings">UTF-8 的修改版本</a>存储字符串，而 Rust 字符串必须是有效的 <a href="https://doc.rust-lang.org/std/string/struct.String.html#utf-8">UTF-8</a>。尽管 Rust 具有用于<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">处理任意字符串</a>的类型，但是我们的代码仅使用“经典”的字符串类型，对其进行全部修改需要大量工作。</p>
<p>幸运的是，<code>jni</code>库带有内置的机制，可以通过特殊的 <a href="https://docs.rs/jni/0.19.0/jni/strings/struct.JNIStr.html">JNIStr</a> 类型在标准 UTF-8 和 JVM 修改后的 UTF-8 之间进行转换。在仔细阅读了文档之后，我想到了以下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert from JString – a thinly wrapped JObject – to a JavaStr
let code_jvm = env.get_string(code).unwrap();
// Create a String from JavaStr, causing text conversion
let code_rust = String::from(code_jvm);
<span class="boring">}
</span></code></pre></pre>
<p>现在我有了一个 Rust 字符串，可以将其传递给之后的 Rust 代码。又是个巨大的成功！</p>
<h2><a class="header" href="#返回值" id="返回值">返回值</a></h2>
<p>接收参数只是故事的一半，我还需要一个返回值，巧的是，它也是一个字符串 - 一个代表服务端返回值的字符串。</p>
<pre><code class="language-java">package com.startup.hip;
 
public class RustCode {
    public static native String doStuff(String code);
}
</code></pre>
<p>我再一次修改了 Java 代码，重新生成了 C 语言的头文件，并据此编辑 Rust 代码。</p>
<pre><code class="language-java">use jni::{objects::JClass, JNIEnv};
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff&lt;'a&gt;(
    env: JNIEnv&lt;'a&gt;,
    _class: JClass,
    code: JString,
) -&gt; JString&lt;'a&gt;
{
    // function body here
}
</code></pre>
<p>如你所见，JNI 中的返回值仍然作为返回值处理。剩下要做的事就是创建保存结果的 JString。与<code>get_string()</code>类似，<code>JNIEnv</code>结构还包含一个<code>new_string()</code>函数，该函数的功能与名称指代的完全相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copy-pasted from earlier snippet 
let code_rust = String::from(env.get_string(code_jni).unwrap());
 
let result = match some_rust_function(code_rust) {
    Ok(value) =&gt; format!(&quot;OK {}&quot;, value),
    Err(e) =&gt; format!(&quot;ER {:?}&quot;, e),
};
return env.new_string(result).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>就像这样，我的 JNI 封装器就完成了。现在，我可以在 Java 代码中调用 Rust 函数，将值传递给调用并接收返回值。</p>
<h2><a class="header" href="#rust-的错误处理" id="rust-的错误处理">Rust 的错误处理</a></h2>
<p>尽管代码如预期一样执行，但是我不喜欢出现的<code>.unwrap()</code>调用次数。毕竟，错误处理是 Rust 的重要组成部分，仅仅因为我正在进行语言的互操作，并不意味着就可以忽略此事。恰恰相反，我认为两种语言的接触面应该尽可能简单，以防止最终发现一些晦涩的错误是由于互操作性差而引起的。而且，必须检查 Java 的返回值以确定调用是否成功，这使得整个过程使用起来有些笨拙。</p>
<p>我没有重复造轮子，而是对如何更好的将 Rust 的<a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result&lt;A, B&gt;</a>方式转换成 Java 侧的代码进行了思考。幸运的是，我的 Rust 函数的返回值都是字符串。至于错误，大多数错误要么是不可恢复的，要么是由错误的输入引起的 - 这意味着我可以放弃使用精确的错误代码，而仅仅依靠正确格式的错误信息 - 这又是指字符串。因此<code>Result&lt;A, B&gt;</code>可以变成<code>Result&lt;String, String&gt;</code>。</p>
<h2><a class="header" href="#定义-java-类" id="定义-java-类">定义 Java 类</a></h2>
<p>尽管 Java 支持范型(虽然有点<a href="https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">欺骗</a>的感觉)，但是我不想从 JNI 中深入了解使用范型的细节。我决定创建一个 Java 类，大致表示<code>Result&lt;String, String&gt;</code>语义。</p>
<pre><code class="language-java">public class Result {
    private boolean ok;
    private String value;
 
    public Result(boolean is_ok, String value) {
        this.ok = is_ok;
        this.value = value;
    }
 
    public boolean isOk() {
        return this.ok;
    }
 
    public boolean isError() {
        return !this.ok;
    }
 
    public String getValue() {
        return this.ok ? this.value : null;
    }
 
    public String getError() {
        return this.ok ? null : this.value;
    }
}
</code></pre>
<p>尽管完成了这项工作，但与 Rust 相比，它有一些缺点 - 最严重的就是当访问错误的结果变量时返回<code>null</code>。由于 null 对于 Java 字符串来说是一个没有问题的值，因此调用<code>getValue()</code>可能没有注意并将其传递给其他地方导致在无关紧要的代码中弹出 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html">NullPointerException</a>。尽管可以通过抛出异常来轻松地改善这个问题，我仍决定使用最好的方式来处理这个问题，以便此处以后永远也不需要修改这部分的代码。</p>
<h2><a class="header" href="#从-jni-中返回一个对象" id="从-jni-中返回一个对象">从 JNI 中返回一个对象</a></h2>
<p>剩下的唯一一件事就是从 Rust 函数中返回 Result 类的实例。经过一番搜索后，我找到了名为 <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/functions.html#newobject-newobjecta-newobjectv">NewObject()</a> 的 JNI 函数。该函数有四个参数：</p>
<ul>
<li>JNI 环境的句柄</li>
<li>我们想要创建的类的句柄</li>
<li>构造函数签名</li>
<li>构造函数的参数</li>
</ul>
<p>Rust 函数将 JNI 环境句柄作为其参数之一，因此已经进行了处理。构造函数参数可以作为数组传递，我需要找到另外两个函数参数。</p>
<p>为了获取该函数的句柄，JNI 提供了 <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/functions.html#findclass">FindClass()</a> 函数。它有两个参数：环境句柄和类的完全限定名 - 简单的说就是类的“导入名”，但是<code>.</code>用<code>/</code>代替。例如<code>java.lang.String</code>变成<code>java/lang/String</code>。在本例中是指，<code>com.startup.hip.Result</code>变成<code>com/startup/hip/Result</code>。</p>
<p>构造函数签名是一个字符串，它很好的描述了构造函数签名需要多少个参数以及哪些类型。乍一看，这让人有些困惑 - 但后来我想起 Java 支持函数重载，并且包括构造函数。由于一个类可能有多个构造函数，所以我必须让 JNI 知道我想使用哪个构造函数。在互联网上搜索了之后，我发现最简单的学习函数签名的方法就是编译 Java 类。然后使用 Java 的反汇编工具：<a href="https://docs.oracle.com/en/java/javase/11/tools/javap.html">javap</a>。</p>
<pre><code class="language-console">$ javac android/app/src/main/java/com/startup/hip/Result.java
$ javap -s android/app/src/main/java/com/startup/hip/Result.class
Compiled from &quot;Result.java&quot;
public class com.startup.hip.Result {
  public com.startup.hip.Result(boolean, java.lang.String);
    descriptor: (ZLjava/lang/String;)V

  public boolean isOk();
    descriptor: ()Z

  public boolean isError();
    descriptor: ()Z

  public java.lang.String getValue();
    descriptor: ()Ljava/lang/String;

  public java.lang.String getError();
    descriptor: ()Ljava/lang/String;
}
</code></pre>
<p>执行了上述的命令，现在我知道了我想要使用的函数签名是<code>(ZLjava/lang/String;)V</code>。</p>
<p>在所有步骤都准备就绪之后，是时候创建持有构造函数参数的数组，并调用<code>NewObject()</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_java_result&lt;'e&gt;(
    env: &amp;JNIEnv&lt;'e&gt;,
    is_ok: bool,
    value: &amp;str,
) -&gt; JObject&lt;'e&gt;
{
    let class = env
        .find_class(&quot;com/startup/hip/Result&quot;)
        .unwrap();
    let args: [JValue&lt;'e&gt;; 2] = [
        JValue::Bool(u8::from(is_ok)),
        JValue::Object(JObject::from(env.new_string(value).unwrap())),
    ];
    env.new_object(class, &quot;(ZLjava/lang/String;)V&quot;, &amp;args)
        .unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，我可以从 native 函数中返回自定义的<code>Result</code> Java 类了。</p>
<h2><a class="header" href="#使用更通用的解决方案" id="使用更通用的解决方案">使用更通用的解决方案</a></h2>
<p>尽管上面的代码可以很好的实现这个目的，但是它有一个缺点：它显示地采用了布尔值和字符串，要求调用者自己处理 Result 并使用适当的参数调用函数。编写“错误应该尽早返回”的逻辑很繁琐，但是幸运的是，Rust 为此提供了一个解决方案 - <a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html">?</a> 运算符。但是我们的代码从不同的库中调用函数，这些函数又使用了不同的错误类型 - 这意味着我们无法使用<code>Result&lt;OurType, OurError&gt;</code>，并且必须执行类似 <code>Result&lt;OurType, std::error::Error&gt;</code>的操作 - 这是不可能的，因为 Rust 不允许将特征用作函数的返回类型。</p>
<p>解决此问题的标准方法是使用 <a href="https://doc.rust-lang.org/rust-by-example/trait/dyn.html">Box<dyn Trait>
</a>，但为了使事情变得更加简单，我决定使用 <a href="https://crates.io/crates/anyhow">anyhow</a> 库，该库允许按我的喜好混合和匹配错误。不管怎样，我可以这样编写代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rust_result_to_java_result&lt;'e, T&gt;(
    env: &amp;JNIEnv&lt;'e&gt;,
    result: anyhow::Result&lt;T&gt;,
) -&gt; JObject&lt;'e&gt;
where
    T: Display,
{
    let (is_ok, value) = match result {
        Ok(v) =&gt; (true, format!(&quot;{}&quot;, v)),
        Err(e) =&gt; (false, format!(&quot;{:?}&quot;, e)),
    };
    create_java_result(env, is_ok, value)
}
 
fn actually_do_stuff&lt;'a&gt;(
    env: JNIEnv&lt;'a&gt;,
    code: JString,
) -&gt; anyhow::Result&lt;String&gt;
{
    let code = String::from(env.get_string(code)?);
    let intermediate_value = some_rust_function(code)?;
    other_rust_function(intermediate_value)
}
 
#[no_mangle]
pub extern &quot;C&quot; fn Java_com_startup_hip_RustCode_doStuff&lt;'a&gt;(
    env: JNIEnv&lt;'a&gt;,
    _class: JClass,
    code: JString,
) -&gt; JObject&lt;'a&gt;
{
    rust_result_to_java_result(actually_do_stuff(env, code))
}
<span class="boring">}
</span></code></pre></pre>
<p>更简单了！现在我可以返回任何想要的结果，并将其转换为 Java 类的实例，以供 Java 代码使用。</p>
<h2><a class="header" href="#封装" id="封装">封装</a></h2>
<p>在 Android 中运行 Rust 并不是一件容易的事，但是我对最终找到的解决方案感到满意。我们使用及其普通的 Rust 编写代码并将其编译到共享库中，然后由 JVM 在运行时加载。尽管 JNI 乍一看有点令人生畏，但是使用此标准化解决方案意味着 Java 代码和 Gradle 构建系统都不关心我们的 native 代码是用 Rust 编写的。使用 Cargo 进行交叉编译仍然有些棘手，因为事实证明<code>cargo-apk</code>设置了许多<a href="https://github.com/rust-windowing/android-ndk-rs/blob/7936944edc699d3e7f380cfa87515f8899ce7027/ndk-build/src/cargo.rs#L6">环境变量</a>以使整个过程正常运行。我们的代码还依赖于外部库 - 但是所有的这些都可以通过一堆 shell 脚本来解决。</p>
<p>如果你想要自己尝试一下，我已经准备了一个公共 <a href="https://github.com/suve/rust-on-android/">Github</a> 仓库，其中包含了一个最小的 Android 应用程序，既包含用 Rust 编写的部分，还依赖于外部的 C 库。该项目的许可证是 <a href="https://tldrlegal.com/license/zlib-libpng-license-%28zlib%29">zlib</a>。因此可以随意的获取源代码并将其用于你的个人目的。</p>
<h2><a class="header" href="#参考-4" id="参考-4">参考</a></h2>
<ul>
<li><a href="https://developer.android.com/ndk/guides/other_build_systems#autoconf">Android NDK documentation: other build systems: Autoconf</a></li>
<li><a href="https://crates.io/crates/cargo-apk">crates.io: cargo-apk</a></li>
<li><a href="https://github.com/rust-windowing/android-ndk-rs/blob/b430a5e274dea8fd7c45e176d5d19c31b73a20ac/ndk-glue/src/lib.rs#L132">cargo-apk: ndk-glue/src/lib.rs</a></li>
<li><a href="https://github.com/rust-windowing/android-ndk-rs/blob/7936944edc699d3e7f380cfa87515f8899ce7027/ndk-build/src/cargo.rs#L6">cargo-apk: nkd-build/src/cargo.rs</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/activity-element">Android developer documentation: app manifest: <activity>
</a></li>
<li><a href="https://developer.android.com/reference/android/app/Activity">Android developer documentation: Activity</a></li>
<li><a href="https://developer.android.com/reference/android/app/NativeActivity">Android developer documentation: NativeActivity</a></li>
<li><a href="https://developer.android.com/reference/android/content/Intent.html">Android developer documentation: Intent</a></li>
<li><a href="https://crates.io/crates/jni">crates.io: jni</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html">Java SE 11: JNI specification</a></li>
<li><a href="https://docs.oracle.com/javase/9/tools/javah.htm">Java SE 9: tools: javah</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#calling-rust-functions-from-other-languages">The Rust Programming Language: Calling Rust Functions from Other Languages</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/11/tools/javap.html">Java SE 11: tools: javap</a></li>
<li><a href="https://www.thorntech.com/2012/08/using-jni-with-java-for-android-sawbix-case-study-part-ii/">Thorn Technologies: Using JNI to call C functions from Android Java</a></li>
<li><a href="https://coderanch.com/t/446953/java/create-NewObject-JNI-methods">Code Ranch: How to create new objects with JNI</a></li>
<li><a href="https://stackoverflow.com/questions/22038466/jni-signature-for-method">Stack Overflow: Java signature for method</a></li>
</ul>
<h1><a class="header" href="#rust-与-区块链--ink-编程实战一-初识-ink" id="rust-与-区块链--ink-编程实战一-初识-ink">Rust 与 区块链 | <code>ink!</code> 编程实战（一）: 初识 <code>ink!</code></a></h1>
<p>作者： 朱春雷</p>
<hr />
<p>笔者注：本篇我们不会深入探讨 ink! 语法的细节，主要介绍编程环境的搭建，并引导读者逐步完成智能合约的创建、编译、测试和部署，具体的 ink! 语法将会在下一篇中详细讲解。此外，本系列文章将默认读者已经掌握 Rust 的基础语法，故不涉及对 Rust 语法的解释。如果读者对 Rust 基础语法还不熟练的话，可参阅相关资料或购买本文下方推荐的 Rust 入门书籍《Rust 编程入门、实战与进阶》学习。
​</p>
<h2><a class="header" href="#11-ink-简介" id="11-ink-简介">1.1 ink! 简介</a></h2>
<p>Parity 官方对 ink! 的定义是：“ink! is an eDSL to write smart contracts in Rust for blockchains built on the Substrate framework. ink! contracts are compiled to WebAssembly.” 也就是说，ink! 是使用 Rust 开发的嵌入式领域特定语言（eDSL），为基于 Substrate 框架构建的区块链编写 WASM（WebAssembly）智能合约。</p>
<p>WASM 是一种新的字节码格式，是一种全新的底层二进制语法，它所编译的代码指令具有体积小、可移植、加载快等特点。相对于基于 EVM 的 Solidity 智能合约，WASM 智能合约占用资源少，运行合约更快速且稳定，网络传输信息更加高效。WASM 支持 Rust、C/C++、C#、Go、Typescript 等语言编写智能合约所编译的字节码，目前 Substrate、ETH 2.0 以及多条联盟链均表示将支持 WASM 智能合约。
​</p>
<h2><a class="header" href="#12-搭建编程环境" id="12-搭建编程环境">1.2 搭建编程环境</a></h2>
<p>“工欲善其事，必先利其器”。在开始 ink! 编程之前，需要先安装和配置相关的编程环境。</p>
<h3><a class="header" href="#121-rust-环境安装及配置" id="121-rust-环境安装及配置">1.2.1 Rust 环境安装及配置</a></h3>
<h4><a class="header" href="#1-安装-rust" id="1-安装-rust">1. 安装 Rust</a></h4>
<p>Rust 由工具 rustup 安装和管理。rustup 既是 Rust 安装器，也是版本管理工具。</p>
<p>在终端运行以下命令，遵循指示即可完成最新稳定版 Rust 的下载与安装。</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>如果安装成功，将会出现以下内容。</p>
<pre><code>Rust is installed now. Great!
</code></pre>
<h4><a class="header" href="#2-设置-path-环境变量" id="2-设置-path-环境变量">2. 设置 PATH 环境变量</a></h4>
<p>在 Rust 开发环境中，rustc、cargo 和 rustup 等所有 Rust 工具都安装在 ~/.cargo/bin 中，我们可以将其加入 PATH 环境变量中。
​</p>
<p>在 ~/.bash_profile 文件中增加以下内容：</p>
<pre><code>export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<p>保存文件，回到终端命令行窗口，使用 source 命令使配置立即生效。</p>
<pre><code>source ~/.bash_profile
</code></pre>
<p>运行以下命令，检查是否已正确设置 PATH 环境变量。</p>
<pre><code>rustc --version
</code></pre>
<p>如果能显示 Rust 最新稳定版的版本号、提交哈希和日期等信息，代表环境变量设置成功。如果未看到这些信息，请检查 ~/.bash_profile 文件中 PATH 环境变量设置的路径是否正确。
​</p>
<h3><a class="header" href="#122-ink-环境安装及配置" id="122-ink-环境安装及配置">1.2.2 ink! 环境安装及配置</a></h3>
<p>在配置了基本的 Rust 环境后，我们来配置 ink! 所需的开发环境。
​</p>
<h4><a class="header" href="#1-安装-wasm-工具链" id="1-安装-wasm-工具链">1. 安装 WASM 工具链</a></h4>
<p>由于 ink! 需要 Rust 的 WASM 工具链，且当前 WASM 只能在 nightly 工具链下运行，我们需要先准备 WASM 编译环境。</p>
<pre><code>rustup install nightly
rustup component add rust-src --toolchain nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
<h4><a class="header" href="#2-安装-cargo-contract" id="2-安装-cargo-contract">2. 安装 cargo-contract</a></h4>
<p>我们可以安装 Parity 官方提供的编译智能合约的工具 cargo-contract。</p>
<pre><code>cargo install cargo-contract --force --feature=“binaryen-as-dependency”
</code></pre>
<p>也可以使用由 Patract 提供的 cargo-contract，它与 Europa 配合使用可以打印详细的出错信息。</p>
<pre><code>cargo install cargo-contract --git https://github.com/patractlabs/cargo-contract --branch=v0.10.0 --force
</code></pre>
<h4><a class="header" href="#3-安装区块链节点" id="3-安装区块链节点">3. 安装区块链节点</a></h4>
<p>智能合约必须运行在区块链上，推荐安装由 Patract 开发的用于智能合约测试的沙盒 Europa（https://github.com/patractlabs/europa）。Europa 提供智能合约在部署与调用过程中的详细日志，能够最大程度地呈现合约模块这个“黑盒”的运行情况，对开发者有很大的帮助。
​</p>
<p>可以执行如下命令在本地安装 Europa。</p>
<pre><code>cargo install europa --git https://github.com/patractlabs/europa --locked --force
</code></pre>
<h3><a class="header" href="#123-node-环境安装及配置" id="123-node-环境安装及配置">1.2.3 Node 环境安装及配置</a></h3>
<p>下文用到的 Redspot 需要使用 Node，因此请确定系统已安装的 Node 版本 &gt;= 12.0。如果不是，可以访问官方网站（https://nodejs.org/zh-cn）进行安装或升级。
​</p>
<h2><a class="header" href="#13-使用-ink-cli-开发-ink-项目" id="13-使用-ink-cli-开发-ink-项目">1.3 使用 ink! CLI 开发 ink! 项目</a></h2>
<h3><a class="header" href="#131-创建-flipper-合约" id="131-创建-flipper-合约">1.3.1 创建 flipper 合约</a></h3>
<p>使用 cargo contract new 命令在当前目录下创建智能合约项目 flipper。</p>
<pre><code>cargo contract new flipper
</code></pre>
<p>​</p>
<p>flipper 的目录结构如下所示。</p>
<pre><code>flipper
|
+-- .gitignore
|
+-- Cargo.toml
|
+-- lib.rs
</code></pre>
<p>​</p>
<p>flipper 合约的核心代码在 lib.rs 文件，如代码清单 1-1 所示。flipper 是仅包含一个布尔对象的简单合约，它通过 flip 方法转换布尔值（从 true 转换为 false，或从 false 转换为 true），并通过 get 方法返回当前布尔对象的状态。
​</p>
<p>代码清单 1-1 flipper 合约代码​</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod flipper {

    /// Defines the storage of your contract.
    /// Add new fields to the below struct in order
    /// to add new static storage fields to your contract.
    #[ink(storage)]
    pub struct Flipper {
        /// Stores a single `bool` value on the storage.
        value: bool,
    }

    impl Flipper {
        /// Constructor that initializes the `bool` value to the given `init_value`.
        #[ink(constructor)]
        pub fn new(init_value: bool) -&gt; Self {
            Self { value: init_value }
        }

        /// Constructor that initializes the `bool` value to `false`.
        ///
        /// Constructors can delegate to other constructors.
        #[ink(constructor)]
        pub fn default() -&gt; Self {
            Self::new(Default::default())
        }

        /// A message that can be called on instantiated contracts.
        /// This one flips the value of the stored `bool` from `true`
        /// to `false` and vice versa.
        #[ink(message)]
        pub fn flip(&amp;mut self) {
            self.value = !self.value;
        }

        /// Simply returns the current value of our `bool`.
        #[ink(message)]
        pub fn get(&amp;self) -&gt; bool {
            self.value
        }
    }

    /// Unit tests in Rust are normally defined within such a `#[cfg(test)]`
    /// module and test functions are marked with a `#[test]` attribute.
    /// The below code is technically just normal Rust code.
    #[cfg(test)]
    mod tests {
        /// Imports all the definitions from the outer scope so we can use them here.
        use super::*;

        /// Imports `ink_lang` so we can use `#[ink::test]`.
        use ink_lang as ink;

        /// We test if the default constructor does its job.
        #[ink::test]
        fn default_works() {
            let flipper = Flipper::default();
            assert_eq!(flipper.get(), false);
        }

        /// We test a simple use case of our contract.
        #[ink::test]
        fn it_works() {
            let mut flipper = Flipper::new(false);
            assert_eq!(flipper.get(), false);
            flipper.flip();
            assert_eq!(flipper.get(), true);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>​</p>
<h3><a class="header" href="#132-编译-flipper-合约" id="132-编译-flipper-合约">1.3.2 编译 flipper 合约</a></h3>
<p>运行以下命令，可以编译合约。</p>
<pre><code>cargo +nightly contract build
</code></pre>
<p>代码编译成功会在当前目录下生成 target/ink 文件夹，里面有 3 个重要文件：flipper.contract、flipper.wasm、metadata.json。flipper.wasm 是代码编译后的字节码文件，metadata.json 是元数据文件，其中包含合约提供的可被调用的方法信息。flipper.contract 是将 flipper.wasm 和 metadata.json 合并到一个文件中，在区块链上部署合约时使用。
​</p>
<h3><a class="header" href="#133-测试-flipper-合约" id="133-测试-flipper-合约">1.3.3 测试 flipper 合约</a></h3>
<p>运行以下命令，可以对合约做单元测试。</p>
<pre><code>cargo +nightly test
</code></pre>
<p>​</p>
<p>看到如下结果，代表已成功完成测试。</p>
<pre><code>running 2 tests
test flipper::tests::it_works ... ok
test flipper::tests::default_works ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>​</p>
<h2><a class="header" href="#14-使用-patract-工具套件开发-ink-项目" id="14-使用-patract-工具套件开发-ink-项目">1.4 使用 Patract 工具套件开发 ink! 项目</a></h2>
<p>Patract Labs 为波卡 WASM 智能合约开发提供全面的解决方案，为开发者提供覆盖开发、测试、调试、部署、监控和前端开发等阶段的全栈工具和服务支持。</p>
<p>我们这里主要用到 Patract 工具套件中的 Redspot 和 Europa。Redspot 是智能合约开发、测试和调试的脚手架工具，Europa 提供智能合约运行环境的模拟节点并在运行过程中记录合约执行的信息日志。
​</p>
<h3><a class="header" href="#141-创建-flipper-合约" id="141-创建-flipper-合约">1.4.1 创建 flipper 合约</a></h3>
<p>Redspot 提供了合约开发模版，可以让用户快速搭建起一个项目。执行以下命令将会拉取最新版的 Redspot，并以 erc20 为模板构建项目。</p>
<pre><code>npx redspot-new flipper
</code></pre>
<p>flipper 的目录结构如下所示。</p>
<pre><code>flipper
|
+-- contracts
|  |
|  +-- Cargo.toml
|  |
|  +-- lib.rs
|
+-- scripts
|  |
|  +-- deploy.ts
|
+-- tests
|  |
|  +-- erc20.test.ts
|
+-- .gitignore
|
+-- package.json
|
+-- redspot.config.ts
|
+-- tsconfig.json
</code></pre>
<p>​</p>
<p>修改 contracts/lib.rs 文件，用代码清单 1-1 中的代码替换原代码。
​</p>
<h3><a class="header" href="#142-编译-flipper-合约" id="142-编译-flipper-合约">1.4.2 编译 flipper 合约</a></h3>
<p>运行 npx redspot compile 命令进行合约编译。对于 compile 命令，我们可以传入合约的路径来指定需要编译的合约，如下所示的命令将仅对 contracts/flipper 目录下的合约进行编译。</p>
<pre><code>npx redspot compile contracts/flipper
</code></pre>
<p>编译完成后，可以在 artifacts 目录中找到 Flipper.contract 和 Flipper.json 两个文件。Flipper.json 是元数据文件，Flipper.contract 是在区块链上部署合约时使用。
​</p>
<h3><a class="header" href="#143-测试-flipper-合约" id="143-测试-flipper-合约">1.4.3 测试 flipper 合约</a></h3>
<p>可以使用 Redspot 对合约进行单元测试。首先，删除 tests 目录下默认的 erc20.test.ts 文件，再创建 flipper.test.ts 文件，其内容如代码清单 1-2 所示。
​</p>
<p>代码清单 1-2 flipper 单元测试脚本</p>
<pre><code class="language-typescript">import BN from 'bn.js';
import { expect } from 'chai';
import { patract, network, artifacts } from 'redspot';

const { getContractFactory, getRandomSigner } = patract;

const { api, getSigners } = network;

describe('Flipper', () =&gt; {
  after(() =&gt; {
    return api.disconnect();
  });

  async function setup() {
    const one = new BN(10).pow(new BN(api.registry.chainDecimals[0]));
    const signers = await getSigners();
    const Alice = signers[0];
    const sender = await getRandomSigner(Alice, one.muln(10000));
    const contractFactory = await getContractFactory('Flipper', sender);
    const contract = await contractFactory.deploy('new', false);
    const abi = artifacts.readArtifact('Flipper');
    const receiver = await getRandomSigner();

    return { sender, contractFactory, contract, abi, receiver, Alice, one };
  }

  it('Initial value', async () =&gt; {
    const { contract } = await setup();
    const result = await contract.query.get();
    expect(result.output).to.equal(false);
  });

  it('Flip value', async () =&gt; {
    const { contract } = await setup();
    await contract.tx.flip();

    const result = await contract.query.get();
    expect(result.output).to.equal(true);
  });
});
</code></pre>
<p>​</p>
<p>其次，在运行测试命令前需要确保正确配置了区块链节点信息，这里使用 redspot.config.ts 文件中的默认配置。
​</p>
<p>最后，通过 europa 命令启动本地开发节点。</p>
<pre><code>europa --tmp
</code></pre>
<p>运行 npx redspot test 命令进行单元测试。对于 test 命令，我们可以传入单元测试脚本的路径来指定需要测试的合约，如下所示的命令将仅对 flipper 合约进行单元测试，同时设置 --no-compile 可以避免自动运行编译命令。</p>
<pre><code>npx redspot test tests/flipper.test.ts --no-compile
</code></pre>
<p>​</p>
<p>看到如下结果，代表已成功完成测试，Redspot 的插件会自动计算并打印出执行合约操作的 Gas 费用。
<img src="chapter_5/./image/ink/1.png" alt="image.png" />
​</p>
<h3><a class="header" href="#144-部署-flipper-合约" id="144-部署-flipper-合约">1.4.4 部署 flipper 合约</a></h3>
<p>在 Substrate 中，部署合约的过程分为两个步骤：</p>
<ul>
<li>上传代码到区块链上 </li>
<li>创建合约实例</li>
</ul>
<p>​</p>
<p>通过这种模式，诸如标准的 ERC20 合约代码只需上传一次，就可以实例化任意次，避免了因上传相同功能的源代码而浪费区块链上的存储空间。
​</p>
<p>下面首先也是使用 europa 命令启动本地开发节点。</p>
<pre><code>europa --tmp
</code></pre>
<p>​</p>
<p>打开网址 https://polkadot.js.org/apps，配置连接本地启动的开发节点。
<img src="chapter_5/./image/ink/2.png" alt="image.png" />
​</p>
<p>点击菜单栏上“开发者”中的子菜单“合约”，打开合约页面后，点击“Upload &amp; deploy code”按钮。
<img src="chapter_5/./image/ink/3.png" alt="image.png" />
​</p>
<p>“upload &amp; deploy code 1/2”窗口对应部署合约的第一个步骤——上传代码到区块链上。选择有帐户余额的部署帐户，再上传 Flipper.contract 文件，确认智能合约的信息后，点击“Next”按钮。
<img src="chapter_5/./image/ink/4.png" alt="image.png" /></p>
<p><img src="chapter_5/./image/ink/5.png" alt="image.png" /></p>
<p>“upload &amp; deploy code 2/2”窗口对应部署合约的第二个步骤——创建合约实例。设置捐赠的数量用以支付合约的存储租金与 Gas 费，再点击“部署”按钮。
<img src="chapter_5/./image/ink/6.png" alt="image.png" />
​</p>
<p>在“批准交易”窗口，点击“签名并提交”按钮，即可完成合约部署。
<img src="chapter_5/./image/ink/7.png" alt="image.png" /></p>
<p><img src="chapter_5/./image/ink/8.png" alt="image.png" /></p>
<p>​</p>
<h3><a class="header" href="#145-调用-flipper-合约" id="145-调用-flipper-合约">1.4.5 调用 flipper 合约</a></h3>
<p>flipper 合约已成功部署，可以与它进行交互了！
​</p>
<p>我们可以看到布尔对象的当前值是 false，这是因为创建合约实例时将初始值设置为 false。</p>
<p><img src="chapter_5/./image/ink/9.png" alt="image.png" /></p>
<p>点击“flip()”左边的“exec”按钮，调用合约的 flip 方法，签名提交后布尔对象的当前值变成了 true，这个合约交互结果符合预期。</p>
<p><img src="chapter_5/./image/ink/10.png" alt="image.png" /></p>
<p><img src="chapter_5/./image/ink/11.png" alt="image.png" /></p>
<p><img src="chapter_5/./image/ink/12.png" alt="image.png" /></p>
<p>我们可以看到，Patract 工具套件为开发 ink! 项目带来了极大的便利，本系列后续文章的示例都将使用 Patract 工具套件来构建。
​</p>
<h2><a class="header" href="#15-参考资料" id="15-参考资料">1.5 参考资料</a></h2>
<ol>
<li>
<p>ink! Smart Contracts Tutorial
https://substrate.dev/substrate-contracts-workshop</p>
</li>
<li>
<p>ink! 官方文档
https://paritytech.github.io/ink-docs
​</p>
</li>
<li>
<p>Patract 官方文档
https://docs.patract.io</p>
</li>
</ol>
<hr />
<p>推荐 Rust 入门学习书籍《Rust 编程入门、实战与进阶》，该书详细讲解 Rust 核心语法，注重编码能力训练，将数据结构、算法与 Rust 编程结合，精选 39 道 LeetCode 高频算法面试真题。需要购买书籍的朋友，可以扫描下方二维码。</p>
<p><img src="chapter_5/./image/ink/13.png" alt="image.png" /></p>
<hr />
<p><strong>扫码关注公众号</strong></p>
<p><img src="chapter_5/./image/ink/14.png" alt="image.png" /></p>
<h1><a class="header" href="#常见问题汇总-2" id="常见问题汇总-2">常见问题汇总</a></h1>
<blockquote>
<p>说明：</p>
<p>常见问题汇总来自于：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/tagged/rust?tab=Votes">StackOverflow - Rust</a></li>
<li><a href="https://www.zhihu.com/topic/19674381/hot">知乎 - Rust</a></li>
<li><a href="https://rust-zh.github.io/faq/">https://rust-zh.github.io/faq/</a></li>
</ul>
</blockquote>
<hr />
<h2><a class="header" href="#为什么go仅仅160m的安装包就可以编译程序而rust却还需要几个g的msvc才能编译" id="为什么go仅仅160m的安装包就可以编译程序而rust却还需要几个g的msvc才能编译">为什么go仅仅160M的安装包就可以编译程序？而rust却还需要几个G的msvc才能编译？</a></h2>
<blockquote>
<p>来源：<a href="https://www.zhihu.com/question/458838401">知乎</a></p>
</blockquote>
<blockquote>
<p>在windows下，我下载了一个go1.16.zip版，仅仅150M，解压后，都不需要安装，就可以用命令行编译程序，非常小巧。但是，为什么rust，在安装了自身安装包后，却还得要vstudio build，安装得好几个G！为什么都同样是编译程序，差距如此之大？我的疑问是差距在哪里，在编译方面？难道rust不能设计成象go这样，不依赖msvc？</p>
</blockquote>
<h3><a class="header" href="#回答" id="回答">回答：</a></h3>
<p><strong>什么是 MSVC ？</strong></p>
<p>the Microsoft Visual C++ compiler and libraries toolset 。微软 Visual C++ 编译器和库工具集。</p>
<p><strong>为什么要有 MSVC ？</strong></p>
<p>MSVC的目标是成为Windows上针对Windows的最佳编译器选择，无论您选择使用哪种编辑器或IDE。 我们旨在通过在以下关键领域上进行持续投资来实现我们的目标：完全符合C ++，更好的错误和警告，运行时性能，可靠性，构建吞吐量和最佳安全性。</p>
<p><strong>Rust 为什么要支持 MSVC 以及如何支持 ？</strong></p>
<p><a href="https://link.zhihu.com/?target=https%3A//rust-lang.github.io/rustup/installation/windows.html">Windows - The rustup book</a></p>
<p>因为 Rust 要支持 Windows 开发，而 Windows 上面有两类 ABI ：</p>
<ul>
<li>Visual Studio使用的本机（MSVC）ABI</li>
<li>GCC工具链使用的GNU ABI。</li>
</ul>
<p>你需要哪种版本的Rust很大程度上取决于您要与哪些C / C ++库进行互操作：</p>
<ul>
<li>要与Visual Studio生产的软件互操作，请使用Rust的MSVC版本；</li>
<li>要与使用MinGW / MSYS2工具链构建的GNU软件互操作，请使用GNU构建。</li>
</ul>
<p>以MSVC ABI为目标时，Rust还需要安装Visual Studio 2013（或更高版本）或Visual C ++ Build Tools 2019，以便rustc可以使用其链接器。 对于Visual Studio，请确保选中“ C ++工具”和“ Windows 10 SDK”选项。 基本使用GNU构建不需要额外的软件安装。</p>
<p>如果你计划仅使用 Rust 库和可以与 MinGW 一起构建和使用的各种开源库，则可以完全避免使用Microsoft 的工具。 只需将 Rust 切换到x86_64-pc-windows-gnu目标即可。</p>
<p>但是，如果你打算使用本地Windows库进行Windows开发，则需要Microsoft的链接器，并且应该使用 Rust 的 x86_64-pc-windows-msvc 目标与之兼容。 由于Windows上的大多数人都对Windows开发感兴趣，因此这是默认设置。</p>
<p><strong>而 Rust却还需要几个G的 msvc 才能编译？</strong></p>
<p>因为找不到人实现必要的功能，不得不依赖Windows sdk 。</p>
<p><strong>go 为什么不需要 MSVC ？</strong></p>
<p>因为go根本没做 msvc 的支持（不是默认支持，需要你自己手工再做处理），你用 cgo 只支持用 GCC。 （不晓得现在支持 msvc 没有）。</p>
<p><strong>为什么 Rust 不能像 go 那样，不依赖 msvc ？</strong></p>
<p>所以，你觉得呢？</p>
<p>这正是 Rust 和 Go 设计目标的差别了。</p>
<p>Rust 语言是一个通用的系统级语言，Go 语言则不是这个目标。所以 Go 可以不依赖 MSVC ，Rust 则不可以。</p>
<p>未来，Rust 将越来越倾向于使用 LLVM LLD 链接器，而不是平台本机链接器（Microsoft或GNU binutils）。 LLD 是通用的，旨在支持所有平台和ABI。 因此，未来预计将不需要任何其他工具。</p>
<hr />
<h2><a class="header" href="#为什么rust中的string不能用整数下标进行切片" id="为什么rust中的string不能用整数下标进行切片">为什么Rust中的String不能用整数下标进行切片？</a></h2>
<blockquote>
<p>来源：<a href="https://www.zhihu.com/question/458788810">知乎</a></p>
</blockquote>
<pre><code>```rust
fn main() {
    let name: String = &quot;ABCD&quot;.to_string();
    println!(&quot;{}&quot;, &amp;name[2..3]);
}
// 为什么不能直接用 name[2] 或者 &amp;name[2] ？
```
</code></pre>
<blockquote>
<p>另外，为什么切片还要加&amp;？</p>
</blockquote>
<h3><a class="header" href="#回答-1" id="回答-1">回答：</a></h3>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html#utf-8">std::string::String - Rust</a></p>
<p>文档里说的很清楚了。</p>
<p>Rust 里 String 总是按 UTF-8 编码的。而索引旨在进行恒定时间操作，但是UTF-8编码不允许我们执行此操作。 另外，索引应返回哪种类型呢？字节，码点 还是 字素簇(grapheme cluster)。</p>
<p>实际上String 文档里帮你定义基于 字节和字符 处理的两类基本方法。</p>
<p>切片为啥加 &amp; ，因为 Rust 里 切片 是一个 DST，必须放 &amp; 后面。</p>
<hr />
<h2><a class="header" href="#错误处理推荐使用什么库" id="错误处理推荐使用什么库">错误处理推荐使用什么库？</a></h2>
<p>目前一般认为对于应用程序推荐使用 <a href="https://crates.io/crates/anyhow">anyhow</a>，而对于库推荐使用 <a href="https://crates.io/crates/thiserror">thiserror</a>。</p>
<p>anyhow 提供了一个基于[特质对象]的错误类型，可以很容易地将不同来源的错误统一到单一来源，并可以方便地为错误添加上下文，以及就地创建新的错误。</p>
<p>thiserror 则提供了一个 derive 宏，方便为自定义的错误类型实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> 特质</a>。</p>
<h2><a class="header" href="#fn-类型与-fn-等特质的关系和区别是什么" id="fn-类型与-fn-等特质的关系和区别是什么"># <code>fn()</code> 类型与 <code>Fn()</code> 等特质的关系和区别是什么？</a></h2>
<p>在 Rust 中，每一个函数，无论是由 <code>fn</code> 关键字定义的一般函数，还是由闭包表达式定义的闭包，都有一个各自独立的匿名类型。为了能间接地使用函数，Rust 准备了两种方式，即 <a href="https://doc.rust-lang.org/std/primitive.fn.html"><code>fn()</code></a> 类型与 <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn()</code></a>、<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut()</code></a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce()</code></a> 等[特质]。</p>
<p>要表达不同的类型，最常见的方法即是使用特质（作为类型约束，即 <code>T: Fn()</code> 和 <code>impl Fn()</code>，或者使用[特质对象]，即 <code>dyn Fn()</code>），<code>Fn()</code> 一族就是用于表达函数类型的特质。</p>
<p><code>fn()</code> 不是一个特质，而是一个具体的类型，表示一个函数指针。功能上它与特质对象类似，可以近似地看作 <code>&amp;'static dyn Fn()</code>。但 <code>fn()</code> 与 <code>Fn()</code> 不同，它不包含对上下文的引用，因而只有一般函数或没有捕获任何上下文的闭包能够被转换成 <code>fn()</code>。因此它也与 <code>&amp;dyn Fn()</code> 不同，不需要使用[胖指针]。它的大小与普通的指针一致。</p>
<p>因为 <code>fn()</code> 是一个函数指针，通过它调用函数与通过特质对象一样是间接调用，而使用 <code>Fn()</code> 等特质约束的泛型则是通过[单态化]来直接调用的。</p>
<h2><a class="header" href="#rust-的-future-是基于轮询的这种方式不会有性能问题吗" id="rust-的-future-是基于轮询的这种方式不会有性能问题吗"># Rust 的 <code>Future</code> 是基于轮询的，这种方式不会有性能问题吗？</a></h2>
<p><code>Future</code> 的轮询是带通知机制的轮询，与传统意义上的轮询不完全一样。</p>
<p>当<a href="chapter_5/%22executor%22">执行器</a>调用 <code>Future</code> 的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll"><code>poll</code></a> 方法时会传入一个 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a>，而 <code>Future</code> 可以将这个 <code>Waker</code> 保存起来，当自己的状态有所变化时，通过其通知执行器可以再次对自己进行轮询。通过这个机制，执行器可以避免反复轮询一个未准备好的 <code>Future</code>，避免了传统轮询带来的性能问题。</p>
<h2><a class="header" href="#标准库的-futurefutures-cratetokio-和-async-std-等之间的关系是什么" id="标准库的-futurefutures-cratetokio-和-async-std-等之间的关系是什么">标准库的 <code>Future</code>、futures crate、tokio 和 async-std 等之间的关系是什么？</a></h2>
<p>标准库的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> [特质]以及相关的 <a href="https://doc.rust-lang.org/std/task/struct.Context.html"><code>Context</code></a>、<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a>、<a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a> 等是核心。由于编译器编译[异步函数]需要依赖它们的定义，因而它们必须被包含在标准库里。</p>
<p><a href="https://crates.io/crates/futures">futures</a> 是 <code>Future</code> 的扩展，提供了许多虽不必进入标准库但依然重要的基础性的东西，比如 <a href="https://docs.rs/futures/0.3/futures/future/trait.FutureExt.html"><code>FutureExt</code></a>、<a href="https://docs.rs/futures/0.3/futures/stream/trait.StreamExt.html"><code>StreamExt</code></a> 等扩展特质和基础的<a href="https://docs.rs/futures/0.3/futures/channel/index.html">通道</a>、<a href="https://docs.rs/futures/0.3/futures/executor/index.html">执行器</a>实现等。</p>
<p><a href="https://crates.io/crates/tokio">tokio</a> 和 <a href="https://crates.io/crates/async-std">async-std</a> 是同一个层次的，主要提供异步运行时的实现，都依赖 futures 提供的元语，但因为处理的层次不同，所以可以看到一些自定义的与 futures 差不多的模块。</p>
<p>此外，虽然目前 <a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>Stream</code></a> 是由 futures 提供的，但未来如果编译器要实现<a href="https://rust-lang.github.io/rfcs/2394-async_await.html#generators-and-streams" title="async generator">异步生成器</a>，这个特质也很可能会进入标准库，因而对其的扩展也依然放进了独立的 <code>StreamExt</code> 里。</p>
<h1><a class="header" href="#语言技巧-1" id="语言技巧-1">语言技巧</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#为生命周期参数命名" id="为生命周期参数命名">为生命周期参数命名</a></h2>
<p>假如有这样一段代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String
}

impl Person {
    pub fn name&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str {
        &amp;self.name
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面示例只是简单的单一生命周期参数<code>'a</code>，但我们将其重写命名为<code>'me</code>，可能会更加直观：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String
}

impl Person {
    pub fn name&lt;'me&gt;(&amp;'me self) -&gt; &amp;'me str {
        &amp;self.name
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在下面一些场景中，命名生命周期参数可能更好：</p>
<h3><a class="header" href="#场景一" id="场景一">场景一</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use once_cell::unsync::OnceCell;

struct Provider {
    data_cache: OnceCell&lt;Data&gt;,
    metadata_cache: OnceCell&lt;Metadata&gt;,
}

// ...

fn process_data(data: &amp;Data) -&gt; Result&lt;&amp;str&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>修正为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_data&lt;'prov&gt;(data: &amp;'prov Data) -&gt; Result&lt;&amp;'prov str&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>将生命周期参数命名为 <code>'prov</code> 有助于标识 data 数据来自于 <code>Provider</code>结构体实例。 在 Rust 编译器源码中也能见到<code>'tcx </code>这样的命名，用来标识这是类型上下文（typing context ）。</p>
<h3><a class="header" href="#场景二" id="场景二">场景二</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Article {
    title: String,
    author: Author,
}

#[derive(PartialEq, Eq)]
struct Author {
    name: String,
}

struct ArticleProvider {
    articles: Vec&lt;Article&gt;,
}

struct AuthorProvider {
    authors: Vec&lt;Author&gt;,
}

// 这里具有两种生命周期参数命名
struct AuthorView&lt;'art, 'auth&gt; {
    author: &amp;'auth Author,
    articles: Vec&lt;&amp;'art Article&gt;,
}

// 这里具有两种生命周期参数命名
// 在需要指定两个生命周期参数长短关系的时候可以通过 'auth : 'art 这种方式指定，但是此处不需要
fn authors_with_articles&lt;'art, 'auth&gt;(
    article_provider: &amp;'art ArticleProvider,
    author_provider: &amp;'auth AuthorProvider,
) -&gt; Vec&lt;AuthorView&lt;'art, 'auth&gt;&gt; {
    author_provider
        .authors
        .iter()
        .map(|author| {
            let articles = article_provider
                .articles
                .iter()
                .filter(|article| &amp;article.author == author)
                .collect();

            AuthorView { author, articles }
        })
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#小结-3" id="小结-3">小结</a></h2>
<p>将生命周期参数重新命名，面对使用引用比较复杂的场景，可以增加可读性，方便开发者分析生命周期参数。这算得上一个最佳实践。</p>
<p>来源： <a href="https://www.possiblerust.com/pattern/naming-your-lifetimes">https://www.possiblerust.com/pattern/naming-your-lifetimes</a></p>
<h2><a class="header" href="#优化技巧rust-中-match-分支语句中避免使用-" id="优化技巧rust-中-match-分支语句中避免使用-">优化技巧：Rust 中 match 分支语句中避免使用 <code>?</code></a></h2>
<p>来自微信群：David Li</p>
<p>最近碰到rust的一个坑，在match 的分支里面使用<code>?</code>可能会导致栈内存特别大。</p>
<p>有一个函数，match 一个 Enum，这个Enum 有十几个定义，因此match 有十几个分支，每个分支里面最后都会调一个函数，返回值是Result，因此使用了<code>?</code>。</p>
<p>上周测试报告说 debug 版本跑查询进程会崩掉，分析发现栈溢出了。我们上层代码把线程栈设置为 512 KB，然后调试发现某些函数栈内存竟然用了几百KB。</p>
<p>代码示意：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match SomeEnum {
    One(_) =&gt; get_result()?,
    Two(_) =&gt; get_result()?,
    Three(_) =&gt; get_result()?,
    Four(_) =&gt; get_result()?,
    Five(_) =&gt; get_result()?,
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>最后把match分支的Result去掉<code>?</code>，把 match表达式赋值 给临时变量之后再用<code>?</code>，内存占用降下来了。</p>
<p>代码示意：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let get_res = match SomeEnum {
    One(_) =&gt; get_result(),
    Two(_) =&gt; get_result(),
    Three(_) =&gt; get_result(),
    Four(_) =&gt; get_result(),
    Five(_) =&gt; get_result(),
    //...
};

let res = get_res?
<span class="boring">}
</span></code></pre></pre>
<p>P.S : 还可以获得一个优化技巧是：先把栈内存调低点，让这种问题尽早暴露。</p>
<h1><a class="header" href="#了解一点关于泛型关联类型gat的事" id="了解一点关于泛型关联类型gat的事">了解一点关于泛型关联类型(GAT)的事</a></h1>
<p>作者：CrLF0710 / 后期编辑：张汉东</p>
<hr />
<p>这名字好长！这是啥子哟？</p>
<p>不要紧，我们从头理理。咱们先来温习一下Rust的语法结构。Rust程序是什么构成的？答案是：条目(item)。</p>
<p>每个Rust程序都是一条一条的，每个都是一个条目。比如你在main.rs里写一个结构体定义， 再写一个实现定义为它加两个方法，再写一个main函数。这就是crate对应的模块条目里的三个条目。</p>
<p>说完了条目，咱们再来说关联条目。关联条目不是条目！重点就是在“关联”俩字上，什么是关联呢？ 其实就是“跟某个类型有关”，效果就是可以使用一个专门的关键字叫做Self。 这个关键词就是用来指代刚才说的那个类型的。</p>
<p>关联条目可以定义在两处，一个是特质定义的花括号中，一个是实现定义的花括号中。</p>
<p>关联条目一共有三种：关联常数，关联函数，关联类型(别名)；它们与条目中的三种：常数、函数、类型(别名) 一一对应。</p>
<p>举个栗子吧！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(generic_associated_types)]
#![allow(incomplete_features)]
<span class="boring">fn main() {
</span>const A: usize = 42;
fn b&lt;T&gt;() {}
type C&lt;T&gt; = Vec&lt;T&gt;;

trait X {
    const D: usize;
    fn e&lt;T&gt;();
    type F&lt;T&gt;; // 新加的就是这个！之前在这里不可以写&lt;T&gt;
}

struct S;
impl X for S {
    const D: usize = 42;
    fn e&lt;T&gt;() {}
    type F&lt;T&gt; = Vec&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>这个有啥用咧？</p>
<p>蛮有用的，但是仅仅是在特定的场景之下。Rust社区里对泛型关联类型有两个用例是非常经典的，我们先试着介绍它们一下。</p>
<p>但是在开始介绍之前，我们还要再来温习一下泛型。泛型这个词英文是generic，其实是通用的意思。 泛型类型是什么呢？简单来说，就是缺点什么参数的类型，让使用的人填充。</p>
<p>顺便说一下，前人把它意译取名叫泛型，因为很多系统里能填的参数是类型。其实在Rust里面，不只是类型可以当泛型参数。 泛型参数有三种：类型、生存期、常数。</p>
<p>好，我们来看一个具体的泛型类型的例子：<code>Rc&lt;T&gt;</code>，它是具有一个泛型参数的泛型类型。 泛型类型Rc不是类型哈，只有提供了这个泛型参数的“实参”，才是真正的类型，比如<code>Rc&lt;bool&gt;</code>。</p>
<p>如果我写一个数据结构，里面要共享数据，但是我事先不知道使用者到底需要我在这里用Rc还是Arc，怎么办呢？ 最简单的方法就是代码写两遍，这个听起来有点笨拙，确实也是如此，但是也是确实有效的。 随口一提，<a href="http://crates.io">http://crates.io</a>上有俩库im和im-rc代码主要区别就是里面用的是Arc还是Rc。 实际上泛型关联类型就可以很好的解决这个问题，接下来， 我们就来看泛型关联类型的第一个经典使用场景：类型家族(type family)。</p>
<h2><a class="header" href="#任务1用泛型关联类型支持类型家族" id="任务1用泛型关联类型支持类型家族">任务#1：用泛型关联类型支持类型家族</a></h2>
<p>好，现在我们来做一个“选择器”，让编译器根据这个选择器来知道需要用的到底是<code>Rc&lt;T&gt;</code>还是<code>Arc&lt;T&gt;</code>。代码长这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait PointerFamily {
    type PointerType&lt;T&gt;;
}

struct RcPointer;

impl PointerFamily for RcPointer {
    type PointerType&lt;T&gt; = Rc&lt;T&gt;;
}

struct ArcPointer;

impl PointerFamily for ArcPointer {
    type PointerType&lt;T&gt; = Arc&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>挺简单的吧，这样你就定义了两个“选择器”类型，可以用它来代表要用的是Rc还是Arc。实际用用看：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyDataStructure&lt;T, PointerSel: PointerFamily&gt; {
    data: PointerSel::PointerType&lt;T&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>这样你泛型参数用<code>RcPointer</code>或者<code>ArcPointer</code> 就可以选择实际的数据表示了。 有了这个功能，刚才说的两个包就可以合成一个包了。好耶~</p>
<h2><a class="header" href="#任务2用泛型关联类型实现流式处理迭代器" id="任务2用泛型关联类型实现流式处理迭代器">任务#2：用泛型关联类型实现流式处理迭代器</a></h2>
<p>另一个问题其实是Rust比较特有的，其他语言里，要么不存在这个问题（古尔丹：代价是什么呢？）， 要么，放弃治疗这个问题（咳咳）。</p>
<p>这个问题是这样的，希望在API接口上表示输入值与输入值之间、输入值与输出值之间的依赖关系。 依赖关系并不是一个很容易表达出来的东西。Rust的方案是什么呢？ 在Rust里，这个人见人爱的生存期小标记<code>'_</code>大家都见过啦。它就负责在API上表示这种依赖关系的对应。</p>
<p>我们来实际用用这个生存期标记，标准库里的迭代器特质大家都见过，它长这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    pub fn next(&amp;'_ mut self) -&gt; Option&lt;Self::Item&gt;;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>挺好的，但是有个小问题。Item类型的值是与Iterator本身的类型(Self)完全不能有依赖关系的。为什么呢？ 因为你从Iterator取一个值这个动作，产生的这个临时范围（也就是上面的'_），是next这个关联函数的泛型参数。 定义的Item是单独的另一个关联类型，怎么可能用到呢？</p>
<p>大多数时候这个不是什么问题，但是对于某些库的API来说，这个就不够用了。 比如假如有一个迭代器，依次递给用户一些临时文件用，用户什么时候关闭都可以。这个时候你用Iterator，没有任何问题。 但是要是每次生成一个临时文件，加载一个什么数据，你用完之后它需要关闭临时文件来删除的那种， 这个迭代器肯定就会希望你能够告诉它你用完了。这样它就可以删掉临时文件了， 或者干脆不删除，而是直接复用它的存储空间来存下一个文件，这些都是ok的。</p>
<p>所以这个时候我们可以用泛型关联类型来设计这个API。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StreamingIterator {
    type Item&lt;'a&gt;;

    pub fn next(&amp;'_ mut self) -&gt; Option&lt;Self::Item&lt;'_&gt;&gt;;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>实现时你其实就可以让Item的类型是一个带依赖的类型，比如一个借用， 类型系统能够保证你在下次调用next或者移动析构这个迭代器之前，Item已经不再被用户使用了。好耶~</p>
<p>你讲的太接地气了，能不能来点抽象的？
好嘞，从现在起我们开始不说人话了。先说一下，这里要说的依然是简化过的，比如我们会把各种binder和predicate放一边。</p>
<p>首先我们来建立泛型类型的名字和具体类型之间的关系。当然就是个映射关系了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 伪代码
fn generic_type_mapping(_: GenericTypeCtor, _: Vec&lt;GenericArg&gt;) -&gt; Type;
<span class="boring">}
</span></code></pre></pre>
<p>比如<code>Vec&lt;bool&gt;</code>中，Vec就是这个泛型类型的名字也是它的构造器, <code>&lt;bool&gt;</code> 是这个泛型参数的列表，就一项。经过了这个映射，得到了一个<code>Vec&lt;bool&gt;</code>。</p>
<p>好，然后是特质，啥是特质啊，特质其实也是一个映射。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 伪代码
fn trait_mapping(_: Type, _: Trait) -&gt; Option&lt;Vec&lt;AssociateItem&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这里这个Trait可以起到一个谓词的作用，也就是拿它来对某个类型做判定，结论要么是None，表示“不符合这个特质”， 要么是一个Some(items) ，表示“这个类型符合这个特质”，并映射出一串关联条目。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 伪代码
enum AssociateItem {
    AssociateType(Name, Type),
    GenericAssociateType(Name, GenericTypeCtor), // 这次新加的
    AssociatedFunction(Name, Func),
    GenericFunction(Name, GenericFunc),
    AssociatedConst(Name, Const),
}
<span class="boring">}
</span></code></pre></pre>
<p>这里的<code>AssociateItem::GenericAssociateType</code>是当前rust里唯一一处间接地执行generic_type_mapping的地方。 通过给trait_mapping的第一个参数传不同的Type，就可以用相同的Trait获取到不同的GenericTypeCtor， 然后执行generic_type_mapping，从而在Rust的语法框架下达到了让不同的GenericTypeCtor跟指定的<code>Vec&lt;GenericArg&gt;</code>组合的目的！</p>
<p>顺便提一下，GenericTypeCtor这类东西，就是某些文章里面介绍的HKT。通过以上描述的这套方法，Rust里第一次加入了供用户使用的HKT能力。 虽然只有这一种形式，但是其他使用形式都可以通过这一种形式做出来。总之就是，奇怪的能力增加了！</p>
<p>我和小鸭子学走路
好嘞，作为收尾，我们来试着用 GAT 仿制一些其他语言的一些构造。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(generic_associated_types)]
#![allow(incomplete_features)]

<span class="boring">fn main() {
</span>trait FunctorFamily {
    type Type&lt;T&gt;;

    fn fmap&lt;T, U, F&gt;(value: Self::Type&lt;T&gt;, f: F) -&gt; Self::Type&lt;U&gt;
    where
        F: FnMut(T) -&gt; U;
}

trait ApplicativeFamily: FunctorFamily {
    fn pure&lt;T&gt;(inner: T) -&gt; Self::Type&lt;T&gt;;

    fn apply&lt;T, U, F&gt;(value: Self::Type&lt;T&gt;, f: Self::Type&lt;F&gt;) -&gt; Self::Type&lt;U&gt;
    where
        F: FnMut(T) -&gt; U;
}

trait MonadFamily: ApplicativeFamily {
    fn bind&lt;T, U, F&gt;(value: Self::Type&lt;T&gt;, f: F) -&gt; Self::Type&lt;U&gt;
    where
        F: FnMut(T) -&gt; Self::Type&lt;U&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后我们来给一个“选择器”实现这些类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OptionType;

impl FunctorFamily for OptionType {
    type Type&lt;T&gt; = Option&lt;T&gt;;

    fn fmap&lt;T, U, F&gt;(value: Self::Type&lt;T&gt;, f: F) -&gt; Self::Type&lt;U&gt;
    where
        F: FnMut(T) -&gt; U,
    {
        value.map(f)
    }
}

impl ApplicativeFamily for OptionType {
    fn pure&lt;T&gt;(inner: T) -&gt; Self::Type&lt;T&gt; {
        Some(inner)
    }

    fn apply&lt;T, U, F&gt;(value: Self::Type&lt;T&gt;, f: Self::Type&lt;F&gt;) -&gt; Self::Type&lt;U&gt;
    where
        F: FnMut(T) -&gt; U,
    {
        value.zip(f).map(|(v, mut f)| f(v))
    }
}

impl MonadFamily for OptionType {
    fn bind&lt;T, U, F&gt;(value: Self::Type&lt;T&gt;, f: F) -&gt; Self::Type&lt;U&gt;
    where
        F: FnMut(T) -&gt; Self::Type&lt;U&gt;,
    {
        value.and_then(f)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>好嘞，然后我们就可以通过OptionType这个“选择器”来表达、使用Option作为Functor, Applicative, Monad 的性质了。 怎么样，是不是打开了无数的新的可能性？</p>
<h1><a class="header" href="#rust-runtime-与-abi" id="rust-runtime-与-abi">Rust Runtime 与 ABI</a></h1>
<p>作者：于航 / 后期编辑：张汉东</p>
<blockquote>
<p>本文主要介绍了 Rust 语言的 Runtime 与 ABI 的相关内容。由于这两个概念均较为底层且通用，而不会涉及诸如 <code>std::Vec</code> 等具体标准库应用层类型的实现细节，因此这里放到一起作为本文主要内容。</p>
</blockquote>
<hr />
<p>本文主要介绍了 Rust 语言（版本 <strong>1.52.0</strong>）的 Runtime 与 ABI 等相关内容。由于这两个概念均较为底层且通用，而不会涉及诸如 <code>std::Vec</code> 等具体标准库应用层概念的实现细节，因此这里放到一起作为本文主要内容。</p>
<p>相信无论是做前端、后端，还是移动端，对于 “runtime” 一词，你都肯定有所耳闻。Runtime 翻译过来即“<strong>运行时</strong>”，在 Wikipedia 上我们可以得到对它的一种定义：</p>
<blockquote>
<p>In computer science, runtime, run time, or execution time is the final phase of a computer program's life cycle, in which the code is being executed on the computer's central processing unit (CPU) as machine code. In other words, &quot;runtime&quot; is the running phase of a program.</p>
</blockquote>
<p>在这段定义中，我们可以将 “runtime” 简单理解为「<strong>尤指程序代码被 CPU 执行的那段时间</strong>」，这其实是对 runtime 一词最直观的字面理解，即 runtime 是指程序众多生命周期中的一个最重要的阶段。比如我们常见的一种运行时错误 —— “除零异常”，这里的“运行时”通常所指的便是程序的运行阶段。</p>
<p>每种编程语言都有其自身的“<strong>执行模型</strong>（Execution Model）”，比如以 C 语言为例，C 标准中规定了 C 语句在实际执行时应有的执行顺序（如下引用所示），以及诸如 C 程序在启动和终止时，执行环境所应该进行的处理：比如程序启动时应该调用名为 <code>main</code> 的函数；根据该函数签名的不同，应选择性地传入相应的 <code>argc</code> 与 <code>argv</code> 参数；程序运行结束前需要选择性地调用 <code>exit</code> 系统调用等等。再举一个例子，WebAssembly 在其标准中也有定义当一个“抽象机器”在执行一段 Wasm 代码时，这个机器可以被抽象出来的、应有的组成部分，比如符合 Wasm 计算模型的“栈（stack）”结构、存放包含有所有 Wasm 全局实例（<em>func</em> \ <em>table</em> \ <em>memory</em> \ <em>global</em> \ <em>element</em> \ <em>data</em> 等）的 “Store” 结构等等。但值得注意的是，抽象机器的定义与真实的虚拟机实现并不完全相等，虚拟机的实现只要能够保证 Wasm 代码的执行在抽象层级上的表现与抽象机器完全一致即可。</p>
<blockquote>
<p>A statement specifies an action to be performed. Except as indicated, statements are executed in sequence.</p>
</blockquote>
<p>话说回来，执行模型本身是“脱离”于语言的具体语法与语义的，这意味着源代码本身无法直观地反映出其全部的执行细节。一般来说，编程语言的执行模型可以通过编译器或解释器来实现（对应于两种不同的执行方式）。对于编译器来说，它可以将高层次的上层代码转换为较低层次的中间（IR）或者汇编代码，而在这些代码中，上层代码所隐含的执行模型已经被“解构”到低层次代码的执行语义中了。而对于解释器来说，上层语言所隐含的执行语义则需要通过对程序进行结构化分析，再根据具体 token 类别的不同来分别进行相应的处理。而通常来说，我们会将「所有这些无法从程序源代码上直观体现的、为支持执行模型，使得程序可以正常运行而进行的处理和实现」统称为“<strong>运行时系统</strong>（Runtime System）”。</p>
<p>一门编程语言的运行时系统，提供了以该语言编写的程序可以在其中运行的环境。这个环境涉及到程序能够正确运行的多个重要方面，大到对应用程序内存的管理、提供程序与操作系统的可交互接口；小到正确设置函数调用时的 <em>prologue</em> 与 <em>epilogue</em> 等等。还是以 C 语言为例，当我们运行一个需要动态链接的 C 应用时，个人认为动态链接器的行为也属于运行时系统的范畴。比如当我们在类 Unix 系统上运行这个应用时，操作系统将会以动态链接器作为执行入口，动态链接器首先完成自身的符号重定位，然后对将要运行的 C 应用进行所有依赖共享库的地址空间加载、符号重定位等一系列工作，最后再将执行流程（PC）转交给应用本身。而动态链接器的这一系列工作其目的便是为了能够正确执行我们的目标 C 应用，<strong>只是这部分流程并非局限于 C 语言本身</strong>，属于独立于具体语言的运行时系统组成。</p>
<p>而对于 C 语言本身来说，也有其专有的运行时系统组成，对于这部分内容我们一般称之为 <strong>CRT</strong>（C-Runtime）。在类 Unix 系统中，CRT 一般以几个不同目标文件的形式提供（<em>crt1.o</em> \ <em>crti.o</em> \ <em>crtn.o</em>）。其中，<em>crt1.o</em> 中包含了程序的实际入口函数（_start），在这部分汇编实现中，运行时系统一般会正确设置 <em>argc</em> 与 <em>argv</em> 的参数，并最后调用 C 源代码中定义的 <em>main</em> 函数。而在 <em>main</em> 函数返回后，其还会调用 <em>exit</em> 系统调用以正确退出程序。另外的目标文件 <em>crti.o</em> 与 <em>crtn.o</em> 提供了部分用于辅助全局构造与析构相关功能的实现组成，这里不详细展开。</p>
<p>总而言之，对于“运行时系统”的识别边界并没有十分详细、清楚的区分条件（目前来看）。针对不同的编程语言、技术体系，有些时候可能需要用不同的视角来进行判断。而在下文对 Rust Runtime System 的陈述中，我们将主要介绍与 Rust 语言本身相关的那部分运行时系统组成，而对于独立于语言的部分（比如上文中提供到动态链接器）则不会涉及。</p>
<p>对于 Rust ABI 的部分，我们所讨论的内容不会详细到 ABI 的每一个具体细节。但实际上 Rust ABI 所涉及的内容与 C/C++ 十分类似，比如：内置类型的大小和在内存中的存储方式（字节序）、组合类型的存储方式和内存分布、函数调用方式（<em>calling convention</em>）、寄存器使用约定、虚函数表的内容和布局形式等等。在本文中，我们会概述现阶段 Rust ABI 的整体情况，以给大家一个直观的印象。</p>
<h2><a class="header" href="#rust-runtime-system" id="rust-runtime-system">Rust Runtime System</a></h2>
<p>为了保证阅读上的流畅性，后续我们会直接将 “Runtime System” 简称为 “Runtime”。从 Rust 官方的 FAQ 文档中我们可以得知，Rust 语言几乎没有运行时系统（如下引用所示）。而这使得它可以更方便地与其他带有 GC 的语言进行集成。</p>
<blockquote>
<p>By avoiding GC, Rust can offer numerous benefits: predictable cleanup of resources, lower overhead for memory management, and essentially no runtime system. </p>
</blockquote>
<p>但“几乎没有”并不代表完全没有，Rust 的一部分标准库实现可以被认定为属于 Rust 运行时系统的功能范畴，这部分标准库提供了与：<em>Panic</em>、<em>回溯（backtrace）</em>、<em>Stack Unwinding</em> 以及<em>栈保护</em>等概念有关的具体实现。不仅如此，同 C 语言类似，Rust 同样有着一部分运行时系统功能为实际的 <code>main</code> 函数调用提供了准备。</p>
<p>我们可以从 Rust 项目的源代码位置 <em><strong>rust/library/std/src/rt.rs</strong></em> 处看到 Rust Runtime 的完整实现。这段代码实现十分简短，完整的代码参考如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Runtime services
//!
//! The `rt` module provides a narrow set of runtime services,
//! including the global heap (exported in `heap`) and unwinding and
//! backtrace support. The APIs in this module are highly unstable,
//! and should be considered as private implementation details for the
//! time being.

#![unstable(
    feature = &quot;rt&quot;,
    reason = &quot;this public module should not exist and is highly likely \
              to disappear&quot;,
    issue = &quot;none&quot;
)]
#![doc(hidden)]

// Re-export some of our utilities which are expected by other crates.
pub use crate::panicking::{begin_panic, begin_panic_fmt, panic_count};

// To reduce the generated code of the new `lang_start`, this function is doing
// the real work.
#[cfg(not(test))]
fn lang_start_internal(
    main: &amp;(dyn Fn() -&gt; i32 + Sync + crate::panic::RefUnwindSafe),
    argc: isize,
    argv: *const *const u8,
) -&gt; isize {
    use crate::panic;
    use crate::sys_common;

    // SAFETY: Only called once during runtime initialization.
    unsafe { sys_common::rt::init(argc, argv) };

    let exit_code = panic::catch_unwind(main);

    sys_common::rt::cleanup();

    exit_code.unwrap_or(101) as isize
}

#[cfg(not(test))]
#[lang = &quot;start&quot;]
fn lang_start&lt;T: crate::process::Termination + 'static&gt;(
    main: fn() -&gt; T,
    argc: isize,
    argv: *const *const u8,
) -&gt; isize {
    lang_start_internal(
        &amp;move || crate::sys_common::backtrace::__rust_begin_short_backtrace(main).report(),
        argc,
        argv,
    )
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#导出的-panicking-内部接口" id="导出的-panicking-内部接口">导出的 Panicking 内部接口</a></h3>
<p>从上往下看这段代码，首先可以发现这里重新导出了一些与 <code>panic!</code> 宏相关的内部函数，我们来一一看下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Re-export some of our utilities which are expected by other crates.
pub use crate::panicking::{begin_panic, begin_panic_fmt, panic_count};
<span class="boring">}
</span></code></pre></pre>
<p>其中，名为 <code>begin_panic</code> 的函数是宏 <code>panic!</code> 与 <code>assert!</code> 对应变体的实际入口函数，该函数可以接受任意的（<code>std::any::Any</code>）参数类型作为 Panic Payload。函数内部通过调用 <code>rust_panic_with_hook</code> 函数执行了为触发 Panic 所做的一些处理，这些处理包括：处理递归的 Panic（比如在 Panic Hook 中触发 Panic）、执行 Panic Hook（自定义或默认的）、输出 Panic 信息，最后通过调用 Panic Runtime 提供的 <code>__rust_start_panic</code> 函数，Rust 可以选择性地通过 <code>panic_abort</code> 或 <code>panic_unwind</code>（默认情况）这两种不同的方式实现最后的 Panic 副作用。其中，前者将直接调用诸如 C 标准库中的 <code>abort</code> 函数来结束当前进程；而后者则会通过调用平台相关的 <em>Stack Unwinding</em> 逻辑来“解构”与异常相关的调用栈帧，直到可以将（如果有）控制逻辑转移给最外层的 <code>std::panic::catch_unwind</code> 函数栈帧。一个有关设置 Panic Hook 与 Panic 捕获的简单例子可以参考如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    // setup a panic hook, will be called once a panic occurs.
    std::panic::set_hook(Box::new(|panic_info| {
        if let Some(s) = panic_info.payload().downcast_ref::&lt;&amp;str&gt;() {
            println!(&quot;Panic occurred: {:?}&quot;, s);
        }
    }));
    // catch occurred panics.
    let result = std::panic::catch_unwind(|| {
        (|| panic!(&quot;A panic occurs!&quot;))();
    });
    /**
     * Output:
        Err(
            Any { .. },
        )
     */
    println!(&quot;{:#?}&quot;, &amp;result);
}
</code></pre></pre>
<p><code>begin_panic_fmt</code> 函数与 <code>begin_panic</code> 类似，只不过它主要用来处理接收了类似 <code>format!</code> 宏格式参数的 <code>panic!</code> 调用，该函数在执行过程中也会间接调用 <code>rust_panic_with_hook</code> 函数，其后续处理流程与上述一致。</p>
<p>最后导出的 <code>panic_count</code> 模块中主要包含了与 “Panic 计数” 相关的一些内部接口，这些计数逻辑会计算发生的、分别独立于进程和线程（通过 TLS）的 Panic 数量，并进行不同的处理。其中的基本逻辑是：当发生 Panic 时，计数器会加一；相反，当 Panic 被捕获和处理后（比如通过 <code>catch_unwind</code>），计数器会减一。而在正常情况下，发生 Panic 会直接导致 Rust 程序的运行终止。</p>
<h3><a class="header" href="#runtime-入口函数" id="runtime-入口函数">Runtime 入口函数</a></h3>
<p>出于对代码生成大小的考虑，实际的 Runtime 入口函数被拆分成了两部分，分别对应 <code>lang_start</code> 与 <code>lang_start_internal</code>，其中前者为首先被调用（由属性 <code>#[lang = &quot;start&quot;]</code> 标记）的函数，该函数在其内部直接调用了后者。调用的方式如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[cfg(not(test))]
#[lang = &quot;start&quot;]
fn lang_start&lt;T: crate::process::Termination + 'static&gt;(
    main: fn() -&gt; T,
    argc: isize,
    argv: *const *const u8,
) -&gt; isize {
    lang_start_internal(
        &amp;move || crate::sys_common::backtrace::__rust_begin_short_backtrace(main).report(),
        argc,
        argv,
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>其中传入的第一个参数为一个闭包（Closure）。在该闭包内部，一个指向 <code>main</code> 函数的指针被作为参数传递给了 <code>__rust_begin_short_backtrace</code> 函数。Rust 自 1.47.0 版本后，在默认情况下，应用发生 Panic 时将会输出更加精简的 <em>stack backtrace</em> 信息，而这种改变便是由函数 <code>__rust_begin_short_backtrace</code> 与 <code>__rust_end_short_backtrace</code> 一起配合并共同完成的。</p>
<p>这两个函数需要成对使用，两者在其内部并没有任何特殊逻辑，而只是简单地调用了传入其中的函数，并将调用结果返回。从 Rust 应用的完整调用栈（<em>call stack</em>）上来看，处于 <code>__rust_begin_short_backtrace</code> 和 <code>__rust_end_short_backtrace</code> 之间的函数调用过程便可被视作完整的用户代码调用过程。而 Rust 在遇到 Panic 而需要打印当前的 <em>backtrace</em> 时，它实际上会遍历每一个栈帧，而通过栈帧附带的“符号名”来区分当前栈帧是否为上述两个函数中的某一个，进而 Rust 能够区分哪部分栈帧属于用户代码、哪部分属于运行时系统。</p>
<p>再回到之前的闭包，当函数 <code>__rust_begin_short_backtrace</code> 在其内部调用了传入的 <code>main</code> 函数并返回后，Rust 在此返回值的基础之上又调用了名为 <code>report</code> 的函数。从上面给出的 Runtime 入口函数 <code>lang_start</code> 的实现代码中可以看到，<code>main</code> 函数所对应的类型 <em>fn() -&gt; T</em> 其返回值 <em>T</em> 实际上带有一个名为 <code>crate::process::Termination</code> 的 <em>trait bound</em>，而该 trait 便提供了名为 <code>report</code> 的方法。该方法在调用后会返回一个用于表示<strong>状态信息</strong>的 <em>i32</em> 类型整数，该整数随后将会被传递给操作系统以作为状态信息。如下图所示，实际上 Rust 对诸如 <code>()</code> \ <code>!</code> \ <code>Result&lt;(), E&gt;</code> 等常见的 <code>main</code> 函数返回值都默认实现了该 trait。通常情况下，Rust 使用来自 libc 的宏 <code>libc::EXIT_SUCCESS</code> 的值（整数 0）来表示成功状态；而使用宏 <code>libc::EXIT_FAILURE</code> 的值（整数 1）来表示失败状态。在这些 <code>main</code> 函数常见返回值类型对该 trait 的实现中，你可以看到对这些值的使用。</p>
<p><img src="chapter_5/./image/rust-abi/1.png" alt="" /></p>
<p>接下来，函数 <code>lang_start_internal</code> 在调用时传入的最后两个参数 <em>argc</em> 与 <em>argv</em> 想必你已经十分熟悉了，两者与 C/C++ 程序中 <code>main</code> 函数所接收到的两个参数其含义和数值类型完全一致。流程继续行进到 <code>lang_start_internal</code> 函数的内部。在该函数内部，Rust 首先调用了名为 <code>sys_common::rt::init</code> 的“运行时初始化”函数，该函数主要完成了以下几件事情：</p>
<ul>
<li>初始化用于存放 <em>argc</em> 与 <em>argv</em> 的全局静态变量；</li>
<li>为当前 <code>main</code> 函数的所在线程设置名称（“main”）；</li>
<li>为当前 <code>main</code> 函数的所在线程设置 Thread Guard，以防（通过 <em>bounds checking</em>）栈缓冲区溢出。</li>
</ul>
<p>其内部调用如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// One-time runtime initialization.
// Runs before `main`.
// SAFETY: must be called only once during runtime initialization.
// NOTE: this is not guaranteed to run, for example when Rust code is called externally.
#[cfg_attr(test, allow(dead_code))]
pub unsafe fn init(argc: isize, argv: *const *const u8) {
    unsafe {
        sys::init(argc, argv);

        let main_guard = sys::thread::guard::init();
        // Next, set up the current Thread with the guard information we just
        // created. Note that this isn't necessary in general for new threads,
        // but we just do this to name the main thread and to give it correct
        // info about the stack bounds.
        let thread = Thread::new(Some(&quot;main&quot;.to_owned()));
        thread_info::set(main_guard, thread);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在调用完初始化函数后，我们在 Rust 源代码中定义的 <code>main</code> 函数便开始被真正地调用了。这里 <code>main</code> 函数实际上会被放置在 <code>catch_unwind</code> 中进行调用，以检查主函数在实际调用过程中是否产生了 Panic，借此来设置不同的返回值。紧接着在 <code>main</code> 函数执行完毕并返回后，Rust 通过调用 <code>sys_common::rt::cleanup</code> 函数完成对运行时上下文的清理，这些清理工作包括：</p>
<ul>
<li>输出并禁用 <em>stdout</em> 缓冲区；</li>
<li>清理先前用于保存 <em>argc</em> 与 <em>argv</em> 的静态变量。</li>
</ul>
<p>最后，Rust 返回用户指定的或默认的（101 - 发生错误）退出状态码到操作系统，应用结束运行。</p>
<p>到这里一切看起来都很简单，我们可观测到的 Rust Runtime 并没有提供过多的功能，但实际上还有一个问题没有解决。我们在文章开头曾提到，名为 <code>lang_start</code> 的函数会被 Rust 首先调用，而后才是我们定义在 Rust 源代码中的 <code>main</code> 函数。但究竟 <code>lang_start</code> 函数是如何被调用的呢？函数在调用时传入的 <em>argc</em> 与 <em>argv</em> 参数又是怎样获得的呢？</p>
<h4><a class="header" href="#入口点entry-point" id="入口点entry-point">入口点（Entry Point）</a></h4>
<p>实际上，我们上述介绍的<strong>函数 <code>lang_start</code> 只是 Rust Runtime 的入口点，而非整个程序的执行入口</strong>。当我们在通过 <em>rustc</em> 编译 Rust 源代码时，Rust 编译器会帮助我们动态生成一个名为 “main” 的函数，这个函数的签名同我们在 C/C++ 中定义的 <em>main</em> 函数基本一致。接着，Rust 借助在编译过程中链接的 <em>libc</em> 的帮助下，这个 <em>main</em> 函数便可以被正确调用（一般在 <em>_start</em> 中由汇编指定）。而我们在上文最开始介绍的 <code>lang_start</code> 函数便会由这个 <em>rustc</em> 自动生成的 <em>main</em> 函数来调用。具体可以参考 Rust 源代码 <em><strong>compiler/rustc_codegen_ssa/src/base.rs</strong></em> 中的 <code>create_entry_fn</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// location: compiler/rustc_codegen_ssa/src/base.rs.
fn create_entry_fn&lt;'a, 'tcx, Bx: BuilderMethods&lt;'a, 'tcx&gt;&gt;(
    cx: &amp;'a Bx::CodegenCx,
    rust_main: Bx::Value,
    rust_main_def_id: DefId,
    use_start_lang_item: bool,
) -&gt; Bx::Function {}
<span class="boring">}
</span></code></pre></pre>
<p>当然，在某些特殊场景下，我们也可以通过一些方式来让 <em>rustc</em> 不使用那个默认的、由 <em>lang item</em> 标记的 <code>lang_start</code> 函数。比如借助 <code>#[start]</code> 属性，我们可以让 <em>rustc</em> 在编译时直接使用我们指定的入口函数。一个简单的示例如下所示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(start)]
<span class="boring">fn main() {
</span>#[start]
fn my_custom_start(argc: isize, argv: *const *const u8) -&gt; isize {
    println!(&quot;{}&quot;, argc);
    unsafe {
        use std::ffi::{CStr, OsString};
        use std::os::unix::ffi::OsStringExt;
        use std::os::raw::c_char;
        let v: Vec&lt;OsString&gt; = (0..argc).map(|i| {
            let cstr = CStr::from_ptr(*argv.offset(i) as *const c_char);
            OsStringExt::from_vec(cstr.to_bytes().to_vec())
        }).collect();
        println!(&quot;{:?}&quot;, v);  // print out the argc and argv.
    }
    0
}
<span class="boring">}
</span></code></pre></pre>
<p>但这样做的问题在于：由于 <em>rustc</em> 直接使用了我们指定的入口函数（这个函数仍然是由编译器自动生成的 <em>main</em> 函数调用的），而没有执行 Rust 默认的 Runtime 初始化函数，因此我们上述介绍的那些在 Rust Runtime 中完成的事情，在这种情况下都不会被执行。而这是否会对应用的实际表现产生影响，则需要视具体情况而定。</p>
<h4><a class="header" href="#输入参数argc--argv" id="输入参数argc--argv">输入参数（argc / argv）</a></h4>
<p>对于程序运行时输入的 <em>argc</em> 与 <em>argv</em> 两个参数，本质上 Rust 会通过两种方式来获取：</p>
<ul>
<li>Runtime 启动时通过 <code>main</code> 函数直接传入，并保存于静态变量中；</li>
<li>借助 FFI 通过链接的外部系统库来获得。</li>
</ul>
<p>其中第一种方式，比如在与 libc 进行链接时，位于 _start 标签处的汇编代码便可能会对 <em>argc</em> 与 <em>argv</em> 这两个参数进行处理。而在 libc 实际调用 <em>main</em> 函数时（在 Rust 中由 <em>rustc</em> 动态生成），这两个参数便会被放置在栈上，进而直接作为 <em>main</em> 函数的参数传入其中。而根据链接的具体 libc 其种类的不同，比如 glibc 则可能会采用 “<em>init_array 扩展</em>” 的方式来获取 <em>argc</em> 与 <em>argv</em> 的实际值。</p>
<p>第二种方式的一个典型例子便是 macOS 系统上的 <code>_NSGetArgc</code> 与 <code>_NSGetArgv</code> 方法。这两个方法均由操作系统提供，可以直接用来获得传递给当前运行进程的 <em>argc</em> 与 <em>argv</em> 参数信息。因此，当我们在 Rust 中尝试通过 <code>std::env::args</code> 来获取当前进程的输入参数时，如下代码所示，在 macOS 系统上 Rust 将会直接通过 FFI 调用这两个函数来获取这些信息。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// location: library/std/src/sys/unix/args.rs.
#[cfg(target_os = &quot;macos&quot;)]
pub fn args() -&gt; Args {
    use crate::os::unix::prelude::*;
    extern &quot;C&quot; {
        // These functions are in crt_externs.h.
        fn _NSGetArgc() -&gt; *mut libc::c_int;
        fn _NSGetArgv() -&gt; *mut *mut *mut libc::c_char;
    }
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#rust-abi" id="rust-abi">Rust ABI</a></h2>
<p>同样的，从 Rust 官方的 FAQ 中我们也可以了解到，实际上目前 Rust 还没有稳定的 ABI。因此这里只简短地挑几个方面讲讲。</p>
<h3><a class="header" href="#内存布局memory-layout" id="内存布局memory-layout">内存布局（Memory Layout）</a></h3>
<p>对于诸如 <em>i32</em> \ <em>f32</em> \ <em>&amp;T</em> \ <em>*const T</em> 等基本类型以及复合类型 <em>array</em> 来说，Rust ABI 保证其与 C/C++ 是相互兼容的。</p>
<p>而对于某些复合类型，从 Rustonomicon 中我们得知，在默认情况下，Rust 编译器对 <code>struct</code> 内部字段的内存排列方式并不固定。在某些情况下出于优化目的，其实际的字段内存排列顺序可能与定义时的“可见排列顺序”并不相同。而为了使内存布局保持稳定，我们可以通过添加额外的诸如 <code>#[repr(C)]</code> 等属性来指定被标记结构体应该采用哪种 ABI 规定的内存排列方式。如下所示我们规定结构体 Foo 应该按照 C 语言的 ABI 来进行实际的内存布局。同样的方式也可被应用于 <code>enum</code> 类型，但需要注意 Rust 与 C 中的 enum 本质并不相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Foo {
    a: bool,
    b: f64,
    c: bool,
    d: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>除此之外，对于某些特殊类型（比如 <code>Option&lt;T&gt;</code> \ <code>enum</code> ），Rust 编译器可能会使用“<strong>空指针优化</strong>（<em>Null-pointer Optimization</em>）”来优化这些类型的内存布局。此时，<code>Option&lt;T&gt;</code> 其内存布局将与 T 的内存布局保持一致（T 必须为 <em>non-null</em>）。</p>
<h3><a class="header" href="#对齐alignment" id="对齐alignment">对齐（Alignment）</a></h3>
<p>Rust 中<strong>所有类型都有以“字节”为单位的对齐要求</strong>。基本类型（整数、浮点数、布尔值，以及字符值）通常对齐到它们类型本身的大小（当然也受到具体平台的限制）。默认情况下，复合类型（如 <code>struct</code>）的整体大小需要是其内部字段最大对齐大小的整数倍。并且，内部的每一个字段的起始偏移也需要为该字段对齐字节大小的整数倍（同 C/C++ 一致）。某些情况下，Rust 会自动插入“对齐字节”以满足上述要求。</p>
<p>而动态大小类型（DSTs）其大小与对齐方式可能无法在静态编译时得知。对零大小类型（ZSTs）的操作通常会被编译器优化为 “no-op”，且对 ZSTs 的引用必须是 <em>non-null</em> 且适当对齐的。而解引用一个 <em>null</em> 或未对齐的 ZST 指针是未定义行为（UB）。</p>
<h3><a class="header" href="#调用规范calling-convention" id="调用规范calling-convention">调用规范（Calling Convention）</a></h3>
<p>目前还没有相关资料记载 Rust-to-Rust 调用时所采用的具体调用规范。而对于 C-to-Rust 调用，我们可以选择借助 <code>extern</code> 关键字让函数调用遵循当前平台默认的 C ABI。示例代码如下所示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>同样，我们也可以显式指定想要使用的其他 ABI，比如 <em>_cdecl</em>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;cdecl&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#参考资料-7" id="参考资料-7">参考资料</a></h2>
<ol>
<li><em>https://en.wikipedia.org/wiki/Runtime_system.</em></li>
<li><em>https://en.wikipedia.org/wiki/Execution_model.</em></li>
<li><em>https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase).</em></li>
<li><em>https://whatis.techtarget.com/definition/runtime-system.</em></li>
<li><em>https://www.techopedia.com/definition/24023/runtime-system.</em></li>
<li><em>https://edge.seas.harvard.edu/runtime-systems.</em></li>
<li><em>https://stackoverflow.com/questions/42728239/runtime-system-in-c.</em></li>
<li><em>https://www.quora.com/Is-there-an-execution-model-for-every-programming-language-I-cannot-find-any-for-C++.</em></li>
<li><em>http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf.</em></li>
<li><em>https://webassembly.github.io/spec/core/exec/index.html.</em></li>
<li><em>https://prev.rust-lang.org/en-US/faq.html.</em></li>
<li><em>https://ferrous-systems.github.io/rust-three-days-course/presentation/index.html?chapter=libcore-and-libstd&amp;locale=en-US.</em></li>
<li><em>https://blog.mgattozzi.dev/rusts-runtime.</em></li>
<li><em>https://en.wikipedia.org/wiki/Stack_trace.</em></li>
<li><em>https://rustc-dev-guide.rust-lang.org/panic-implementation.html.</em></li>
<li><em>https://en.wikipedia.org/wiki/Call_stack#Unwinding.</em></li>
<li><em>https://doc.rust-lang.org/beta/std/panic/fn.catch_unwind.html.</em></li>
<li><em>https://mashplant.online/2020/09/06/panic-in-wasm/.</em></li>
<li><em>https://blog.rust-lang.org/2020/10/08/Rust-1.47.html#shorter-backtraces.</em></li>
<li><em>https://en.wikipedia.org/wiki/Buffer_overflow_protection.</em></li>
<li><em>https://www.gnu.org/software/libc/manual/html_node/Exit-Status.html.</em></li>
<li><em>https://users.rust-lang.org/t/who-calls-lang-start/51446/2.</em></li>
<li><em>https://stackoverflow.com/questions/67444319/how-does-rust-begin-short-backtrace-work-in-rust.</em></li>
<li><em>https://stackoverflow.com/questions/67445967/how-does-rust-retrieve-the-input-argc-and-argv-values-from-a-running-program.</em></li>
<li><em>https://gankra.github.io/blah/rust-layouts-and-abis/.</em></li>
<li><em>https://people.gnome.org/~federico/blog/rust-stable-abi.html.</em></li>
<li><em>https://users.rust-lang.org/t/rust-function-calling-conventions/13499.</em></li>
<li><em>https://doc.rust-lang.org/nomicon/ffi.html.</em></li>
<li><em>https://www.reddit.com/r/rust/comments/50qk14/rust_abi/.</em></li>
<li><em>https://github.com/rust-lang/rust/issues/29633.</em></li>
<li><em>https://doc.rust-lang.org/unstable-book/language-features/lang-items.html.</em></li>
<li><em>http://www.dpldocs.info/experimental-docs/core.sys.darwin.crt_externs._NSGetArgc.html.</em></li>
</ol>
<h1><a class="header" href="#借鉴数据库缓存解决动态规划难题" id="借鉴数据库缓存解决动态规划难题">借鉴数据库缓存解决动态规划难题</a></h1>
<p>作者: 吴翱翔 / 后期编辑：张汉东</p>
<hr />
<blockquote>
<p>原文: <a href="https://pymongo.github.io/#/2021/05/cache_and_recursion_memoization.md">缓存解决动态规划难题</a></p>
</blockquote>
<p>分享下 leetcode 困难题<a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">停在原地的方案数</a>
不断推敲和优化逐步通过题目的过程</p>
<p>看到这种不同路径求方案总数，很容易想到 <a href="https://leetcode-cn.com/problems/unique-paths/">unique_path</a> 这道动态规划入门题，</p>
<p>这题跟 unique_path 一样也是「求从起点到终点不同行走路径的方案总数」，自然想到用动态规划去实现</p>
<h2><a class="header" href="#无记忆化的搜索" id="无记忆化的搜索">无记忆化的搜索</a></h2>
<p>由于动态规划迭代解法的状态表达较难抽象，于是我先写出更简单动态规划递归的无记忆化搜索版本</p>
<h3><a class="header" href="#递归的结束条件-1" id="递归的结束条件-1">递归的结束条件</a></h3>
<p>那么递归的结束条件显然是「剩余步数」为 0</p>
<h3><a class="header" href="#解答的更新条件" id="解答的更新条件">解答的更新条件</a></h3>
<p>方案数的更新条件则是 剩余步数为 0 且 当前位置也是 0，这时候可以将方案数+1</p>
<h3><a class="header" href="#递归函数的入参" id="递归函数的入参">递归函数的入参</a></h3>
<p>首先需要当前位置和当前剩余步数两个&quot;可变&quot;的入参</p>
<p>再需要一个&quot;常数&quot;表达最大可前往的位置，一旦移动到数组的右边界，下一步就只能原地走或向左走</p>
<p>最后需要一个已发现方案总数的可变指针，用来更新解答集</p>
<h3><a class="header" href="#递归搜索的决策层" id="递归搜索的决策层">递归搜索的决策层</a></h3>
<p>只能在数组范围 [0, arr_len] 行走，行走方向 原地不动、向左、向右 三种</p>
<ol>
<li>如果当前坐标是 0, 则只能 原地不动 或 向右</li>
<li>如果当前坐标是 arr_len-1，则只能 原地不动 或 向左</li>
<li>其余情况的行走方向决策则是 原地不动 或 向左 或 向右</li>
</ol>
<h3><a class="header" href="#无记忆化搜索代码" id="无记忆化搜索代码">无记忆化搜索代码</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn num_ways_dfs(cur_position: i32, remain_steps: i32, max_position: i32, plans_count: &amp;mut u32) {
    if remain_steps == 0 {
        if cur_position == 0 {
            // panicked at 'attempt to add with overflow'
            *plans_count += 1;
        }
        return;
    }

    // 剪枝: 走的太远不可能移动回原点的情况
    if cur_position &gt; remain_steps {
        return;
    }

    // 做决策
    // 决策: 原地不动
    num_ways_dfs(cur_position, remain_steps-1, max_position, plans_count);
    if cur_position == 0 {
        // 只能向右
        num_ways_dfs(cur_position+1, remain_steps-1, max_position, plans_count);
    } else if cur_position == max_position {
        // 只能向左
        num_ways_dfs(cur_position-1, remain_steps-1, max_position, plans_count);
    } else {
        num_ways_dfs(cur_position+1, remain_steps-1, max_position, plans_count);
        num_ways_dfs(cur_position-1, remain_steps-1, max_position, plans_count);
    }
}

fn num_ways_dfs_entrance(steps: i32, arr_len: i32) -&gt; i32 {
    let mut plans_count = 0;
    num_ways_dfs(0, steps, arr_len-1, &amp;mut plans_count);
    (plans_count % (10_u32.pow(9)+7)) as i32
}
<span class="boring">}
</span></code></pre></pre>
<p>虽然我加上了递归的剪枝条件，但是 leetcode 上只过了 1/3 的测试用例便在 (27,7) 这个测试用例上超时了</p>
<p>不仅如此，更新方案总数时还出现 u32 溢出的问题，我粗略估算下该函数的时间复杂度是 O(3^n) 指数级别的时间复杂度，其中 n 为剩余步数</p>
<h3><a class="header" href="#非线性递归导致超时" id="非线性递归导致超时">非线性递归导致超时？</a></h3>
<p>所谓线性递归大概指递归的决策层只有一个分支，或者说递归搜索树只有一个分支</p>
<p>像我上述代码的决策层有 向左/向右/原地不动 三种决策的就显然是个非线性递归，通常都很慢需要剪枝或记忆化才能提速</p>
<h2><a class="header" href="#记忆化搜索" id="记忆化搜索">记忆化搜索</a></h2>
<h3><a class="header" href="#斐波那契递归的记忆化" id="斐波那契递归的记忆化">斐波那契递归的记忆化</a></h3>
<p>斐波那契递归解法也是个典型的非线性递归</p>
<p>假设斐波那契数列的第 n 项为 fib(n)，很容易想到斐波那契数列的 fib(3) 的搜索树可以展开为:</p>
<blockquote>
<p>fib(3)=fib(2)+fib(1)=(fib(1)+fib(0))+fib(1)=2*fib(1)+fib(0)</p>
</blockquote>
<p>我们发现 fib(1) 被重复计算了两次，所以业界有种「记忆化搜索」的优化策略</p>
<p>具体实现是定义一个 HashMap，key 为递归函数的入参，value 为该入参情况的计算结果</p>
<p>例如计算 fib(3) 的过程中，第一次遇到 fib(1) 这个入参时进行计算，并将计算结果存入 HashMap 中，</p>
<p>第二次递归调用 fib(1) 时可以直接从 HashMap 中查表取结果而不需要「重复计算」</p>
<p>这种优化思路有点像缓存，相信一个无状态的函数同样的入参一定能得到同样的结果，所以第二次遇到同样的入参时直接拿上一次相同入参的计算结果去返回</p>
<h3><a class="header" href="#记忆化搜索的实现条件" id="记忆化搜索的实现条件">记忆化搜索的实现条件</a></h3>
<p>我第一版的递归搜索代码中，方案总数作为可变指针参数来传入，这种写法「不能用记忆化搜索优化」</p>
<p>因函数 <code>fn num_ways_dfs(cur_position: i32, remain_steps: i32, max_position: i32, plans_count: &amp;mut u32)</code></p>
<p><strong>并没有返回值</strong>，我无法实现一个 key 为入参，value 为该入参的上次计算结果返回值这样的记忆化缓存</p>
<h3><a class="header" href="#逆向思维-自下而上的递归" id="逆向思维-自下而上的递归">逆向思维: 自下而上的递归</a></h3>
<p>假设 <code>f(pos,steps)=plans</code> 表示从原点出发，当前位置 pos，剩余步数为 steps 的方案总数 plans</p>
<p>很容易想到 状态转移规律: f(0,0)=f(0,1)+f(1,1)</p>
<p>也就是终点是原点的前一个状态只能是: 前一个位置是 0 然后选择原地不动 或 前一个位置是 1 然后向左走</p>
<p>然后参考「数学归纳法」可以按照相同的规律将 f(0,1) 和 f(1,1) 也展开成子项，直到展开成 f(0, steps) 也就是起点</p>
<h3><a class="header" href="#记忆化搜索的函数签名" id="记忆化搜索的函数签名">记忆化搜索的函数签名</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NumWaysHelper {
    max_position: i32,
    steps: i32,
    /// memo
    cache: std::collections::HashMap&lt;(i32, i32), u64&gt;
}

impl NumWaysHelper {
    fn dfs(&amp;mut self, cur_pos: i32, remain_steps: i32) -&gt; u64 {
        // TODO 递归结束条件

        let mut plans_count = 0;
        // 做决策/状态转移
        // 上一步是: 原地不动
        // TODO
        if cur_pos == 0 {
            // 上一步是: 向左
            // TODO
        } else if cur_pos == self.max_position {
            // 上一步是: 向左
            // TODO
        } else {
            // 上一步是: 向左或向右
            // TODO
        }
        self.cache.insert((cur_pos, remain_steps), plans_count);
        plans_count
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#缓存的写入" id="缓存的写入">缓存的写入</a></h3>
<p>其中最关键的就是 <code>self.cache.insert((cur_pos, remain_steps), plans_count);</code> 这行</p>
<p>函数在 return 前先把(当前入参,返回值)这对计算结果「缓存到 HashMap」中</p>
<h3><a class="header" href="#利用缓存避免重复计算" id="利用缓存避免重复计算">利用缓存避免重复计算</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut plans_count = 0;
// 做决策/状态转移
// 上一步是: 原地不动
if let Some(plans) = self.cache.get(&amp;(cur_pos, remain_steps+1)) {
    plans_count += *plans;
} else {
    plans_count += self.dfs(cur_pos, remain_steps+1);
}
<span class="boring">}
</span></code></pre></pre>
<p>因为递归调用的开销挺大的，以上上一步是原地不动的决策分支中，一旦发现之前运算过 (cur_pos, remain_steps+1) 的入参情况就直接取缓存中的上次计算结果(因为函数是无状态的，相同的入参一定能得到相同的结果)</p>
<h3><a class="header" href="#记忆化搜索版本的实现" id="记忆化搜索版本的实现">记忆化搜索版本的实现</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NumWaysHelper {
    max_position: i32,
    steps: i32,
    cache: std::collections::HashMap&lt;(i32, i32), u64&gt;
}

impl NumWaysHelper {
    fn dfs(&amp;mut self, cur_pos: i32, remain_steps: i32) -&gt; u64 {
        if remain_steps == self.steps {
            if cur_pos == 0 {
                return 1;
            } else {
                // 只有从起点出发的方案才是有效的方案，其余方案都不可取(0)
                return 0;
            }
        }

        let mut plans_count = 0;
        // 做决策/状态转移
        // 共同的决策分支-上一步是: 原地不动
        plans_count += self.calc_plans_from_cache(cur_pos, remain_steps+1);
        if cur_pos == 0 {
            // 上一步是: 向左
            plans_count += self.calc_plans_from_cache(cur_pos+1, remain_steps+1);
        } else if cur_pos == self.max_position {
            // 上一步是: 向右
            plans_count += self.calc_plans_from_cache(cur_pos-1, remain_steps+1);
        } else {
            // 上一步是: 向左或向右
            plans_count += self.calc_plans_from_cache(cur_pos+1, remain_steps+1);
            plans_count += self.calc_plans_from_cache(cur_pos-1, remain_steps+1);
        }
        self.cache.insert((cur_pos, remain_steps), plans_count);
        plans_count
    }

    fn calc_plans_from_cache(&amp;mut self, last_pos: i32, last_remain_steps: i32) -&gt; u64 {
        if let Some(plans) = self.cache.get(&amp;(last_pos, last_remain_steps)) {
            *plans
        } else {
            self.dfs(last_pos, last_remain_steps)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#本题缓存与数据库缓存的异同" id="本题缓存与数据库缓存的异同">本题缓存与数据库缓存的异同</a></h2>
<p>MySQL 为了提高短时间相同 Query 的查询速度，会将查询的 SQL 语句计算哈希和对应的查询结果存入 Query Cache</p>
<p>在缓存的有效期内，遇到第二个相同的 SQL 查询就能直接从缓存中获取上次查询结果进行返回</p>
<p>MySQL 将 SQL 语句进行哈希是不是跟我们这题将递归调用的入参元祖作为 key 存入 HashMap 类似?</p>
<p>除了数据库，graphql 和 dataloader 也是大量用到了缓存，也是将查询计算 hash 作为 key 存入 HashMap 中</p>
<p>可以了解下 dataloader 这个 crate 的 <a href="https://docs.rs/dataloader/0.14.0/src/dataloader/cached.rs.html#8">源码</a>
是如何进行缓存以及解决 <code>N+1</code> 查询的问题的</p>
<h2><a class="header" href="#解决溢出错误" id="解决溢出错误">解决溢出错误</a></h2>
<p>我们记忆化搜索的解法通过了80%的测试用例，但是在输入参数特别大时就出错了</p>
<pre><code>输入：
93
85
输出：
468566822
预期结果：
623333920
</code></pre>
<p>看到期待值不对很多人以为「是不是我算法写错了」？</p>
<p>其实不是，一般这种入参很大的都是整数溢出的问题，leetcode 的 Rust 用的是溢出时自动 <code>wrapping</code> 的 release 编译</p>
<p>所谓 <code>wrapping</code> 值得就例如 <code>0_u8.wrapping_sub(1)==255</code>，0_u8 减 1 会下溢成 255</p>
<p>由于 leetcode 的题目描述中也提示了 方案总数可能会很大，所以每次加法都需要取模避免 i32 溢出</p>
<p>我也尝试修改 <code>type PlansCount = i32</code>，就算方案数用 u128 存储也会溢出，所以还是老老实实加法后取模</p>
<h2><a class="header" href="#题解完整代码及测试代码" id="题解完整代码及测试代码">题解完整代码及测试代码</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PlansCount = i32;

struct NumWaysHelper {
    max_position: i32,
    steps: i32,
    /// memo
    cache: std::collections::HashMap&lt;(i32, i32), PlansCount&gt;,
}

impl NumWaysHelper {
    /// leetcode rust version not support const_fn pow
    const MOD: PlansCount = 1_000_000_007;
    fn dfs(&amp;mut self, cur_pos: i32, remain_steps: i32) -&gt; PlansCount {
        // 递归结束条件
        if remain_steps == self.steps {
            if cur_pos == 0 {
                return 1;
            }
            // 只有从起点出发的方案才是有效的方案，其余方案都不可取(0)
            return 0;
        }

        // 做决策/状态转移
        // 共同的决策分支: 上一步-原地不动
        let mut plans_count = self.calc_plans_from_cache(cur_pos, remain_steps + 1);
        if cur_pos == 0 {
            // 上一步是: 向左
            plans_count += self.calc_plans_from_cache(cur_pos + 1, remain_steps + 1);
        } else if cur_pos == self.max_position {
            // 上一步是: 向右
            plans_count += self.calc_plans_from_cache(cur_pos - 1, remain_steps + 1);
        } else {
            // 上一步是: 向左或向右
            plans_count += self.calc_plans_from_cache(cur_pos + 1, remain_steps + 1);
            plans_count =
                plans_count % Self::MOD + self.calc_plans_from_cache(cur_pos - 1, remain_steps + 1);
        }
        self.cache.insert((cur_pos, remain_steps), plans_count);
        plans_count
    }

    /// can't use map_or_else, reason: Error: closure requires unique access to `self` but `self` is already borrowed
    #[allow(clippy::option_if_let_else)]
    fn calc_plans_from_cache(&amp;mut self, last_pos: i32, last_remain_steps: i32) -&gt; PlansCount {
        (if let Some(plans) = self.cache.get(&amp;(last_pos, last_remain_steps)) {
            *plans
        } else {
            self.dfs(last_pos, last_remain_steps)
        }) % Self::MOD
    }
}

fn num_ways_dfs_entrance(steps: i32, arr_len: i32) -&gt; i32 {
    let mut helper = NumWaysHelper {
        max_position: arr_len - 1,
        steps,
        cache: std::collections::HashMap::new(),
    };
    helper.dfs(0, 0) % NumWaysHelper::MOD
}

#[test]
fn test_num_ways() {
    const TEST_CASES: [(i32, i32, i32); 4] = [(93, 85, 623333920), (3, 2, 4), (2, 4, 2), (4, 2, 8)];
    for (steps, arr_len, plans_count) in TEST_CASES {
        assert_eq!(num_ways_dfs_entrance(steps, arr_len), plans_count);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>完整源码: <a href="https://github.com/pymongo/leetcode-rust/blob/b6f0101a50a70512c12dd33333bfa535307ac40e/src/dp/number_of_ways_to_stay_in_the_same_place_after_some_steps.rs#L277">https://github.com/pymongo/leetcode-rust/blob/b6f0101a50a70512c12dd33333bfa535307ac40e/src/dp/number_of_ways_to_stay_in_the_same_place_after_some_steps.rs#L277</a></p>
<h2><a class="header" href="#小结下逐步优化题解的过程" id="小结下逐步优化题解的过程">小结下逐步优化题解的过程</a></h2>
<p>首先是根据题目意思写出了无缓存/无记忆化的从搜索树自上而下的递归解法，实现的过程中逐步理解了动态规划的状态转移方程，</p>
<p>进而写出了带缓存的深度优先搜索解法，解决了溢出等小问题后终于通过了</p>
<p><img src="chapter_5/./image/cache/cache_and_recursion_memoization.png" alt="" /></p>
<h2><a class="header" href="#为什么不是-dpij-的动态规划写法" id="为什么不是-dpij-的动态规划写法">为什么不是 dp[i][j] 的动态规划写法</a></h2>
<p>有读者可能疑惑，为什么 leetcode 这题官方题解或绝大部分题解都用 <code>dp[i][j]</code> 这种写法</p>
<p>我的题解运行速度比 <code>dp[i][j]</code> 的写法慢得多</p>
<p>首先我要明确一点动态规划其实是有两种主流的写法的，一种就是常见的 <code>dp[i][j]</code> 迭代写法去填表</p>
<p>另一种就是我介绍的递归记忆化/缓存化搜索</p>
<p><code>dp[i][j]</code> 写法的最大毛病就是「可读性极差」，构思难度高</p>
<p>我以前写的动态规划代码，过五个月再看完全忘记 i 和 j 表达什么意思了</p>
<p><code>dfs(cur_position: i32, remain_steps: i32)</code> 这种写法不比 <code>dp[i][j]</code> 的可读性强很多?</p>
<p>记忆化搜索另一种好处就是，可以快速写出简单的无缓存版本，再慢慢优化解决超时问题，而迭代的动态规划写法起步就很难</p>
<p>所以我个人更推荐大家多练习记忆化搜索解动态规划，这种借鉴数据库缓存的思路还是很简单的，面试中遇到不熟悉的动态规划题可以先试着用记忆化搜索去解决</p>
<h1><a class="header" href="#rust-与-os--一种有效的页表系统抽象设计" id="rust-与-os--一种有效的页表系统抽象设计">Rust 与 OS | 一种有效的页表系统抽象设计</a></h1>
<p>作者：洛佳 / 后期编辑 ：张汉东</p>
<hr />
<p>从段进化到页，是操作系统内存抽象的一大进步之处。页式存储管理由软硬件共同实现，软件提供映射关系，
硬件来加速地址翻译的过程。为了更好地设计硬件，往往要求软件页满足一定的数据要求。</p>
<p>这篇笔记尝试梳理软件层次上，页的实现过程。将会包括大页的分配算法，物理地址的对齐，多种分页模式的兼容设计，
以及如何使用泛型、模块化等现代语言技术实现它们。</p>
<p>可能讲得不清楚，请各位看官海涵。</p>
<h2><a class="header" href="#大页分配算法" id="大页分配算法">大页分配算法</a></h2>
<p>页式存储系统拥有“大页”的概念。在一些架构下，大页要求地址对齐。
即大页的物理地址必须对齐到特定的级别，随后的低级页号和索引，将共同看作更长的索引使用。
这就对分配算法提出了一定的要求。</p>
<p>归纳需要解决的问题。我们的问题是：给定页表系统<code>M</code>，最大等级为<code>n</code>；对虚拟页号<code>v = (vn-1, ...v1, v0)</code>和待映射连续页数<code>n</code>,
找到一组页的映射集合<code>U = { (v_开始, p_开始, 长度) }</code>，使得页号<code>v</code>能映射到物理页号<code>p</code>。
考虑使用大页优化这一过程，使<code>| U |</code>越少越好，但需要注意对齐要求，即对等级为<code>k</code>的大页，
起始地址为<code>(vn-1, ...vk, 0, ...0)</code>的<code>k-1</code>到<code>0</code>级均为0，即假如<code>k</code>级的对齐要求为<code>a[k]</code>，有<code>v = 0 (mod a[k])</code>。</p>
<p>在<code>M = Sv39系统</code>中，最大等级<code>n = 3</code>，对齐要求<code>a[0] = 1</code>, <code>a[1] = 512</code>, <code>a[2] = 26'2144</code>[注释1]。即，每一级别包含512个页表项。</p>
<p>为了简化问题理解，我们定义一个<code>M = 简单的页表系统</code>，最大等级也为<code>n = 3</code>，但<code>a[0] = 1</code>, <code>a[1] = 4</code>, <code>a[2] = 16</code>。
每一级别包含3个页表项。给定虚拟地址<code>v = (2, 2, 2)</code>到<code>v + n = (5, 2, 1)</code>，要映射到物理地址<code>p = (2, 2, 2)</code>。</p>
<p>现在我们在最高的3级，将要分配<code>r(v) = (2, 2, 2)..=(5, 2, 1)</code>到<code>p = (2, 2, 2)</code>。
如果直接使用大页，将必须保证2、1级的编号都为0。也就是说，只能分配<code>r(v) = (3, 0, 0)..(5, 0, 0)</code>到<code>p = (3, 0, 0)</code>。</p>
<p>为什么不分配<code>(2, 0, 0)..(3, 0, 0)</code>到<code>(2, 0, 0)</code>呢？因为这将分配超过<code>(2, 2, 2)..=(5, 2, 1)</code>的范围，
和我们要求解的问题不同。同理，也不能分配<code>(5, 0, 0)..(6, 0, 0)</code>到<code>(5, 0, 0)</code>。这部分的范围，需要借助更低级的大页来完成。</p>
<p>第3级的分配完成了，然后我们借助2级页表，分配附近零碎的<code>(2, 3, 0)..(3, 0, 0)</code>和<code>(5, 0, 0)..(5, 2, 0)</code>。
分配<code>(2, 3, 0)..(3, 0, 0)</code>到<code>(2, 3, 0)</code>；<code>(5, 0, 0)..(5, 2, 0)</code>到<code>(5, 0, 0)</code>。</p>
<p>最后，借助1级页表，分配<code>(2, 2, 2)..(2, 3, 0)</code>到<code>(2, 2, 2)</code>；<code>(5, 2, 0)..(5, 2, 2)</code>到<code>(5, 2, 0)</code>。
至此，所有的分配完成了。</p>
<p>由于这种方法要求在虚拟的大页上分配物理的大页，两个大页的基地址必须有相同的对齐方式，因此，
初始传入的虚拟页号和物理页号，差值必须对齐到相应的页，即<code>v = p (mod a[k])</code>，才可以使用这种分配方法；否则就应当使用更低等级的分配方法。
（想想看为什么？）否则就会在分配过程中，产生对齐要求的异常。</p>
<p>比如<code>v = (2, 2, 2)</code>到<code>p = (2, 2, 2)</code>，就可以使用3级；而<code>v = (2, 2, 2)</code>到<code>p = (2, 1, 2)</code>，就只能使用2级。</p>
<p><img src="chapter_5/./image/kernel_huge_page_subsystem/huge_page_alloc_example.png" alt="大页分配图示" /></p>
<p>推广这个结论，我们可以得到一个规律。首先，使用贪心的方法，将地址的上下限分别向内取整，分配最大的大页给最高的地址范围。
然后，对两边的零碎范围，使用低1级的页表，继续分配。继续降低等级，直到所有的页都被分配完毕。</p>
<p><img src="chapter_5/./image/kernel_huge_page_subsystem/huge_page_algorithm.png" alt="大页分配算法推导" /></p>
<p>根据对齐规则和所需求的页数，逐级降低算法的起始等级。对等级<code>n = 3</code>的页表系统，以分支形式，我们编写顺序规则的伪代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// input: v: VirtPageNum, p: PhysPageNum, n: usize, a: PageMode;
if (v - p) % (a[2].frame_align()) == 0 &amp;&amp; n &gt;= a[2].frame_align() {
    let l2n = (vs2 - ve2) / a[2].frame_align();
    map(2, ve2, vs2, ve2-v+p);
    let l1n = (ve2 - ve1 + vs1 - vs2) / a[1].frame_align();
    map(1, ve1, ve2, ve1-v+p); map(1, vs2, vs1, vs2-v+p);
    let l0n = (n + ve1 - vs1) / a[0].frame_align();
    map(0, v, ve1, p); map(0, vs1, v+n, vs1-v+p);
} else if (v - p) % (a[1].frame_align()) == 0 &amp;&amp; n &gt;= a[1].frame_align() {
    let l1n = (vs1 - ve1) / a[1].frame_align();
    map(1, ve1, vs1, ve1-v+p);
    let l0n = (n + ve1 - vs1) / a[0].frame_align();
    map(0, v, ve1, p); map(0, vs1, v+n, vs1-v+p);
} else if (v - p) % (a[0].frame_align()) == 0 &amp;&amp; n &gt;= a[0].frame_align() {
    let l0n = n / a[0].frame_align();
    map(0, v, v+n, p);
} else {
    panic!(&quot;Can't map v to p under this page mode&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们发现，等级低算法的中间变量，也在等级高的地方出现了。于是这个算法可以改成循环的形式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// input: v: VirtPageNum, p: PhysPageNum, n: usize, M: PageMode;
for i in M::visit_levels_until(PageLevel::leaf_level()) { // 遍历顺序：[n, ...1, 0]
    let align = M::a(i); // i层的对齐要求
    if (v - p) % align != 0 || n &lt; align { // 对齐要求达不到等级，或者数量不够，使用低级算法
        continue;
    }
    let (mut ve_prev, mut vs_prev) = (None, None);
    for j in M::visit_levels_from(i) { // 遍历顺序：[j, j-1, ...0]
        let a = M::a(j); // j层的对齐要求
        let ve_cur = a * roundup(v / a)
        let vs_cur = a * rounddown((v + n) / a)
        if let (Some(ve_prev), Some(vs_prev)) = (ve_prev, vs_prev) {
            map(j, ve_cur..ve_prev); // 执行映射函数
            map(j, vs_prev..vs_cur);
        } else {
            map(j, ve_cur..vs_cur);
        }
        (ve_prev, vs_prev) = (Some(ve_cur), Some(vs_cur));
    }
    break;
} 
<span class="boring">}
</span></code></pre></pre>
<p>这个算法就可以用于任何等级的页表系统了，因此题目要求的算法得到解决。
使用Rust语言的生成器或者迭代器包装算法，即可得到比较好的算法实现。</p>
<p>传统分配算法是，将地址段内的所有地址，映射到最小的页帧上。此时，需要管理多少个页帧，就需要分配多少个页。
大页分配算法通过分配满足对齐要求更少的页，就能完成同样的任务。我们如何比较大页分配算法和传统算法分配的页数呢？</p>
<p>我们取用<code>M = Sv39系统</code>。其中，最大等级<code>n = 3</code>，对齐要求<code>a[0] = 1</code>, <code>a[1] = 512</code>, <code>a[2] = 26'2144</code>。</p>
<p>同样分配<code>505'5550</code>个页帧，假设页号对齐能满足最大的<code>26'2144</code>，采用不同的虚拟页号。</p>
<table><thead><tr><th align="left">虚拟页号</th><th align="left">数量</th><th align="left">所需页表数</th><th align="left">节省</th><th align="left">等级0</th><th align="left">等级1</th><th align="left">等级2</th></tr></thead><tbody>
<tr><td align="left">0</td><td align="left">505'5550</td><td align="left">227</td><td align="left">0.00%</td><td align="left">62</td><td align="left">146</td><td align="left">19</td></tr>
<tr><td align="left">10</td><td align="left">505'5550</td><td align="left">1249</td><td align="left">0.02%</td><td align="left">574</td><td align="left">657</td><td align="left">18</td></tr>
<tr><td align="left">20</td><td align="left">505'5550</td><td align="left">1249</td><td align="left">0.02%</td><td align="left">574</td><td align="left">657</td><td align="left">18</td></tr>
<tr><td align="left">512</td><td align="left">505'5550</td><td align="left">738</td><td align="left">0.01%</td><td align="left">62</td><td align="left">658</td><td align="left">18</td></tr>
<tr><td align="left">1024</td><td align="left">505'5550</td><td align="left">738</td><td align="left">0.01%</td><td align="left">62</td><td align="left">658</td><td align="left">18</td></tr>
<tr><td align="left">1025</td><td align="left">505'5550</td><td align="left">1249</td><td align="left">0.02%</td><td align="left">574</td><td align="left">657</td><td align="left">18</td></tr>
<tr><td align="left">26'2144</td><td align="left">505'5550</td><td align="left">227</td><td align="left">0.00%</td><td align="left">62</td><td align="left">146</td><td align="left">19</td></tr>
<tr><td align="left">100'0000</td><td align="left">505'5550</td><td align="left">738</td><td align="left">0.01%</td><td align="left">574</td><td align="left">145</td><td align="left">19</td></tr>
</tbody></table>
<table><thead><tr><th align="left">虚拟页号</th><th align="left">数量</th><th align="left">所需页表数</th><th align="left">节省</th><th align="left">等级0</th><th align="left">等级1</th><th align="left">等级2</th></tr></thead><tbody>
<tr><td align="left">30'0000</td><td align="left">1</td><td align="left">1</td><td align="left">100.00%</td><td align="left">1</td><td align="left">N/A</td><td align="left">N/A</td></tr>
<tr><td align="left">30'0000</td><td align="left">10</td><td align="left">10</td><td align="left">100.00%</td><td align="left">10</td><td align="left">N/A</td><td align="left">N/A</td></tr>
<tr><td align="left">30'0000</td><td align="left">100</td><td align="left">100</td><td align="left">100.00%</td><td align="left">100</td><td align="left">N/A</td><td align="left">N/A</td></tr>
<tr><td align="left">30'0000</td><td align="left">1000</td><td align="left">489</td><td align="left">48.90%</td><td align="left">488</td><td align="left">1</td><td align="left">N/A</td></tr>
<tr><td align="left">30'0000</td><td align="left">1'0000</td><td align="left">291</td><td align="left">2.91%</td><td align="left">272</td><td align="left">19</td><td align="left">N/A</td></tr>
<tr><td align="left">30'0000</td><td align="left">10'0000</td><td align="left">355</td><td align="left">0.36%</td><td align="left">160</td><td align="left">195</td><td align="left">N/A</td></tr>
<tr><td align="left">30'0000</td><td align="left">100'0000</td><td align="left">995</td><td align="left">0.10%</td><td align="left">64</td><td align="left">929</td><td align="left">2</td></tr>
<tr><td align="left">30'0000</td><td align="left">1000'0000</td><td align="left">752</td><td align="left">0.01%</td><td align="left">128</td><td align="left">587</td><td align="left">37</td></tr>
</tbody></table>
<p>可以发现，Sv39下对齐要求高、页帧数量大时，大页只需要小于一千个页表，就能管理百万个页帧空间，非常节省页表的数量。
页帧数量小时，由于对齐要求不高，节省的数量并不明显；对齐要求低时，节省数量也不明显。</p>
<p>实际使用时，尽量给出最大的对齐要求，这样可以在分配大量页帧时，节省更多的页帧空间。
这一结果对芯片外设的布局也有指导作用，如果高级的嵌入式芯片拥有较多外设，尽量将外设的物理地址放置到更高的对齐要求上，
这样操作系统管理时就可以腾出更多的内存空间，供应用使用。</p>
<p>[注释1]：表格中的'号表示万位分隔符，<a href="https://zhuanlan.zhihu.com/p/358635675">成会明院士：传承祖先的智慧，倡导中文中阿拉伯数字书写方式采用“4位数分隔法”. 中国科学院院刊</a></p>
<h2><a class="header" href="#抽象软件设计" id="抽象软件设计">抽象软件设计</a></h2>
<p>以Rust语言为例，给出页系统常见结构的抽象方法。</p>
<h3><a class="header" href="#页号" id="页号">页号</a></h3>
<p>首先定义物理和虚拟页号。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct PhysPageNum(usize);

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct VirtPageNum(usize);
<span class="boring">}
</span></code></pre></pre>
<p>“物理页号长度 + 偏移长度”可能大于“架构地址宽度”，这允许我们访问大于架构宽度的地址。
比如RISC-V RV32下，使用Sv32系统，可以访问34位的物理地址，即使架构只有32位。</p>
<p>物理页号和虚拟页号，可以通过对应的地址转换而来。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PhysPageNum {
    pub fn addr_begin&lt;M: PageMode&gt;(&amp;self) -&gt; PhysAddr {
        PhysAddr(self.0 &lt;&lt; M::FRAME_SIZE_BITS)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种转换关系要求输入页表的模式。不同架构下，地址的偏移量可能不同。</p>
<h3><a class="header" href="#页帧分配器" id="页帧分配器">页帧分配器</a></h3>
<p>然后我们需要一个页帧分配器。模仿Rust语言alloc包的设计，可以给出结构如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FrameAllocator {
    fn allocate_frame(&amp;self) -&gt; Result&lt;PhysPageNum, FrameAllocError&gt;;
    fn deallocate_frame(&amp;self, ppn: PhysPageNum);
}
<span class="boring">}
</span></code></pre></pre>
<p>构造页帧分配器时，应当给定一个物理页的范围。</p>
<p>而后，每次请求分配，其中的算法将返回分配的结果，或者当没有页存在时，返回一个错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl StackFrameAllocator {
    pub fn new(start: PhysPageNum, end: PhysPageNum) -&gt; Self {
        StackFrameAllocator { current: start, end, recycled: Vec::new() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>页帧分配器只分配编号，不会向被分配的内存中存储或读取数据，所以它的设计与alloc库简单。</p>
<p>这种设计是为了方便测试页帧分配器的正确性和性能。</p>
<h3><a class="header" href="#装箱的页帧" id="装箱的页帧">装箱的页帧</a></h3>
<p>或者说<code>FrameBox</code>，借鉴了Rust中拥有所有权的Box名称，表示拥有所有权的一个页帧。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct FrameBox&lt;A: FrameAllocator = DefaultFrameAllocator&gt; {
    ppn: PhysPageNum, // 相当于*mut类型的指针
    frame_alloc: A,
}
<span class="boring">}
</span></code></pre></pre>
<p>每次新建时，从页帧分配器<code>frame_alloc</code>中得到新的页帧，然后使用所有权语义包装妥当。
当它的生命周期结束，调用页帧分配器，释放所占有的页帧。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;A: FrameAllocator&gt; FrameBox&lt;A&gt; {
    // 分配页帧并创建FrameBox
    pub fn try_new_in(frame_alloc: A) -&gt; Result&lt;FrameBox&lt;A&gt;, FrameAllocError&gt; {
        let ppn = frame_alloc.allocate_frame()?;
        Ok(FrameBox { ppn, frame_alloc })
    }
}

impl&lt;A: FrameAllocator&gt; Drop for FrameBox&lt;A&gt; {
    fn drop(&amp;mut self) {
        // 释放所占有的页帧
        self.frame_alloc.deallocate_frame(self.ppn);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>装箱的页帧实际地保管了页帧内存的所有权，可以向内写入数据，从中读取数据。</p>
<h3><a class="header" href="#页式地址空间" id="页式地址空间">页式地址空间</a></h3>
<p>一个表示分页系统实现的结构体，它保管着所有包含的页帧箱子，在释放时会释放其中的所有页帧。</p>
<p>这个结构体拥有一个分页模式的类型参数，用于计算页帧插入算法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 表示一个分页系统实现的地址空间
//
// 如果属于直接映射或者线性偏移映射，不应当使用这个结构体，应当使用其它的结构体。
#[derive(Debug)]
pub struct PagedAddrSpace&lt;M: PageMode, A: FrameAllocator = DefaultFrameAllocator&gt; {
    root_frame: FrameBox&lt;A&gt;,
    frames: Vec&lt;FrameBox&lt;A&gt;&gt;,
    frame_alloc: A,
    page_mode: M,
}
<span class="boring">}
</span></code></pre></pre>
<p>当创建页式地址空间时，立即分配一个根页表。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M: PageMode, A: FrameAllocator + Clone&gt; PagedAddrSpace&lt;M, A&gt; {
    // 创建一个空的分页地址空间。一定会产生内存的写操作
    pub fn try_new_in(page_mode: M, frame_alloc: A) -&gt; Result&lt;Self, FrameAllocError&gt; {
        // 新建一个根页表要求的页帧
        let mut root_frame = FrameBox::try_new_in(frame_alloc.clone())?;
        // 而后，向帧里填入一个空的根页表 
        unsafe { fill_frame_with_initialized_page_table::&lt;A, M&gt;(&amp;mut root_frame) };
        Ok(Self { root_frame, frames: Vec::new(), frame_alloc, page_mode })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>创建结构后，当插入新的映射关系，使用上一节提供的插入算法，得到需要插入的范围，然后读写页帧箱，完成插入操作。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M: PageMode, A: FrameAllocator + Clone&gt; PagedAddrSpace&lt;M, A&gt; {    
    // 设置页表项。如果寻找的过程中，中间的页表没创建，那么创建它们
    unsafe fn alloc_get_table(&amp;mut self, entry_level: PageLevel, vpn_start: VirtPageNum)
    -&gt; Result&lt;&amp;mut M::PageTable, FrameAllocError&gt; 
    {
        let mut ppn = self.root_frame.phys_page_num();
        for &amp;level in M::visit_levels_before(entry_level) {
            let page_table = unref_ppn_mut::&lt;M&gt;(ppn);
            let vidx = M::vpn_index(vpn_start, level);
            match M::slot_try_get_entry(&amp;mut page_table[vidx]) {
                Ok(entry) =&gt; ppn = M::entry_get_ppn(entry),
                Err(mut slot) =&gt; {  // 需要一个内部页表，这里的页表项却没有数据，我们需要填写数据
                    let frame_box = FrameBox::try_new_in(self.frame_alloc.clone())?;
                    M::slot_set_child(&amp;mut slot, frame_box.phys_page_num());
                    ppn = frame_box.phys_page_num();
                    self.frames.push(frame_box);
                }
            }
        }
        // println!(&quot;[kernel-alloc-map-test] in alloc_get_table PPN: {:x?}&quot;, ppn);
        let page_table = unref_ppn_mut::&lt;M&gt;(ppn); // 此时ppn是当前所需要修改的页表
        // 创建了一个没有约束的生命周期。不过我们可以判断它是合法的，因为它的所有者是Self，在Self的周期内都合法
        Ok(&amp;mut *(page_table as *mut _))
    }
    pub fn allocate_map(&amp;mut self, vpn: VirtPageNum, ppn: PhysPageNum, n: usize, flags: M::Flags)
    -&gt; Result&lt;(), FrameAllocError&gt; 
    {
        for (page_level, vpn_range) in MapPairs::solve(vpn, ppn, n, self.page_mode) {
            // println!(&quot;[kernel-alloc-map-test] PAGE LEVEL: {:?}, VPN RANGE: {:x?}&quot;, page_level, vpn_range);
            let table = unsafe { self.alloc_get_table(page_level, vpn_range.start) }?;
            let idx_range = M::vpn_index_range(vpn_range.clone(), page_level);
            // println!(&quot;[kernel-alloc-map-test] IDX RANGE: {:?}&quot;, idx_range);
            for vidx in idx_range {
                let this_ppn = PhysPageNum(ppn.0 - vpn.0 + M::vpn_level_index(vpn_range.start, page_level, vidx).0);
                // println!(&quot;[kernel-alloc-map-test] Table: {:p} Vidx {} -&gt; Ppn {:x?}&quot;, table, vidx, this_ppn);
                match M::slot_try_get_entry(&amp;mut table[vidx]) {
                    Ok(_entry) =&gt; panic!(&quot;already allocated&quot;),
                    Err(slot) =&gt; M::slot_set_mapping(slot, this_ppn, flags.clone())
                }
            }
        }
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#包装的页帧分配算法" id="包装的页帧分配算法">包装的页帧分配算法</a></h3>
<p>定义与实现如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct MapPairs&lt;M&gt; {
    ans_iter: alloc::vec::IntoIter&lt;(PageLevel, Range&lt;VirtPageNum&gt;)&gt;,
    mode: M,
}

impl&lt;M: PageMode&gt; MapPairs&lt;M&gt; {
    pub fn solve(vpn: VirtPageNum, ppn: PhysPageNum, n: usize, mode: M) -&gt; Self {
        let mut ans = Vec::new();
        /* 省略求解过程 */
        Self { ans_iter: ans.into_iter(), mode }
    }
}

impl&lt;M&gt; Iterator for MapPairs&lt;M&gt; {
    type Item = (PageLevel, Range&lt;VirtPageNum&gt;);
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.ans_iter.next()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>每次迭代它的结果，会返回一个应当分配的页帧。应当根据这个结果，设置映射关系。</p>
<h3><a class="header" href="#激活函数" id="激活函数">激活函数</a></h3>
<p>这个函数的实现与具体架构有关，此处以RISC-V Sv39为例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 切换地址空间，同时需要提供1.地址空间的详细设置 2.地址空间编号
pub unsafe fn activate_paged_riscv_sv39(root_ppn: PhysPageNum, asid: AddressSpaceId) {
    use riscv::register::satp::{self, Mode};
    satp::set(Mode::Sv39, asid.0 as usize, root_ppn.0);
    asm!(&quot;sfence.vma {}&quot;, in(reg) asid.0 as usize);
}
<span class="boring">}
</span></code></pre></pre>
<p>执行完毕后，就已经进入新的地址空间了。注意当前的pc地址仍未改变，如果进入新空间后，
指令对应的代码段已经消失了，将产生异常。因此，一般使用各个虚拟空间中共同映射的“跳板页”，完成这一切换过程。</p>
<h3><a class="header" href="#本设计的优缺点" id="本设计的优缺点">本设计的优缺点</a></h3>
<p>这个设计的优点是，你会发现只需要传入泛型参数M，代表页表模式，就能自动填写算法剩余的部分。</p>
<p>比如，RISC-V Sv39模式可以实现为页表模式，传入泛型参数M；它的定义如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sv39分页系统模式；RISC-V RV64下有效
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Sv39;

impl PageMode for Sv39 {
    const FRAME_SIZE_BITS: usize = 12;
    const PPN_BITS: usize = 44;
    type PageTable = Sv39PageTable;
    type Entry = Sv39PageEntry;
    type Slot = Sv39PageSlot;
    type Flags = Sv39Flags;
    /* 省略了大量的工具函数 */
}
<span class="boring">}
</span></code></pre></pre>
<p>只需要实现模式M中的这些参数，就可以无缝使用这个页表空间系统，包括求解算法。</p>
<p>完整的代码实现在<a href="https://github.com/HUST-OS/luojia-os-labs/blob/main/03-virt-addr-kern/src/mm.rs">这里</a>。</p>
<p>这种方法也有缺点，就是需要支持泛型的编程语言才可以使用；比如操作系统内核用Rust写，可以采用这种编程方法。</p>
<h2><a class="header" href="#目前常见的硬件页表系统" id="目前常见的硬件页表系统">目前常见的硬件页表系统</a></h2>
<p>RISC-V提供了Sv39和Sv48；它们分别是3、4级的页表系统，等级越高，能管理的虚拟空间越大。</p>
<p>我们使用上一节的描述方法，描述这些页表系统的基本参数。</p>
<table><thead><tr><th align="left">页表系统M</th><th align="left">虚拟地址</th><th align="left">物理地址</th><th align="left">等级n</th><th align="left">对齐要求a</th></tr></thead><tbody>
<tr><td align="left">RISC-V Sv39</td><td align="left">39</td><td align="left">55</td><td align="left">3</td><td align="left">1, 512, 26'2144</td></tr>
<tr><td align="left">RISC-V Sv48</td><td align="left">48</td><td align="left">55</td><td align="left">4</td><td align="left">1, 512, 26'2144, 1'3421'7728</td></tr>
<tr><td align="left">RISC-V Sv32</td><td align="left">32</td><td align="left">34*</td><td align="left">2</td><td align="left">1, 1024</td></tr>
<tr><td align="left">龙芯 LA64</td><td align="left">48</td><td align="left">60</td><td align="left">4</td><td align="left">1, 4096/2048*, ...</td></tr>
<tr><td align="left">龙芯 LA32</td><td align="left">32</td><td align="left">36</td><td align="left">2</td><td align="left">1, 1024</td></tr>
<tr><td align="left">arm64</td><td align="left">48</td><td align="left">39</td><td align="left">4</td><td align="left">1, 512, 26'2144, 1'3421'7728</td></tr>
<tr><td align="left">arm32</td><td align="left">32</td><td align="left">32</td><td align="left">2</td><td align="left">1, 256</td></tr>
<tr><td align="left">x86-64 (旧)</td><td align="left">48</td><td align="left">47</td><td align="left">4</td><td align="left">1, 512, 26'2144, 1'3421'7728</td></tr>
<tr><td align="left">x86-64 (新)</td><td align="left">57</td><td align="left">52</td><td align="left">5</td><td align="left">1, 512, 26'2144, 1'3421'7728, 687'1947'6736</td></tr>
<tr><td align="left">x86-32</td><td align="left">32</td><td align="left">32</td><td align="left">2</td><td align="left">1, 1024</td></tr>
</tbody></table>
<p>*Sv32的物理地址的确超过32位</p>
<p>*龙芯LA64架构中，双页存储结构对齐要求不同</p>
<p>系统启动时，内核可以激活Sv39，页表的等级少，开销较低，启动快。随后，根据需求，可以更换到更大空间的页表系统，来容纳更多应用。</p>
<h2><a class="header" href="#页式内存管理笔记" id="页式内存管理笔记">页式内存管理笔记</a></h2>
<p>在文章的最后，我们花一些时间尝试整理页式内存管理概念的笔记。</p>
<h3><a class="header" href="#页式内存管理" id="页式内存管理">页式内存管理</a></h3>
<p>要管理挂载的外设和内存块，我们定义物理地址，它是真实硬件中资源单元的编号。
所有的物理地址构成一个地址空间；地址空间是可由地址索引的，具体资源和硬件的集合。</p>
<p>我们的应用程序可以直接在物理地址上运行。然而，为了便于程序独占地址空间，便于连续地规划内存，
我们为它们构造虚拟空间。于是程序可以在虚拟地址上运行，虚拟地址是虚拟空间中内存单元的编号。</p>
<p>从前我们使用段的方式管理内存。为了减少内碎片和内存的浪费，我们引入了分页管理系统。</p>
<p>分页系统将地址空间分为连续的等大内存块，它们被称作页帧。
又将一个或多个连续页帧组成一个页，页的大小由硬件实现决定，软件必须按硬件给定页的大小。</p>
<p>管理页的数据结构称作页表。在内存中，页表通常占一个页帧的大小，以便硬件上的分页系统管理。
页表在内存中的存储位置被称作页号。</p>
<p>超过一个页帧大小的页，又被称作大页。管理大页的页表中，每个项目代表一个子页。
这个项目被称作页表的页表项，通常由权限位、控制位和物理页号组成。</p>
<p>将地址空间看作最大的页，根页表就是管理最大页的页表。根页表的页号会被保存在专用的位置中，以作为硬件查询的起始地址使用。</p>
<h3><a class="header" href="#翻译过程与地址对齐" id="翻译过程与地址对齐">翻译过程与地址对齐</a></h3>
<p>现代的页表系统中，无论等级，都称管理页的数据结构为页表。页表的翻译过程大致等同于这个步骤：</p>
<ol>
<li>取出根页表的页号</li>
<li>读取虚拟地址的特定区域，作为本级页表的索引</li>
<li>根据索引，取出管理更小页的页表项</li>
<li>如果页表项指向子页表，读取页号，返回到步骤2</li>
</ol>
<p>在这个简化的步骤中，可能出现非常多的异常。需要注意的是，如果当前页表项指向物理页号，这个物理页号有对齐要求。</p>
<p>我们如果使用<code>(v0, v1, v2):offset</code>代表一个虚拟地址。</p>
<p>如果<code>rt[v0][v1]</code>指向子页表，那么将继续查找<code>rt[v0][v1][v2]</code>。得到物理页号<code>(p0, p1, p2)</code>。
和off结合，得到物理地址<code>(p0, p1, p2):offset</code>。</p>
<p>如果<code>rt[v0][v1]</code>指向一个物理页，这是一个大页的页表项。页表项中，得到物理页号<code>(p0, p1, 0)</code>，
直接将v2、off拼接，得到大页对应的物理地址为<code>(p0, p1):v2,offset</code>；相当于延长了偏移量的位数。</p>
<p>采用后一种形式时，硬件通常要求物理页号只有高于大页的等级有效，低于它的无效。
也就是说，如果页表项<code>(p0, p1, p2)</code>的p2不等于零，将会返回页异常。这就是大页页表系统的对齐要求。</p>
<hr />
<p>作者简介：</p>
<p><strong>洛佳</strong></p>
<p>华中科技大学网络空间安全学院本科生，热爱操作系统、嵌入式开发。3年Rust语言开发经验，社区活跃贡献者。目前致力于向产业、教学等更多的领域推广Rust语言。</p>
<h1><a class="header" href="#学习笔记--树莓派-rust-嵌入式操作系统-之-驱动gpio-和-uart" id="学习笔记--树莓派-rust-嵌入式操作系统-之-驱动gpio-和-uart">学习笔记 ｜ 树莓派 Rust 嵌入式操作系统 之 驱动：GPIO 和 UART</a></h1>
<p>作者：张汉东</p>
<blockquote>
<p>学习笔记系列在线阅读地址：<a href="https://zhanghandong.github.io/raspberrypi-os-tutorials-notes/">https://zhanghandong.github.io/raspberrypi-os-tutorials-notes/</a></p>
</blockquote>
<hr />
<p>这是我对官方 <a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Operating System development tutorials in Rust on the Raspberry Pi</a> 的学习笔记。以此来学习 Rust 裸机（Bare-Matel）编程。</p>
<p>学习笔记代码仓库：<a href="https://github.com/ZhangHanDong/raspberrypi-os-tutorials-notes">https://github.com/ZhangHanDong/raspberrypi-os-tutorials-notes</a>，欢迎反馈交流。</p>
<p>注意：如果需要动手实现，请使用官方教程源码仓库配合本学习笔记。</p>
<p>当前已更新：</p>
<ul>
<li>ARM 汇编基础</li>
<li>00: 准备工作</li>
<li>01: 循环等待</li>
<li>02: 初始化执行环境（runtime）</li>
<li>03: 硬核输出 Hello World</li>
<li>04: 安全访问全局数据结构</li>
<li>05: 驱动：GPIO 和 UART</li>
</ul>
<p>本文节选第五章内容。</p>
<hr />
<h1><a class="header" href="#驱动gpio-和-uart" id="驱动gpio-和-uart">驱动：GPIO 和 UART</a></h1>
<blockquote>
<p>注意：这章不支持 <code>BSP=rpi4 make qemu</code>。</p>
</blockquote>
<h2><a class="header" href="#一些前置知识" id="一些前置知识">一些前置知识</a></h2>
<h3><a class="header" href="#arm-物理内存-vs-arm-虚拟地址空间" id="arm-物理内存-vs-arm-虚拟地址空间">Arm 物理内存 vs Arm 虚拟地址空间</a></h3>
<p>Arm 与物理内存等外设统一编址在4GB(32位)的地址空间中。而 x86 是将内存单独编址在一个地址空间，外设I/O端口在另外的地址空间，要访问IO地址空间需要用专门的指令操作。</p>
<p>Linux的每个进程都有4GB的虚拟地址空间，其中1~3GB是每个进程独占的用户空间，3GB~4GB是所有进程共享的内核空间（<code>0xC0000000~0xFFFFFFFF</code>）。因此虚拟地址空间包括内核空间与用户空间。linux的实虚地址的转换就是有MMU通过页表的形式完成转换的。</p>
<p>Arm 虚拟地址空间布局是一个标准的linux kernel实现，地址空间被分割成 1G 内核空间和 3G 用户空间，内核空间地址范围为<code>0xC0000000 - 0xEFFFFFFF</code>, 用户空间地址范围为 <code>0x00000000 - 0xBFFFFFFF</code>。</p>
<p>通过操作内存来访问外设，这种方式称为 <code>memory-mapped IO</code>。</p>
<p>需要注意：外设(Peripherals)的物理地址空间为 <code>0x20000000+16MB</code>，一般在内核虚拟地址中被映射到<code>0x7E000000+16MB</code>。</p>
<blockquote>
<p>树莓派 4b bcm 2711 文档中描述了ARM所见地址之间的映射：</p>
<p>rpi4: 0xFE200000 - 0xFE2000b3 : gpio@ 0x7E200000</p>
<p>只需把 fe200000 减去GPIO-BaseAddr（0x00200000），就可获得树莓派的PeripheralBaseAddr（PBase）：0xFE000000。</p>
</blockquote>
<h3><a class="header" href="#gpio-与-uart" id="gpio-与-uart">GPIO 与 UART</a></h3>
<p>在学习这一章之前，还是需要一些前置知识的。对树莓派如果不了解的话，很难理解它的代码在做什么。这部分内容，如果你暂时不想看，或者已经了解过，可以跳过。需要的时候可以回头看看。</p>
<p>GPIO（General Purpose I/O Ports）意思为通用输入/输出端口，通俗地说，就是一些引脚，可以通过它们输出高低电平或者通过它们读入引脚的状态-是高电平或是低电平。GPIO是个比较重要的概念，用户可以通过GPIO口和硬件进行数据交互(如UART)，控制硬件工作(如LED、蜂鸣器等),读取硬件的工作状态信号（如中断信号）等。GPIO口的使用非常广泛。掌握了GPIO，差不多相当于掌握了操作硬件的能力。</p>
<p>以树莓派 4B 为例，其 40 针脚见下图:</p>
<p><img src="chapter_5/./image/rpi/gpio.png" alt="gpio" /></p>
<p>UART（Universal Asynchronous Receiver/Transmitter)，是一种串行通信协议，其中数据是串行传输的，一次传输一个字节的数据，即逐位传输。作为把并行输入信号转成串行输出信号的芯片，UART 通常被集成于其他通讯接口的连结上。</p>
<p>为了和树莓派串口通信，我们将树莓派的 UART 针脚连接到个人电脑（下面简称 PC）上。</p>
<p>UART 的端口至少有 RX、TX 和地线三个针脚。RX 负责读取，TX 负责输出。如果有两个 UART 端口，它们的连接方式如下：</p>
<p><img src="chapter_5/./image/rpi/uart_connect.png" alt="uart" /></p>
<p>注意这里是：<code>usb2ttl(RXD) &lt;-&gt; gpio(TXD)</code> 以及 <code>usb2ttl(TXD) &lt;-&gt; gpio(RXD)</code>。另外注意，不要连接usb2tt 上的电源线到树莓派，小心烧坏树莓派。</p>
<p><strong>uart 协议层</strong></p>
<p>协议层中，规定了数据包的内容，它由起始位、主体数据、校验位以及停止位组成，通信双方的数据包格式要约定一致才能正常收发数据 。</p>
<ul>
<li>波特率：异步通信中由于没有时钟信号，所以2个通信设备需约定好波特率，常见的有4800、9600、115200等。</li>
<li>通信的起始和停止信号：串口通信的一个数据包从起始信号开始，知道停止信号结束。数据包的起始信号由一个逻辑0的数据位表示，而数据包的停止信号可由0.5、1、1.5或2个逻辑1的数据位表示，只要双方约定一致即可。</li>
<li>有效数据：在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为8位或9位长。</li>
<li>数据校验：在有效数据之后，有一个可选的数据校验位。由于数据通信相对容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。校验方法有奇校验(odd)、偶校验(even)、0校验(space)、1校验(mark)以及无校验(noparity)。</li>
<li>奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个 8 位长的有效数据为：01101001，此时总共有 4 个“1”，为达到奇校验效果，校验位为“1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位。偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4 个，所以偶校验位为“0”。0 校验是不管有效数据中的内容是什么，校验位总为“0”，1 校验是校验位总为“1”</li>
</ul>
<p><strong>uart 波特率计算</strong></p>
<p>公式：</p>
<p><img src="chapter_5/./image/rpi/baud.png" alt="baud" /></p>
<p>其中，<code>fck</code>为 USART 时钟， <code>USARTDIV</code> 是一个存放在波特率寄存器(USART_BRR)的一个无符号定点数。其中 <code>DIV_Mantissa[11:0]</code>位定义 USARTDIV 的整数部分，<code>DIV_Fraction[3:0]</code>位定义 USARTDIV 的小数部分。</p>
<p>例如：<code>DIV_Mantissa=24(0x18)</code>，<code>DIV_Fraction=10(0x0A)</code>，此时 USART_BRR 值为<code>0x18A</code>；那么USARTDIV的小数位<code>10/16=0.625</code>；整数位24，最终USARTDIV的值为<code>24.625</code>。</p>
<p>波特率的常用值有 <code>2400</code>、<code>9600</code>、<code>19200</code>、<code>115200</code>。</p>
<p>如何设定寄存器值得到波特率的值?</p>
<p>假设：串口设置为<code>961200  8N1</code>，即 波特率为 961200，8数据位，N表示没有校验位，1位停止位。</p>
<p>而在内核 <code>config.txt</code>中将时钟设置为 <code>48MHZ</code>（<code>init_uart_clock=48000000</code>）。</p>
<p>那么波特率（baud）计算为: <code>(48_000_000 / 16) / 921_600 = 3.2552083</code>。这意味着整数部分（DIV_Mantissa）为<code>3</code>，小数部分是<code>0.2552083</code>。</p>
<p>根据PL011技术参考手册进行的 DIV_Fraction计算： <code>INTEGER( (0.2552083 * 64) + 0.5 ) = 16</code>。<code>INTEGER</code>代表取整。</p>
<p>因此生成的波特率分频器（baud rate divider）为 <code>3 + 16/64 = 3.25</code>，那么生成的波特率是<code>48_000_000 / (16 * 3.25) = 923_077</code>。误差率为 <code>((923_077 - 921_600) / 921_600) * 100 = 0.16%</code>。</p>
<p>那么反过来，如果想用波特率为 <code>115200 8N1</code>，则：</p>
<ul>
<li>整数部分：<code>(48000000/16)/115200 = 26.0416666667</code>。</li>
<li>小数部分： <code>INTEGER((0.0416666667 * 64) + 0.5) = 3</code></li>
</ul>
<p>设置正确的波特率比较重要。</p>
<h3><a class="header" href="#树莓派启动流程" id="树莓派启动流程">树莓派启动流程</a></h3>
<p>树莓派在设计的时候，为了节省成本，没有使用掉电非易失性存储介质，也就在板子上不能找到相关的flash。这样芯片启动的程序只能放在sd卡里面了。本来U盘启动也是一种方式，但是树莓派4代之前的设计并不是很好，导致这种启动方式不可以使用。树莓派4也有一些尝试，但是目前树莓派4最主流的方式还是使用SD卡启动。</p>
<p>Raspberry Pi 4具有一个SPI连接的EEPROM（4MBits / 512KB）。其中包含用于启动系统的代码，并替换了先前在SD卡的启动分区中找到的<code>bootcode.bin</code>。如果你的树莓派4通电了但是一直无法启动系统，且绿灯常亮不闪，需要检查两种情况：</p>
<ol>
<li>有没有插入 sd 卡。</li>
<li>如果有sd卡，那么就是EEPROM被损坏了。你需要重新格式化sd卡，并去官网下载Recovery固件修复即可。</li>
</ol>
<p>在树莓派裸机实验中，从 sd 卡启动系统必须包含必要的文件：</p>
<ol>
<li><code>bootcode.bin</code> （树莓派4不需要，之前的需要）。</li>
<li><code>config.txt</code></li>
<li><code>kernel8.img</code>，内核镜像</li>
<li><code>start4.elf</code></li>
<li><code>bcm2711-rip-4.dtb</code></li>
</ol>
<p>启动流程：</p>
<ol>
<li>芯片上电，执行固化在内部的 <code>first-stage bootloader</code>，用于加载sd卡中的<code>bootcode.bin</code>文件。但是在树莓派4上，不需要这个文件，因为有了有了SPI的EEPROM。</li>
<li>启动 GPU。ARM Cortex-A72 Core处于standby状态，VideoCore IV GPU Core负责启动系统。</li>
<li>将<code>bootcode.bin</code>读取到了128K大小的二级缓存(L2 Cache)中。开始执行<code>bootcode.bin</code>代码。用于初始化RAM，并且把start4.elf加载到内存中，并且去读取config.txt中的配置信息，设置这些配置信息。当然，树莓派4就没有<code>bootcode.bin</code>什么事了。</li>
<li><code>bcm2711-rpi-4-b.dtb</code>文件也是需要的，如果不存在也会影响串口的输出，也就是只会有乱码输出。所以推测start4.elf文件也会去读取设备树文件，然后设置一些基本的参数。</li>
</ol>
<p><strong>config.txt 配置信息</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enable_uart=1 // 表示使用的是miniUART
arm_64bit=0 // 告诉arm要启动的程序是32位的
core_freq=250 // 设置arm的频率
kernel=kernel7.img // 表示从start4.elf执行的程序是哪一个
kernel_address=0x8000 // 表示需要执行的内存地址，这个地址就是裸机程序在链接时的入口地址
<span class="boring">}
</span></code></pre></pre>
<p>这些配置并不是每个都必须，主要看实际情况。前期理解芯片的启动过程有助于对后面编写裸机代码的分析。</p>
<p><strong>重要</strong></p>
<p>以上概念，需要配合本章代码和真实的树莓派实机来验证才能有更深刻的领会。</p>
<h2><a class="header" href="#代码释意" id="代码释意">代码释意</a></h2>
<p>第五章算是一个里程碑。</p>
<p>前四章完成了从树莓派裸机到建立 Rust 执行环境，但都是基于QEMU。从第五章开始支持真实的树莓派执行内核代码。</p>
<p>所以，为了和真实的树莓派通信，我们需要实现两个驱动程序。</p>
<h3><a class="header" href="#引导程序" id="引导程序">引导程序</a></h3>
<p>引导程序基本和上一章代码一样。只是在 <code>src/_arch/aarch64/cpu.rs</code> 里增加了针对树莓派3的相关代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use asm::nop;

/// Spin for `n` cycles.
#[cfg(feature = &quot;bsp_rpi3&quot;)]
#[inline(always)]
pub fn spin_for_cycles(n: usize) {
    for _ in 0..n {
        asm::nop();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个后面会用到。此处使用条件编译，指定<code>bsp_rpi3</code> feature。使用汇编的<code>nop</code>操作实现cpu 空等待。</p>
<h3><a class="header" href="#内核初始化" id="内核初始化">内核初始化</a></h3>
<p>打开 <code>src/main.rs</code> ，看到 <code>kernel_init</code> 函数有了很大变化。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 因为只有单核（core0）被激活执行初始化代码，能保证正确执行顺序，所以现在是安全的
/// # Safety
///
/// - Only a single core must be active and running this function.
/// - The init calls in this function must appear in the correct order.
unsafe fn kernel_init() -&gt; ! {
    // 此处增加了 驱动管理
    use driver::interface::DriverManager;
    // 迭代驱动实例初始化，如果失败则 panic
    for i in bsp::driver::driver_manager().all_device_drivers().iter() {
        if let Err(x) = i.init() {
            panic!(&quot;Error loading driver: {}: {}&quot;, i.compatible(), x);
        }
    }
    // 
    bsp::driver::driver_manager().post_device_driver_init();
    // println! is usable from here on.

    // 这个是安全的函数
    // Transition from unsafe to safe.
    kernel_main()
}

/// The main function running after the early init.
fn kernel_main() -&gt; ! {
    use bsp::console::console;
    use console::interface::All;
    use driver::interface::DriverManager;

    println!(
        &quot;[0] {} version {}&quot;,
        env!(&quot;CARGO_PKG_NAME&quot;),
        env!(&quot;CARGO_PKG_VERSION&quot;)
    );
    println!(&quot;[1] Booting on: {}&quot;, bsp::board_name());

    // 打印驱动加载过程
    println!(&quot;[2] Drivers loaded:&quot;);
    for (i, driver) in bsp::driver::driver_manager()
        .all_device_drivers()
        .iter()
        .enumerate()
    {
        println!(&quot;      {}. {}&quot;, i + 1, driver.compatible());
    }

    println!(
        &quot;[3] Chars written: {}&quot;,
        bsp::console::console().chars_written()
    );

    // 下面打印回显信息
    println!(&quot;[4] Echoing input now&quot;);

    // 进入回显模式之前，请丢弃所有接收到的噪音字符
    // Discard any spurious received characters before going into echo mode.
    console().clear_rx();
    loop {
        let c = bsp::console::console().read_char();
        bsp::console::console().write_char(c);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#内存映射" id="内存映射">内存映射</a></h3>
<p>MMIO 映射物理内存代码被定义在 <code>src/bsp/raspberrypi/memory.rs</code>中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//--------------------------------------------------------------------------------------------------
// Public Definitions
//--------------------------------------------------------------------------------------------------

/// The board's physical memory map.
#[rustfmt::skip]
pub(super) mod map {

    pub const GPIO_OFFSET:         usize = 0x0020_0000;
    pub const UART_OFFSET:         usize = 0x0020_1000;

    /// Physical devices.
    #[cfg(feature = &quot;bsp_rpi3&quot;)]
    pub mod mmio {
        use super::*;

        pub const START:            usize =         0x3F00_0000;
        pub const GPIO_START:       usize = START + GPIO_OFFSET;
        pub const PL011_UART_START: usize = START + UART_OFFSET;
    }

    // 注意，树莓派4 的物理内存基址为 0xFE00_0000 （前置知识有描述）
    /// Physical devices.
    #[cfg(feature = &quot;bsp_rpi4&quot;)]
    pub mod mmio {
        use super::*;

        pub const START:            usize =         0xFE00_0000;
        pub const GPIO_START:       usize = START + GPIO_OFFSET;
        pub const PL011_UART_START: usize = START + UART_OFFSET;
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#驱动" id="驱动">驱动</a></h3>
<p>在看 <code>src/bsp/raspberrypi.rs</code> 代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//--------------------------------------------------------------------------------------------------
// Global instances
// 这里定义俩全局静态变量 GPIO 和 PL011_UART ，用于持有相应的基址。
// --------------------------------------------------------------------------------------------------
use super::device_driver;

static GPIO: device_driver::GPIO =
    unsafe { device_driver::GPIO::new(memory::map::mmio::GPIO_START) };

static PL011_UART: device_driver::PL011Uart =
    unsafe { device_driver::PL011Uart::new(memory::map::mmio::PL011_UART_START) };

//--------------------------------------------------------------------------------------------------
// Public Code
//--------------------------------------------------------------------------------------------------

/// Board identification.
pub fn board_name() -&gt; &amp;'static str {
    #[cfg(feature = &quot;bsp_rpi3&quot;)]
    {
        &quot;Raspberry Pi 3&quot;
    }

    #[cfg(feature = &quot;bsp_rpi4&quot;)]
    {
        &quot;Raspberry Pi 4&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来我们看一下 <code>src/driver.rs</code> 代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 为驱动定义一个 interface 模块，当命名空间使用
// 该模块定义了两个 trait，规范了驱动的行为 和 管理操作
/// Driver interfaces.
pub mod interface {

    /// Device Driver functions.
    pub trait DeviceDriver {
        // 设备树基本属性之一，用于指定兼容的系统
        /// Return a compatibility string for identifying the driver.
        fn compatible(&amp;self) -&gt; &amp;'static str;


        // 这段 Unsafe Rust 代码写的很标准
        // 初始化函数 init 为 unsafe 操作，因为在初始化的时候，驱动可能会对整个系统产生影响，所以这里加上 `#Safety` 注释来说明这种情况，并且为函数加上 `unsafe` 标签。
        // 整个函数是由内核调用以启动设备
        /// Called by the kernel to bring up the device.
        ///
        /// # Safety
        ///
        /// - During init, drivers might do stuff with system-wide impact.
        unsafe fn init(&amp;self) -&gt; Result&lt;(), &amp;'static str&gt; {
            Ok(())
        }
    }

    /// Device driver management functions.
    /// `BSP` 应该提供一个全局实例
    /// The `BSP` is supposed to supply one global instance.
    pub trait DriverManager {
        // 返回所有实例化驱动的引用集合（切片）
        // 该函数返回 DeviceDriver trait对象，用 `'static`是因为该trait中方法返回都是 `'static str`。
        /// Return a slice of references to all `BSP`-instantiated drivers.
        ///
        /// # Safety
        /// 设备的顺序是调用`DeviceDriver::init()`的顺序
        /// - The order of devices is the order in which `DeviceDriver::init()` is called.
        fn all_device_drivers(&amp;self) -&gt; &amp;[&amp;'static (dyn DeviceDriver + Sync)];

        // 驱动程序初始化后运行的初始化代码
        /// Initialization code that runs after driver init.
        ///
        /// For example, device driver code that depends on other drivers already being online.
        fn post_device_driver_init(&amp;self);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>具体的驱动代码实现在 <code>src/bsp/device_driver/bcm.rs</code> 模块中。</p>
<p>先来看一下 <code>src/bsp/device_driver/common.rs</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Common device driver code.

use core::{marker::PhantomData, ops};

//--------------------------------------------------------------------------------------------------
// Public Definitions
//--------------------------------------------------------------------------------------------------
// 对 MMIO 指针地址做了一个 Rust 包装，此处引入 `PhantomData&lt;fn() -&gt; T&gt;`，为的保证只能传入 `'static`的引用。
pub struct MMIODerefWrapper&lt;T&gt; {
    start_addr: usize,
    phantom: PhantomData&lt;fn() -&gt; T&gt;,
}

//--------------------------------------------------------------------------------------------------
// Public Code
//--------------------------------------------------------------------------------------------------

impl&lt;T&gt; MMIODerefWrapper&lt;T&gt; {
    /// Create an instance.
    pub const unsafe fn new(start_addr: usize) -&gt; Self {
        Self {
            start_addr,
            phantom: PhantomData,
        }
    }
}

// 为 `MMIODerefWrapper&lt;T&gt;` 实现 Deref ，作为智能指针使用，返回一个引用
impl&lt;T&gt; ops::Deref for MMIODerefWrapper&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        unsafe { &amp;*(self.start_addr as *const _) }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>再看 <code>src/bsp/device_driver/bcm/bcm2xxx_gpio.rs</code>，这是 GPIO 驱动的具体实现。下面摘录一些只和树莓派4b相关的关键代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::{
    bsp::device_driver::common::MMIODerefWrapper, driver, synchronization,
    synchronization::NullLock,
};
// 此处用到了 `register-rs` 库，是一个类型安全的 MMIO 和 CPU 寄存器访问的库。
use register::{mmio::*, register_bitfields, register_structs};


// GPIO registers.
// 下面连接是 GPIO 寄存器的一些规格文档
// Descriptions taken from
// - https://github.com/raspberrypi/documentation/files/1888662/BCM2837-ARM-Peripherals.-.Revised.-.V2-1.pdf
// - https://datasheets.raspberrypi.org/bcm2711/bcm2711-peripherals.pdf

// Raspberry Pi 3/4 具有两个UART器件：PL011 UART和 mini UART。 
// 而 PL011 UART连接到蓝牙模块，而 mini UART 用作主要 UART。
// 但我们可以初始化 GPIO 寄存器来直接使用 PL011 UART 来替代 mini UART。

// 此宏为 `register-rs` 库提供，用于定义 MMIO 寄存器
register_bitfields! {
    u32,

    // 为了使用 PL011 UART 
    // 需要将 GPFSEL1寄存器 的 FSEL14 和 FSEL15 位字段设置为与 AltFunc0 功能相对应的 0b100 地址。
    /// GPIO Function Select 1
    GPFSEL1 [
        /// Pin 15
        FSEL15 OFFSET(15) NUMBITS(3) [
            Input = 0b000,
            Output = 0b001,
            AltFunc0 = 0b100  // PL011 UART RX

        ],

        /// Pin 14
        FSEL14 OFFSET(12) NUMBITS(3) [
            Input = 0b000,
            Output = 0b001,
            AltFunc0 = 0b100  // PL011 UART TX
        ]
    ],

    // 为了使用 PL011 UART 
    // 通过将GPPUD寄存器设置为0
    // 树莓派3需要，此处省略
    // ... ...

    // 为了使用 PL011 UART 
    // 将GPIO_PUP_PDN_CNTRL_REG0 寄存器 GPIO_PUP_PDN_CNTRL15 和 GPIO_PUP_PDN_CNTRL14位字段设置为1来关闭 Pullup 来启用这些引脚。 
    /// GPIO Pull-up / Pull-down Register 0
    ///
    /// BCM2711 only.
    GPIO_PUP_PDN_CNTRL_REG0 [
        /// Pin 15
        GPIO_PUP_PDN_CNTRL15 OFFSET(30) NUMBITS(2) [
            NoResistor = 0b00,
            PullUp = 0b01
        ],

        /// Pin 14
        GPIO_PUP_PDN_CNTRL14 OFFSET(28) NUMBITS(2) [
            NoResistor = 0b00,
            PullUp = 0b01
        ]
    ]
}

register_structs! {
    #[allow(non_snake_case)]
    RegisterBlock {
        (0x00 =&gt; _reserved1),
        (0x04 =&gt; GPFSEL1: ReadWrite&lt;u32, GPFSEL1::Register&gt;),
        (0x08 =&gt; _reserved2),
        (0x94 =&gt; GPPUD: ReadWrite&lt;u32, GPPUD::Register&gt;),
        (0x98 =&gt; GPPUDCLK0: ReadWrite&lt;u32, GPPUDCLK0::Register&gt;),
        (0x9C =&gt; _reserved3),
        (0xE4 =&gt; GPIO_PUP_PDN_CNTRL_REG0: ReadWrite&lt;u32, GPIO_PUP_PDN_CNTRL_REG0::Register&gt;),
        (0xE8 =&gt; @END),
    }
}

// 关联的MMIO寄存器的抽象
/// Abstraction for the associated MMIO registers.
type Registers = MMIODerefWrapper&lt;RegisterBlock&gt;;

//--------------------------------------------------------------------------------------------------
// Public Definitions
//--------------------------------------------------------------------------------------------------

pub struct GPIOInner {
    registers: Registers,
}

// Export the inner struct so that BSPs can use it for the panic handler.
pub use GPIOInner as PanicGPIO;

// GPIO 硬件抽象
/// Representation of the GPIO HW.
pub struct GPIO {
    inner: NullLock&lt;GPIOInner&gt;,
}

//--------------------------------------------------------------------------------------------------
// Public Code
//--------------------------------------------------------------------------------------------------

impl GPIOInner {
    /// Create an instance.
    ///
    /// # Safety
    /// 此处用户必须确保提供正确的 MMIO start 地址，所以用 unsafe 标记函数
    /// - The user must ensure to provide a correct MMIO start address.
    pub const unsafe fn new(mmio_start_addr: usize) -&gt; Self {
        Self {
            registers: Registers::new(mmio_start_addr),
        }
    }

    // 关闭引脚 14 和 15 的 pull-up/down 
    /// Disable pull-up/down on pins 14 and 15.
    #[cfg(feature = &quot;bsp_rpi4&quot;)]
    fn disable_pud_14_15_bcm2711(&amp;mut self) {
        self.registers.GPIO_PUP_PDN_CNTRL_REG0.write(
            GPIO_PUP_PDN_CNTRL_REG0::GPIO_PUP_PDN_CNTRL15::PullUp
                + GPIO_PUP_PDN_CNTRL_REG0::GPIO_PUP_PDN_CNTRL14::PullUp,
        );
    }

    // 将  PL011 UART 映射为标准输出
    /// Map PL011 UART as standard output.
    ///
    /// TX to pin 14
    /// RX to pin 15
    pub fn map_pl011_uart(&amp;mut self) {
        // Select the UART on pins 14 and 15.
        self.registers
            .GPFSEL1
            .modify(GPFSEL1::FSEL15::AltFunc0 + GPFSEL1::FSEL14::AltFunc0);

        // Disable pull-up/down on pins 14 and 15.
        #[cfg(feature = &quot;bsp_rpi3&quot;)]
        self.disable_pud_14_15_bcm2837();

        #[cfg(feature = &quot;bsp_rpi4&quot;)]
        self.disable_pud_14_15_bcm2711();
    }
}

impl GPIO {
    /// Create an instance.
    ///
    /// # Safety
    ///
    /// - The user must ensure to provide a correct MMIO start address.
    pub const unsafe fn new(mmio_start_addr: usize) -&gt; Self {
        Self {
            inner: NullLock::new(GPIOInner::new(mmio_start_addr)),
        }
    }

    /// Concurrency safe version of `GPIOInner.map_pl011_uart()`
    pub fn map_pl011_uart(&amp;self) {
        self.inner.lock(|inner| inner.map_pl011_uart())
    }
}

//------------------------------------------------------------------------------
// OS Interface Code
//------------------------------------------------------------------------------
use synchronization::interface::Mutex;

// 注意，这里还有个 init 方法使用默认实现。
impl driver::interface::DeviceDriver for GPIO {
    fn compatible(&amp;self) -&gt; &amp;'static str {
        &quot;BCM GPIO&quot;
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>接下来看 <code>src/bsp/device_driver/bcm/bcm2xxx_pl011_uart.rs</code>中 PL011 uart 的驱动实现。</p>
<p>只摘录关键代码聊聊。定义寄存器和 GPIO 驱动类似。有一些关于 uart 读取的代码就没贴出来。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use register::{mmio::*, register_bitfields, register_structs};

impl PL011UartInner {
    // ... ...

    pub fn init(&amp;mut self) {
        self.flush();

        // Turn the UART off temporarily.
        self.registers.CR.set(0);

        // Clear all pending interrupts.
        self.registers.ICR.write(ICR::ALL::CLEAR);

        // Set the baud rate, 8N1 and FIFO enabled.
        // 这里设置波特率，关于波特率的计算可以查看本章前置知识
        // 这里有一个坑：
        //    现在这个注释的波特率设置最终值为 `921600`，
        //    但是实际在真实树莓派硬件执行的时候，
        //    有的 utf2ttl 可能不支持这么高的波特率，所以可能会出现乱码。
        //    如果遇到乱码输出可以尝试将波特率改为 115200 ，对应设置（26,3）
        // self.registers.IBRD.write(IBRD::BAUD_DIVINT.val(3));
        // self.registers.FBRD.write(FBRD::BAUD_DIVFRAC.val(16));
         self.registers.IBRD.write(IBRD::BAUD_DIVINT.val(26));
        self.registers.FBRD.write(FBRD::BAUD_DIVFRAC.val(3));
        self.registers
            .LCR_H
            .write(LCR_H::WLEN::EightBit + LCR_H::FEN::FifosEnabled);

        // Turn the UART on.
        self.registers
            .CR
            .write(CR::UARTEN::Enabled + CR::TXE::Enabled + CR::RXE::Enabled);
    }
}

// ... ...

impl driver::interface::DeviceDriver for PL011Uart {
    fn compatible(&amp;self) -&gt; &amp;'static str {
        &quot;BCM PL011 UART&quot;
    }

    // 这里使用了同步锁，在当前示例下，不需要这个也可以
    // 因为内核初始化的时候只绑定了单核
    unsafe fn init(&amp;self) -&gt; Result&lt;(), &amp;'static str&gt; {
        self.inner.lock(|inner| inner.init());

        Ok(())
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#驱动管理" id="驱动管理">驱动管理</a></h3>
<p>驱动定义好以后，就可以管理了。看 <code>src/bsp/raspberrypi/driver.rs</code> 中代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定义设备驱动管理器，这里是两个元素的固定大小数组
/// Device Driver Manager type.
struct BSPDriverManager {
    device_drivers: [&amp;'static (dyn DeviceDriver + Sync); 2],
}

// 创建一个静态常量，持有 GPIO 和 PL011_UART 的引用地址
static BSP_DRIVER_MANAGER: BSPDriverManager = BSPDriverManager {
    device_drivers: [&amp;super::GPIO, &amp;super::PL011_UART],
};

//--------------------------------------------------------------------------------------------------
// Public Code
//--------------------------------------------------------------------------------------------------

/// Return a reference to the driver manager.
pub fn driver_manager() -&gt; &amp;'static impl driver::interface::DriverManager {
    &amp;BSP_DRIVER_MANAGER
}

//------------------------------------------------------------------------------
// OS Interface Code
//------------------------------------------------------------------------------
use driver::interface::DeviceDriver;

// 实现 DriverManager trait
impl driver::interface::DriverManager for BSPDriverManager {
    fn all_device_drivers(&amp;self) -&gt; &amp;[&amp;'static (dyn DeviceDriver + Sync)] {
        &amp;self.device_drivers[..]
    }

    // 在 GPIO 启动以后执行 映射 pl011_uart 引脚
    fn post_device_driver_init(&amp;self) {
        // Configure PL011Uart's output pins.
        super::GPIO.map_pl011_uart();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#代码在真实树莓派上执行过程" id="代码在真实树莓派上执行过程">代码在真实树莓派上执行过程</a></h2>
<p>如果没有树莓派，在 qemu 也可以。但是如果在真实硬件上启动内核，需要注意避开一些坑。我分享一下我的流程：</p>
<ol>
<li>在测试内核之前，先安装树莓派官方的 Respbian OS 操作系统。这样做可以完整测试树莓派硬件的功能完整性，为后续启动 rust 实现的内核排坑。</li>
<li>如果遇到无法启动 OS 的情况，观察绿灯是否闪烁，排除是不是EEPROM损坏了。</li>
<li>如果遇到输出字符乱码，请确认内核设置的波特率，和你的串口调试工具波特率是否一致。</li>
<li>确保 usb2ttl RX/TX 连线对接正确。并且 usb2ttl 驱动安装正确。</li>
<li>烧录工具推荐：balenaetcher。官方推荐的不太好使。如果展示烧录失败，可以点击 skip 跳过 验证那一环节。</li>
<li>串口输出推荐使用 Rust 实现的这个工具：<a href="https://github.com/umaYnit/rust-serial-tool">https://github.com/umaYnit/rust-serial-tool</a>。不推荐 官方教程自带的这个 Ruby 实现，因为在 mac m1下有点坑。</li>
</ol>
<h2><a class="header" href="#小结-4" id="小结-4">小结</a></h2>
<p>前五章，以一个非常短小精悍的 Rust 内核程序，为我们展示了如何在树莓派裸机上运行 Rust 代码。为后面的操作系统实现奠定了初步的基础。</p>
<p>在实际树莓派硬件上执行的时候，遇到坑不要轻易放弃，多半是因为知识经验不足导致的，此时正是学习的机会。</p>
<h2><a class="header" href="#参考-5" id="参考-5">参考</a></h2>
<ol>
<li><a href="https://www.raspberrypi.com.tw/tutorial/faq/">https://www.raspberrypi.com.tw/tutorial/faq/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/136806005">https://zhuanlan.zhihu.com/p/136806005</a></li>
<li><a href="https://github.com/bztsrc/raspi3-tutorial">https://github.com/bztsrc/raspi3-tutorial</a></li>
<li><a href="https://datasheets.raspberrypi.org/bcm2711/bcm2711-peripherals.pdf">https://datasheets.raspberrypi.org/bcm2711/bcm2711-peripherals.pdf</a></li>
<li><a href="https://e-mailky.github.io/2016-12-06-dts-introduce">https://e-mailky.github.io/2016-12-06-dts-introduce</a></li>
</ol>
<h1><a class="header" href="#透过-rust-探索系统的本原泛型" id="透过-rust-探索系统的本原泛型">透过 Rust 探索系统的本原：泛型</a></h1>
<p>作者：陈天 / 后期编辑：张汉东</p>
<blockquote>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/SJsEurfZr4TG-I3rncid5A">https://mp.weixin.qq.com/s/SJsEurfZr4TG-I3rncid5A</a></p>
</blockquote>
<hr />
<p>在 Fundamentals of Generic Programming[1] 里，Alexander Stepanov（泛型概念的创立者）用一段优雅的文字描绘了计算机技术不断泛化（generalized）的历史：</p>
<p><img src="chapter_5/./image/rust-to-system/1.png" alt="1" /></p>
<p>他说，目前我们走了三步：</p>
<ul>
<li>第一步，通用的计算机体系结构：将内存视作一组连续可寻址的空间</li>
<li>第二步，通用的计算机语言：使用指针作为统一的引用类型的标识符</li>
<li>第三步，泛型编程</li>
</ul>
<p>今天我们就来讲讲泛型编程。</p>
<p>广义的泛型编程分为两部分：数据类型的泛型（Generic Data Types）或者说参数化类型（Parameterized Type），以及泛型函数（Generic Function）。</p>
<h2><a class="header" href="#参数化类型" id="参数化类型">参数化类型</a></h2>
<p>我们先看参数化类型。参数化类型是指定义数据结构或者类型的时候，不指定具体的类型，而是将其作为参数使用，使得该定义对各种具体类型都适用。参数化类型的好处是语言能够更具表达力（某种程度上接近动态类型语言），同时还保持了完整的静态类型安全。</p>
<p>打个不那么特别恰当，但比较容易理解的比方：类型之于数据，如同泛型之于一般类型。我们从具体的数据中抽象出核心的要素，构造出可以囊括这些数据的类型。比如 <code>u8</code>，囊括了 0-255 所有可能的数值。而我们进一步再从类型中抽取出通用的要素，构造出可以囊括这些类型的元类型。比如所有可以做加法操作的元类型 <code>Add</code>，它囊括了 <code>u32</code>，<code>f64</code>，<code>usize</code> 甚至 <code>Complex</code> 等各种可以进行加法操作的数据类型。</p>
<p>我们看一个实际的例子。</p>
<p>我们要实现一个数据结构，它可以从文件中读取一段数据，放入缓存中，然后对数据做一系列的处理。我们可以很容易定义出这样的结构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyReader {
  reader: File,
  buf: Vec&lt;u8&gt;,
}

impl MyReader {
  pub fn process(&amp;mut self) {
    self.reader.read(&amp;mut self.buf);
    // further processing on buf
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>然而， 如果需求不仅仅是从文件读取，还可能从网络，从一个加密数据流，甚至从磁带上读取，做同样的缓存和处理，那么，我们不得不为每一种需求使用一个几乎相同的数据结构。如果使用参数化类型，我们可以这样定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyReader&lt;R&gt; {
  reader: R,
  buf: Vec&lt;u8&gt;
}

impl&lt;R&gt; MyReader&lt;R&gt; {
  pub fn process(&amp;mut self) {
    self.reader.read(&amp;mut self.buf);
    // further processing on buf
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>从代码中，我们可以更加深刻地领会到上文所说的「参数化类型的好处是语言能够更具表达力，同时还保持了完整的静态类型安全」。它是个非常强大的工具。</p>
<p>但这样给编译器出了一个难题：编译器在编译时如何得知 <code>reader</code> 可以执行 <code>read()</code> 操作呢？</p>
<p>不能。因为在这里，参数 R 可以是任何类型，而大多数类型并不直接支持 <code>read()</code> 操作。所以，这里我们需要对参数 R 进行限制。这个过程和函数的定义很类似：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a, b) // error - 我们不知道在函数调用时如何为 a, b 分配内存，因而需要对 a, b 做进一步限制
fn add(a: usize, b: usize) // ok - 现在我们知道 a, b 的限制（内存大小，允许的操作等）
<span class="boring">}
</span></code></pre></pre>
<p>对类型的参数的限制（bound），不同的语言使用的方式不同，Java 可以要求 <code>&lt;R extends ...&gt;</code>，Rust 使用 trait，而 Swift 使用 protocol，但大家的目标是一致的：编译器需要足够的信息来决定上述的代码是否可以编译通过。</p>
<p>如果你用 rust 编译器编译上述代码，编译器会给出详尽的错误：</p>
<p><img src="chapter_5/./image/rust-to-system/2.png" alt="2" /></p>
<p>它甚至为你推荐合适的 trait 来限制 R，真是比女（男）朋友还要更懂你。</p>
<h2><a class="header" href="#泛型函数" id="泛型函数">泛型函数</a></h2>
<h3><a class="header" href="#静态分派" id="静态分派">静态分派</a></h3>
<p>函数操作的对象是类型，当数据类型使用泛型时，使用其作为参数或者返回值的函数，也被称之为泛型函数，比如：</p>
<pre><pre class="playground"><code class="language-rust">fn generic&lt;T&gt;(t: T) {
  todo!()
}

fn main() {
  generic::&lt;u8&gt;(42);
  generic::&lt;&amp;str&gt;(&amp;&quot;hello&quot;);
}
</code></pre></pre>
<p>在 <code>main()</code> 对 <code>generic()</code> 的两次调用中，第一次使用了 <code>u8</code> 类型，第二次使用了 <code>&amp;str</code> 类型。编译器在编译时就能捕获到使用的类型，从而进行对应的处理，这被称之为静态分派（static dispatch）。不同语言对静态分派的处理很不一样。在 Rust 中，处理的方法叫 monomorphization （单态化）—— 说人话就是编译器会为代码中所有使用到的类型编译出一个副本。对于这个例子，你可以想象编译器生成了类似于如下代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  generic_int(42);
  generic_ref_str(&amp;&quot;hello&quot;);
}
</code></pre></pre>
<p>除了 Rust 外，C++ 也使用了单态化来处理泛型函数，只不过 C++ 使用的 template 并不携带类型，在编译过程中会被直接展开。</p>
<p>Java 对泛型的处理方式和 Rust 不一样。Java 会擦除（erase）类型，编译出的代码类似：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>void main() {
  generic((Object) 42);
  generic((Object) &quot;hello&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>显然，Java 的方式会带来运行时性能上的损失（需要做在具体类型和 Object 间来回做额外的 typecast），并且，由于类型被擦除，所以很难为每种泛型编译的结果做特定的优化。</p>
<h3><a class="header" href="#动态分派" id="动态分派">动态分派</a></h3>
<p>静态分派固然很好，效率很高，但很多时候，类型可能很难在编译时决定。比如我要撰写一个格式化工具，这个在 IDE 里很常见。我们可以定义一个 <code>Formatter</code> 接口，然后创建一系列实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Formatter {
    fn format(&amp;self, input &amp;mut str) -&gt; bool;
}

struct MarkdownFormatter;
impl Formatter for MarkdownFormatter {
    fn format(&amp;self, input &amp;mut str) -&gt; bool { todo!() }
}

struct RustFormatter;
impl Formatter for RustFormatter {
    fn format(&amp;self, input &amp;mut str) -&gt; bool { todo!() }
}

struct HtmlFormatter;
impl Formatter for HtmlFormatter {
    fn format(&amp;self, input &amp;mut str) -&gt; bool { todo!() }
}
<span class="boring">}
</span></code></pre></pre>
<p>使用什么格式化方法，只有当我们打开文件，分析出文件内容之后才能确定，我们并无法在编译期给定一个具体类型，使其满足如下函数（一个文件可能有一到多个格式化工具，比如一个 markdown 文件里有 rust 代码，因而需要 <code>MarkdownFormatter</code> 和 <code>RustFormatter</code> 来格式化，所以这里我们使用一个 <code>Vec</code> 来提供所有需要的格式化工具）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn format(input: &amp;mut str, formatters: Vec&lt;???&gt;) {
    for formatter in formatters {
        formatter.format(input);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>正常情况下，<code>Vec&lt;&gt;</code> 容器里的类型需要是一致的，但此处我们无法给定一个一致的类型。</p>
<p>所以我们需要有一种手段，告诉编译器，此处我们需要并且仅需要任何实现了 <code>Formatter</code> 接口的数据类型。在 Rust 里，这种类型叫 Trait Object，表现为 <code>&amp;dyn Trait</code> 或者 <code>Box&lt;dyn Trait&gt;</code>。这里，<code>dyn</code> 关键字仅仅是用来帮助更好地区分普通类型和 Trait 类型。于是，上述代码可以写成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn format(input: &amp;mut str, formatters: Vec&lt;Box&lt;dyn Formatter&gt;&gt;) {
    for formatter in formatters {
        formatter.format(input);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样，我们可以在运行时构造一个 <code>Formatter</code> 的列表，传递给 <code>format</code> 函数进行文件的格式化。这就是动态分派（dynamic dispatching）。</p>
<p>Trait Object 虽然是 Rust 独有的概念，但这个概念并不新鲜。我们看看它的实现机理。为了方便介绍，我们以 Rust 标准库里的 <code>Write</code> 接口为例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Write {
  fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
  fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

  fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; { ... }
  ...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Write</code> 接口包含若干个方法，其中 <code>write()</code> 和 <code>flush()</code> 必须实现。标准库中，<code>Vec&lt;T&gt;</code> 实现了 <code>Write</code> 接口。</p>
<p>当我们要使用这个接口做动态分派时，我们可以像如下例子一样，将一个具体类型（concrete type，比如 <code>Vec&lt;u8&gt;</code>）的引用，赋给 <code>Write</code> 接口：</p>
<p><img src="chapter_5/./image/rust-to-system/3.png" alt="3" /></p>
<p>这会生成一个 Trait Object，在上图中，我们可以看到，Trait Object 的底层逻辑不过就是胖指针（fat pointer） —— 一个包含两个指针的数据结构。其中，一个指针指向数据本身，另一个则指向虚函数表（vtable）。在这张表里，包含具体类型的一些信息，如 size，aligment 以及一系列函数指针：</p>
<ul>
<li>这个接口支持的所有方法（比如 <code>write()</code>，<code>flush()</code> ）</li>
<li>具体类型的 drop trait，当 Trait object（比如 <code>Box&lt;dyn Writer&gt;</code> ） 被释放，它用来释放其使用的所有资源。</li>
</ul>
<p>这样，当执行 <code>writer.write()</code> 时，就可以从 vtable 里找到对应的函数指针，执行具体的操作。</p>
<p>所以，Rust 里的 Trait Object，没什么神秘的，它不过是 C++/Java 中大家熟知的 vtable 的一个变体而已。当然，C++/Java 指向 vtable 的指针在编译时放在类结构里，而 Rust 放在 Trait object 中。这也是为什么 Rust 很容易对基本类型（primitive type）做动态分派，而 C++/Java 不行。事实上，Rust 也并不区分基本类型，对 Rust 来说，所有的类型的地位都是一致的。</p>
<p>大多数通过接口实现动态分派的语言，都是通过 vtable 来协助接口方法的动态调用，Golang（interfaces）也是如此。Swift 虽然在很多方面跟 Rust 很类似，但在泛型的支持上，走了一条相对独特的道路：witness table[2]。有空讲 Swift 的时候，我可以专门讲讲 witeness table，很有意思（等不及的看参考资料中的视频吧）。</p>
<p>对于不同语言如何实现静态分派和动态分派，下面这个流程图表述地非常清楚，大家可以仔细研读一下。如果你读懂了这幅图，那么你对泛型函数的了解就足够清晰了：</p>
<p><img src="chapter_5/./image/rust-to-system/4.png" alt="4" /></p>
<p>（来源：Models of Generics and Metaprogramming: Go, Rust, Swift, D and More[4]）</p>
<h2><a class="header" href="#泛型编程的实践" id="泛型编程的实践">泛型编程的实践</a></h2>
<p>泛型编程，与其说是一种技术，不如说是一种思想。它不仅仅是类型参数化，函数泛型化那么简单，背后体现的是程序员的抽象思维能力。抽象思维的能力，和语言无关，和工具无关，它是一种在实践中不断探索，不断学习，不断历练得出的能力。支持泛型的语言并不能帮助你更好地做泛型编程，就好比给我一台斯坦威钢琴，并不意味着我就具备了演奏李斯特《钟》的能力。</p>
<p>下图左边的代码是大家都很熟悉的，估计闭着眼睛也能写出来的 C 语言版本的 <code>binary_search</code> 算法。右边是 Alexander Stepanov 为 C++ STL 初版设计的类似算法（之所以叫 <code>lower_bound</code>，是因为它不仅使用 binary search 返回匹配的结果，在没找到时，还会返回其应该所处的位置）：</p>
<p><img src="chapter_5/./image/rust-to-system/5.png" alt="5" /></p>
<p>可以看到， C 语言版本的算法的实现跟参数的细节绑定得很紧，而 Alex 的 <code>lower_bound</code> 版本，除了参数的抽象化之外，所有的实现细节都被不同的函数替代 —— 在不同的数据结构的上下文中，它们有不同的实现。拿 <code>distance()</code> 来说，对于数组，它是两个 index 之间的距离，对于链表，它是两个节点之间的跳数。在我看来，能够区分哪些是实现细节，哪些是算法的核心要素，并且能够把实现细节延迟到尽可能靠后的阶段（调用者调用时），这才是泛型编程的核心所在。Alan Perlis 在 Epigrams of Programming 里有个精妙的论断：</p>
<blockquote>
<p>Functions delay binding: data structures induce binding. Moral: Structure data data in the programming process.</p>
</blockquote>
<p>我们再看一个例子：客户端和服务器间通过 protobuf 来传递消息，两端约定消息的头四个字节是 protobuf 的长度，之后是 protobuf。我们需要做一个库处理消息的收发：从底层接收一个完整的消息，并反序列化传递给上层，以及上层需要发送消息时，序列化消息，添加长度信息，提交给底层发送出去。</p>
<p>这种需求往往一开始就有确定的底层传输机制，比如 WebSocket，以及确定的上层消息类型。如果照着这样的需求直接处理，很容易把系统做死：上层的消息的变动，会影响消息收发库的设计；底层传输机制的变化（比如另一个项目，改用 HTTP/2），也会影响消息收发库的设计。所以如果一开始没有做好对需求的足够抽象，日后各种变更会让你忙不过来。</p>
<p>我们可以把不变的部分抽取出来：带长度的数据读取/带长度的数据写入，以及序列化，反序列化。至于消息收发时底层的传输机制是什么，我们尽量不去关心；而上层究竟会传递什么样的消息，也不去关心。底层传输，我们可以将其抽象成 Reader / Writer（async 下是 Stream / Sink），上层的消息，我们将其抽象成 Message。接受和发送的数据，可以看做是一个 Frame，里面有不同的格式，于是，我们可以有这样的设计：</p>
<p><img src="chapter_5/./image/rust-to-system/6.png" alt="6" /></p>
<p>如果定义得当，甚至 frame 结构的变化，都可以不必大动干戈就可以很快实现。具体代码大家可以看 [5]。</p>
<h2><a class="header" href="#贤者时刻-5" id="贤者时刻-5">贤者时刻</a></h2>
<p>我在之前的文章中讲过，语言在开发过程形成的世界观极大地影响和限制着语言本身的行为和能力。Rust 为了追求极致的效率（和零成本抽象），在泛型的处理上选择了单态化来处理静态分派，这极大影响了编译速度，同时单态化也意味着 Rust 代码无法很好地以二进制分发，让其他 Rust 代码以 Rust ABI 的方式调用（而非以 C FFI 的方式调用）。这也意味着，即便 Rust 在很多场合能够取代 C，但 Rust 可能永远也无法取代 C 在操作系统应用程序二进制接口 （ABI）中的地位。</p>
<p>本文是上周四我在 Tubi 的有关 Rust 的 BBL 的一个总结和回顾，BBL 的讲稿可以在我的 github: tyrchen/rust-training 里获得，或者点击「阅读原文」查看。很有意思的是，周六（4/30），Jon Gjengset 在他的 Crust of Rust 系列的最新一期，讲了几乎同样的主题：Dispatch and Fat Pointers[6]，感兴趣的同学可以看看那期视频。Jon 的直播期期都是精品，绝对值得花时间学习。</p>
<p>这个系列写到这里，也要告一段落了。原本只是想写个三四篇，没想到前前后后写了八篇。其实要继续写的话，还有很多方向可以写，比如 debug，分布式，状态机等等：</p>
<p><img src="chapter_5/./image/rust-to-system/7png" alt="7" /></p>
<p>不过，生活中不只有 Rust。我的 Flutter 2，开了个头，尚待完成，Swift 和 iOS 开发，还有很多路要走，最近 Elixir 社区涌现了不少让人激动的项目，也有同学想让我聊一聊。所以，我会花些时间聊聊其它内容。大家有什么感兴趣的和软件开发有关的话题，也欢迎和我探讨。</p>
<h2><a class="header" href="#参考资料-8" id="参考资料-8">参考资料</a></h2>
<p>[1] Fundamentals of Generic Programming:</p>
<p>[2] Implementing Swift Generics: <a href="https://youtu.be/ctS8FzqcRug">https://youtu.be/ctS8FzqcRug</a></p>
<p>[3] How Swift Achieved Dynamic Linking Where Rust Couldn't: <a href="https://gankra.github.io/blah/swift-abi/">https://gankra.github.io/blah/swift-abi/</a></p>
<p>[4] Models of Generics and Metaprogramming: Go, Rust, Swift, D and More:  <a href="https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/">https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/</a></p>
<p>[5] async-prost: <a href="https://github.com/tyrchen/async-prost">https://github.com/tyrchen/async-prost</a></p>
<p>[6] Crust of Rust: Dispatch and Fat Pointers: <a href="https://www.youtube.com/watch?v=xcygqF5LVmM">https://www.youtube.com/watch?v=xcygqF5LVmM</a></p>
<p><a href="https://gist.github.com/Kimundi/8391398">https://gist.github.com/Kimundi/8391398</a></p>
<p>语言的设计很多时候也会影响到语言使用的方式。</p>
<p>Swift 使用 witness table 来处理泛型，而 Rust 在编译时为每种使用到的场景复制出专门的代码，这带来一些显著地不同：</p>
<ul>
<li>Rust 编译速度更慢，而 Swift 会快不少</li>
<li>如果你使用别人做的 Rust library，你需要集成源码进行编译，否则泛型将无法使用（你只能以 C FFI 的形式将其集成）；而 Swift 可以允许你使用第三方的二进制，且不影响泛型的功用。</li>
</ul>
<p>从这一点我们也可以看出，Rust 和 Swift 生态的显著不同 —— Swift 在设计上考虑了潜在的商业伙伴上的需求。</p>
<h1><a class="header" href="#github-趋势榜-1" id="github-趋势榜-1">GitHub 趋势榜</a></h1>
<p>编辑：张汉东</p>
<hr />
<p>盘点一下 本月 <a href="https://github.com/trending/rust?since=daily">GitHub 趋势榜上榜的 Rust 项目</a>。</p>
<p>对于上期出现过的项目，就暂时不排到本文里了。</p>
<h2><a class="header" href="#alacritty-跨平台opengl终端模拟器" id="alacritty-跨平台opengl终端模拟器">Alacritty: 跨平台，OpenGL终端模拟器</a></h2>
<p>Alacritty 号称是最快的终端模拟器，最近发布了最新版本。</p>
<p><img src="chapter_5/./image/github/alacritty.png" alt="alacritty" /></p>
<p><a href="https://github.com/alacritty/alacritty">https://github.com/alacritty/alacritty</a></p>
<h2><a class="header" href="#awesome-alternatives-in-rust" id="awesome-alternatives-in-rust">Awesome Alternatives in Rust</a></h2>
<p>各个领域中可以用 Rust 替换的软件实现列表。可以关注或贡献。</p>
<p><a href="https://github.com/TaKO8Ki/awesome-alternatives-in-rust">https://github.com/TaKO8Ki/awesome-alternatives-in-rust</a></p>
<h2><a class="header" href="#git-工具-delta-和-gitui" id="git-工具-delta-和-gitui">Git 工具： delta 和 gitui</a></h2>
<p>Rust实现了有很多出色的终端工具，delta和gitui就是其中两个。</p>
<p><strong>delta: Git 和 Diff 输出的查看器</strong></p>
<p><img src="https://user-images.githubusercontent.com/52205/87230973-412eb900-c381-11ea-8aec-cc200290bd1b.png" alt="delta" /></p>
<p><a href="https://github.com/dandavison/delta">https://github.com/dandavison/delta</a></p>
<p>gitui: Rust 实现的 Git 终端 UI</p>
<p><img src="https://github.com/extrawurst/gitui/raw/master/demo.gif" alt="gitui" /></p>
<p><a href="https://github.com/extrawurst/gitui">https://github.com/extrawurst/gitui</a></p>
<h2><a class="header" href="#regex-正则表达式引擎" id="regex-正则表达式引擎">Regex: 正则表达式引擎</a></h2>
<p>Regex 本月发布了 1.5.4 版。该正则表达式引擎类似于 Perl 的正则引擎，但是缺乏 环视 和 反向引用，因为这两个特性会包含回溯功能，影响正则引擎的性能。如果想使用环视和反向引用可以使用其他第三方库，比如 <a href="https://github.com/fancy-regex/fancy-regex">fancy-regex</a>。</p>
<p><a href="https://github.com/rust-lang/regex">https://github.com/rust-lang/regex</a></p>
<h2><a class="header" href="#materialize-用于实时应用程序的流数据库" id="materialize-用于实时应用程序的流数据库">materialize: 用于实时应用程序的流数据库</a></h2>
<p>Materialize 是基于pg 和 开源Timely Dataflow项目构建 开发的一个可以处理流式数据的平台，同时提供了强大的数据处理能力。最近发布了新版本。 </p>
<p>在无需复杂的数据管道的情况下，只须用标准SQL视图描述计算，然后将Materialize 连接到数据流，就能实现增量计算。 底层的差分数据流引擎能够运行增量计算，从而以最小的延迟，提供一致且准确的结果。经实验，将 Materialize 与 Spring Cloud Stream 以及 Kafka 配合使用，从而在分布式事件驱动的系统中，查询事件流并分析结果。其效果令人满意。</p>
<p>Materialize被称为“第一个真正的流式SQL数据库”。在 2020 年底，Materialize获得由Kleiner Perkins领投的3200万美元B轮投资。</p>
<p><a href="https://github.com/MaterializeInc/materialize">materialize</a></p>
<h2><a class="header" href="#youki--实验性的容器运行时" id="youki--实验性的容器运行时">Youki : 实验性的容器运行时</a></h2>
<p>youki 是根据 <a href="https://github.com/opencontainers/runtime-spec">runtime-spec 规范</a>来实现的，参考 runc。</p>
<p>作者坦言：</p>
<blockquote>
<p>Rust是实现OCI运行时的最佳语言之一。 许多容器工具都是完全用 Go 写的。这是一件非常好的产品。但是，容器运行时需要使用系统调用，这需要用 Go 实现的时候需要一些特殊处理。 这非常棘手（例如，namespaces(7), fork(2)）; 使用Rust，它不是那么棘手，你可以使用系统调用。 此外，与 C 不同，Rust 提供了内存管理的好处。 Rust尚未成为容器领域的主流，但有可能为此领域提供更多贡献。 我希望 youki 成为该领域如何使用的 Rust 的例子之一。</p>
</blockquote>
<p><a href="https://github.com/utam0k/youki">https://github.com/utam0k/youki</a></p>
<h2><a class="header" href="#tree-sitter-rust-实现的解析器生成器" id="tree-sitter-rust-实现的解析器生成器">tree-sitter: Rust 实现的解析器生成器</a></h2>
<p>最近发布了新版本 0.19.5。</p>
<p>它不仅仅是一个解析器生成器工具，还支持增量解析。 它可以为源文件构建一个具体的语法树，并在源文件更新的时候有效更新语法树。该库还依赖了部分 C 代码。</p>
<p>同类型工具还有：<a href="https://github.com/lalrpop/lalrpop">https://github.com/lalrpop/lalrpop</a></p>
<p><a href="https://github.com/tree-sitter/tree-sitter">https://github.com/tree-sitter/tree-sitter</a></p>
<p>话说，用 Rust 实现的新语言在不断冒出来。</p>
<p>本月看到一个新的语言 Gleam ，Rust 实现的可以与 Erlang 兼容的新语言。刚发布 0.15版本。</p>
<p><a href="https://github.com/gleam-lang/gleam">https://github.com/gleam-lang/gleam</a></p>
<h2><a class="header" href="#v86--用于模拟x86兼容的cpu和硬件" id="v86--用于模拟x86兼容的cpu和硬件">v86 : 用于模拟X86兼容的CPU和硬件</a></h2>
<p>v86 机器代码在运行时转换为webassembly模块，以实现体面的性能。</p>
<ul>
<li><a href="https://copy.sh/v86/">试试在浏览器里跑一个操作系统</a></li>
<li><a href="https://github.com/copy/v86">https://github.com/copy/v86</a></li>
</ul>
<h2><a class="header" href="#tokenizers-hugging-face公司推出的分词器发布新版本" id="tokenizers-hugging-face公司推出的分词器发布新版本">tokenizers: Hugging Face公司推出的分词器发布新版本</a></h2>
<p>Hugging Face（抱抱脸）公司是一家总部位于美国纽约的聊天机器人初创服务商。该公司在 NLP界鼎鼎大名，三月份刚刚完成4000万美元B轮融资。在GitHub上发布了开源 NLP 库 Transformers。</p>
<p>基于深度学习的现代 NLP 管道中的瓶颈之一就是tokenization，尤其是通用性强且独立于框架的实现。</p>
<p>所以，该分词器的核心是用Rust编写的，并且存在Node和Python的绑定。提供当今最常用的分词器的实现，重点是性能和多功能性。</p>
<p><a href="https://github.com/huggingface/tokenizers">https://github.com/huggingface/tokenizers</a></p>
<h1><a class="header" href="#推荐项目--基础工具库-1" id="推荐项目--基础工具库-1">推荐项目 ｜ 基础工具库</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#飞书开源项目rsmpeg--ffmpeg-的-rust-绑定" id="飞书开源项目rsmpeg--ffmpeg-的-rust-绑定">【飞书开源项目】rsmpeg ： FFmpeg 的 Rust 绑定</a></h2>
<p>利用 Rust 语言的设计，帮你构建健壮的多媒体应用。</p>
<p><a href="https://github.com/larksuite/rsmpeg">https://github.com/larksuite/rsmpeg</a></p>
<h2><a class="header" href="#embassy---嵌入式-rust-下的-异步执行器-和-hal" id="embassy---嵌入式-rust-下的-异步执行器-和-hal">embassy :  嵌入式 Rust 下的 异步执行器 和 HAL</a></h2>
<p>该项目旨在 让 async/await 成为 嵌入式开发的 first class 选择</p>
<p><a href="https://github.com/embassy-rs/embassy">https://github.com/embassy-rs/embassy</a></p>
<h2><a class="header" href="#call--用于远程开发的易于使用的命令工具" id="call--用于远程开发的易于使用的命令工具">Call:  用于远程开发的易于使用的命令工具。</a></h2>
<p>它可以帮助您轻松而优雅地进行远程开发。 它可以与 makefile 和justfile 一起使用。</p>
<p>是国内社区朋友开发的。</p>
<p><a href="https://github.com/bingryan/call">https://github.com/bingryan/call</a></p>
<h2><a class="header" href="#经过两年的努力-tauri-终于迎来了-10--beta-版本" id="经过两年的努力-tauri-终于迎来了-10--beta-版本">经过两年的努力， Tauri 终于迎来了 1.0  beta 版本。</a></h2>
<p>Tauri 是基于 Rust 实现的桌面应用开发工具，支持集成可编译为HTML，JS和CSS的任何前端框架来构建用户界面。目前支持 Windows/Linux/Macos，iOS和 Android 的支持还在开发中。</p>
<ul>
<li><a href="https://dev.to/tauri/announcing-tauri-beta-more-efficient-crossplatform-apps-with-better-features-1nbd">https://dev.to/tauri/announcing-tauri-beta-more-efficient-crossplatform-apps-with-better-features-1nbd</a></li>
<li><a href="https://github.com/tauri-apps/tauri">https://github.com/tauri-apps/tauri</a></li>
</ul>
<h2><a class="header" href="#parcel-2-发布-beta3-版本" id="parcel-2-发布-beta3-版本">Parcel 2 发布 beta3 版本</a></h2>
<p>性能提升十倍！</p>
<p><a href="https://v2.parceljs.org/blog/beta3/">https://v2.parceljs.org/blog/beta3/</a></p>
<h2><a class="header" href="#valuable-tokio发布的-对象安全的值检查库" id="valuable-tokio发布的-对象安全的值检查库">Valuable: tokio发布的 对象安全的值检查库</a></h2>
<p>提供了对象安全的trait，即 Valuable，它允许调用者在不知道其类型的情况下检查值的内容，无论是字段，枚举变量还是原生类型。</p>
<p><a href="https://tokio.rs/blog/2021-05-valuable">https://tokio.rs/blog/2021-05-valuable</a></p>
<h2><a class="header" href="#命令行神器typos帮助你找到源码中的拼写错误" id="命令行神器typos帮助你找到源码中的拼写错误">命令行神器：typos，帮助你找到源码中的拼写错误</a></h2>
<p><img src="https://github.com/crate-ci/typos/raw/master/docs/screenshot.png" alt="" /></p>
<p><a href="https://github.com/crate-ci/typos">https://github.com/crate-ci/typos</a></p>
<h1><a class="header" href="#推荐项目---框架引擎-1" id="推荐项目---框架引擎-1">推荐项目 |  框架引擎</a></h1>
<p>编辑：张汉东</p>
<h2><a class="header" href="#cubejs-rust-实现的-bi-框架" id="cubejs-rust-实现的-bi-框架">Cube.js: Rust 实现的 BI 框架</a></h2>
<p>Cube.js 是一个开源的分析 API 平台。主要用于构建内部商业智能工具或将客户面向客户的分析添加到现有应用程序。</p>
<p>你可以使用 Cube.js 构建现代化的数据分析平台。</p>
<p>架构： Data(DB) -&gt; Backend (Cube.js server) -&gt; Frontend(React.js / Ant Design)</p>
<p>在最简单的方案中，Cube.js使用内存高速缓存和查询队列来提供比数据存储能够传递的更好的性能。 但是，它通常是最不可扩展且经济高效的解决方案，因此不建议生产。</p>
<p>因此引入 Cube Store，以提供有保证的高并发性和亚秒级延迟，用于分析查询的性能优化以及通过跨数据库连接的数据联合等附加功能。 Cube Store 由 Rust 实现。</p>
<ul>
<li><a href="https://github.com/cube-js/cube.js">Cube.js</a></li>
<li><a href="https://cube.dev/docs/introduction">Docs</a></li>
<li><a href="https://dev.to/cubejs/introducing-cube-store-high-concurrency-and-sub-second-latency-for-any-database-3n6n">Cube Store 更多介绍</a></li>
</ul>
<h2><a class="header" href="#warp-web-server-框架" id="warp-web-server-框架">Warp: Web server 框架</a></h2>
<p>Warp 构建于 hyper 之上。 特色是：Filter 系统。</p>
<p>**tower vs wrap vs tower-web **</p>
<ul>
<li>tower，类似于 Finagle （Twitter 研发的RPC系统）</li>
<li>warp，类似于 finch（用于构建Finagle HTTP服务的Scala组合器库）</li>
<li>tower-web，类似于 finatra （一个scala 异步 web 框架） </li>
</ul>
<p>warp 的 Filter 抽象 和 Tower-web 的 Middleware 抽象 有异曲同工之效。<a href="https://github.com/seanmonstar/warp/issues/58">阅读更多</a>。</p>
<ul>
<li><a href="https://github.com/seanmonstar/warp">warp</a></li>
<li><a href="https://github.com/carllerche/tower-web">tower-web</a></li>
</ul>
<p>目前 Warp 还在积极维护中。</p>
<h2><a class="header" href="#rocket-最近发布了-0410" id="rocket-最近发布了-0410">Rocket 最近发布了 0.4.10</a></h2>
<p>Rocket 的更新节奏比较缓慢，但还在维护中，五月份连续三天连发三个小版本。</p>
<p>最新的版本更新是移除了一处 unsafe 代码，修复了一个 soundless 的问题。</p>
<p><a href="https://github.com/SergioBenitez/Rocket">https://github.com/SergioBenitez/Rocket</a></p>
<h2><a class="header" href="#sqlx-发布了新版本-055" id="sqlx-发布了新版本-055">sqlx: 发布了新版本 0.5.5</a></h2>
<p>sqlx 是一个纯 Rust 的异步 SQL 库。它的特点是编译期查询检查，并且没有提供任何 DSL，所以它不是一个 ORM。</p>
<p>sqlx 跨数据库/跨运行时/跨TLS后端，不绑定于任何特定数据库和运行时(async-std / tokio / actix)和TLS后端（native-tls, rustls）。</p>
<p><a href="https://github.com/launchbadge/sqlx">sqlx</a></p>
<h2><a class="header" href="#moonzoon-全栈-rust-开发框架进展" id="moonzoon-全栈-rust-开发框架进展">MoonZoon: 全栈 Rust 开发框架进展</a></h2>
<p>MoonZoon 号称是 Rust 全栈框架。</p>
<p>最近 MoonZoon 好像取得了一些进展。增加了一个 光线追踪的教程：<a href="https://github.com/MartinKavik/ray_tracer/blob/main/README.md">https://github.com/MartinKavik/ray_tracer/blob/main/README.md</a>。MoonZoon 支持 HTML canvas 和 后端自动加载，支持快速开发。</p>
<p><a href="https://github.com/MoonZoon/MoonZoon">https://github.com/MoonZoon/MoonZoon</a></p>
<h1><a class="header" href="#rust生态安全漏洞总结系列--part-2" id="rust生态安全漏洞总结系列--part-2">Rust生态安全漏洞总结系列 | Part 2</a></h1>
<p>作者：张汉东</p>
<hr />
<p>本系列主要是分析<a href="https://rustsec.org/advisories/"><code>RustSecurity</code> 安全数据库库</a>中记录的<code>Rust</code>生态社区中发现的安全问题，从中总结一些教训，学习<code>Rust</code>安全编程的经验。</p>
<p>本期分析了下面六个安全问题：</p>
<ul>
<li>RUSTSEC-2021-0067 : Cranelift 模块中代码生成缺陷导致可能的 WASM 沙箱逃逸</li>
<li>RUSTSEC-2021-0054：rkyv crate 可能包含未初始化的内存</li>
<li>RUSTSEC-2021-0041：parse_duration 通过用太大的指数解析 Payload 来拒绝服务(DOS)</li>
<li>RUSTSEC-2021-0053： 算法库中 <code>merge_sort::merge()</code> 导致实现 Drop 的类型 双重释放（ double-free）</li>
<li>RUSTSEC-2021-0068: iced x86 版本中 不合理（Soundness） 的问题</li>
<li>RUSTSEC-2021-0037： Diesel 库的 Sqlite 后端 UAF(use-after-free) bug</li>
</ul>
<p>看是否能给我们一些启示。</p>
<h2><a class="header" href="#rustsec-2021-0067--cranelift-模块中代码生成缺陷导致可能的-wasm-沙箱逃逸" id="rustsec-2021-0067--cranelift-模块中代码生成缺陷导致可能的-wasm-沙箱逃逸">RUSTSEC-2021-0067 : Cranelift 模块中代码生成缺陷导致可能的 WASM 沙箱逃逸</a></h2>
<p>在 Cranelift 中发现了一个漏洞。具有未知输入的操作导致特权升级漏洞。 CWe正在将问题分类为CWE-264。 这将对机密性，完整性和可用性产生影响。</p>
<h3><a class="header" href="#漏洞描述" id="漏洞描述">漏洞描述：</a></h3>
<ul>
<li>漏洞类型：Vulnerability</li>
<li>漏洞分类：code-execution/ memory-corruption/ memory-exposure</li>
<li>CVE 编号：CVE-2021-32629</li>
<li>详细：<a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5</a></li>
<li>影响架构：x86</li>
<li>补丁：<code>&gt;=0.73.1</code> 和 <code>&gt;=0.74.0</code></li>
</ul>
<p>Cranelift X64后端的<code>0.73.0</code>中有一个错误，可以创建一个可能导致 Webassembly 模块中的潜在沙箱逃逸(sandbox escape )的场景。 版本<code>0.73.0</code>的Cranelift的用户应升级到<code>0.73.1</code>或<code>0.74</code>，以修复此漏洞。 </p>
<p>如果未使用旧的默认后端，则在<code>0.73.0</code>之前的 Cranelift 用户应该更新为<code>0.73.1</code>或<code>0.74</code>。</p>
<h3><a class="header" href="#漏洞分析" id="漏洞分析">漏洞分析</a></h3>
<p>此问题是在 Cranelift 新后端中引入的（Cranelift 经历过大的重构）。</p>
<blockquote>
<p>一些背景： 寄存器分配</p>
<p>如果物理寄存器的数量不足以满足虚拟寄存器的需求，有些虚拟寄存器显然就只能映射到内存。这些虚拟寄存器称为溢出（spill）虚拟寄存器。寄存器分配算法的好坏直接决定了程序中寄存器的利用率。</p>
<p>Cranelift 寄存器分配相关文章：<a href="https://cfallin.org/blog/2021/03/15/cranelift-isel-3/">https://cfallin.org/blog/2021/03/15/cranelift-isel-3/</a></p>
<p>该文章还详细介绍了该团队如何保证 Cranelift 生成正确的代码。即便如此，还是产生了逻辑 Bug。</p>
</blockquote>
<p>这个 Bug 是一个逻辑 Bug:</p>
<p>原因是，寄存器分配器重新加载比 64位 窄的溢出（spill）整数值时，从栈上加载的值执行了符号扩展而不是零扩展。 </p>
<p>这对另一个优化产生了糟糕的影响：当我们知道产生32位值的指令实际上将其目标寄存器的高32位置零时，指令选择器将选择一个32到64位的零扩展运算符。因此，我们依赖于这些归零位，但值的类型仍然是I32，并且溢出/重新加载将这些比特位重构为I32的MSB的符号扩展。</p>
<p>所以，在某些特定情况下，如果i32值为指针，则可能会出现沙箱逃逸的情况。为堆访问发出的常规代码对 WebAssembly 堆地址进行零扩展，将其添加到64位堆基，然后访问结果地址。如果零扩展成为符号扩展，则模块可以在堆开始之前向后访问并访问最大2GiB的内存。</p>
<blockquote>
<p>符号扩充 (sign-extend): 指在保留数字的符号（正负性）及数值的情况下，增加二进制数字位数的操作。</p>
<p>零扩充（zero-extend）：用于将无符号数字移动至较大的字段中，同时保留其数值。</p>
</blockquote>
<p>该 Bug 的影响力依赖于堆的实现。具体而言：</p>
<p>如果堆有边界检查。并且，不完全依赖于保护页面。并且堆绑定为2GiB或更小。则该 Bug 无法用于从另一个 WebAssembly 模块堆访问内存。</p>
<p>如果使用此 Bug 可访问的范围中没有映射内存，例如，如果 WebAssembly 模块堆之前有 2 GiB 保护区域，则可以减轻此漏洞的影响。</p>
<ul>
<li>修复 PR: <a href="https://github.com/bytecodealliance/wasmtime/pull/2919/files">https://github.com/bytecodealliance/wasmtime/pull/2919/files</a></li>
<li>点击查看详细内容，了解对 lucet 和 wastmtime的影响：<a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5</a></li>
</ul>
<h2><a class="header" href="#rustsec-2021-0054rkyv-crate-可能包含未初始化的内存" id="rustsec-2021-0054rkyv-crate-可能包含未初始化的内存">RUSTSEC-2021-0054：rkyv crate 可能包含未初始化的内存</a></h2>
<h3><a class="header" href="#漏洞描述-1" id="漏洞描述-1">漏洞描述：</a></h3>
<ul>
<li>漏洞类型：Vulnerability</li>
<li>漏洞分类： memory-exposure</li>
<li>CVE 编号：无</li>
<li>详细：<a href="https://github.com/djkoloski/rkyv/issues/113">https://github.com/djkoloski/rkyv/issues/113</a></li>
<li>补丁：<code>&gt;=0.6.0</code></li>
</ul>
<p>rkyv是一个序列化框架 在序列化期间，可能无法初始化结构填充字节和未使用的枚举字节。 这些字节可以写入磁盘或发送不安全的通道。</p>
<h3><a class="header" href="#漏洞分析-1" id="漏洞分析-1">漏洞分析</a></h3>
<p>补丁代码：<a href="https://github.com/djkoloski/rkyv/commit/9c65ae9c2c67dd949b5c3aba9b8eba6da802ab7e">https://github.com/djkoloski/rkyv/commit/9c65ae9c2c67dd949b5c3aba9b8eba6da802ab7e</a></p>
<p>有问题的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn resolve_aligned&lt;T: Archive + ?Sized&gt;(
        &amp;mut self,
        value: &amp;T,
        resolver: T::Resolver,
    ) -&gt; Result&lt;usize, Self::Error&gt; {
    // ...
    let mut resolved = mem::MaybeUninit::zeroed();
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>mem::MaybeUninit::zeroed()</code>函数会创建一个新的<code>MaybeUninit&lt;T&gt;</code>实例，并且该内存位会被填充<code>0</code>。但是这依赖于 <code>T</code>是否能被正确初始化。比如：<code>MaybeUninit&lt;usize&gt;::zeroed()</code>是初始化，但是<code>MaybeUninit&lt;&amp;'static i32&gt;::zeroed()</code>就没有被正确初始化。这是因为 Rust 里引用不能为空。</p>
<p>所以，现在这个 resolver 是个泛型 <code>T</code>，不一定能正确初始化，所以有未初始化的风险。</p>
<p>修复之后的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut resolved = mem::MaybeUninit::&lt;T::Archived&gt;::uninit();
    resolved.as_mut_ptr().write_bytes(0, 1);
<span class="boring">}
</span></code></pre></pre>
<p>直接假设其没有正确初始化，然后使用<code>write_bytes</code>手工将其初始化，确保正确。</p>
<h2><a class="header" href="#rustsec-2021-0041parse_duration-通过用太大的指数解析-payload-来拒绝服务dos" id="rustsec-2021-0041parse_duration-通过用太大的指数解析-payload-来拒绝服务dos">RUSTSEC-2021-0041：parse_duration 通过用太大的指数解析 Payload 来拒绝服务(DOS)</a></h2>
<h3><a class="header" href="#漏洞描述-2" id="漏洞描述-2">漏洞描述：</a></h3>
<ul>
<li>漏洞类型：Vulnerability</li>
<li>漏洞分类： denial-of-service</li>
<li>CVE 编号：CAN-2021-1000007 / CVE-2021-29932</li>
<li>详细：<a href="https://github.com/zeta12ti/parse_duration/issues/21">https://github.com/zeta12ti/parse_duration/issues/21</a></li>
<li>补丁：无，作者放弃维护</li>
</ul>
<h3><a class="header" href="#漏洞解析" id="漏洞解析">漏洞解析</a></h3>
<p>parse_duration 库用来将字符串解析为持续时间（duration）。</p>
<p>问题代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if exp &lt; 0 {
    boosted_int /= pow(BigInt::from(10), exp.wrapping_abs() as usize);
} else {
    boosted_int *= pow(BigInt::from(10), exp.wrapping_abs() as usize);
}
duration.nanoseconds += boosted_int;
<span class="boring">}
</span></code></pre></pre>
<p>此为 parse 函数内的代码片段，允许使用指数级的持续时间字符串解析，其中BigInt 类型与 pow 功能一起用于这类 Payload。该功能会导致长时间占用CPU和内存。</p>
<p>这允许攻击者使用 parse 功能来制造 DOS 攻击。虽然该库已经不维护了，而且star数也不多，但是不清楚依赖它的库有多少，可以使用 cargo-audit 来检查你项目里的依赖。</p>
<h2><a class="header" href="#rustsec-2021-0053-算法库中-merge_sortmerge-导致实现-drop-的类型-双重释放-double-free" id="rustsec-2021-0053-算法库中-merge_sortmerge-导致实现-drop-的类型-双重释放-double-free">RUSTSEC-2021-0053： 算法库中 <code>merge_sort::merge()</code> 导致实现 Drop 的类型 双重释放（ double-free）</a></h2>
<ul>
<li>漏洞类型：Vulnerability</li>
<li>漏洞分类： memory-corruption</li>
<li>CVE 编号：无</li>
<li>详细：<a href="https://github.com/AbrarNitk/algorithmica/issues/1">https://github.com/AbrarNitk/algorithmica/issues/1</a></li>
<li>补丁：暂无</li>
</ul>
<h3><a class="header" href="#漏洞分析-2" id="漏洞分析-2">漏洞分析</a></h3>
<p><a href="https://github.com/AbrarNitk/algorithmica">algorithmica</a>是 Rust 实现算法的教学库，网站为：<a href="https://www.fifthtry.com/abrar/rust-algorithms/">https://www.fifthtry.com/abrar/rust-algorithms/</a>。</p>
<p>该库中的归并排序的实现中，merge 函数导致 对列表元素持有双份所有权，所以会双重释放（double free）。</p>
<p>注意下面源码中，为 unsafe rust 实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn merge&lt;T: Debug, F&gt;(list: &amp;mut [T], start: usize, mid: usize, end: usize, compare: &amp;F) 
 where 
     F: Fn(&amp;T, &amp;T) -&gt; bool, 
 { 
     let mut left = Vec::with_capacity(mid - start + 1); 
     let mut right = Vec::with_capacity(end - mid); 
     unsafe { 
         let mut start = start; 
         while start &lt;= mid { 
             left.push(get_by_index(list, start as isize).read()); 
             start += 1; 
         } 
         while start &lt;= end { 
             right.push(get_by_index(list, start as isize).read()); 
             start += 1; 
         } 
     } 
  
     let mut left_index = 0; 
     let mut right_index = 0; 
     let mut k = start; 
  
     unsafe { 
         while left_index &lt; left.len() &amp;&amp; right_index &lt; right.len() { 
             if compare(&amp;left[left_index], &amp;right[right_index]) { 
                 
                 // 通过 `list[k] = ` 这种方式重复持有元素所有权
                 list[k] = get_by_index(&amp;left, left_index as isize).read(); 
                 
                 left_index += 1; 
             } else { 
                 list[k] = get_by_index(&amp;right, right_index as isize).read(); 
                 right_index += 1; 
             } 
             k += 1; 
         } 
  
         while left_index &lt; left.len() { 
             list[k] = get_by_index(&amp;left, left_index as isize).read(); 
             left_index += 1; 
             k += 1; 
         } 
  
         while right_index &lt; right.len() { 
             list[k] = get_by_index(&amp;right, right_index as isize).read(); 
             right_index += 1; 
             k += 1; 
         } 
     } 
 } 

unsafe fn get_by_index&lt;T&gt;(list: &amp;[T], index: isize) -&gt; *const T {
    let list_offset = list.as_ptr();
    list_offset.offset(index)
}
<span class="boring">}
</span></code></pre></pre>
<p>Bug 复现：</p>
<pre><pre class="playground"><code class="language-rust">#![forbid(unsafe_code)]
use algorithmica::sort::merge_sort::sort;

fn main() {
    let mut arr = vec![
        String::from(&quot;Hello&quot;),
        String::from(&quot;World&quot;),
        String::from(&quot;Rust&quot;),
    ];

    // Calling `merge_sort::sort` on an array of `T: Drop` triggers double drop
    algorithmica::sort::merge_sort::sort(&amp;mut arr);
    dbg!(arr);
}
</code></pre></pre>
<p>输出： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>free(): double free detected in tcache 2

Terminated with signal 6 (SIGABRT)
<span class="boring">}
</span></code></pre></pre>
<p>该 Bug 还未得到修复。</p>
<p>此问题给我们的启示：不要为了刷题而忽略安全。</p>
<h2><a class="header" href="#rustsec-2021-0068-iced-x86-版本中-不合理soundness-的问题" id="rustsec-2021-0068-iced-x86-版本中-不合理soundness-的问题">RUSTSEC-2021-0068: iced x86 版本中 不合理（Soundness） 的问题</a></h2>
<h3><a class="header" href="#漏洞描述-3" id="漏洞描述-3">漏洞描述：</a></h3>
<ul>
<li>漏洞类型：Vulnerability</li>
<li>漏洞分类： soundness</li>
<li>CVE 编号：无</li>
<li>详细：<a href="https://github.com/icedland/iced/issues/168">https://github.com/icedland/iced/issues/168</a></li>
<li>补丁：<code>&gt;1.10.3</code></li>
</ul>
<h3><a class="header" href="#漏洞分析-3" id="漏洞分析-3">漏洞分析</a></h3>
<p>iced 用户在使用 miri 编译其项目时，发现 UB:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error: Undefined Behavior: memory access failed: pointer must be in-bounds at offset 4, but is outside bounds of alloc90797 which has size 3
    --&gt; C:\Users\lander\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\slice\mod.rs:365:18
     |
365  |         unsafe { &amp;*index.get_unchecked(self) }
     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset 4, but is outside bounds of alloc90797 which has size 3
     |
     = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
     = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
             
     = note: inside `core::slice::&lt;impl [u8]&gt;::get_unchecked::&lt;usize&gt;` at C:\Users\lander\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\slice\mod.rs:365:18
     = note: inside `iced_x86::Decoder::new` at C:\Users\lander\.cargo\registry\src\github.com-1ecc6299db9ec823\iced-x86-1.9.1\src\decoder\mod.rs:457:42
note: inside `Emulator::run` at src\lib.rs:563:27
    --&gt; src\lib.rs:563:27
     |
563  |         let mut decoder = Decoder::new(self.bitness, bytes, self.decoder_options);
<span class="boring">}
</span></code></pre></pre>
<p>该用户在使用 <code>Decoder::new</code> 的时候出现了 UB。在 iced相关源码中，即 <code>iced/src/rust/iced-x86/src/decoder.rs</code> 中，存在</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data_ptr_end: *const u8 = unsafe { 
    data.get_unchecked(data.len()) 
}; 
<span class="boring">}
</span></code></pre></pre>
<p>根据<a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked">标准库文档</a>描述：</p>
<blockquote>
<p>Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used.</p>
<p>使用 界外索引调用该方法就是 未定义行为（UB），即便这个结果的引用没有被使用。</p>
</blockquote>
<p>示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;[1, 2, 4];

unsafe {
    assert_eq!(x.get_unchecked(1), &amp;2);
    assert_eq!(x.get_unchecked(3), &amp;2); // UB
}
<span class="boring">}
</span></code></pre></pre>
<p>该代码已经被修复为，不再使用 get_unchecked ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data_ptr_end = data.as_ptr() as usize + data.len();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#rustsec-2021-0037-diesel-库的-sqlite-后端-uafuse-after-free-bug" id="rustsec-2021-0037-diesel-库的-sqlite-后端-uafuse-after-free-bug">RUSTSEC-2021-0037： Diesel 库的 Sqlite 后端 UAF(use-after-free) bug</a></h3>
<h3><a class="header" href="#漏洞描述-4" id="漏洞描述-4">漏洞描述：</a></h3>
<ul>
<li>漏洞类型：Vulnerability</li>
<li>漏洞分类： memory-corruption</li>
<li>CVE 编号：CVE-2021-28305</li>
<li>详细：<a href="https://github.com/diesel-rs/diesel/pull/2663">https://github.com/diesel-rs/diesel/pull/2663</a></li>
<li>补丁：<code>&gt;=1.4.6</code></li>
</ul>
<h3><a class="header" href="#漏洞分析-4" id="漏洞分析-4">漏洞分析</a></h3>
<p>Diesel 的 sqlite 后端使用了 libsqlite3_sys 这个库来调用 sqlite 提供的sql函数。比如<code>sqlite3_finalize</code> 和 <code>sqlite3_step</code> 之类。</p>
<blockquote>
<p>sqlite 函数执行调用过程：</p>
<ul>
<li>sqlite3_open()</li>
<li>sqlite3_prepare()</li>
<li>sqlite3_step() // 用于执行有前面sqlite3_prepare创建的 预编译语句</li>
<li>sqlite3_column() // 从执行sqlite3_step()执行一个预编译语句得到的结果集的当前行中返回一个列</li>
<li>sqlite3_finalize() // 销毁前面被sqlite3_prepare创建的预编译语句</li>
<li>sqlite3_close()</li>
</ul>
</blockquote>
<p>Diesel 的 by_name 查询通用做法是将预编译语句的所有字段名称保存为字符串切片以备以后使用。</p>
<p>但是sqlite的行为是：</p>
<ul>
<li>返回的字符串指针一直有效，直到准备好的语句被 <code>sqlite3_finalize()</code> 销毁，</li>
<li>或者直到第一次调用 <code>sqlite3_step()</code> 为特定运行自动重新预编译该语句，</li>
<li>或者直到下一次调用 <code>sqlite3_column_name()</code> 或 <code>sqlite3_column_name16()</code> 在同一列。</li>
</ul>
<p>在之前版本的 Diesel 中，没有注意到这种情况，在调用 <code>sqlite3_step()</code> 之后，因为重新预编译语句，导致之前字符串切片指针就无效了。就造成 UAF 的情况。</p>
<p>这个案例告诉我们，在使用 FFi 的时候，要注意绑定sys库 的相关行为。这个在 Rust 编译器这边是无法检查发现的，案例应该属于逻辑 Bug。</p>
<h1><a class="header" href="#rust-与-安全--rust-让恶意软件也变强了" id="rust-与-安全--rust-让恶意软件也变强了">Rust 与 安全 | Rust 让恶意软件也变强了</a></h1>
<p>作者：张汉东 </p>
<hr />
<p><em>技术 是一把锋利的双刃剑。 —— 鲁迅。</em></p>
<h2><a class="header" href="#背景-3" id="背景-3">背景</a></h2>
<p>今天看到 proofpoint 发表了一篇题为<a href="https://www.proofpoint.com/us/blog/threat-insight/new-variant-buer-loader-written-rust">Buer Loader 用 Rust 创造了新的变种 （New Variant of Buer Loader Written in Rust）</a>的文章。</p>
<blockquote>
<p>Proofpoint是一家位于加利福尼亚州桑尼维尔的企业安全公司，为入站电子邮件安全，出站数据丢失防护，社交媒体，移动设备，数字风险，电子邮件加密，电子发现和电子邮件归档提供软件即服务和产品。</p>
<p>Buer 是在地下市场上出售的下载程序，以分发包括勒索软件在内的其他恶意软件。 Proofpoint于 2019年 首次观察到 Buer。</p>
</blockquote>
<p>Proofpoint研究人员确定了4月初通过伪装成（快递公司 DHL）发货通知的电子邮件分发的 Buer 恶意软件加载程序的新变种。 邮件中包含指向恶意 Microsoft Word 或 Excel 文档下载的链接，这些链接使用宏来投放新的恶意软件变体。</p>
<p>Proofpoint 把新的变种称为 RustyBuer，因为它们用 Rust的语言完全重写，这与以前的C编程语言有所不同。常见的恶意软件以完全不同的方式编写是很少见的。用 Rust 重写恶意软件可以使威胁者更好地逃避现有的 Buer 检测功能，并且通过使用不同的诱饵技术，提升链接的点击率。这一切都表明威胁者正在以多种方式发展技术，从而逃避检测并试图提高成功的点击率。</p>
<p>RustyBuer 直接嵌入到文档宏中，需要用户交互才能启动感染。此宏利用应用程序绕过（通过 LOLBAS 的 Windows Shell DLL）逃避了端点安全性机制的检测。</p>
<p>尚不清楚威胁者为何花时间和精力用新的编程语言重写恶意软件，但是Proofpoint研究人员指出了两个可能的原因：</p>
<ul>
<li>
<p>Rust 是一种越来越流行的编程语言，它比 C 语言更高效且具有更广泛的功能集。（例如，Microsoft越来越多地在其产品中使用它，并于2021年2月加入了Rust 基金会）。</p>
</li>
<li>
<p>用 Rust 重写恶意软件可以使威胁参与者逃避基于 C 语言编写的恶意软件功能的现有 Buer 检测。恶意软件作者对其进行了编程，使其应与现有 Buer 后端 C2 服务器和面板保持兼容。</p>
</li>
</ul>
<h2><a class="header" href="#乱炖" id="乱炖">乱炖</a></h2>
<p>其实用 Rust 写恶意软件，这个案例并不是第一个。早在 2016 年 Dr.Web（俄罗斯杀毒软件公司 大蜘蛛）公司就发现了一款<a href="https://news.drweb.com/show/?i=10193&amp;lng=en">用 Rust 实现的 针对 Linux 的特洛伊木马 <code>Linux.BackDoor.Irc.16</code></a>。Doctor Web的分析师认为，<code>Linux.BackDoor.Irc.16</code> 实际上是一个原型（概念验证），因为它无法自我复制。然而 RustyBuer 就是一款完全黑产化的软件了。</p>
<p>随着目前 Rust 知名度越来越高，Rust 在安全/黑产领域可能会越来越流行。抛开黑产软件的伦理道德不谈，单从技术以及 Rust 自身而言，在这种「攻与防」的觥筹交错中，也许会促进各种针对 Rust 的检测工具诞生，进一步丰富生态，促进 Rust 发展。</p>
<p>因此，我对目前安全领域生态中有多少用 Rust 实现的工具产生了好奇。接下来盘点一下 GitHub/GitLab 上发现的一些用 Rust 实现的安全工具。欢迎补充。</p>
<h3><a class="header" href="#渗透测试工具-metasploit-无rust-重写计划" id="渗透测试工具-metasploit-无rust-重写计划">渗透测试工具 Metasploit （无）Rust 重写计划</a></h3>
<p>2017 年有人在 <a href="https://github.com/rapid7/metasploit-framework/issues/9092">Metasploit issue 留言</a>，请求 Metasploit 用 Rust 重写。当然，这个 issue 被无情关闭了。因为 Metasploit 当年是从 Python 转为 Ruby 重写，是看中了 Ruby 强大的 DSL 能力。作为渗透测试工具的扛把子，Metasploit 目前没有使用 Rust 重写的理由。除非，有人直接提交 PR，用 Rust 完成了大部分功能，不过我想这件事不会发生。</p>
<p>不过还有个曲线救国的办法，就是用 Rust 重写 Ruby。这个还是有希望的：<a href="https://github.com/artichoke/artichoke">artichoke/artichoke</a>。Artichoke 就是用 Rust 实现 Ruby 的项目，目前维护也很活跃，已经兼容 MIR(Ruby 2.6.3) 规格。</p>
<p>Metasploit 还有一个功能，叫「Metasploit's Hardware Bridge」，提供了一系列<a href="https://www.rapid7.com/about/press-releases/rapid7-enables-iot-hardware-security-testing-with-metasploit/">Hardware REST API</a>，可以让 Metasploit 拥有对硬件（IoT领域）操作的能力。对于 REST Api，用任何语言都可以包装它，Rust 也可以。不过这个相关文档有五年没有更新了，不知道发展如何。</p>
<h3><a class="header" href="#扫描" id="扫描">扫描</a></h3>
<p><strong><a href="https://github.com/rustscan/rustscan">rustscan/rustscan</a></strong></p>
<p>RustScan 是一个现代化的端口扫描器，并且提供脚本引擎来支持运行 Python，Lua，Shell。</p>
<p>该工具的特色是：</p>
<ul>
<li>高性能。<code>3</code> 秒内可以扫描 <code>65,000</code> 个端口。</li>
<li>全面的脚本引擎支持。自动将结果传送到 Nmap，并支持自定义脚本。</li>
<li>支持 自适应学习（Adaptive learning）。用的越多，RustScan 越智能，不是基于臃肿的机器学习，主要是基于基本数学。</li>
</ul>
<p><strong><a href="https://github.com/epi052/feroxbuster">feroxbuster</a></strong></p>
<p>一款高性能的内容发现工具，用于渗透测试。feroxbuster 使用蛮力结合单词列表​​在目标目录中搜索未链接的内容，这是一种攻击行为。这些资源可能存储有关 Web 应用程序和操作系统的敏感信息，例如源代码，凭据，内部网络寻址等。此攻击也称为可预测资源位置，文件枚举，目录枚举和资源枚举。</p>
<h3><a class="header" href="#隐身匿名" id="隐身匿名">隐身匿名</a></h3>
<p><strong>Tor 和 Rust</strong></p>
<ul>
<li><a href="https://gitlab.torproject.org/legacy/trac/-/wikis/RustInTor">在 2020 年 Tor 浏览器用 Rust 实现部分模块: Rust in Tor</a></li>
<li><a href="https://gitlab.torproject.org/tpo/core/arti/">Arti: 纯 Rust 实现的 Tor 协议</a>，目前维护非常频繁。详细看<a href="https://forum.zcashcommunity.com/t/arti-a-pure-rust-tor-implementation-for-zcash-and-beyond/38776">这里</a>。</li>
</ul>
<p><strong><a href="https://github.com/zero-gear/rusty-tor">zero-gear/rusty-tor</a></strong></p>
<p>一个概念验证的 Tor 客户端。不过有两年没有维护了。</p>
<h3><a class="header" href="#免杀" id="免杀">免杀</a></h3>
<p>Rust 写 Shell Code 也是可以的。</p>
<ul>
<li><a href="https://jade.fyi/blog/writeonly-in-rust/">Writing shellcode in Rust</a></li>
<li><a href="https://github.com/lf-/ctf/tree/main/writeonly.rs">writeonly.rs</a></li>
<li><a href="https://github.com/b1tg/rust-windows-shellcode">rust-windows-shellcode</a></li>
<li><a href="https://zerosum0x0.blogspot.com/2020/08/sassykitdi-kernel-mode-tcp-sockets.html#sassy_rust">SassyKitdi: Kernel Mode TCP Sockets + LSASS Dump</a></li>
<li><a href="https://github.com/zerosum0x0/SassyKitdi">zerosum0x0/SassyKitdi</a></li>
<li><a href="https://github.com/cdong1012/Crab-Runner">Crab-Runner</a>，shellcode Runner.</li>
<li><a href="https://github.com/b1tg/rs_shellcode">rs_shellcode</a>，shellcode Runner.</li>
</ul>
<p><strong>重点介绍：</strong></p>
<p><a href="https://github.com/EgeBalci/amber">amber</a>。号称首款 反射式 PE 打包器，目前开发很活跃。</p>
<p>Amber是位置无关（反射）的 PE 加载器，可在内存中执行本机PE文件（EXE，DLL，SYS ...）。 它实现了秘密的的内存有效负载部署，可用于绕过防病毒，防火墙，IDS，IPS产品和应用程序白名单缓解措施。 由Amber生成的反射性有效负载可以从远程服务器上演，也可以像在通用Shellcode中一样直接在内存中执行。 </p>
<p>amber 提供的打包方法，可以改变将恶意软件传送到系统的方式。 通过尝试通过无文件代码注入将有效负载传递到系统，可以直接绕过大多数安全机制，而不是尝试寻找提供机器学习数据集的新的反检测技术。 使用这种新的打包方法，可以将已编译的PE文件转换为可与常见软件漏洞（例如缓冲区溢出）一起使用的多阶段感染有效负载。</p>
<p>更多介绍：<a href="https://pentest.blog/introducing-new-packing-method-first-reflective-pe-packer/">Introducing New Packing Method: First Reflective PE Packer Amber</a></p>
<h3><a class="header" href="#exploits-payloads--hacking" id="exploits-payloads--hacking">Exploits/ payloads / hacking</a></h3>
<p>这个开发者 <a href="https://github.com/kpcyrd">kpcyrd</a>，编写了一系列安全工具。</p>
<ul>
<li>
<p><a href="https://github.com/kpcyrd/sn0int">sn0int</a>， 半自动高级公开资源情报（OSINT）框架和程序包管理器，用于扫描目标IP地址、电子邮件、网站和组织信息，并从不同消息源收集各种情报信息。</p>
</li>
<li>
<p><a href="https://github.com/kpcyrd/sniffglue">sniffglue</a>，多线程网络嗅探器。Kpcyrd 经常使用tcpdump，但他认为输出更友好的话会更好，并且 wireshark 也经常存在漏洞，tcpdump 有时也有漏洞，所以他用 Rust 实现了这个工具。</p>
</li>
<li>
<p><a href="https://github.com/kpcyrd/badtouch">badtouch</a>， 可编写脚本的网络身份验证破解程序。</p>
</li>
<li>
<p><a href="https://github.com/kpcyrd/rshijack">rshijack</a>，用 Rust 重写了 shijack，实现 TCP 会话劫持。</p>
</li>
</ul>
<h3><a class="header" href="#fuzz-工具" id="fuzz-工具">Fuzz 工具</a></h3>
<ul>
<li><a href="https://github.com/rust-fuzz/cargo-fuzz">Cargo Fuzz</a>，Rust 官方开发的 Fuzz 工具。</li>
<li><a href="https://github.com/rust-fuzz/honggfuzz-rs">honggfuzz-rs</a>，Google 开发的 Fuzz 工具。</li>
<li><a href="https://github.com/phayes/sidefuzz">Sidefuzz</a>， 侧信道漏洞检测工具。</li>
</ul>
<h3><a class="header" href="#其他工具" id="其他工具">其他工具</a></h3>
<ul>
<li><a href="https://github.com/RustSec/advisory-db/">RustSec/advisory-db</a>，通过<a href="chapter_5/crates.io">crates.io</a>发布的Rust Crate 的安全咨询数据库。</li>
<li><a href="https://github.com/RustSec/cargo-audit">cargo-audit</a>，<code>Cargo.lock</code>中依赖审查工具。</li>
<li><a href="https://github.com/crev-dev/cargo-crev">cargo-crev</a>，代码 Review 工具。</li>
<li><a href="https://github.com/cortex/ripasso/">ripasso</a>，一款密码管理工具。</li>
<li><a href="https://github.com/arvancloud/libinjection-rs">libinjection-rs</a>， 对 libinjection 的 Rust 绑定，libinjection 是一款 SQL 注入工具。</li>
<li><a href="https://github.com/kostassoid/lethe">lethe</a>，安全，免费，跨平台和开源的驱动擦除工具。</li>
</ul>
<h1><a class="header" href="#六月刊" id="六月刊">六月刊</a></h1>
<p><img src="chapter_6/../image/rust_magazine3.png" alt="logo" /></p>
<p>目录顺序排名不分先后！</p>
<h2><a class="header" href="#发刊通告-7" id="发刊通告-7">发刊通告</a></h2>
<ul>
<li><a href="chapter_6/./announce.html">发刊通告</a></li>
</ul>
<h2><a class="header" href="#rust-资讯-2" id="rust-资讯-2">Rust 资讯</a></h2>
<ul>
<li><a href="chapter_6/./lang.html">官方动态</a></li>
<li><a href="chapter_6/./hots.html">社区热点</a></li>
<li><a href="chapter_6/./events.html">活动回顾</a></li>
<li><a href="chapter_6/./jobs.html">本月招聘</a></li>
<li><a href="chapter_6/./rust-not-a-company.html">Rust与开源 ｜ Rust 并不是一家公司</a></li>
<li><a href="chapter_6/./open-source-mental-health.html">开源与心理健康</a></li>
<li><a href="chapter_6/./rust-report.html">三万言｜2021 年 Rust 行业调研报告</a></li>
</ul>
<h2><a class="header" href="#rust-与-学术-2" id="rust-与-学术-2">Rust 与 学术</a></h2>
<ul>
<li><a href="chapter_6/./webassmebly-security.html">华为 | WebAssembly 安全性调研</a></li>
</ul>
<h2><a class="header" href="#rust-in-production-5" id="rust-in-production-5">Rust in Production</a></h2>
<ul>
<li><a href="chapter_6/./hw_StratoVirt_balloon.html">华为 | StratoVirt - 基于Rust的 balloon 功能实践</a></li>
<li><a href="chapter_6/./ant-rust-data-layout.html">蚂蚁集团 ｜ Rust 数据内存布局</a></li>
<li><a href="chapter_6/./rust-lockfree.html">Datenlord | Rust 语言无锁数据结构的内存管理</a></li>
<li><a href="chapter_6/./docker-wasm.html">SecondState | 用 Docker 工具管理 Rust 函数</a></li>
</ul>
<h2><a class="header" href="#clippy-专题" id="clippy-专题">Clippy 专题</a></h2>
<ul>
<li><a href="chapter_6/./custom-clippy.html">华为 | 如何定制 Cargo Clippy </a></li>
<li><a href="chapter_6/./static_analysis_custom_clippy_lint.html">定制静态分析 lint 检查规则</a></li>
<li><a href="chapter_6/./write-rust-lints-without-forking-clippy.html">无需 fork Clippy 就可以编写 Rust lints</a></li>
</ul>
<h2><a class="header" href="#学习园地-5" id="学习园地-5">学习园地</a></h2>
<h3><a class="header" href="#新手入门-2" id="新手入门-2">新手入门</a></h3>
<ul>
<li><a href="chapter_6/./learn.html">学习资源</a></li>
<li><a href="chapter_6/./proc_macro_workshop_guide_for_builder_project.html">Rust过程宏系列教程 | Proc Macro Workshop 之 Debug </a></li>
<li><a href="chapter_6/./rust_study_part_4.html">Rust 学习笔记系列｜ Part 4</a></li>
<li><a href="chapter_6/./rust_study_part_5.html">Rust 学习笔记系列｜ Part 5</a></li>
<li><a href="chapter_6/./rust_study_part_6.html">Rust 学习笔记系列｜ Part 6</a></li>
<li><a href="chapter_6/./rust_study_part_7.html">Rust 学习笔记系列｜ Part 7</a></li>
</ul>
<h3><a class="header" href="#语言特性与技巧-2" id="语言特性与技巧-2">语言特性与技巧</a></h3>
<ul>
<li><a href="chapter_6/./parser-combinator.html">用 Rust 学习解析器组合子 (combinator)</a></li>
</ul>
<h3><a class="header" href="#web-30-专题" id="web-30-专题">Web 3.0 专题</a></h3>
<ul>
<li><a href="chapter_6/./web3-part1.html">对Web3.0概念的梳理</a></li>
</ul>
<h2><a class="header" href="#开源项目巡礼-2" id="开源项目巡礼-2">开源项目巡礼</a></h2>
<ul>
<li><a href="chapter_6/./rabits.html"> Rbatis ORM 2.0 | 零开销编译时动态SQL的探索</a></li>
<li><a href="chapter_6/./github_trending.html">GitHub 趋势榜</a></li>
<li><a href="chapter_6/./tool_libs.html">推荐项目 ｜ 基础工具库</a></li>
<li><a href="chapter_6/./frameworks.html">推荐项目 |  框架引擎</a></li>
</ul>
<h1><a class="header" href="#发刊通告-8" id="发刊通告-8">发刊通告</a></h1>
<p>编辑：张汉东</p>
<h3><a class="header" href="#六月发刊通告" id="六月发刊通告">六月发刊通告</a></h3>
<p>《 RustMagazine 中文精选 》2021 年第六期发布了! </p>
<p>随着六月刊的发布，意味着2021年半年已经过去了。祝大家抓紧每一份时光，活在当下。无论如何，加油吧！</p>
<p>欢迎大家随时投稿分享，共建 Rust 社区繁荣。</p>
<h3><a class="header" href="#本刊动态-2" id="本刊动态-2">本刊动态</a></h3>
<p><strong>（GitHub Page）从本月起停止 Rss 订阅</strong></p>
<p>因为当前 mdbook 的 rss 插件不是很方便，等以后再加 rss 支持吧。</p>
<p>可以到语雀平台自动支持邮件订阅。</p>
<h3><a class="header" href="#上期五月刊访问数据统计小结" id="上期五月刊访问数据统计小结">上期（五月刊）访问数据统计小结</a></h3>
<p><strong>用户数</strong></p>
<ul>
<li>新用户新增 1969</li>
</ul>
<p><strong>浏览量：</strong></p>
<ul>
<li>网页浏览量 ： 14,447</li>
</ul>
<p><strong>五月份比较受欢迎的原创文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_5/rust-memory-troubleshootting.html">蚂蚁集团 ｜ 如何在生产环境排查 Rust 内存占用过高问题</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_5/pl.html">漫谈编程语言的设计和实现</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_5/hw_StratoVirt_vcpu.html">华为 | StratoVirt VCPU管理-Rust线程同步的实现</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_5/proc_macro_workshop_guide_for_builder_project.html">Rust过程宏系列教程 | Proc Macro Workshop 之 Builder 实现</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_5/rust-epoll-rdma.html">Datenlord | Rust实现RDMA异步编程（一）：基于epoll实现RDMA 异步操作</a></li>
</ul>
<p><strong>四月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/improve-std-slice-binary-search.html">《优化 Rust 标准库的 binary_search》</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_async_os_opt.html">蚂蚁集团 | 异步化OS：利用 async/await 带来 10 倍性能提升</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_trait.html">蚂蚁集团 | Trait 使用及实现分析</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/hw_bin_opt.html">华为 | Rust 编译后二进制大小和常用优化方式</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/tensorbase.html">开源产品 | TensorBase，基于Rust的现代化开源数据仓库</a></li>
</ul>
<p><strong>三月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li>《华为 | 基于 Rust 的下一代虚拟化平台 StratoVirt》</li>
<li>《华为 ｜ 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型》</li>
<li>《透过 Rust 探索系统本原 : 并发篇》</li>
<li>《蚂蚁集团 | Rust CPU Affinity 初探》</li>
<li>《Rust 中使用 MySql》</li>
</ul>
<p><strong>二月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<p>注： 一月刊的 《图解 Rust 所有权》文章依旧最受欢迎，作者：肖猛 </p>
<ul>
<li>《 前端入门 ｜ Rust 和 WebAssembly》，作者: 陈鑫(lencx)</li>
<li>《 实践案例 | 使用 Bevy 游戏引擎制作炸弹人》，作者：Cupnfish</li>
<li>《 蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考 》， 作者：evenyag</li>
<li>《 华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景》，作者：俞一峻等三位</li>
<li>《 DatenLord ｜ Linux 全新异步接口 io_uring 的 Rust 生态盘点》，作者：施继成</li>
</ul>
<p>后续也期待大家投稿。欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！</p>
<h1><a class="header" href="#官方动态" id="官方动态">官方动态</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#随着-try-v2-rfc-的跟进noneerror-已经被删除" id="随着-try-v2-rfc-的跟进noneerror-已经被删除">随着 try-v2 RFC 的跟进，<code>NoneError</code> 已经被删除</a></h2>
<p><a href="https://github.com/rust-lang/rust/issues/46871#issuecomment-852663986">https://github.com/rust-lang/rust/issues/46871#issuecomment-852663986</a></p>
<h2><a class="header" href="#rust-153-unicode-ident--支持" id="rust-153-unicode-ident--支持">Rust 1.53 unicode ident  支持</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BLÅHAJ: &amp;str = &quot;🦈&quot;;

struct 人 {
    名字: String,
}

let α = 1;
<span class="boring">}
</span></code></pre></pre>
<p>Rust 1.53 支持了 Unicode 字符作为标识符，这意味着，只要是合法的 Unicode ，就可以作为标识符。对应 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md">RFC 2457</a>，该 RFC 中也记录了哪些 Unicode 是不安全的，感兴趣可以查看。</p>
<p>团队可以配置lint 属性， <code>#[deny(uncommon_codepoints)]</code> ，禁止一些不推荐的 codepoint 。</p>
<p><img src="chapter_6/./image/unicode/luanma.png" alt="unicode" /></p>
<p>这样用就有点过分了！也许团队内要针对 Unicode 标识符来做一些编码规范了。</p>
<h2><a class="header" href="#一个新的-mcp-将-rustc_codegen_gcc-作为-compilerrustc_codegen_gcc-组件合并到--rust-langrust" id="一个新的-mcp-将-rustc_codegen_gcc-作为-compilerrustc_codegen_gcc-组件合并到--rust-langrust">一个新的 MCP ：将 rustc_codegen_gcc 作为 compiler/rustc_codegen_gcc 组件合并到  rust-lang/rust</a></h2>
<p><a href="https://github.com/rust-lang/compiler-team/issues/442">https://github.com/rust-lang/compiler-team/issues/442</a></p>
<p>rustc_codegen_gcc 是rustc的GCC代码生成器，这意味着它可以被现有的rustc前端加载，但受益于GCC，因为它支持更多的架构，并可以获得GCC的优化。</p>
<p><a href="https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-1">进展报告 #1</a></p>
<h2><a class="header" href="#rustup-1243-发布" id="rustup-1243-发布">Rustup 1.24.3 发布</a></h2>
<p>使用rustup self update更新 rustup,然后使用rustup update更新 toolchain</p>
<p><a href="https://blog.rust-lang.org/2021/06/08/Rustup-1.24.3.html">Announcing Rustup 1.24.3 | Rust Blog (rust-lang.org)</a></p>
<h1><a class="header" href="#社区热点-3" id="社区热点-3">社区热点</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#rust-for-linux-项目相关进展" id="rust-for-linux-项目相关进展">Rust for Linux 项目相关进展</a></h2>
<p>Google 赞助 且 由 ISRG 组织雇佣 Miguel Ojeda，让他全职从事Rust for Linux和其他安全工作，为期一年。希望能通过让他全职从事这项工作，为支持数字基础设施尽一份力。 </p>
<p><a href="https://www.memorysafety.org/blog/supporting-miguel-ojeda-rust-in-linux/">https://www.memorysafety.org/blog/supporting-miguel-ojeda-rust-in-linux/</a></p>
<h2><a class="header" href="#rustconf-2021-cfp-开放申请" id="rustconf-2021-cfp-开放申请">RustConf 2021 CFP 开放申请</a></h2>
<p>RustConf 2021 大会计划于 9月14号举行， 提案开放时间为太平洋时间6月13日至7月11日晚上11:59分。</p>
<p><a href="https://cfp.rustconf.com/events/rustconf-2021">https://cfp.rustconf.com/events/rustconf-2021</a></p>
<h2><a class="header" href="#国内新的--cratesio-和-rustup-的国内镜像" id="国内新的--cratesio-和-rustup-的国内镜像">国内新的  crates.io 和 rustup 的国内镜像</a></h2>
<p>字节跳动 的小伙伴搞的，希望能帮助建设国内的 rust 生态，感兴趣的话可以试用。</p>
<p>不限速（实际上是 1000Gbps），优质 CDN 分发，欢迎大家使用~ </p>
<p>有问题可以直接在评论区反馈。</p>
<p><a href="https://rsproxy.cn/">https://rsproxy.cn/</a></p>
<h2><a class="header" href="#2021-rust-china-conf-的调研" id="2021-rust-china-conf-的调研">2021 Rust China Conf 的调研</a></h2>
<p>朋友们，请抽出一分钟完成一下 2021 Rust China Conf 的调研，只有3个问题 。</p>
<p><a href="https://wj.qq.com/s2/8683119/cbf3/">https://wj.qq.com/s2/8683119/cbf3/</a></p>
<h2><a class="header" href="#现场实录20210619-北京-rust区块链开发者活动" id="现场实录20210619-北京-rust区块链开发者活动">【现场实录】20210619-北京-Rust区块链开发者活动</a></h2>
<p><a href="https://www.bilibili.com/video/BV1Jh411h7pp">https://www.bilibili.com/video/BV1Jh411h7pp</a></p>
<h2><a class="header" href="#rustsbi组织宣布成立" id="rustsbi组织宣布成立">RustSBI组织宣布成立</a></h2>
<p>RustSBI是RISC-V平台下的引导程序实现，它完全由Rust编写，并已经被录入RISC-V SBI国际标准。6月3日，RustSBI已经在GitHub上成立了组织，并提交了它对多个RISC-V平台的支持示例软件包。</p>
<p>RISC-V处理器架构中，存在着定义于操作系统之下的环境，它被称作SBI标准。这个环境除了引导系统启动，还将常驻后台，在内核运行时提供处理器功能。RustSBI就是这样的一种环境，它是一个扩展性较好的库，允许开发者自由地添加需要的功能模块，以支持芯片研发企业、应用厂商和板卡厂商提供自己芯片的SBI支持环境。</p>
<p>根据它的GitHub主页介绍，RustSBI项目组已经根据Mulan-PSL v2协议开源了它对K210和QEMU平台的支持，更多平台如FU540、C906等的支持也在筹划中。RustSBI组织以模块化开发、较好的支持嵌入式Rust生态，期望以这一形式，使厂商无需担忧是否合并到主分支，并鼓励开发者尝试多种多样的设计，来丰富引导程序方面的RISC-V生态环境。</p>
<p>“未来的RISC-V引导程序可能包含很多种可能性，这包括已经用在无盘工作站、安全网络等引导程序中的下载和验证机制，也可用于DIY爱好者的主板诊断。甚至用它做调试器也是可以的，它事实上提供了完全可定制的硬件兼容层，”RustSBI的维护者洛佳这样告诉《Rust日报》，“实践证明，它可以完成硬件到硬件的兼容性，从而延长硬件的生命周期，降低管理和迭代更新成本。”</p>
<p>“RustSBI已经能引导启动rCore等类Unix系统，”维护者继续说，“它是开源开放的，我们期待它被更进一步的被科研、教学和生产界广泛使用。”</p>
<p>RustSBI组织首页：<a href="https://github.com/rustsbi">https://github.com/rustsbi</a></p>
<h2><a class="header" href="#惊叹-rust-在艺术领域的商业应用" id="惊叹-rust-在艺术领域的商业应用">惊叹！ Rust 在艺术领域的商业应用！</a></h2>
<p><a href="https://t.me/rust_daily_news/4863">观看视频</a></p>
<p>该艺术项目使用486步进电机，86,000个LED和5通道颗粒式合成引擎，控制软件系统使用 Rust 实现，利用的是 nannou 和 koto。</p>
<p>该项目背后是一家德国公司：<a href="chapter_6/mindbuffer.net">mindbuffer.net</a></p>
<ul>
<li><a href="https://nannou.cc/">https://nannou.cc/</a></li>
<li><a href="https://github.com/koto-lang/koto">https://github.com/koto-lang/koto</a></li>
</ul>
<h2><a class="header" href="#2021年开源操作系统夏令营-欢迎报名" id="2021年开源操作系统夏令营-欢迎报名">2021年开源操作系统夏令营 欢迎报名</a></h2>
<p><strong>任何</strong> 对Rust 和 RISC-V写操作系统<strong>感兴趣的均可报名</strong></p>
<p>鹏城实验室和清华大学组织的2020年开源操作系统夏令营收到同学们的积极响应，参与夏令营的同学在今年的“2021全国大学生计算机系统能力大赛 - 操作系统赛”的初赛中都有不错的表现( <a href="https://mp.weixin.qq.com/s/Cb2SaonAAHDVNDli_80Bpw">https://mp.weixin.qq.com/s/Cb2SaonAAHDVNDli_80Bpw</a> )，今年启元实验室、清华大学和CSDN等将继续组织“2021年开源操作系统夏令营”，希望能把对开源操作系统开发有兴趣的朋友团结在一起，形成一个活跃的开源社区。欢迎对开源操作系统有兴趣的任何人报名（需填写下面的报名问卷）参加。</p>
<p><strong>2021年开源操作系统夏令营</strong></p>
<ul>
<li>第一阶段： <a href="https://github.com/rcore-os/rCore/wiki/os-tutorial-summer-of-code-2021">https://github.com/rcore-os/rCore/wiki/os-tutorial-summer-of-code-2021</a></li>
<li>第二阶段： <a href="https://github.com/rcore-os/rCore/wiki/zcore-summer-of-code-2021">https://github.com/rcore-os/rCore/wiki/zcore-summer-of-code-2021</a></li>
<li>报名问卷： <a href="http://oscourse2019.mikecrm.com/vzZqxgM">http://oscourse2019.mikecrm.com/vzZqxgM</a></li>
</ul>
<h2><a class="header" href="#gdc-2021-峰会--treyarch-公司致力于-游戏工具库的-rust-应用" id="gdc-2021-峰会--treyarch-公司致力于-游戏工具库的-rust-应用">GDC 2021 峰会 ： Treyarch 公司致力于 游戏工具库的 Rust 应用</a></h2>
<p>GDC (Game Developers Conference 2021) 峰会将于 7月19～23日举行。 Treyarch 公司（《使命召唤系列》游戏公司）将在该峰会发表 Rust 相关议题。</p>
<blockquote>
<p>Treyarch是美国的一家电子游戏开发商，总部位于加利福尼亚州的圣莫尼卡。 Treyarch成立于1996年，2001年被美国动视收购。其代表作为《使命召唤系列》。</p>
</blockquote>
<p>Rust编程语言已经悄悄地在科技界掀起风暴，但在游戏工作室中的采用却比较缓慢。自2018年以来，Treyarch一直在逐步将Rust整合到我们的工具和管道中。本次会议将利用这一经验，探讨Rust可以给游戏工具程序员带来的机遇和挑战，并研究Rust可以成为游戏工具库的有力补充的方式。</p>
<p>Treyarch 在 GDC  大会的议题：</p>
<ul>
<li>The Rust Programming Language for Game Tooling</li>
<li>Boots on the Ground: The Terrain of 'Call of Duty'</li>
<li>Shadows of Cold War: A Scalable Approach to Shadowing</li>
</ul>
<p><a href="https://schedule.gdconf.com/session/tools-summit-the-rust-programming-language-for-game-tooling/880599">https://schedule.gdconf.com/session/tools-summit-the-rust-programming-language-for-game-tooling/880599</a></p>
<h2><a class="header" href="#在curl中使用hyper如何帮助使互联网更安全" id="在curl中使用hyper如何帮助使互联网更安全">在curl中使用hyper如何帮助使互联网更安全</a></h2>
<blockquote>
<p>作者：Sean McArthur（hyper作者）</p>
</blockquote>
<p><strong>大概翻译了一下重点摘要：</strong></p>
<p>今年2月，互联网安全研究小组的Josh Aas、curl的Daniel Stenberg和我（来自hyper和Amazon Web Services）联合举办了一场网络研讨会，讨论内存安全和互联网，以及在curl中使用hyper如何帮助使互联网更安全。由于curl是开源和许可的，从物联网设备到卫星，以及大多数Linux发行版中都可以找到它。Curl是那些我们认为理所当然的基础库之一，但它影响着我们的网络生活。（视频回顾：https://www.youtube.com/watch?v=okGUxW_i9yk）</p>
<p><strong>不太安全的互联网</strong></p>
<p>内存安全是编程语言或系统的一个属性，它可以保护程序不会错误地访问它不应该访问的内存，例如认为缓冲区比它大，或者从一个指针解释数据，而这个指针后来被清理并用于不同的值。缺乏内存安全是对互联网基础设施的一个严重的持续威胁，并对个人和组织都造成了重大的、有意义的损害。比如说。</p>
<ul>
<li>微软估计，在过去十年中，他们的产品中70%的漏洞都是由缺乏内存安全造成的。</li>
<li>谷歌发现，Chrome浏览器70%的严重安全漏洞是内存安全问题。</li>
<li>Android团队报告说，他们90%的漏洞是内存安全问题。</li>
<li>Mozilla指出，Firefox在其风格组件中的74%的安全漏洞是内存安全漏洞。</li>
<li>最近的一项研究表明，60-70%的iOS和macOS漏洞都与内存安全有关。</li>
<li>Project Zero的一项分析发现，被利用的0-day中，有超过80%是由于缺乏内存安全。</li>
</ul>
<p>这些漏洞可能导致现实生活中的隐私被侵犯、财务损失、公共服务被剥夺，以及人权受到影响。</p>
<p>造成这种漏洞泛滥的一个重要原因是，许多工具是用编程语言编写的，而这些语言对内存安全漏洞的保护作用不大，甚至没有。尽管 &quot;内存安全 &quot;语言已经存在了很长时间，但由于性能或互操作性要求，它们经常被忽视。</p>
<p>通常说到内存安全就要提到 Rust 。Rust是一种较新的语言，它执行内存安全，但具有与C类似的性能和互操作性。然而，这篇博文并不是呼吁 &quot;用Rust重写（所有）&quot;。</p>
<p>重写所有的东西是不现实的，每一段代码对人类的影响也是不一样的。相反，让我们简单地走过一个实际的努力，把内存安全带到互联网的关键部分。这种努力鼓励项目用内存安全库来取代库或模块化功能，而不是着手进行基础重写。它将工作分解成可管理的部分，并逐步提供价值。</p>
<p><strong>curl无处不在</strong></p>
<p>curl是开始这项工作的理想人选。潜在的影响是巨大的，因为curl无处不在。根据curl网站的说法。</p>
<p>curl在命令行或脚本中被用来传输数据。curl也被用于汽车、电视机、路由器、打印机、音频设备、手机、平板电脑、机顶盒、媒体播放器中，并且是超过100亿套软件应用程序的互联网传输引擎。</p>
<p>curl也是用C语言编写的。</p>
<p>在最近的一篇博文中，Daniel Stenberg指出，curl有一半的漏洞是C语言的错误--换句话说，与内存安全有关。这些错误包括缓冲区超读、缓冲区溢出、使用后释放和双重释放。尽管curl处理了一大堆协议，但HTTP是内存安全漏洞的第二大领域。</p>
<p>我们能让curl更安全吗？</p>
<p>这样做会使互联网更安全，所以值得努力。而这正是我们要做的。Curl的API和ABI是稳定的 &quot;装甲门&quot;，不会损坏。但是curl已经熟悉了为其内部实现细节选择不同的 &quot;后端&quot;。在此之前，curl可以被配置为内部支持TLS、DNS、压缩和其他组件的后端。我们只需要提供一个更安全的HTTP后端选项。</p>
<p><strong>&quot;此时 Hyper 加入了群聊&quot;</strong></p>
<p>Hyper是一个安全、正确、快速的Rust语言的HTTP库。Hyper是开源的，并被AWS、Buoyant、Discord、谷歌、微软、Mozilla等公司使用。它有客户端和服务器端的API，并提供对HTTP/1和HTTP/2的支持。</p>
<p>Rust库不会带来对新运行时的依赖，在C语言中调用Rust函数也没有开销，反之亦然。它只是需要工程师的工作来暴露一个与C语言兼容的API。</p>
<p>Hyper开发人员立即知道这是需要做的事情。考虑到curl的使用量，这是一个让互联网更安全的机会。而hyper的Rust用户也会受益，因为这项工作所处理的任何bug修复或边缘案例也会为他们修复。</p>
<p>我们为hyper设计了一个C语言API。大部分的工作是围绕着识别Rust和C语言之间的假设差异。在这些部分被解决后，API就开始工作了。Hyper添加了几个选项，让curl对他们的用户来说几乎没有区别。</p>
<p><strong>目前状态：</strong></p>
<p>curl和hyper的代码都已经合并到了各自的主开发分支。Curl 可以被配置为以 hyper 作为其 HTTP 后台进行编译，尽管它将处于实验状态，直到 curl 的所有 HTTP 支持与它的内部 C 后台一样工作，并且被更广泛地试用。大部分的代码已经工作了，剩下的问题是更复杂的HTTP功能，仍然需要更新以支持不同的后端。跟踪工作的最好方法是通过curl的广泛测试套件。</p>
<p>从数量上看，在800个左右的HTTP单元测试中，有95%的测试被移植并通过了配置为后端的hyper。这意味着 curl 的很多标准功能已经在工作了。使用hyper后端，curl支持HTTP/1和HTTP/2。它可以使用任何 TLS 后台的 HTTPS，甚至可以使用 HTTP(S) 代理。无论使用哪种后端，电线上的HTTP请求都是相同的。</p>
<p><strong>下一步是什么？</strong></p>
<p>还需要在curl中加入一些功能，以使整个测试套件通过。此外，我们还希望改善对恐慌和内存不足的处理，以及其他关于从Rust中暴露C语言库的细节。此外，开发人员还需要调整或修复curl在完成单元测试时注意到的任何问题。</p>
<p><a href="https://aws.amazon.com/blogs/opensource/how-using-hyper-in-curl-can-help-make-the-internet-safer/">https://aws.amazon.com/blogs/opensource/how-using-hyper-in-curl-can-help-make-the-internet-safer/</a></p>
<h2><a class="header" href="#tensorbase--risc-v-芯片上执行-sql" id="tensorbase--risc-v-芯片上执行-sql">TensorBase | RISC-V 芯片上执行 SQL</a></h2>
<p>TensorBase 是第一个在真正的 RISC-V 芯片上运行的 SQL 数据库</p>
<p><a href="https://tensorbase.io/2021/06/08/sql_on_riscv_in_rust.html">SQL on RISC-V Chip in Rust (tensorbase.io)</a></p>
<h2><a class="header" href="#aws-添加了-9-项关于rust-sdk的新服务" id="aws-添加了-9-项关于rust-sdk的新服务">AWS 添加了 9 项关于rust sdk的新服务</a></h2>
<p><a href="https://github.com/awslabs/aws-sdk-rust/releases/tag/v0.0.7-alpha">https://github.com/awslabs/aws-sdk-rust/releases/tag/v0.0.7-alpha</a></p>
<h2><a class="header" href="#reddit-讨论rust语言在项目管理上的优势" id="reddit-讨论rust语言在项目管理上的优势">Reddit 讨论：Rust语言在项目管理上的优势</a></h2>
<p>Rust在技术/项目管理上有什么优势吗？足以支撑你说服自己和其他人在公司内部开始尝试使用Rust？ </p>
<p>作者提到了两点：</p>
<ol>
<li>安全
<ul>
<li>理由：&quot;70%的安全问题都和内存安全有关&quot;</li>
<li>证据：
<ul>
<li><a href="https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/#:%7E:text=Microsoft%3A%2070%20percent%20of%20all%20security%20bugs%20are%20memory%20safety%20issues,-Percentage%20of%20memory&amp;text=Around%2070%20percent%20of%20all,week%20at%20a%20security%20conference">Microsoft: 70 percent of all security bugs are memory safety issues</a></li>
<li><a href="https://www.chromium.org/Home/chromium-security/memory-safety">Google: chromium memory-safety problem</a></li>
</ul>
</li>
</ul>
</li>
<li>维护
<ul>
<li>理由：软件设计、研发到生产过程中的维护复杂度会逐步上升</li>
<li>证据：<a href="https://www.whitesourcesoftware.com/wp-content/media/2021/04/graph2.jpg">Relative cost to fix, based on time of detection</a></li>
</ul>
</li>
</ol>
<p>或者你有其他任何观点和证据来说服别人使用rust吗？</p>
<p><a href="https://www.reddit.com/r/rust/comments/o0a61h/rusts_advantages_in_13_slides_on_management_level/%5D">https://www.reddit.com/r/rust/comments/o0a61h/rusts_advantages_in_13_slides_on_management_level/%5D</a></p>
<h2><a class="header" href="#在-facebook-rust-是如何被用来构建-linux-系统工具库和服务的" id="在-facebook-rust-是如何被用来构建-linux-系统工具库和服务的">在 Facebook Rust 是如何被用来构建 Linux 系统工具、库和服务的</a></h2>
<p>这篇是一篇采访纪录，@NavyataBawa邀请到了 Facebook 工程师 Daniel Xu，分享他在 Facebook 是如何使用 Rust 来构建 Linux 系统工具、库和服务的。</p>
<p><a href="https://developers.facebook.com/blog/post/2021/06/24/meet-rustaceans-daniel-xu/">https://developers.facebook.com/blog/post/2021/06/24/meet-rustaceans-daniel-xu/</a></p>
<h1><a class="header" href="#活动回顾-2" id="活动回顾-2">活动回顾</a></h1>
<p>后期编辑：张汉东</p>
<blockquote>
<p>编者按：</p>
<p>总结了本月的活动，包括线上和线下。</p>
<p>线上： 《Rust 唠嗑室》和 《RustFriday 飞书群线上沙龙》</p>
</blockquote>
<hr />
<h1><a class="header" href="#线上rust-唠嗑室本月汇总-2" id="线上rust-唠嗑室本月汇总-2">【线上】Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598/video">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
<li>后期编辑：高宪凤</li>
</ul>
<h3><a class="header" href="#rust-唠嗑室第-26-期---利用-rust-构造-riscv-asm-分析工程" id="rust-唠嗑室第-26-期---利用-rust-构造-riscv-asm-分析工程">《Rust 唠嗑室》第 26 期 - 利用 Rust 构造 riscv asm 分析工程</a></h3>
<p><strong>时间</strong>: 2021/06/8 20:30-21:30</p>
<p><strong>主讲人</strong>：lyzh</p>
<p><strong>内容</strong>：</p>
<ol>
<li>如何利用 Pest 库做文法分析，</li>
<li>用 PyO3 与 Python 交互</li>
<li>一些简单的数据流分析方法</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1UB4y1T7PB">查看回放</a></p>
<hr />
<h3><a class="header" href="#rust-唠嗑室第-27-期-michael-yuan-wasmedge-介绍使用-wasm-reactor-开发飞书机器人" id="rust-唠嗑室第-27-期-michael-yuan-wasmedge-介绍使用-wasm-reactor-开发飞书机器人">《Rust 唠嗑室》第 27 期-Michael Yuan-WasmEdge 介绍使用 Wasm Reactor 开发飞书机器人</a></h3>
<p><strong>时间</strong>: 2021/06/23 20:30-21:30</p>
<p><strong>主讲人</strong>：Michael Yuan@WasmEdge</p>
<p><strong>内容</strong>：</p>
<p>SaaS 平台通常会为开发者和客户提供 API 以扩展其核心功能，比如 JIRA 的自定义插件或 Slack 上的聊天机器人。但是，传统的 RESTful API 方法通常需要开发者设置服务器来接收和响应来自 SaaS 平台的事件。例如，在 飞书聊天机器人应用程序中，开发者需要设置一个服务器来监听发送给机器人的消息，然后将机器人的响应发送回 Slack。这对开发人员来说既乏味又昂贵。</p>
<p>随着 serverless 计算的进步，尤其是由 WebAssembly 等新运行时启用的轻量级无服务器功能，现在可以将反应式功能直接嵌入到 SaaS 平台中，而无需让创建任何新服务器。</p>
<p>这次将会与大家讨论 SaaS 平台中反应式 serverless 函数背后的想法、用例和应用程序架构。</p>
<p>参考资料：</p>
<ol>
<li>https://github.com/WasmEdge/WasmEdge</li>
<li>https://github.com/second-state/runw</li>
<li>https://github.com/second-state/crunw</li>
<li>http://reactor.secondstate.info</li>
<li>http://reactor.secondstate.info/en/docs/user-create-a-bot.html</li>
<li>https://github.com/second-state/serverless-reactor-starter</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV16b4y1C7B5">查看回放</a></p>
<hr />
<center> 🔥🔥🔥🔥 <strong>RustFriday 飞书群线上沙龙</strong> 🔥🔥🔥🔥 </center>
<h1><a class="header" href="#线上rustfriday-飞书群线上沙龙-2" id="线上rustfriday-飞书群线上沙龙-2">【线上】RustFriday 飞书群线上沙龙</a></h1>
<p>每周五晚八点，限定两个主题：语言特性和开源项目，在线讨论。</p>
<p>Rust 中文社群 飞书群 邀请你加入：</p>
<p>对话群： <a href="https://applink.feishu.cn/TeLAcbDR">https://applink.feishu.cn/TeLAcbDR</a></p>
<p>话题群：<a href="https://applink.feishu.cn/TeLD868w">https://applink.feishu.cn/TeLD868w</a></p>
<p>视频来源：<a href="https://space.bilibili.com/24917186">https://space.bilibili.com/24917186</a></p>
<h2><a class="header" href="#第十期讨论主题" id="第十期讨论主题">第十期讨论主题：</a></h2>
<ol>
<li>语言特性： 聊聊 Rust 类型系统和 特质（trait）系统</li>
<li>领域项目： 继续跟随 Linux 基金会在线 WebAssembly 课程学习 Host 和 guest 高级通信方式：WAPC</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://github.com/wasmCloud</li>
<li>https://github.com/waPc</li>
<li>https://crates.io/crates/wasmtime-provider</li>
<li>https://www.infoq.cn/article/bc0fzghd9s6fmm03pmbi</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1Lo4y1278N">查看回放</a></p>
<hr />
<h2><a class="header" href="#rust-中文社区飞书群线上直播尝试-websocket-聊天的桌面端开发" id="rust-中文社区飞书群线上直播尝试-websocket-聊天的桌面端开发">Rust 中文社区飞书群线上直播：尝试 websocket 聊天的桌面端开发</a></h2>
<ol>
<li>考察 tauri 的可行性和易用性</li>
<li>gtk glade layout Editor 工具编辑 ListView</li>
<li>学习 TreeView 追加元素的代码</li>
<li>完成类似微信/飞书的聊天 UI 界面</li>
<li>完成文本输入框和点击发送按钮更新聊天消息的功能</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1vV411x7fe">查看回放</a></p>
<hr />
<h2><a class="header" href="#第十一期-讨论主题" id="第十一期-讨论主题">第十一期 讨论主题：</a></h2>
<ol>
<li>
<p>三个 Rust Friday 线上沙龙，也就是三个周五晚上的时间，学习了 Linux 基金会的免费 Web Assembly 课程，感觉收获颇丰。（沙龙 九/十/十一期）</p>
</li>
<li>
<p>课程的难度适中，重点在于比较系统。很多细节其实是需要自己去学习和了解的，但是课程为你布置好了体系结构。一些关键的概念都讲到了。可以让对 wasm 在分布式和边缘计算方向有一个比较具象的认识。</p>
</li>
<li>
<p>最有意思的是作者针对 Web Assembly 现状，提出的 wa PC 协议和 wasmcloud 项目，都很有创新精神。</p>
</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://wasmcloud.com/</li>
<li>https://lunatic.solutions/</li>
<li>https://crates.io/crates/nats</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV17h411a7xq">查看回放</a></p>
<hr />
<h2><a class="header" href="#第十二期-讨论主题" id="第十二期-讨论主题">第十二期 讨论主题：</a></h2>
<ol>
<li>聊聊 eBPF 技术。</li>
<li>聊聊 Rocket web 框架设计。</li>
</ol>
<p>参考资料：</p>
<ol>
<li>https://jishuin.proginn.com/p/763bfbd4c155</li>
<li>https://doc.rust-lang.org/rustc/platform-support.html#tier-3</li>
<li>https://security.tencent.com/index.php/blog/msg/124</li>
<li>https://www.anquanke.com/post/id/221545</li>
<li>https://github.com/alessandrod/aya</li>
<li>https://www.infinyon.com/blog/2021/05/ebpf-routing-rust/</li>
<li>https://github.com/nacardin/ebpf-proxy</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1hq4y1L7GE">查看回放</a></p>
<h1><a class="header" href="#本月招聘-2" id="本月招聘-2">本月招聘</a></h1>
<h2><a class="header" href="#北京中关村远程tensorbase开源数据仓库等一群人做一件事" id="北京中关村远程tensorbase开源数据仓库等一群人做一件事">[北京中关村/远程][TensorBase][开源数据仓库]等一群人，做一件事</a></h2>
<p><a href="https://github.com/tensorbase/tensorbase">TensorBase</a>，基于Rust的现代化开源实时数据仓库。它专注于开源大数据存储和分析的基础设施，让大数据背后的价值可以惠及这个时代中每个个体和企业。</p>
<p>团队介绍：我本人的<a href="https://jinmingjian.xyz/resume/">简介在这里</a>。TensorBase已获陆奇博士旗下奇绩创坛（原YC中国）的种子轮投资，陆奇博士就是我们的合伙人！</p>
<p>开源，惠人达己。创新，守正出奇。基础设施的未来，必定是开源和创新的。目前TensorBase有很好的社区和成果，ClickHouse的核心领导人Alexey Milovidov给TensorBase提交了PR，中国的开源数据基础设施项目首次赢得了国外开源数仓领袖的敬意，我们可以骄傲！</p>
<p>我有一个梦想：和一群中国工程师一起相互帮助、探索和努力，做一件可以走在这个时代的最前沿，还可以让自己成长、开心和骄傲的事情。我等这样一群人：</p>
<ol>
<li>愿意使用Rust语言，并贡献到Rust开源社区（希望你不要把语言当作一个工具，虽然客观上它确是一个工具）。</li>
<li>有创新和探索精神，愿意在无人区工作。</li>
</ol>
<ul>
<li>内核向：对数据工程、高性能系统、高性能计算、编译器、Linux内核、分布式、并发、网络协议等一个或者多个领域有实践或有兴趣。</li>
<li>社区向：对Rust/数据有兴趣的前端或Technical writer。</li>
</ul>
<ol start="3">
<li>爱做TensorBase这样一件事情，爱和TensorBase这样一群人一起工作。</li>
</ol>
<p>全职、实习均可，但实习生需要onsite。</p>
<p>对比大厂，提供有竞争力的薪酬 + 期权。</p>
<p>联系方式：</p>
<p>邮箱： <strong>hr@tensorbase.io</strong></p>
<p>工作地点：</p>
<p>海淀区中关村。这里离好几个新近的开源创业团队都很近，比如太极图形。这里是中国开源创业的新硅谷。不加班，希望大家早睡早起，我邀请大家一起去边上的海淀公园晨跑，为家国健康工作50年。同时，对于合适的同学，可以远程工作。</p>
<p>加入我们，一起创造TensorBase的下一个五年！ </p>
<h2><a class="header" href="#datafuse--数据库rust讲师" id="datafuse--数据库rust讲师">Datafuse | 数据库Rust讲师</a></h2>
<blockquote>
<p>Datafuse是使用Rust构建的完全面向云架构的新一代开源数仓，目的为用户提供更高性能，更低成本、更加易用的数据分析服务。</p>
<p>Datafuse项目地址： <a href="https://github.com/datafuselabs/datafuse">https://github.com/datafuselabs/datafuse</a></p>
</blockquote>
<p>简历发送： <strong>hr @ datafuselabs.com</strong></p>
<p><strong>职位诱惑：</strong></p>
<ul>
<li>Remote办公，六险一金，弹性工作，大牛带队，扁平管理。</li>
<li>待遇：面谈</li>
</ul>
<p><strong>职位职责：</strong></p>
<ol>
<li>负责Rust相关课程开发及授课工作</li>
<li>了解Datafuse项目，从项目中抽取模块编排教学工作</li>
<li>从事Datafuse部分文档输出</li>
<li>针对Datafuse输出用户解决方案</li>
</ol>
<p><strong>职位要求：</strong></p>
<ol>
<li>良好的系统编程能力，喜爱或是有Rust经验及扎实的C/C++功底更佳</li>
<li>熟悉数据库运行原理或是大数据应用场景更佳</li>
<li>喜欢关注新技术，愿意做技术推广</li>
<li>了解课程设计及开发</li>
<li>热忠自动完成事情</li>
</ol>
<h2><a class="header" href="#百度招聘rust研发工程师" id="百度招聘rust研发工程师">百度招聘Rust研发工程师</a></h2>
<p><strong>1. 职位概况</strong></p>
<ul>
<li>岗位名称：资深Rust研发工程师</li>
<li>所属部门：百度安全部</li>
<li>岗位职级：技术T5-T7</li>
<li>工作地点：北京市</li>
</ul>
<p><strong>2. 工作职责</strong></p>
<ul>
<li>负责数据安全计算相关产品核心组件研发以及开源社区建设</li>
<li>参与数据安全与隐私计算产品研发</li>
<li>负责基于Intel SGX、ARM TrustZone等硬件技术的调研、分析与应用转化</li>
<li>负责机器学习与深度学习算法在TEE技术上的移植与优化</li>
</ul>
<p><strong>3.职位要求</strong></p>
<ul>
<li>计算机软件、信息安全等相关专业，统招本科及以上学历</li>
<li>有良好的系统编程能力，喜爱或有Rust开发经验以及扎实的C/C++功底</li>
<li>熟悉常用数据结构和算法，熟悉Linux系统</li>
<li>关注代码设计和新技术，有持续学习的习惯</li>
<li>有TEE可信执行环境、Intel SGX、机器学习、区块链相关技术经验者优先</li>
<li>熟悉Github开源社区，长期贡献者优先</li>
</ul>
<p>有意者请投简历至邮箱：luoyanhua@baidu.com</p>
<h2><a class="header" href="#phala招聘-rust区块链研发工程师" id="phala招聘-rust区块链研发工程师">Phala招聘 Rust区块链研发工程师</a></h2>
<p><strong>1. 关于Phala Network</strong></p>
<p>波卡系保密智能合约平台，可以实现保密前提下的数据交易协议，致力于成为 Web3.0 数据隐私计算的基础设施。基于 Substrate 开发的 Phala 未来将会成为 Polkadot 平行链，通过跨链协议为任何区块链的提供机密智能合约能力。Phala 是波卡生态的重要成员：2019 年 8 月获得 Web3 基金会 Grant，2020 年 3 月成为首批加入 Parity Substrate Builders 计划的项目之一。在 Phala Network，我们相信下一代区块链需要安全高效的处理机密数据，因此我们开发了基于 TEE 的保密合约，致力于为区块链实现保密能力。</p>
<p><strong>2. 职位描述</strong> </p>
<ul>
<li>有 Rust 开发经验，或拥有快速上手 Rust 的能力</li>
<li>区块链相关数据结构与算法</li>
<li>扎实的计算机科学基础知识</li>
<li>熟悉 Git 版本管理、单元测试，熟悉开源协作</li>
<li>认同技术文档、开源教程、参与技术分享的重要性并积极参与</li>
</ul>
<p><strong>3. 职位方向</strong></p>
<p><strong>核心协议</strong></p>
<ul>
<li>
<p>Intel SGX SDK 开发与整合</p>
</li>
<li>
<p>P2P网络通信与密钥管理</p>
</li>
<li>
<p>XCM 跨链协议整合</p>
</li>
<li>
<p>对接 Filecoin 等分布式存储协议</p>
</li>
</ul>
<p><strong>保密合约基础设施</strong></p>
<ul>
<li>WASM、Ink! 执行环境的整合、优化、Chain Extension 开发</li>
<li>调研和改进合约编程模型</li>
<li>WASM 工具链的整合</li>
</ul>
<p><strong>区块链开发</strong></p>
<ul>
<li>设计与实现 Substrate Pallet</li>
<li>Ink! 合约研发、测试与部署</li>
<li>不同场景下的 XCM API 设计与实现</li>
</ul>
<p><strong>计算平台</strong></p>
<ul>
<li>构建兼容工业标准的 Serverless、FaaS 基础平台在 Phala 上开发与移植应用，并测试平台的可用性</li>
</ul>
<p><strong>4. 加分项</strong> </p>
<ul>
<li>有可信执行环境应用开发经验：Intel SGX、AMD SEV、Arm TrustZone</li>
<li>Substrate或其他区块链节点开发经验</li>
<li>扎实的应用密码学知识：非对称加密、零知识证明、多方安全计算</li>
<li>跨链桥（比特币SPV节点）、Layer 2 开发经验（核心协议方向）</li>
<li>Solidity、Ink等智能合约开发经验（区块链开发方向）</li>
<li>FaaS、Serverless、Event Sourcing实施经验（计算平台方向）</li>
<li>分布式系统任务调度、分布式事务、分布式存储等基础设施的开发经验（计算平台方向）</li>
</ul>
<p>有意者请联系邮箱：hire@phala.network或微信：h4xbigcat</p>
<h2><a class="header" href="#automata-network-招聘区块链研发工程师" id="automata-network-招聘区块链研发工程师">Automata Network 招聘区块链研发工程师</a></h2>
<p><strong>1. 关于Automata Network</strong></p>
<p>Automata Network 是一个全新的隐私中间件网络，致力于通过为 dApp 提供无缝衔接的隐私保护和高可用性解决方案，来促进 Web3.0 社区的发展。我们正在寻找对此领域感兴趣，有热情，同时具有强大自力驱 的小伙伴。希望你能加入我们，作为团队核心的研发成员，进行技术的探索和应用的研发。公司总部位于新加坡，你也可以选择在家远程办公，请速将简历砸向我们吧!</p>
<p><strong>2. 职位描述</strong></p>
<ul>
<li>基于 Substrate (https://substrate.dev) 进行区块链相关应用的研发</li>
<li>基于 Intel SGX 进行支持可信执行环境(TEE)相关研发</li>
<li>探索前沿的技术解决方案，设计技术架构</li>
<li>编写单元测试，编写技术文档，审核其他成员的代码</li>
</ul>
<p><strong>3. 职位要求</strong></p>
<ul>
<li>两年以上的软件开发经验</li>
<li>熟练掌握 Rust 或者 Modern C++ 其中一门语言，熟悉常见脚本语言如 Shell 和 Python的使用</li>
<li>具有很强的解决问题能力和沟通能力，能够快速学习并掌握新的技术</li>
<li>熟悉开源社区的开发和协作方式</li>
<li>加分项: 熟悉 TEE 相关技术，如 Intel SGX 开发，了解区块链相关协议和常见共识算法</li>
</ul>
<p><strong>4. 加分福利</strong></p>
<ul>
<li>具有市场竞争力的薪资待遇，优秀的小伙伴更可获得 token 配额</li>
<li>灵活安排的工作时间，积极开放的工作氛围以及行业大牛的手把手指导</li>
<li>在最前沿的技术领域进行探索，填补技术空白，能让你快速成长，成为领域内的专家</li>
</ul>
<p>有意者请投简历至邮箱: hiring@ata.network</p>
<p>如果对Rust与区块链有兴趣，请关注OneBlock+微信公众号，还有多家区块链项目在招募Rust工程师。</p>
<h2><a class="header" href="#rust-与开源--rust-并不是一家公司" id="rust-与开源--rust-并不是一家公司">Rust 与开源 | Rust 并不是一家公司</a></h2>
<p>译者：郭晓双 / 后期编辑：张汉东</p>
<blockquote>
<p>原文： https://blog.m-ou.se/rust-is-not-a-company/</p>
<p>本文是 Mara(Rust Library Team Leader) 写的一篇关于 Rust 项目开源治理的文章。</p>
</blockquote>
<hr />
<h3><a class="header" href="#不是公司" id="不是公司">不是公司</a></h3>
<p>在大多数公司中，董事和股东等等都在层次结构的顶端，他们为公司设定目标。目标、里程碑、最后期限，以及有望推动公司朝着最终目标前进的事情；通常是钱。</p>
<p>然后在部门和团队上划分了几层管理来划分工作量。每个人都负责部分目标，确保他们的部分完成，最终将任务分配给层次结构底部的员工，所有人都以某种方式朝着主要目标努力。</p>
<p>虽然像 Rust 这样的大型开源项目背后的结构从远处看起来很相似，但它通常是完全颠倒的。在这样的项目中，目标和目标不是顶级团队的，而是贡献者的。</p>
<p>例如，作为库团队，我们可以尝试决定应该重写格式机制 (std::fmt) 以使其更小更高效。但是做出这个决定并不会让它发生。而且我们没有分配任务的员工。这不是它的工作原理。</p>
<p>相反，一个对格式化算法充满热情的贡献者可能会出现，并开始研究这些事情。作为图书馆团队，我们的工作是赋予这个人权力。确保他们的计划与标准库的其余部分一致，审查他们的更改并提供有用的建设性反馈，如果更多人出现在这方面工作，则成立一个工作组来帮助他们组织一切等等。</p>
<p>公司不会让新人随机出现来做某事。如果做得好，这就是开源的特别之处和如此美妙的地方。</p>
<h3><a class="header" href="#个人目标" id="个人目标">个人目标</a></h3>
<p>理想情况下，像 Rust 这样的开源项目的项目目标只是参与其中的每个人的个人目标的组合。这很棘手。因为当一个新人出现时，我们不会为他们分配符合我们目标的任务。相反，这个人有自己的目标和想法，增加了已经非常多样化的潜在冲突目标。</p>
<p>这就是为什么一个由志愿者运营的开源项目需要一个管理结构。你不能把一百个人都有自己的目标，然后希望一切顺利。</p>
<p>因此，管理层所做的就是从每个从事某个主题的人那里获取所有个人目标，并尝试以某种方式引导他们，使事情顺利进行。这可能涉及对不适合其他想法的想法说不，或者可能需要进行大量讨论以调整想法以使其适合。这与典型公司的工作方式完全相反，目标来自上层，管理层决定如何拆分并将其分配给从事技术工作的人员。</p>
<p>虽然包括 Rust 在内的许多开源项目确实有一个总体方向或路线图，但这些必须基于个人贡献者的目标才能成功。说“我们 2021 年的主要目标是改进标准库中的格式化机制”将赋予那些已经在致力于它的人，并吸引那些已经想从事类似工作的人。这会对他们有所帮助，因为我们现在会优先考虑他们需要的任何管理决策和代码审查。它可以让人们集中注意力，完成更多工作。但没有这些贡献者，设定这样的目标毫无意义。与公司不同，我们无法选择人们花时间做什么，我们也不会雇用人员分配任务。</p>
<p>这是一个很好的事情。</p>
<p>这就是人们想要在 Rust 上工作的原因。</p>
<p>我并不是说不能像公司那样“自上而下”管理编程语言。许多编程语言已经并且正在以这种方式非常有效地开发。然而，我要说的是，我个人不希望 Rust 项目以这种方式工作。</p>
<p>我不希望管理锈公司库部门。我想授权那些想要改进 Rust 语言库的人。</p>
<h3><a class="header" href="#蓬勃的空间" id="蓬勃的空间">蓬勃的空间</a></h3>
<p>不同的贡献者有着不同的目标，通过非常不同的方式工作，并且需要与管理结构完全不同的东西。</p>
<p>对他们中的一些人来说，我们有适当的流程让他们的工作更轻松。想要开发新的语言特性的人可以以RFC的形式提交他们的想法，并加入库团队的讨论，以获得建议和指导。想要改进编译器实现的某些重要部分的人可以提交一个MCP（majorchangeproval）并与编译器团队讨论。如果有人想修复标准库中的一个bug，可以提交一个PR并让了解上下文的人对其进行复查(review)。</p>
<p>换句话说，我们为贡献者提供了很多空间。工作的空间，反馈问题的空间，得到帮助的空间，赢得认可的空间,  每一种能帮助他们成功做成事情的空间。</p>
<p>然而我们没有为一些类型的、不幸的贡献者创造合适的空间。</p>
<p>理想情况下，Rust库团队直到最近的工作一直集中在在API设计上。编译器团队只会关注关键重要问题的开发。较小的变更由单个库审阅者审阅。但是并没有对更大领域的变更进行管理。这意味着没有合适的空间提供给那些想要彻底检查并且变更std : : fmt实现的人。没有一个团队他们可以去或参与这方面的工作，那么对于想去变更std : : fmt实现的人来讲，这个目标就是更难、或者完全不可能完成的了。</p>
<p>这就是我成立<a href="https://twitter.com/m_ou_se/status/1405281369140334595">新库团队</a>的原因。</p>
<p>为某个事情腾出空间通常会（意外地）导致其它事情的空间被夺走。 如果一个人不太理解事情的实现，但是他们想要应用标准库设计的实践经验，并且非常关心标准库的接口，但是周会上面主要讨论如何让bug少，在下一个版本之前如何解决现有的问题的事情，那么他是不会在一个这样的周会上面十分积极的。</p>
<p>我们现在已经有了库贡献者。这是一个空间，容纳管理比一般人更加多的参与项目，但是不参与整体团队的决策的人。例如那些只处理库的特定部分，或者帮助审核(review)的人，我们为这些人提供了空间。一年之前如果没有一个更加合适的团队的话，就没有合适的空间让一个人去审核(review)库的实现。</p>
<p>在核心团队和库团队成员的授权和帮助下，我能够做出这些团队结构的改变。反过来，这些变化有望使这些新团队的成员茁壮成长，并反过来使更多的贡献者受益，最终使语言的所有用户受益。</p>
<h3><a class="header" href="#保持改变" id="保持改变">保持改变</a></h3>
<p>我并不认为我们现在已经成功地为每个可能的贡献者创造了空间。但是一旦团队的重组尘埃落定，我确实认为结果会比我们之前的情况有所改善，更符合目前的项目。</p>
<p>“此时此刻” 在这里成为了一个重要的部分。这些团队是围绕着目前的成员和我认为在不久的将来可能成为成员的人而设计的。但是团队的成员的需求变化，有时会出奇地快。在一个完全由为其做出贡献的人定义的项目中，对于这个项目自身和结构发生变化的事情的时候， 它就会快速的改变。</p>
<p>2018年,库团队大量参与指导了流行crate的作者。该团队发布了一套指南，将会审查(review) crate 并且和crate的作者一起实施它。所有这些都是为了提高 Rust crate 生态系统的一致性和质量。</p>
<p>直到几天前，这在技术上仍然是我们团队明确目标的一部分，尽管这种事情已经不是很多了；尤其是因为 Ashley Mannix 离开了一段时间。如果没有人将事情作为他们的个人目标，那么这个事情就不会发生。</p>
<p>这是一个很好的事情。</p>
<p>每个人的 Rust 愿望清单上都有很多事情没有发生，因为没有人在做这件事。我们不是一家有我们需要达到的最后期限和里程碑的公司。我们是一群多元化且瞬息万变的人，他们热衷于让我们想要付出努力的事情发生。包括一群热衷于管理这一切的人，试图为所有这些努力的发生腾出空间。</p>
<p>有很多事情，我们应该有属于它的空间，但目前没有空间。但如果我们继续努力, 我们不断进行小的改进。继续适应。继续关注我们周围也想做出贡献的人；赋予他们以及彼此权力。然后每一步都将朝着正确的方向迈出一步，使 Rust 和所有为它做过贡献的人，与它一起茁壮成长。</p>
<h1><a class="header" href="#开源与心理健康" id="开源与心理健康">开源与心理健康</a></h1>
<p>作者： jackpot51(Redox作者) / 译者：张汉东</p>
<hr />
<p>今天看到 Redox （Rust 实现的下一代操作系统）作者在 Redox 官方博客上发了一篇文章 <a href="https://www.redox-os.org/news/open-source-mental-health/">《开源与心智健康》</a> 。这篇文章是他对多年的好朋友，Redox OS 贡献者 jD91mZM2 的回忆录。</p>
<p>“ jD91mZM2 于 2021 年 3 月去世，享年 18 岁。他参与了 2018、2019 和 2020 年的 Redox OS Summer of Code。他的开发涉及Redox OS 的各个层面，从内核到 relibc，再到移植程序。** jD91mZM2** 在 <a href="https://www.redox-os.org/news/">https://www.redox-os.org/news/</a> 上发表的许多文章来介绍他自己的这些工作。
这篇文章有些黑暗、沉重，但作者写它的目的也不仅仅是为了回忆好朋友，同时也想帮助开源社区里有同样心智问题的朋友。作者给出了联系方式：<a href="https://twitter.com/jeremy_soller">https://twitter.com/jeremy_soller</a> ，希望有相同问题的朋友能早点和他联系，他愿意提供帮助。</p>
<p>虽然这篇文章可能比较黑暗和沉重，但我觉得这篇文章值得翻译，也许能给我们有所警示。以下是正文。</p>
<h2><a class="header" href="#反思" id="反思">反思</a></h2>
<p>昨天，另一位贡献者给我发来消息，说 jD91mZM2 离线的时间很长，而且他没有回复电子邮件。我通过我所掌握的信息进行了联系，但无济于事。我把他的真实姓名告诉了另一位贡献者，后者找到了他的讣告。我们验证了他的名字、地点和出生日期是否相符。虽然没有列出死因，但我相信我们找到的证据表明他是在精神疾病发作后自杀的。</p>
<p>在得知这一切后，我感到很震惊。这样一个多产的贡献者，不仅对Redox，而且对许多项目都有贡献，怎么会觉得死亡比生命更重要？他是一个能力极其出色的人，而且直到最近，他似乎还能很好地把握自己的生活。但我思考越久就越意识到，这只是我对他生活的一种幻觉。而且，这种幻觉越深，事实可能越恶化。</p>
<p>我最后一次与 jD91mZM2 交流是在二月，在他去世前一个月。这次交流纯粹是技术性的，关于 Redox 内核的 arch64 端口。我不禁想到，这也许是他决定选择死亡的一个因素。</p>
<p>在开放源代码中，我们经常强调好的代码的重要性。毕竟，每个开源项目的交付物，都是源代码，对吗？我们常常忘记，好的代码是由优秀的人编写的，而留住这些人并让他们保持快乐，应该是任何项目维护者的首要考虑。</p>
<p>心理健康问题的发作有很多方面。一方面，精神疾病通常有一个遗传因素。另一方面，这些遗传的前兆通常需要慢性和急性的环境诱因。这些慢性诱因可以是长期的不良家庭或工作环境，并导致精神疾病本身的表现。急性诱因可能是，例如，与某人发生争执，导致精神疾病发作。这些发作可能严重到足以压倒求生本能，导致自杀。</p>
<p>在这种情况下，自杀并不是一种软弱的表现。事实上，它是一种极致信念和实力的展示。即使在精神疾病的背景下，大脑的某些部分通常不受影响。这些部分伴随人类历史悠久，我们很少有意识地控制它们。自杀的企图需要克服有意识的求生欲望。要成功，就是要克服极端的潜意识欲望。这就意味着，对于自杀，往往是最聪明、最有能力的人才能够成功。</p>
<p>这种对有能力的人的逆选择是一种可怕的流行病。人类总体上迫切需要人为地解决长期存在的问题。以气候变化为例。在每年80万自杀的人中，平均来说也许比我们其他人更有能力，如果有几个人在开发核聚变发电方面起到了作用，那会怎么样？</p>
<p>然而，我们作为一个社会已经采取了这样的立场：这些事件是一种不可阻挡的力量。导致自杀的因素是内部的，而不是外部的。原则上，我拒绝相信这一点。对于每一个问题，我们都必须寻找原因并加以缓解，即使最后不可能做到。</p>
<p>因此，我不得不审视自己的行为，看看有什么可以做得不同。看看我是否可以挽救一个人的生命，并看看我在未来可以挽救哪些生命。</p>
<h2><a class="header" href="#开源与心理健康-1" id="开源与心理健康-1">开源与心理健康</a></h2>
<p>开源的某些方面似乎吸引了人类中最奇怪的人，包括我自己。坚持所有的东西都是可检查的，这也许是由强迫性行为驱动的。而那些容易出现这种行为的人，往往会从其他疾病中继承下来。多动症、自闭症、双相情感障碍、抑郁症和其他疾病在开放源码贡献者中非常普遍。</p>
<p>因此，开源社区中也明显缺乏软技能。这显然会导致分裂社区和将开源本身与 &quot;正常 &quot;世界隔离的后果。对我们来说，幸运的是，开放源代码最终成为一个足以盈利的行业。这种资本的注入导致了开源领域人才的显著多样化。</p>
<p>然而，这也是有代价的。那些不符合开源项目新的商业利益的人往往被抛在一边。由于与原始维护者的分歧导致项目本身出现难以克服的变化，项目被进一步被分叉又分叉。我自己也参与了这方面的所有工作。</p>
<p>在大多数情况下，都缺乏对人力成本的调查。调查开源贡献者中众多的心理健康事件，并试图找出一些共同的因素。有时这些事件会导致新的项目，有时会导致贡献者精疲力尽，然后离开开放源码，有时会导致自杀。</p>
<p>我们必须认识到，我们在创造导致精神疾病的慢性压力和导致危险发作的急性压力方面所扮演角色。</p>
<h2><a class="header" href="#我自己的旅程" id="我自己的旅程">我自己的旅程</a></h2>
<p>我对心理疾病没有免疫力。我经常收到这样的信息：&quot;你似乎把你的东西都控制住了，你是怎么做到的？&quot; 残酷的事实是，我怀疑我们中是否有人真的做到了。而我们对 &quot;控制 &quot;的定义可能是非常不同的。拥有成功的项目并不等同于拥有普遍的幸福。</p>
<p>我不得不承认，我现在比以前幸福多了。因此，也许与一般人相比，我确实有事情在控制之中。我的生活一直是治疗师、精神病医生、药物和隔离的奥德赛。它本来很容易像其他人一样结束。我很幸运地找到了我的慢性压力源，并尽职尽责地消除它们。</p>
<p>我大一的时候，与 jD91mZM2 决定结束自己生命的年龄差不多，特别艰难。我的体重增加了近50磅。我和另外三个室友住在一起，其中两个也早逝了。我交替使用多动症药物、抗抑郁药，甚至吸烟，以寻找能 &quot;修复 &quot;自我的方法。在整个过程中，我一直在编程，为此常常忽略了我的学业。</p>
<p>在上大学之前，我曾在卓尔医疗公司担任实习生，编写除颤器软件。我在这项工作中拥有两项专利。老实说，在对计算机的理解上，我比别人高出一截。我也对自己说实话，在对人的理解方面，我比别人差了一大截，包括我自己。</p>
<p>在那段时间里，我与研发部的副总裁建立了关系，他成了我事实上的老板。大一快结束时，他联系我，问我是否想继续工作。我答应了。</p>
<p>大二的时候，我的情况非常不同。我把大部分时间花在写软件上，并且赚了不少钱。我对学校没有兴趣。我有几门课不及格，而许多高水平的CS课程也挂了。我很快就从大学退学，全职从事软件工程。</p>
<p>这对我的心理健康产生了巨大的积极影响。我减轻了体重。我与我大学的其他校友保持联系，并最终通过他们认识了我的妻子。我们一起买了一套房子。我开始了Redox操作系统，并且我和妻子结婚了，也开始在System76工作。我们拥有一个漂亮的女儿。从大二开始，我从来没有想过自己的心理健康问题，也不需要去治疗或用药。我所有的压力都消失了。</p>
<p>一个人的心理健康成功并不总是能转化为其他人的成功。在这一历程中，我创造和破坏了（通过忽视）数百种关系。我不得不承认，虽然我很快乐，但我有一种倾向，会在别人身上造成相当大的反差。我保留了给我带来快乐的关系，而忽略了那些需要努力的关系。而在某些时候，也许我忘记了与 jD91mZM2 保持联系，确保他找到与我一样的幸福。</p>
<h2><a class="header" href="#有没有一个解决方案" id="有没有一个解决方案">有没有一个解决方案？</a></h2>
<p>没有解决方案，每个案例都是不同的。但我觉得有必要检查一下这些年来我失去的许多人，我希望你也这样做。我们仍然处于了解人类思想的黑暗时代，我们越是相互检查，我们就会做得越好。我知道我本可以有所作为，如果我多做一点的话。也许不是为了jD91mZM2，而是为了有同样感觉的人。我不会再以他们所写的代码来评价贡献者。代码不会自己产生，写代码的人甚至比 &quot;开源 &quot;本身更需要维护。</p>
<h2><a class="header" href="#尾声" id="尾声">尾声</a></h2>
<p>翻译完本文的时候，在google上搜索到一个组织 <a href="https://osmihelp.org/">https://osmihelp.org/</a> ，该组织出了一本书：《Mental Health in Tech: Guidelines for Mental Wellness in the Workplace》，可以在 Leanpub 上找到，也许能有所帮助。</p>
<h1><a class="header" href="#三万言2021-年-rust-行业调研报告" id="三万言2021-年-rust-行业调研报告">三万言｜2021 年 Rust 行业调研报告</a></h1>
<p>作者：张汉东</p>
<blockquote>
<p><a href="https://github.com/ZhangHanDong/star-rust/blob/main/2021-reports/Rust%E8%A1%8C%E4%B8%9A%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A-20210623-latest.pdf">PDF 版本下载 </a></p>
</blockquote>
<hr />
<h2><a class="header" href="#文前" id="文前">文前</a></h2>
<p>Rust 语言是一门通用系统级编程语言，无GC且能保证内存安全、并发安全和高性能而著称。自2008年开始由 Graydon Hoare 私人研发，2009年得到 Mozilla 赞助，2010年首次发布 0.1.0 版本，用于Servo 引擎的研发，于 2015年5月15号发布 1.0 版本。</p>
<p>自发布以来，截止到2021 年的今天，经历六年的发展，Rust 得到稳步上升，已逐渐趋于成熟稳定。</p>
<p>至 2016 年开始，截止到 2021年，Rust 连续五年成为<a href="https://insights.stackoverflow.com/survey/2020"> StackOverflow 语言榜上最受欢迎的语言</a>。</p>
<p><img src="chapter_6/./image/report/so.png" alt="1" /></p>
<p>2021年 2 月 9 号，<strong>Rust 基金会宣布成立</strong>。<strong>华为、AWS、Google、微软、Mozilla、Facebook 等科技行业领军巨头加入 Rust 基金会</strong>，成为白金成员，以致力于在全球范围内推广和发展 Rust 语言。</p>
<p>那 Rust 语言到底有何魅力，能让广大开发者和巨头公司这么感兴趣呢？</p>
<p>本文打算从 Rust 语言自身特性 和 Rust 行业应用盘点两个方面的社区调研来尝试来解答这个问题。供想选择 Rust 的公司参考。</p>
<p>其实 Rust 生态还有很多内容，等待大家挖掘。本文内容还未覆盖完全 Rust 生态的方方面面。</p>
<p>注明： 本文中所罗列数据均来源互联网公开内容。</p>
<h2><a class="header" href="#认识-rust-语言" id="认识-rust-语言">认识 Rust 语言</a></h2>
<p>编程语言设计在两个看似不可调和的愿望之间长期存在着矛盾对立。</p>
<ul>
<li>安全 ( safe )。 我们想要强类型系统来静态地排除大量错误。 我们要自动内存管理。我们想要数据封装， 这样我们就可以对私有变量执行不变的对象的表示形式，并确保它们将不会被不受信任的代码破坏。</li>
<li>控制 (control )。 至少对于 Web浏览器，操作系统，或游戏引擎这样的 <code>系统编程 (system programming)</code> 程序，约束它们性能或资源是一个重要的问题，我们想了解数据的字节级表示。 我们想要用<code>底层语言 (low-level programming)</code> 的编程技术优化我们程序的时间和空间的使用。 我们希望在需要时使用 <code>裸机</code> 。</li>
</ul>
<p>然而，按照传统的看法，鱼和熊掌不能兼得。 Java 之类的语言使我们极大的安全保证，但代价是牺牲对底层的控制。结果，对于许多系统编程应用程序，唯一现实的选择是使用一种像 C 或 C++ 提供细粒度的语言控制资源管理。 但是，获得这种控制需要很高的成本。例如，微软最近报告说，他们修复的 70％ 安全漏洞都归因于内存安全违规行为 <a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/safe_system.html#33">33</a>，并且都是能被强类型系统排除的问题。同样，Mozilla 报告指出，绝大多数关键 他们在Firefox中发现的错误是内存有关的<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/safe_system.html#16">16 </a>。</p>
<p>如果可以以某种方式两全其美: 安全系统编程的同时对底层有控制权，岂不美哉。因此，Rust 语言应运而生。</p>
<p>官方网如此介绍 Rust  : 一门赋予每个人 构建可靠且高效软件能力的语言。</p>
<p>Rust 语言有三大优势值得大家关注：</p>
<ol>
<li>高性能。Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</li>
<li>可靠性。Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</li>
<li>生产力。Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</li>
</ol>
<p>Rust 足够底层，如果有必要，它可以像 C 一样进行优化，以实现最高性能。</p>
<p>抽象层次越高，内存管理越方便，可用库越丰富，Rust 程序代码就越多，做的事情越多，但如果不进行控制，可能导致程序膨胀。</p>
<p>然而，Rust 程序的优化也很不错，有时候比 C 语言更好，C 语言适合在逐个字节逐个指针的级别上编写最小的代码，而 Rust 具有强大的功能，能够有效地将多个函数甚至整个库组合在一起。</p>
<p>但是，最大的潜力是可以无畏（fearless）地并行化大多数 Rust 代码，即使等价的 C 代码并行化的风险非常高。在这方面，Rust 语言是比 C 语言更为成熟的语言。</p>
<p>Rust 语言也支持高并发零成本的异步编程，Rust 语言应该是首个支持异步编程的系统级语言。</p>
<h3><a class="header" href="#媲美-c--cpp-的高性能" id="媲美-c--cpp-的高性能">媲美 C / Cpp 的高性能</a></h3>
<p><strong>Rust vs C</strong></p>
<p><img src="chapter_6/./image/report/rustvsc.png" alt="rustvsc" /></p>
<p><strong>Rust vs Cpp</strong></p>
<p><img src="chapter_6/./image/report/rustvscpp.png" alt="rustvscpp" /></p>
<p><strong>Rust vs Go</strong></p>
<p><img src="chapter_6/./image/report/rustvsgo.png" alt="rustvsgo" /></p>
<p>用 Rust 编写的程序的运行时速度和内存使用量应该和用 C 编写的程序差不多，但这两种语言的总体编程风格不同，很难去概括它们的性能。</p>
<p>总的来说：</p>
<ol>
<li>抽象是一把双刃剑。Rust 语言抽象程度比 C 语言更高，抽象会隐藏一些不是那么优化的代码，这意味着，默认实现的 Rust 代码性能不是最好的。所以，你的 Rust 代码必须经过优化才能达到媲美 C 的性能。Unsafe Rust 就是高性能出口。</li>
<li>Rust 默认线程安全，消除数据竞争，让多线程并发编程更具实用价值。</li>
<li>Rust  在有些方面确实比 C 快。理论上，C 语言什么都可以做。 但在实践中，C 抽象能力比较低，不那么现代化，开发效率比较低。只要开发者有无限时间和精力，就可以让 C 语言在这些方面比 Rust 更快。</li>
</ol>
<p>因为 C 语言足以代表高性能，下面就分别谈一下 C 和 Rust 的异同。如果你熟悉 C/Cpp，也可以根据此对比来评估 Cpp 和 Rust。</p>
<h4><a class="header" href="#rust-和-c-都是硬件直接抽象" id="rust-和-c-都是硬件直接抽象">Rust 和 C 都是硬件直接抽象</a></h4>
<p>Rust 和 C 都是直接对硬件的抽象，都可看作一种「可移植汇编程序」。</p>
<p>Rust 和 C 都能控制数据结构的内存布局、整数大小、栈与堆内存分配、指针间接寻址等，并且一般都能翻译成可理解的机器代码，编译器很少插入 &quot;魔法&quot;。</p>
<p>即便 Rust 比 C 有更高层次的结构，如迭代器、特质（trait）和智能指针，它们也被设计为可预测地优化为简单的机器代码（又称 &quot;零成本抽象&quot;）。</p>
<p>Rust的类型的内存布局很简单，例如，可增长的字符串<code>String</code> 和 <code>Vec&lt;T&gt;</code> 正好是<code>{byte*, capacity, length}</code>。Rust没有任何像 Cpp里的 移动 或 复制构造函数 这样的概念，所以对象的传递保证不会比传递指针或 <code>memcpy</code> 更复杂。</p>
<p>Rust 借用检查只是编译器对代码中引用的静态分析。生命周期（lifetime）信息早就在 中级中间语言（MIR） 生成前完全抽离了。</p>
<p>Rust 中不使用传统的异常处理，而是使用基于返回值的错误处理。但你也可以使用 恐慌（Panic）来处理像 Cpp 中那样的异常行为。它可以在编译时被禁用<code>（panic = abort）</code>，但即便如此，Rust 也不喜欢 与 Cpp异常 或 longjmp 混在一起。</p>
<h4><a class="header" href="#同样的-llvm-后端" id="同样的-llvm-后端">同样的 LLVM 后端</a></h4>
<p>Rust与LLVM有很好的整合，所以它支持链接时间优化，包括ThinLTO，甚至是跨越C/C++/Rust语言边界的内联。也有按配置优化（Profile-guided Optimization，PGO）的支持。尽管 rustc 比 clang 生成的LLVM IR更加冗长，但优化器仍然能够很好地处理它。</p>
<p>C 语言用 GCC 编译比用 LLVM 更快，现在 Rust 社区也有人在开发 GCC 的 Rust 前端。</p>
<p>理论上，因为 Rust 有比C 更严格的不可变和别名规则，应该比 C 语言有更好的性能优化，但实际上并没有起到这样的效果。目前在LLVM中，超越 C语言的优化是一项正在进行的工作，所以Rust仍然没有达到其全部潜力。</p>
<h4><a class="header" href="#都允许手工优化但有一些小例外" id="都允许手工优化但有一些小例外">都允许手工优化，但有一些小例外</a></h4>
<p>Rust 的代码足够底层和可预测，可以通过手工调整它的优化到什么样的汇编代码。</p>
<p>Rust 支持 SIMD ，对内联和调用约定有很好的控制。</p>
<p>Rust 和 C 语言足够相似，C 语言的一些分析工具通常可以用于 Rust 。</p>
<p>总的来说，如果性能绝对关键，并且需要手工优化压榨最后一点性能，那么优化 Rus t 与 优化 C 语言并没有什么不同。</p>
<p>但是在一些比较底层的特性，Rust 没有特别好的替代方法。</p>
<ul>
<li><code>goto</code>。Rust 中没有提供<code>goto</code>，不过你可以使用循环的 break 标签来代替。C 语言中一般使用 goto 来清理内存，但是 Rust 因为有确定性析构功能，所以不需要 goto。然而有一个 非标准的 goto 扩展，对性能优化比较有用。</li>
<li>栈内存分配<code>alloca</code>和<code>C99</code>可变长度数组，可以节省内存空间，减少内存分配次数。但这些即使在 C 语言中也是有争议的，所以Rust远离了它们。</li>
</ul>
<h4><a class="header" href="#rust-相比-c-语言的一些开销" id="rust-相比-c-语言的一些开销">Rust 相比 C 语言的一些开销</a></h4>
<p>如果没有经过手工优化，Rust 因为其抽象表达也会有一些开销。</p>
<ul>
<li>Rust缺乏隐式类型转换和只用usize的索引，这导致开发者只能使用这种类型，哪怕只需要更小的数据类型。64位平台上用usize做索引更容易优化，而不需要担心未定义行为，但多余的bit位可能会给寄存器和内存带来更大的压力。而在 C 中，你可以选择 32位类型。</li>
<li>Rust 中的字符串，总是会携带指针和长度。但是很多 C 代码中的函数只接收指针而不管大小。</li>
<li>像 <code>for i in 0...len {arr[i]}</code> 这样的迭代，性能取决于 LLVM 优化器能否证明长度匹配。有时候，它不能，并且边界检查也会抑制自动矢量化。</li>
<li>C 语言比较自由，对于内存有很多“聪明”的使用技巧，但在 Rust 里就没这么自由了。但Rust仍然给了内存分配很多控制权，并且可以做一些基本的事情，比如内存池、将多个分配合并为一个、预分配空间等等。</li>
<li>在不熟悉 Rust 借用检查的情况下，可能会用 Clone 来逃避使用引用。</li>
<li>Rust 的标准库中 I/O 是不带缓存的，所以需要使用 <strong>BufWriter</strong> 来包装。这就是为什么有些人说 Rust 写的代码还不如 Python 快的原因，因为 99% 的时间都用在 I/O上了。</li>
</ul>
<h4><a class="header" href="#可执行文件大小" id="可执行文件大小">可执行文件大小</a></h4>
<p>每个操作系统都有一些内置的标准C库，其中有大约30MB的代码。C 语言的执行文件，可以“免费”使用这些库。</p>
<p>一个小的 &quot;Hello World &quot; 级 C 可执行文件实际上不能打印任何东西，它只调用操作系统提供的printf。</p>
<p>而 Rust 则不可以，Rust可执行文件会捆绑自己的标准库（300KB或更多）。幸运的是，这只是一次性的开销，可以减少。</p>
<p>对于嵌入式开发，可以关闭标准库，使用 &quot;no-std&quot;，Rust将生成 &quot;裸 &quot;代码。</p>
<p>在每个函数的基础上，Rust代码的大小与C差不多，但有一个 &quot;泛型膨胀 &quot;的问题。泛型函数为它们所使用的每一种类型都有优化的版本，所以有可能出现同一个函数有8个版本的情况，<a href="https://lib.rs/cargo-bloat">cargo-bloat</a> 库有助于发现这些问题。</p>
<p>在Rust中使用依赖关系是非常容易的。与 JS/npm 类似，现在推荐使用小型且单用途的包，但它们确实在不断增加。<code>cargo-tree</code> 命令对于删减它们非常有用。</p>
<h4><a class="header" href="#rust-略胜-c--的一些地方" id="rust-略胜-c--的一些地方">Rust 略胜 C  的一些地方</a></h4>
<ol>
<li>为了隐藏实现细节，C 库经常返回不透明的数据结构指针，并确保结构的每个实例只有一个副本。它会消耗堆分配和指针间接寻址的成本。Rust 内置的隐私、单一所有权规则和编码惯例允许库暴露其对象，而不需要间接性，这样，调用者可以决定将其放入堆（heap）上还是栈（stack）中。可以主动或彻底地优化栈上的对象。</li>
<li>缺省情况下，Rust 可以将来自标准库、依赖项和其他编译单元的函数内联。</li>
<li>Rust 会对结构体字段进行重排，以优化内存布局。</li>
<li>字符串携带大小信息，使得长度检查速度很快。并允许就地生成子串。</li>
<li>与 C++ 模板类似，Rust 中泛型函数会单态化，生成不同类型的副本，因此像 sort 这样的函数和 HashMap 这样的容器总是针对相应的类型进行优化。对于 C 语言，则必须在修改宏或者处理<code>void*</code>和运行时变量大小的效率较低的函数之间做出选择。</li>
<li>Rust的迭代器可以组合成链状，作为一个单元一起被优化。因此，你可以调用<code>it.buy().use().break().change().mail().upgrade()</code>，而不是对同一个缓存区多次写入的一系列调用。</li>
<li>同样，通过 Read 和 Write 接口，接收一些未缓存的流数据，在流中执行 CRC 校验，然后将其转码、压缩，再写入网络中，所有这些都可以在一次调用中完成。虽然 C 语言中应该也可以做到，但它没有泛型和特质（trait），将很难做到。</li>
<li>Rust 标准库中内置高质量的容器和优化过的数据结构，比 C 使用起来更方便。</li>
<li>Rust的 serde 是世界上最快的JSON解析器之一，使用体验非常棒。</li>
</ol>
<h4><a class="header" href="#rust-比-c-明显优越的地方" id="rust-比-c-明显优越的地方">Rust 比 C 明显优越的地方</a></h4>
<p>主要是两点：</p>
<ol>
<li>Rust 消除数据竞争，天生线程安全，解放多线程生产力，是 Rust 明显比 C / Cpp  等语言优越的地方。</li>
<li>Rust 语言支持异步高并发编程。</li>
<li>Rust 支持 安全的编译期计算。</li>
</ol>
<p><strong>线程安全</strong></p>
<p>即使是在第三方库中，Rust 也会强制实现所有代码和数据的线程安全，哪怕那些代码的作者没有注意线程安全。一切都遵循一个特定的线程安全保证，或者不允许跨线程使用。当你编写的代码不符合线程安全时，编译器会准确地指出不安全之处。</p>
<p>Rust 生态中已经有了很多库，如数据并行、线程池、队列、任务、无锁数据结构等。有了这类组件的帮助，再加上类型系统强大的安全网，完全可以很轻松地实现并发/并行化 Rust 程序。有些情况下，用 par_iter 代替 iter 是可以的，只要能够进行编译，就可以正常工作！这并不总是线性加速（ 阿姆达尔定律（Amdahl's law）很残酷），但往往是相对较少的工作就能加速 2~3 倍。</p>
<p>延伸：阿姆达尔定律，一个计算机科学界的经验法则，因 Gene Amdahl 而得名。它代表了处理器并行计算之后效率提升的能力。</p>
<p>在记录线程安全方面，Rust 和 C 有一个有趣的不同。</p>
<p>Rust 有一个术语表用于描述线程安全的特定方面，如 <code>Send</code> 和 <code>Sync</code>、<code>guards</code> 和 <code>cell</code>。</p>
<p>对于 C 库，没有这样的说法：“可以在一个线程上分配它，在另一个线程上释放它，但不能同时从两个线程中使用它”。</p>
<p>根据数据类型，Rust 描述了线程安全性，它可以泛化到所有使用它们的函数。</p>
<p>对于 C 语言来说，线程安全只涉及单个函数和配置标志。</p>
<p>Rust 的保证通常是在编译时提供的，至少是无条件的。</p>
<p>对于 C 语言，常见的是“仅当 turboblub 选项设置为 7 时，这才是线程安全的” （这句话并不是真的让你去设置 turboblub 选项，因为本来就没有这个选项，所以 C 语言不会保证你线程安全 ）。</p>
<p><strong>异步并发</strong></p>
<p>Rust 语言支持 <code>async/await</code>异步编程模型。</p>
<p>该编程模型，基于一个叫做 <code>Future</code> 的概念，，在 JavaScript 中也叫做 <code>Promise</code>。<code>Future</code> 表示一个尚未得出的值，你可以在它被解决（resolved）以得出那个值之前对它进行各种操作。在许多语言中，对 <code>Future</code> 所做的工作并不多，这种实现支持很多特性比如组合器（Combinator），尤其是能在此基础上实现更符合人体工程学的 <code>async</code>/<code>await</code> 语法。</p>
<p><code>Future</code> 可以表示各种各样的东西，尤其适用于表示异步 I/O ：当你发起一次网络请求时，你将立即获得一个 <code>Future</code> 对象，而一旦网络请求完成，它将返回任何响应可能包含的值；你也可以表示诸如“超时”之类的东西，“超时”其实就是一个在过了特定时间后被解决的 <code>Future</code> ；甚至不属于 I/O 的工作或者需要放到某个线程池中运行的CPU密集型的工作，也可以通过一个 <code>Future</code> 来表示，这个 <code>Future</code> 将会在线程池完成工作后被解决。</p>
<p><strong><code>Future</code> 存在的问题</strong> 是它在大多数语言中的表示方式是这种基于回调的方法，使用这种方式时，你可以指定在 <code>Future</code> 被解决之后运行什么回调函数。也就是说， <code>Future</code> 负责弄清楚什么时候被解决，无论你的回调是什么，它都会运行；而所有的不便也都建立在此模型上，它非常难用，因为已经有很多开发者进行了大量的尝试，发现他们不得不写很多分配性的代码以及使用动态派发；实际上，你尝试调度的每个回调都必须获得自己独立的存储空间，例如 crate 对象、堆内存分配，这些分配以及动态派发无处不在。这种方法没有满足零成本抽象的第二个原则，如果你要使用它，它将比你自己写要慢很多，那你为什么还要用它。</p>
<p>Rust 中的方案有所不同。不是由 <code>Future</code> 来调度回调函数，而是由一个被称为执行器（executor）的组件去轮询 <code>Future</code>。而 <code>Future</code> 可能返回“尚未准备就绪（Pending）”，也可能被解决就返回“已就绪（Ready）”。该模型有很多优点。其中一个优点是，你可以非常容易地取消 <code>Future</code> ，因为取消 <code>Future</code> 只需要停止持有 <code>Future</code>。而如果采用基于回调的方法，要通过调度来取消并使其停止就没这么容易了。</p>
<p>同时它还能够使我们在程序的不同部分之间建立真正清晰的抽象边界，大多数其他 <code>Future</code> 库都带有事件循环（event loop），这也是调度 你的<code>Future</code> 执行 I/O 的方法，但实际上你对此没有任何控制权。</p>
<p>而在 Rust 中，各组件之间的边界非常整洁，执行器（executor）负责调度你的 <code>Future</code> ，反应器（reactor）处理所有的 I/O ，然后是你的实际代码。因此最终用户可以自行决定使用什么执行器，使用他们想使用的反应器，从而获得更强的控制力，这在系统编程语言中真的很重要。</p>
<p>而此模型最重要的真正优势在于，它使我们能够以一种真正零成本的完美方式实现这种状态机式的 <code>Future</code> 。也就是当你编写的 <code>Future</code> 代码被编译成实际的本地（native）代码时，它就像一个状态机；在该状态机中，每次 I/O 的暂停点都有一个变体（variant），而每个变体都保存了恢复执行所需的状态。</p>
<p>而这种 <code>Future</code> 抽象的真正有用之处在于，我们可以在其之上构建其他 API 。可以通过将这些组合器方法应用于 <code>Future</code> 来构建状态机，它们的工作方式类似于迭代器（<code>Iterator</code>）的适配器（如 <code>filter</code>、<code>map</code>）。但是这种方式是有一些缺点的，尤其是诸如嵌套回调之类，可读性非常差。所以才需要实现 <code>async</code> / <code>await</code>异步语法。</p>
<p>目前 Rust 生态中，已经有了成熟的 <a href="https://tokio.rs/">tokio</a> 运行时生态，支持 epoll 等异步 I/O。如果你想用 io_uring ，也可以使用 <a href="https://github.com/DataDog/glommio">Glommio</a> ，或者等待 tokio 对 io_uring 的支持。甚至，你可以使用 smol 运行时提供的 <a href="https://github.com/smol-rs/async-executor">async_executor</a> 和 <a href="https://github.com/smol-rs/async-io">async-io</a> 来构建你自己的运行时。</p>
<p><strong>编译期计算</strong></p>
<p>Rust 可以支持类似于 Cpp 那样的 编译期常量求值。这一点是明显比C优越的。</p>
<p>虽然目前功能还不如 Cpp 那样强大，但还在不断的维护中。</p>
<p>为什么 Rust 中支持 编译期计算这么谨慎呢？因为Rust 编译期求值是必须要保证安全的，所以有很多考虑。Rust 编译期求值不像 Cpp 那样自由且容易滥用。</p>
<h3><a class="header" href="#可靠性" id="可靠性">可靠性</a></h3>
<p>2020 年 6月份，来自3所大学的5位学者在ACM SIGPLAN国际会议（PLDI'20）上发表了一篇研究成果，针对近几年使用Rust语言的开源项目中的安全缺陷进行了全面的调查。这项研究调查了5个使用Rust语言开发的软件系统，5个被广泛使用的Rust库，以及两个漏洞数据库。调查总共涉及了850处unsafe代码使用、70个内存安全缺陷、100个线程安全缺陷。</p>
<p><img src="chapter_6/./image/report/safety.png" alt="safety" /></p>
<p>在调查中，研究员不光查看了所有漏洞数据库中报告的缺陷和软件公开报告的缺陷，还查看了所有开源软件代码仓库中的提交记录。通过人工的分析，他们界定出提交所修复的BUG类型，并将其归类到相应的内存安全/线程安全问题中。所有被调查过的问题都被整理到了公开的Git仓库中：<a href="https://github.com/system-pclub/rust-study">https://github.com/system-pclub/rust-study</a></p>
<p><strong>调查结果说明：</strong></p>
<ol>
<li>
<p>Rust语言的safe代码对于空间和时间内存安全问题的检查非常有效，所有稳定版本中出现的内存安全问题都和unsafe代码有关。</p>
</li>
<li>
<p>虽然内存安全问题都和unsafe代码有关，但大量的问题同时也和safe代码有关。有些问题甚至源于safe代码的编码错误，而不是unsafe代码。</p>
</li>
<li>
<p>线程安全问题，无论阻塞还是非阻塞，都可以在safe代码中发生，即使代码完全符合Rust语言的规则。</p>
</li>
<li>
<p>大量问题的产生是由于编码人员没有正确理解Rust语言的生命周期规则导致的。</p>
</li>
<li>
<p>有必要针对Rust语言中的典型问题，建立新的缺陷检测工具。</p>
</li>
</ol>
<p>那么这份调查报告背后 Rust 的安全性是如何保证的呢？Unsafe  Rust 又是为什么 Unsafe 呢？</p>
<h4><a class="header" href="#所有权-rust-语言内存安全机制" id="所有权-rust-语言内存安全机制">所有权： Rust 语言内存安全机制</a></h4>
<p>Rust 的设计深深地吸取了关于安全系统编程的学术研究的精髓。特别是，与其他主流语言相比，Rust 设计的最大特色在于采用了<strong>所有权类型系统</strong>（在学术文献中通常称为<em>仿射</em>或<em>子结构</em>类型系统<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/safe_system.html#36">36</a>）。</p>
<p>所有权机制，就是Rust 语言借助类型系统，承载其“内存安全”的思想，表达出来的安全编程语义和模型。</p>
<p>所有权机制要解决的内存不安全问题包括：</p>
<ol>
<li>
<p>引用空指针。</p>
</li>
<li>
<p>使用未初始化内存。</p>
</li>
<li>
<p>释放后使用，也就是使用悬垂指针。</p>
</li>
<li>
<p>缓冲区溢出，比如数组越界。</p>
</li>
<li>
<p>非法释放已经释放过的指针或未分配的指针，也就是重复释放。</p>
</li>
</ol>
<p>注意，内存泄露不属于内存安全问题范畴，所以 Rust 也不解决内存泄露问题。</p>
<p><strong>为了保证内存安全，Rust 语言建立了严格的安全内存管理模型：</strong></p>
<ul>
<li>所有权系统。每个被分配的内存都有一个独占其所有权的指针。只有当该指针被销毁时，其对应的内存才能随之被释放。</li>
<li>借用和生命周期。每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。</li>
</ul>
<p>其中所有权系统还包括了从现代 C++ 那里借鉴的 RAII 机制，这是 Rust 无 GC 但是可以安全管理内存的基石。</p>
<p>建立了安全内存管理模型之后，再用类型系统表达出来即可。<strong>Rust 从 Haskell 的类型系统那里借鉴了以下特性：</strong></p>
<ul>
<li>没有空指针</li>
<li>默认不可变</li>
<li>表达式</li>
<li>高阶函数</li>
<li>代数数据类型</li>
<li>模式匹配</li>
<li>泛型</li>
<li>trait 和关联类型</li>
<li>本地类型推导</li>
</ul>
<p><strong>为了实现内存安全，Rust 还具备以下独有的特性：</strong></p>
<ul>
<li>仿射类型（Affine Type），该类型用来表达 Rust 所有权中的 Move 语义。</li>
<li>借用、生命周期。</li>
</ul>
<p>借助类型系统的强大，Rust 编译器可以在编译期对类型进行检查，看其是否满足安全内存模型，在编译期就能发现内存不安全问题，有效地阻止未定义行为的发生。</p>
<p>内存安全的 Bug 和并发安全的 Bug 产生的内在原因是相同的，都是因为内存的不正当访问而造成的。同样，利用装载了所有权的强大类型系统，Rust 还解决了并发安全的问题。Rust 编译器会通过静态检查分析，在编译期就检查出多线程并发代码中所有的数据竞争问题。</p>
<h4><a class="header" href="#unsafe-rust-划分安全边界" id="unsafe-rust-划分安全边界">Unsafe Rust ：划分安全边界</a></h4>
<p>**为了和现有的生态系统良好地集成，**Rust 支持非常方便且零成本的 FFI 机制，兼容 C-ABI，并且从语言架构层面上将 Rust 语言分成 Safe Rust 和 Unsafe Rust 两部分。</p>
<p>其中 Unsafe Rust 专门和外部系统打交道，比如操作系统内核。之所以这样划分，是因为 Rust 编译器的检查和跟踪是有能力范围的，它不可能检查到外部其他语言接口的安全状态，所以只能靠开发者自己来保证安全。</p>
<p>Rust 的最终目标并不是完全消除那些危险点，因为在某种程度上，我们需要能够访问内存和其他资源。实际上，Rust 的目标是将所有的unsafe元素抽象出来。在考虑安全性时，你需要考虑“攻击面”，或者我们可以与程序的哪些部分进行交互。像解析器这样的东西是一个很大的攻击面，因为：</p>
<ul>
<li>
<p>它们通常可以被攻击者访问；</p>
</li>
<li>
<p>攻击者提供的数据可以直接影响解析通常需要的复杂逻辑。</p>
<p>你可以进一步分解，将传统的攻击面分解成“攻击面”（可以直接影响程序代码的部分）和“安全层”，这部分代码是攻击面依赖的代码，但是无法访问，而且可能存在潜在的 Bug。在 C 语言中，它们是一样的：C 语言中的数组根本不是抽象的，所以如果你读取了可变数量的项，就需要确保所有的不变量都保持不变，因为这是在不安全层中操作，那里可能会发生错误。</p>
</li>
</ul>
<p>所以，Rust 提供了 <code>unsafe</code>  关键字和<code>unsafe</code>块，显式地将安全代码和访问外部接口的不安全代码进行了区分，也为开发者调试错误提供了方便。Safe Rust 表示开发者将信任编译器能够在编译时保证安全，而 Unsafe Rust 表示让编译器信任开发者有能力保证安全。</p>
<p>有人的地方就有 Bug。Rust 语言通过精致的设计，将机器可以检查控制的部分都交给编译器来执行，而将机器无法控制的部分交给开发者自己来执行。</p>
<p>Safe Rust 保证的是编译器在编译时最大化地保障内存安全，阻止未定义行为的发生。</p>
<p>Unsafe Rust 用来提醒开发者，此时开发的代码有可能引起未定义行为，请谨慎！人和编译器共享同一个“安全模型”，相互信任，彼此和谐，以此来最大化地消除人产生 Bug 的可能。</p>
<p>Unsafe Rust，是Rust的安全边界。世界的本质就是Unsafe的。你无法避免它。还有人说，因为Unsafe Rust的存在，所以也不见得能比C/C++安全到哪里去？Unsafe Rust确实和C/C++一样，要靠人来保证它的安全。但它对人的要求更高。</p>
<p>它也给了开发者一个Unsafe的边界，这其实也是一种安全边界。它把你代码里的雷区，显式地标记了出来。团队代码里review的话，可以更快地发现问题。这本身就是一种安全。而反观C++，你写出的每一行代码都是Unsafe的，因为它没有像Rust这样明显的界限（Unsafe 块）。</p>
<p><strong>以下是我总结的五条使用Unsafe的简单规范，方便大家做权衡：</strong></p>
<ol>
<li>能用Safe Rust就用Safe Rust；</li>
<li>为了性能可以使用Unsafe Rust；</li>
<li>在使用Unsafe Rust的时候确保不要产生UB，并且尽量判断其安全边界，抽象为 Safe 方法；</li>
<li>如果无法抽象为Safe，需要标注为Unsafe，并配以产生UB的条件文档；</li>
<li>对于Unsafe的代码，大家可以重点review。</li>
</ol>
<p>所以，Unsafe 使用不当也会引发内存安全或逻辑 Bug 。所以，学习 如何对 Unsafe Rust 进行安全抽象至关重要。</p>
<p>不过，Rust 社区生态中有一个 Rust 安全工作组，该组提供 <a href="https://github.com/RustSec/rustsec">cargo-audit等一系列工具</a>，并且维护<a href="https://rustsec.org/advisories/"><code>RustSecurity</code> 安全数据库库</a>中记录的<code>Rust</code>生态社区中发现的安全问题。可以方便地检查 Rust 项目中依赖库的安全问题。</p>
<h3><a class="header" href="#生产力" id="生产力">生产力</a></h3>
<p>编程语言生产力，大概可以通过以下三个方面来评估：</p>
<ol>
<li>学习曲线。</li>
<li>语言工程能力。</li>
<li>领域生态。</li>
</ol>
<h4><a class="header" href="#学习曲线" id="学习曲线">学习曲线</a></h4>
<p>学习曲线的高低，依个人水平不同而不同。以下罗列了不同基础学习 Rust 应该注意的地方。</p>
<ol>
<li>
<p>完全零基础的开发者：掌握计算机基础体系知识结构，理解Rust语言和硬件/OS层的抽象，理解Rust语言核心概念、以及它的抽象模式，选择Rust语言的某个适用领域进行实操训练，通过实践来提升Rust语言的熟练度和理解深度，同时掌握领域知识。</p>
</li>
<li>
<p>有C语言基础：由于C语言开发者对高级语言的抽象不是很理解，所以着重了解掌握Rust所有权机制，包括所有权的语义，生命周期和借用检查。了解Rust语言的抽象模式，主要是类型和trait；以及Rust本身的的OOP和函数式语言特性。</p>
</li>
<li>
<p>有C++基础：C++开发者对于Rust语言的所有权有很好的理解能力，主要精力放在Rust的抽象模式和函数式语言特性上。</p>
</li>
<li>
<p>有Java/Python/Ruby基础：着重理解攻克Rust所有权机制、抽象模式、函数式编程语言特性。</p>
</li>
<li>
<p>有Go基础：Go语言开发者比较容易理解Rust的类型和trait抽象模式，但Go也是GC语言，所以所有权机制和函数式语言特性是他们的学习重点。</p>
</li>
<li>
<p>有Haskell基础：Haskell系的开发者对Rust语言函数式特性能很好的理解，主要攻克所有权机制和OOP语言特性。</p>
</li>
</ol>
<p>所以，对于有一定基础的开发者来说，学习Rust语言要掌握的几个关键概念有：</p>
<p>1、Rust所有权机制，包括所有权的语义，生命周期和借用检查</p>
<p>​		所有权机制是Rust语言最核心的特性，它保证了在没有垃圾回收机制下的内存安全，所以对于习惯了GC的开发者，理解Rust的所有权是最关键的一环，切记这三点：</p>
<ul>
<li>Rust中的每一个值都有一个被称为其所有者 (owner)的变量。</li>
<li>值有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。
这其中又涉及到生命周期和借用检查等概念，是相对比较难啃的一块硬骨头。</li>
</ul>
<p>2、Rust语言的抽象模式，主要是类型和trait。trait借鉴了Haskell中的Typeclass，它是对类型行为的抽象，可以通俗地类比为其他编程语言里的接口，它告诉编译器一个类型必须提供哪些功能语言特性。使用时要遵循一致性，不能定义相互冲突的实现。</p>
<p>3、OOP语言特性。熟悉面向对象编程（OOP）的常见的四个特性：对象、封装、继承和多态，可以更好地理解Rust的一些特性，比如impl、pub、trait等等。</p>
<p>4、函数式语言特性。Rust语言的设计深受函数式编程的影响，看到函数式特性，数学不好的人可能会望而却步，因为函数式编程语言的最大特点是把运算过程尽量写成一系列嵌套的函数调用,在Rust中，掌握闭包和迭代器是编写函数式语言风格的高性能Rust代码的重要一环。</p>
<h4><a class="header" href="#语言工程能力" id="语言工程能力">语言工程能力</a></h4>
<p>Rust 已经为开发工业级产品做足了准备。</p>
<p>**为了保证安全性，**Rust 引入了强大的类型系统和所有权系统，不仅保证内存安全，还保证了并发安全，同时还不会牺牲性能。</p>
<p>**为了保证支持硬实时系统，**Rust 从 C++那里借鉴了确定性析构、RAII 和智能指针，用于自动化地、确定性地管理内存，从而避免了 GC 的引入，因而就不会有“世界暂停”的问题了。这几项虽然借鉴自 C++，但是使用起来比 C++更加简洁。</p>
<p>**为了保证程序的健壮性，**Rust 重新审视了错误处理机制。日常开发中一般有三类非正常情况：失败、错误和异常。但是像 C 语言这种面向过程的语言，开发者只能通过返回值、goto 等语句进行错误处理，并且没有统一的错误处理机制。而 C++和 Java 这种高级语言虽然引入了异常处理机制，但没有专门提供能够有效区分正常逻辑和错误逻辑的语法，而只是统一全局进行处理，导致开发者只能将所有的非正常情况都当作异常去处理，这样不利于健壮系统的开发。并且异常处理还会带来比较大的性能开销。</p>
<p>Rust 语言针对这三类非正常情况分别提供了专门的处理方式，让开发者可以分情况去选择。</p>
<ul>
<li>对于失败的情况，可以使用断言工具。</li>
<li>对于错误，Rust 提供了基于返回值的分层错误处理方式，比如 Option 可以用来处理可能存在空值的情况，而 Result 就专门用来处理可以被合理解决并需要传播的错误。</li>
<li>对于异常，Rust 将其看作无法被合理解决的问题，提供了线程恐慌机制，在发生异常的时候，线程可以安全地退出。</li>
</ul>
<p>通过这样精致的设计，开发者就可以从更细的粒度上对非正常情况进行合理处理，最终编写出更加健壮的系统。</p>
<p><strong>为了提供灵活的架构能力</strong>，Rust 使用 特质（trait） 来作为零成本抽象的基础。特质 面向组合而非继承，让开发者可以灵活地架构 紧耦合 和 松耦合的系统。Rust 也提供了 泛型 来表达类型抽象，结合 trait 特性，让 Rust 拥有静态多态 和 代码复用 的能力。泛型和trait 让你可以灵活使用各种设计模式来对系统架构进行重塑。</p>
<p><strong>为了提供强大的语言扩展能力和开发效率</strong>，Rust 引入了基于宏的元编程机制。Rust提供了两种宏，分别是声明宏和过程宏。声明宏的形式和C的宏替换类似，区别在于Rust会对宏展开后的代码进行检查，在安全方面更有优势。过程宏则让 Rust 在代码复用、代码生成拥有强大的能力。</p>
<p>**为了和现有的生态系统良好地集成，**Rust 支持非常方便且零成本的 FFI 机制，兼容 C-ABI，并且从语言架构层面上将 Rust 语言分成 Safe Rust 和 Unsafe Rust 两部分。其中 Unsafe Rust 专门和外部系统打交道，比如操作系统内核。之所以这样划分，是因为 Rust 编译器的检查和跟踪是有能力范围的，它不可能检查到外部其他语言接口的安全状态，所以只能靠开发者自己来保证安全。Unsafe Rust 提供了 unsafe 关键字和 unsafe 块，显式地将安全代码和访问外部接口的不安全代码进行了区分，也为开发者调试错误提供了方便。Safe Rust 表示开发者将信任编译器能够在编译时保证安全，而 Unsafe Rust 表示让编译器信任开发者有能力保证安全。</p>
<p>有人的地方就有 Bug。Rust 语言通过精致的设计，将机器可以检查控制的部分都交给编译器来执行，而将机器无法控制的部分交给开发者自己来执行。Safe Rust 保证的是编译器在编译时最大化地保障内存安全，阻止未定义行为的发生。Unsafe Rust 用来提醒开发者，此时开发的代码有可能引起未定义行为，请谨慎！人和编译器共享同一个“安全模型”，相互信任，彼此和谐，以此来最大化地消除人产生 Bug 的可能。</p>
<p>**为了让开发者更方便地相互协作，**Rust 提供了非常好用的包管理器<a href="https://doc.rust-lang.org/cargo/guide/index.html">Cargo</a>。Rust 代码是以包（crate）为编译和分发单位的，Cargo 提供了很多命令，方便开发者创建、构建、分发、管理自己的包。Cargo 也提供插件机制，方便开发者编写自定义的插件，来满足更多的需求。比如官方提供的 rustfmt 和 clippy 工具，分别可以用于自动格式化代码和发现代码中的“坏味道”。再比如，rustfix 工具甚至可以帮助开发者根据编译器的建议自动修复出错的代码。Cargo 还天生拥抱开源社区和 Git，支持将写好的包一键发布到 crates.io 网站，供其他人使用。</p>
<p>**为了方便开发者学习 Rust，**Rust 官方团队做出了如下努力：</p>
<ul>
<li>独立出专门的社区工作组，编写官方 <em>Rust Book</em>，以及其他各种不同深度的文档，比如编译器文档、nomicon book 等。甚至组织免费的社区教学活动 Rust Bridge，大力鼓励社区博客写作，等等。</li>
<li>Rust 语言的文档支持 Markdown 格式，因此 Rust 标准库文档表现力丰富。生态系统内很多第三方包的文档的表现力也同样得以提升。</li>
<li>提供了非常好用的在线 Playground 工具，供开发者学习、使用和分享代码。</li>
<li>Rust 语言很早就实现了自举，方便学习者通过阅读源码了解其内部机制，甚至参与贡献。</li>
<li>Rust 核心团队一直在不断改进 Rust，致力于提升 Rust 的友好度，极力降低初学者的心智负担，减缓学习曲线。比如引入 NLL 特性来改进借用检查系统，使得开发者可以编写更加符合直觉的代码。</li>
<li>虽然从 Haskell 那里借鉴了很多类型系统相关的内容，但是 Rust 团队在设计和宣传语言特性的时候，会特意地去学术化，让 Rust 的概念更加亲民。</li>
<li>在类型系统基础上提供了混合编程范式的支持，提供了强大而简洁的抽象表达能力，极大地提升了开发者的开发效率。</li>
<li>提供更加严格且智能的编译器。基于类型系统，编译器可以严格地检查代码中隐藏的问题。Rust 官方团队还在不断优化编译器的诊断信息，使得开发者可以更加轻松地定位错误，并快速理解错误发生的原因。</li>
</ul>
<p><strong>为了方便 Rust 开发者提升开发效率</strong>，Rust 社区还提供了强大的 IDE 支持。VSCode/Vim/Emacs + <strong>Rust Analyzer</strong> 成为了 Rust 开发的标配。当然 <strong>JetBrains家族</strong>的 IDEA/ Clion  也对 Rust 支持十分强力。</p>
<h3><a class="header" href="#rust-与-开源" id="rust-与-开源">Rust 与 开源</a></h3>
<p>Rust 语言自身作为一个开源项目，也是现代开源软件中的一颗璀璨的明珠。</p>
<p>在 Rust 之前诞生的所有语言，都仅仅用于商用开发，但是 Rust 语言改变了这一状况。对于 Rust 语言来说，Rust 开源社区也是语言的一部分。同时，Rust 语言也是属于社区的。</p>
<p>Rust 团队由 Mozilla 和非 Mozilla 成员组成，至今 Rust 项目贡献者已经超过了 1900 人。Rust 团队分为核心组和其他领域工作组，针对 Rust 2018 的目标，Rust 团队被分为了嵌入式工作组、CLI 工作组、网络工作组以及 WebAssembly 工作组，另外还有生态系统工作组和社区工作组等。</p>
<p>这些领域中的设计都会先经过一个 RFC 流程，对于一些不需要经过 RFC 流程的更改，只需要给 Rust 项目库提交 Pull Request 即可。所有过程都是对社区透明的，并且贡献者都可参与评审，当然，最终决策权归核心组及相关领域工作组所有。后面为了精简 FCP流程，也引入了 MCP。</p>
<p>**Rust 团队维护三个发行分支：稳定版（Stable）、测试版（Beta）和开发版（Nightly）。**其中稳定版和测试版每 6 周发布一次。标记为不稳定（Unstable）和特性开关（Feature Gate）的语言特性或标准库特性只能在开发版中使用。</p>
<p>在 Rust 基金会成立以后，Rust 团队也在不断探索新的开源治理方案。</p>
<h3><a class="header" href="#rust-语言的不足" id="rust-语言的不足">Rust 语言的不足</a></h3>
<p>Rust 虽然有很多优势，但肯定也存在一些缺点。</p>
<ol>
<li>Rust 编译速度很慢。虽然 Rust 官方也一直在改进 Rust 编译速度，包括增量编译支持，引入新的编译后端（ cranelift ），并行编译等措施，但还是慢。而且 增量编译目前也有 Bug。</li>
<li>学习曲线陡峭。</li>
<li>IDE 支持不够完善。比如，对宏代码的支持不是很好。</li>
<li>缺乏针对 Rust 语言特有内存不安全问题的各种检测工具。</li>
<li>针对某些场景、架构和硬件生态支持不是很完善，这其实是需要投入人力和硬件成本来支持了，需要社区和生态的共同努力。</li>
</ol>
<h3><a class="header" href="#rust-生态基础库和工具链" id="rust-生态基础库和工具链">Rust 生态基础库和工具链</a></h3>
<p>Rust 生态日趋丰富，很多基础库和框架都会以 包（crate） 的方式发布到 <a href="https://crates.io/crates">crates.io</a> ，截止目前，crates.io 上面已经有 <strong>62981</strong> 个 crate，总下载量已经达到 <strong>7,654,973,261</strong>次。</p>
<p>按包的使用场景分类，Crates.io 最流行的几个场景依次如下：</p>
<ul>
<li>命令行工具 （3133  crates）</li>
<li>no-std 库 （2778   crates）</li>
<li>开发工具（测试/ debug/linting/性能检测等， 2652 crates）</li>
<li>Web 编程 （1776 crates）</li>
<li>API 绑定 （方便 Rust 使用的特定 api 包装，比如 http api、ffi 相关api等，1738 crates）</li>
<li>网络编程 （1615 crates）</li>
<li>数据结构 （1572 crates）</li>
<li>嵌入式开发 （1508 crates）</li>
<li>加密技术（1498 crates）</li>
<li>异步开发（1487 crates）</li>
<li>算法 （1200 crates）</li>
<li>科学计算（包括物理、生物、化学、地理、机器学习等，1100 crates）</li>
</ul>
<p>除此之外，还有  WebAssembly 、编码、文本处理、并发、GUI、游戏引擎、可视化、模版引擎、解析器、操作系统绑定 等其他分类，也有不少库。</p>
<p><strong>常用知名基础库和工具链</strong></p>
<p>其中已经涌现出不少优秀的基础库，都可以在 crates.io 首页里看到。这里罗列出一些：</p>
<ul>
<li>
<p>序列化/反序列化：<a href="https://crates.io/crates/serde">Serde</a></p>
</li>
<li>
<p>命令行开发：<a href="https://crates.io/crates/clap">clap </a>/  <a href="https://crates.io/crates/structopt">structopt</a> </p>
</li>
<li>
<p>异步/Web/网络开发： <a href="https://crates.io/crates/tokio">tokio </a> / <a href="https://crates.io/crates/tracing">tracing </a> /<a href="https://crates.io/crates/async-trait">async-trait </a> / <a href="https://crates.io/crates/tower">tower </a>/ <a href="https://crates.io/crates/async-std">async-std </a> <a href="https://crates.io/crates/tonic">tonic </a>/ <a href="https://crates.io/crates/actix-web">actix-web </a>/<a href="https://crates.io/crates/smol">smol </a>/ <a href="https://crates.io/crates/surf">surf </a>/ <a href="https://crates.io/crates/async-graphql">async-graphql </a>/ <a href="https://crates.io/crates/warp">warp /</a> <a href="https://crates.io/crates/tungstenite">tungstenite </a>/  <a href="https://crates.io/crates/encoding_rs">encoding_rs </a>/ <a href="https://crates.io/crates/loom">loom </a>/ <a href="https://github.com/SergioBenitez/Rocket">Rocket</a> </p>
</li>
<li>
<p>FFi 开发： <a href="https://crates.io/crates/libc">libc </a>/ <a href="https://crates.io/crates/winapi">winapi </a>/ <a href="https://crates.io/crates/bindgen">bindgen </a>/ <a href="https://crates.io/crates/pyo3">pyo3 </a>/ <a href="https://crates.io/crates/num_enum">num_enum </a>/ <a href="https://crates.io/crates/jni">jni </a>/ <a href="https://crates.io/crates/rustler_sys">rustler_sys</a>/ <a href="https://crates.io/crates/cxx">cxx </a>/ <a href="https://crates.io/crates/cbindgen">cbindgen </a>/ <a href="https://crates.io/crates/autocxx-bindgen">autocxx-bindgen </a></p>
</li>
<li>
<p>API 开发: <a href="https://crates.io/crates/jsonwebtoken">jsonwebtoken </a>/ <a href="https://crates.io/crates/validator">validator </a>/ <a href="https://crates.io/crates/tarpc">tarpc </a>/ <a href="https://crates.io/crates/nats">nats </a>/ <a href="https://crates.io/crates/tonic">tonic</a>/ <a href="https://crates.io/crates/protobuf">protobuf </a>/ <a href="https://crates.io/crates/hyper">hyper </a>/ <a href="https://crates.io/crates/httparse">httparse </a>/ <a href="https://crates.io/crates/reqwest">reqwest </a> / <a href="https://crates.io/crates/url">url </a></p>
</li>
<li>
<p>解析器：<a href="https://crates.io/crates/nom">nom </a>/ <a href="https://crates.io/crates/pest">pest </a>/ <a href="https://crates.io/crates/csv">csv </a>/ <a href="https://crates.io/crates/combine">combine </a>/ <a href="https://crates.io/crates/wasmparser">wasmparser </a>/ <a href="https://crates.io/crates/ron">ron </a>/ <a href="https://crates.io/crates/lalrpop">lalrpop </a></p>
</li>
<li>
<p>密码学： <a href="https://crates.io/crates/openssl">openssl </a>/ <a href="https://crates.io/crates/ring">ring </a>/ <a href="https://crates.io/crates/hmac">hmac </a>/ <a href="https://github.com/ctz/rustls">rustls</a>  / <a href="https://github.com/orion-rs/orion">orion</a> / <a href="https://github.com/cossacklabs/themis">themis</a> / <a href="https://github.com/RustCrypto">RustCrypto</a></p>
</li>
<li>
<p>WebAssembly:   <a href="https://crates.io/crates/wasm-bindgen">wasm-bindgen</a>/ <a href="https://crates.io/crates/wasmer">wasmer </a>/ <a href="https://crates.io/crates/wasmtime">wasmtime </a>/ <a href="https://crates.io/crates/yew">yew </a> </p>
</li>
<li>
<p>数据库开发： <a href="https://crates.io/crates/diesel">diesel </a>/  <a href="https://crates.io/crates/sqlx">sqlx </a>/ <a href="https://crates.io/crates/rocksdb">rocksdb </a>/ <a href="https://crates.io/crates/mysql">mysql </a>/ <a href="https://crates.io/crates/elasticsearch">elasticsearch </a>/ <a href="https://crates.io/crates/rbatis">rbatis </a> </p>
</li>
<li>
<p>并发：<a href="https://crates.io/crates/crossbeam">crossbeam </a>/ <a href="https://crates.io/crates/parking_lot">parking_lot </a>/ <a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel </a>/ <a href="https://crates.io/crates/rayon">rayon </a>/ <a href="https://crates.io/crates/concurrent-queue">concurrent-queue</a>/ <a href="https://crates.io/crates/threadpool">threadpool </a> / <a href="https://crates.io/crates/flume">flume </a></p>
</li>
<li>
<p>嵌入式开发：<a href="https://crates.io/crates/embedded-hal">embedded-hal </a>/ <a href="https://crates.io/crates/cortex-m">cortex-m </a>/ <a href="https://crates.io/crates/bitvec">bitvec </a>/ <a href="https://crates.io/crates/cortex-m-rtic">cortex-m-rtic </a>/ <a href="https://crates.io/crates/embedded-dma">embedded-dma </a>/ <a href="https://crates.io/crates/cross">cross </a>/ <a href="https://knurling.ferrous-systems.com/tools/">Knurling Tools</a> </p>
</li>
<li>
<p>测试：<a href="https://crates.io/crates/static_assertions">static_assertions </a>/ <a href="https://crates.io/crates/difference">difference </a>/ <a href="https://crates.io/crates/quickcheck">quickcheck </a>/ <a href="https://crates.io/crates/arbitrary">arbitrary </a>/ <a href="https://crates.io/crates/mockall">mockall </a>/ <a href="https://crates.io/crates/criterion">criterion </a>/ <a href="https://crates.io/crates/proptest">proptest</a> / <a href="https://crates.io/crates/cargo-tarpaulin">tarpaulin</a>/ <a href="https://github.com/cksac/fake-rs">fake-rs</a> </p>
</li>
<li>
<p>多媒体开发： <a href="https://github.com/rust-av/rust-av">rust-av</a>/ <a href="https://crates.io/crates/image">image</a>/ <a href="https://crates.io/crates/svg">svg </a>/ <a href="https://github.com/CCExtractor/rusty_ffmpeg">rusty_ffmpeg</a>/ <a href="https://github.com/pdeljanov/Symphonia">Symphonia</a>/ </p>
</li>
<li>
<p>游戏引擎和基础组件：<a href="https://crates.io/crates/glam">glam </a>/ <a href="https://crates.io/crates/sdl2">sdl2 </a>/ <a href="https://crates.io/crates/bevy">bevy </a>/ <a href="https://crates.io/crates/amethyst">amethyst</a>/ <a href="https://crates.io/crates/laminar">laminar</a>/ <a href="https://crates.io/crates/ggez">ggez </a>/ <a href="https://crates.io/crates/tetra">tetra</a>/ <a href="https://crates.io/crates/hecs">hecs</a>/ <a href="https://crates.io/crates/simdeez">simdeez</a>/ <a href="https://crates.io/crates/rg3d">rg3d </a> / [rapier](https://github.com/dimforge/ra pier) / <a href="https://github.com/dskart/rustcraft">Rustcraft</a> <a href="https://github.com/zer0x64/nestadia">Nestadia</a>/ <a href="https://github.com/gfx-rs/naga">naga</a>/ <a href="https://github.com/katharostech/bevy_retro">Bevy Retro</a>/ <a href="https://github.com/Orchaldir/texture_generator">Texture Generator</a> / <a href="https://crates.io/crates/building_blocks">building_blocks</a> / <a href="https://github.com/facundoolano/rpg-cli">rpg-cli </a>/ <a href="https://github.com/not-fl3/macroquad">macroquad</a> </p>
</li>
<li>
<p>TUI/GUI 开发：<a href="https://crates.io/crates/winit">winit </a>/ <a href="https://crates.io/crates/gtk">gtk </a>/ <a href="https://crates.io/crates/egui">egui </a>/ <a href="https://crates.io/crates/imgui">imgui </a>/ <a href="https://crates.io/crates/yew">yew </a>/ <a href="https://crates.io/crates/cursive">cursive </a>/ <a href="https://crates.io/crates/iced">iced </a>/ <a href="https://crates.io/crates/fontdue">fontdue </a>/ <a href="https://crates.io/crates/tauri">tauri </a>/ <a href="https://crates.io/crates/druid">druid </a></p>
</li>
</ul>
<hr />
<h2><a class="header" href="#rust-行业应用盘点" id="rust-行业应用盘点">Rust 行业应用盘点</a></h2>
<p>Rust 是一门通用的高级系统级编程语言，其应用领域基本可以同时覆盖 C/Cpp/Java/Go/Python 的应用领域。</p>
<p>具体而言，Rust 的应用领域目前覆盖到以下领域：</p>
<p>下面来盘点不同领域内国内外的 Rust 项目。通过提供代码量、团队规模、项目周期相关数据，希望可以让大家对 Rust 领域应用和开发效率能有一个比较直观的认识。</p>
<h3><a class="header" href="#数据服务" id="数据服务">数据服务</a></h3>
<p>数据服务领域，包括了数据库，数据仓储，数据流，大数据，分布式系统等。</p>
<h4><a class="header" href="#tikv国内开源分布式数据库" id="tikv国内开源分布式数据库">TiKV（国内/开源/分布式数据库）</a></h4>
<p>关键字：数据库/ 分布式系统/ CNCF</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/tikv/tikv">TiKV </a>是一个开源的分布式事务 Key-Value 数据库，专注为下一代数据库提供可靠、高质量、实用的存储架构。最初由 PingCAP 团队在 目前，TiKV 已经在知乎、一点资讯、Shopee、美团、京东云、转转等多行业头部企业得到上线应用。</p>
<p>TiKV 通过 Raft 一致性算法来实现数据多副本之间的一致性，本地采用了 RocksDB 存储引擎存储数据，同时 TiKV 支持数据自动切分和迁移。TiKV 的跨行事务最初参考 Google Percolator 事务模型，并进行了一些优化，提供快照隔离与带锁快照隔离，支持分布式事务。</p>
<p>2018 年 8 月被 CNCF 宣布接纳为沙箱云原生项目，在 2019 年 5 月从沙箱晋级至孵化项目。</p>
<p><strong>代码与团队规模</strong></p>
<p>TiKV 项目 包含 Rust 代码行数大约 30 万行（包含测试代码）。</p>
<p>TiKV 是全球性开源项目，可以从<a href="https://github.com/tikv/tikv/graphs/contributors">贡献者名单</a>来查看团队规模。TiKV 组织中也包含了一些 Go/Cpp 项目，这个并不算在内，只统计参与 Rust 项目的人力规模。</p>
<ul>
<li>主力开发：20人左右。</li>
<li>社区贡献： 300 多人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>TiKV 是作为 TiDB 的底层存储跟随 TiDB 演进。TiDB 为 Go 开发，TiKV 为 Rust 开发。</p>
<p>2016 年 1 月作为 TiDB 的底层存储引擎设计并开发 。</p>
<p>2016 年 4 月开源 发布第一版。</p>
<p>2017 年 10 月 16 日，TiDB 发布 GA 版（TiDB 1.0）， TiKV 发布 1.0 。</p>
<p>2018 年 4 月 27 日，TiDB 发布 2.0 GA 版， TiKV 发布 2.0 。</p>
<p>2019 年 6 月 28 日，TiDB 发布 3.0 GA 版本， TiKV 发布 3.0 。</p>
<p>2020 年 5 月 28 日，TiDB 发布 4.0 GA 版本， TiKV 发布 4.0。</p>
<p>2021 年 4 月 07 日，TiDB 发布 5.0 GA 版本， TiKV 发布 5.0。</p>
<p><strong>小评</strong></p>
<p>有些朋友可能比较关注 Rust 开发效率如何，并且想对其量化，尤其是想对比 C/ Cpp / Go 等其他语言的开发效率。</p>
<p>私以为量化开发效率是非常困难的，尤其是和其他语言比较的量化。我们不妨换个角度来看这件事，比如，从敏捷项目迭代管理来看这件事。如果一门语言，可以满足日常的敏捷开发迭代需求，可以帮助完成产品的进化，那足以说明这门语言的开发效率了。</p>
<p>据了解，PingCAP 中 Go 开发人员是 Rust 开发人员的四五倍之多，当然工作量也差不多是这样的比例。从上面的数据，我们可以看得出来， Rust 项目（TiKV）依然可以稳步跟得上 Go 项目（TiDB）的迭代节奏，说明 Rust 的开发效率还是足以胜任现代化开发需求。</p>
<h4><a class="header" href="#tensorbase-国内开源实时数据仓库" id="tensorbase-国内开源实时数据仓库">TensorBase （国内/开源/实时数据仓库）</a></h4>
<p>关键字：实时数据仓库/ 创业/ 天使轮</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/tensorbase/tensorbase">TensorBase</a> 是金明剑博士于 2020 年 8月启动的创业项目，从一个现代的全新视角出发，用开源的文化和方式，重新构建一个Rust下的实时数据仓库，服务于这个海量数据时代的数据存储和分析。TensorBase 项目目前已获得世界知名创业投资加速机构的天使轮投资。</p>
<p><strong>代码与团队规模</strong></p>
<p>因为 TensorBase 是构建于 <a href="https://github.com/apache/arrow-rs">Apache Arrow</a> 和 <a href="https://github.com/apache/arrow-datafusion">Arrow DataFusion</a> 之上，所以代码统计排除掉这两个项目的依赖。</p>
<p>TensorBase 核心代码行数 54000 多行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 1人。</li>
<li>社区贡献：13 人。</li>
</ul>
<p>因为是新项目，开源社区还在建设中。</p>
<p><strong>项目周期</strong></p>
<p>TensorBase 以时间为节奏发版，而非语义版。 迭代周期预计 一年一个大版本，一月一个小版本。</p>
<p>从 2021年 4 月 20 正式发版，到最近 6月 16，保持这个节奏。</p>
<h4><a class="header" href="#timely-dataflow-国外开源实时数据流" id="timely-dataflow-国外开源实时数据流">Timely Dataflow (国外/开源/实时数据流)</a></h4>
<p>关键字：Dataflow/ 分布式系统/创业</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/TimelyDataflow/timely-dataflow">Timely Dataflow</a> 是 <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2013/11/naiad_sosp2013.pdf">基于微软 这篇 Timely Dataflow 论文： 《Naiad: A Timely Dataflow System》</a>的 现代化 Rust 实现。是 <a href="http://www.clockworks.io/">clockworks.io</a> 公司的开源产品。</p>
<p>在分布式系统中对流式数据进行复杂的处理，比如多次迭代或者递增计算是非常困难的。Storm, Streaming Spark, MillWheel 都不能很好的适应各种应用复杂的需求。Naiad 通过引入 timestamp 的概念，给出了一个非常 low-level 的模型，可以用来描述任意复杂的流式计算。</p>
<p>dataflow系统包罗万象，MapReduce，Spark都可以算是其中代表。Timely dataflow 给出了一个完全基于时间的抽象，统一了流式计算和迭代计算。当你需要对流式数据并行处理且需要迭代控制的时候，可以使用 Timely Dataflow 。</p>
<p><strong>代码与团队规模</strong></p>
<p>Rust 代码量 大约 13000 行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：4人。</li>
<li>社区贡献：30多人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>2017年9月7号，0.3.0 版本。</p>
<p>2018年6月28号，0.6.0 版本。</p>
<p>2018年9月16号，0.7.0 版本。</p>
<p>2018年12月3号，0.8.0 版本。</p>
<p>2019年3月31号，0.9.0 版本。</p>
<p>2019年7月10号，0.10.0 版本。</p>
<p>2021年3月10号，0.12.0版本。</p>
<p>基本上 三个月 出 一个 小版本，除了 Timely Dataflow 之外该团队同时还维护一个构建于 Timely Dataflow 之上的 <a href="https://github.com/timelydataflow/differential-dataflow/blob/master/differentialdataflow.pdf">Differential Dataflow</a> ，和 Timely Dataflow 同步迭代。</p>
<h4><a class="header" href="#noria-国外学术研究开源数据库" id="noria-国外学术研究开源数据库">Noria （国外/学术研究/开源/数据库）</a></h4>
<p>关键字：数据库/ 学术论文项目</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/mit-pdos/noria">Noria </a> 是一种新的流式数据流系统，旨在作为基于MIT  <a href="https://github.com/jonhoo">Jon Gjengset</a> 的<a href="https://jon.thesquareplanet.com/papers/phd-thesis.pdf">博士学位论文</a>的重型Web应用程序的快速存储后端，也参考了OSDI'18的<a href="https://jon.tsp.io/papers/osdi18-noria.pdf">论文</a>。 它类似于数据库，但支持预计算和缓存关系查询结果，以便加速查询。 Noria 自动将缓存的结果保持为底层数据，存储在持久性基础表中。 Noria使用部分状态数据流来减少内存开销，并支持动态，运行时数据流和查询更改。</p>
<p><strong>代码与团队规模</strong></p>
<p>Rust 代码行数大约 59000 多行。</p>
<p>团队规模：</p>
<ul>
<li>主力贡献者：2人</li>
<li>社区贡献者：21人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>因为是个人学术研究项目，所以发布周期没有那么明显。</p>
<p>项目周期 2016年7月30 ~ 2020年 4月30，一共5000多commit。</p>
<h4><a class="header" href="#vector-国外开源数据管道" id="vector-国外开源数据管道">Vector （国外/开源/数据管道）</a></h4>
<p>关键字：数据管道/分布式系统/创业</p>
<p><a href="https://github.com/timberio/vector">Vector</a> 是 Timer 公司构建的一款高性能的、端到端的（代理和聚合器）可观察性数据管道。它是开源的，比该领域（Logstash、Fluentd之类）的所有替代方案快10倍。目前像 豆瓣、checkbox.ai、fundamentei、BlockFi、Fly.io 等公司使用了 Vector 。 <a href="https://vector.dev/#performance">点击此处</a>查看官方性能报告，<a href="https://github.com/timberio/vector/issues/790">点击此处</a>查看目前生产环境中使用 Vector 的公司。</p>
<p><strong>代码与团队规模</strong></p>
<p>代码量大约 18 万行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：9人</li>
<li>社区贡献：140 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>2019年3月22，初始版本发布。</p>
<p>2019年6月10，0.2.0版本发布</p>
<p>2019年7月2，0.3.0版本发布</p>
<p>2019年9月25，0.4.0版本发布</p>
<p>2019年10月11，0.5.0版本发布</p>
<p>2019年12月13，0.6.0版本发布</p>
<p>2020年1月12，0.7.0版本发布</p>
<p>2020年2月26，0.8.0版本发布</p>
<p>2020年4月21，0.9.0版本发布</p>
<p>2020年7月23，0.10.0版本发布</p>
<p>2021年3月12，0.11.0 ～ 0.12 版本发布</p>
<p>2021年4月22，0.13.0版本发布</p>
<p>2021年6月3，0.14.0版本发布</p>
<h4><a class="header" href="#arrow-rs-国外开源大数据标准" id="arrow-rs-国外开源大数据标准">Arrow-rs （国外/开源/大数据标准）</a></h4>
<p>关键字： 大数据/数据格式标准/Apach </p>
<p><a href="https://github.com/apache/arrow-rs">arrow-rs</a> 是 Apache Arrow 的 Rust 实现。Apache Arrow 是 一种适合异构大数据系统的内存列存数据格式标准。它有一个非常大的愿景：提供内存数据分析 (in-memory analytics) 的开发平台，让数据在异构大数据系统间移动、处理地更快。</p>
<p><a href="https://arrow.apache.org/blog/2020/10/27/rust-2.0.0-release/">Arrow 从 2.0 版本开始引入 Rust</a> ，从 4.0 开始 Rust 实现迁移到了独立仓库 arrow-rs 。</p>
<p>Arrow的Rust实现实际上由几个不同的项目组成，包括以下几个独立 crate 和 库 ：</p>
<ul>
<li><a href="https://github.com/apache/arrow-rs/blob/master/arrow/README.md">arrow</a>，arrow-rs 核心库，包含在 arrow-rs 中。</li>
<li><a href="https://github.com/apache/arrow-rs/blob/master/arrow-flight/README.md">arrow-flight </a>，arrow-rs 组件之一，包含在 arrow-rs 中。</li>
<li><a href="https://github.com/apache/arrow-rs/blob/master/parquet/README.md">parquet</a>，arrow-rs 组件之一，包含在 arrow-rs 中。在大数据生态内，Parquet 是最为流行的文件存储格式。</li>
<li><a href="https://github.com/apache/arrow-datafusion">DataFusion</a>，一个可扩展的内存查询执行引擎，使用Arrow作为其格式。</li>
<li><a href="https://github.com/apache/arrow-datafusion/blob/master/ballista/README.md">Ballista</a>，一个分布式计算平台，由Apache Arrow和DataFusion驱动，包含在 DataFusion 中。</li>
</ul>
<p><strong>代码与团队规模</strong></p>
<p>arrow-rs 各相关组件加起来，Rust 代码量 大约 18 万行。</p>
<p>团队规模：</p>
<ul>
<li>
<p>主力开发：大约 10 人</p>
</li>
<li>
<p>社区贡献： 550 多人</p>
</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目 DataFusion 在 2016 年就开始构建了，后来进入了 Apache Arrow 项目。</p>
<p>以 arrow-rs 4.0 开始算：</p>
<p>2021 年 4 月 18 ，版本 4.0 发布。</p>
<p>2021 年 5 月 18，版本 4.1 发布。</p>
<p>2021 年 5 月 30， 版本 4.2 发布。</p>
<p>2021 年 6 月11， 版本 4.3 发布。</p>
<h4><a class="header" href="#influxdb-iox-国外-开源时序数据库" id="influxdb-iox-国外-开源时序数据库">InfluxDB IOx （国外/ 开源/时序数据库）</a></h4>
<p>关键字：时序数据库/分布式</p>
<p><a href="https://github.com/influxdata/influxdb_iox.git"> InfluxDB IOx</a>，是 InfluxDB 的下一代时序引擎，使用 Rust + Aarow 来重写。</p>
<p>现有设计主要有以下几个致命性问题：</p>
<ol>
<li>无法解决时间线膨胀的问题</li>
<li>在云原生环境下，对内存管理要求比较严格，这意味 mmap 不在适用，而且 InfluxDB 需要支持无本地盘的运行模式</li>
<li>由于索引与数据分开存储，导致高效的数据导入导出功能难以实现</li>
</ol>
<p>上述这三个问题都是现有设计的核心之处，因此要想支持现阶段需求，重写是个比较好的选择。</p>
<p><strong>代码与团队规模</strong></p>
<p>InfluxDB IOx 代码量大约是 16万行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 5人</li>
<li>社区贡献： 24 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目从 2019年 11月开始立项，但截至到今天此项目还非常早期，它还没有准备好进行测试，也没有任何构建或文档。 </p>
<p>但是从 GitHub 活动状态来看，开发状态还非常积极。主要的开发工作都是在2021年开始的。</p>
<h4><a class="header" href="#ceresdb-国内商业时序数据库" id="ceresdb-国内商业时序数据库">CeresDB （国内/商业/时序数据库）</a></h4>
<p>关键字：时序数据库</p>
<p><strong>介绍</strong></p>
<p>CeresDB 是蚂蚁集团研发的一款TP/AP 融合时序数据库，满足金融时序、监控、IOT 等场景下的海量时序数据的存储、多维查询下钻和实时分析需求。有开源计划，但目前暂未开源。</p>
<p><strong>团队规模</strong></p>
<p>目前数据库开发大约 8-10个人。</p>
<p>其他信息还未可知。</p>
<h4><a class="header" href="#tantivy-国外开源全文检索" id="tantivy-国外开源全文检索">tantivy (国外/开源/全文检索)</a></h4>
<p>关键字：全文检索/ lucene</p>
<p><a href="https://github.com/tantivy-search/tantivy">tantivy</a> 是一个由 Apache Lucene 启发的全文搜索引擎库，用 Rust 实现。</p>
<p>tantivy 性能卓越，这里有一个基于 Rust + Tantivy + AWS 构建的应用 ：<a href="https://common-crawl.quickwit.io/">提供十亿网页搜索并生成常见单词云</a>。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 50000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1 人</li>
<li>社区贡献：85人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目自 2016 年立项，迭代周期为平均一月一个小版本发布，目前发布到 0.15.2 版本。</p>
<h4><a class="header" href="#rucene-国内开源搜索引擎" id="rucene-国内开源搜索引擎">Rucene （国内/开源/搜索引擎）</a></h4>
<p>关键字：知乎/ lucene</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/zhihu/rucene">Rucene</a> 是知乎团队开源的一款基于 Rust 实现的搜索引擎。Rucene不是完整的应用程序，而是可以轻松用于将完整文本搜索功能添加到应用程序的代码库和API。它是对 Apache Lucene 6.2.1 项目的 Rust 移植。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 10 万 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 4人</li>
<li>社区贡献： 0 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>可能因为是公司内部项目开源化，目前没有迭代出具体语义版本。在知乎内是用于生产环境的。</p>
<h4><a class="header" href="#其他一些项目" id="其他一些项目">其他一些项目</a></h4>
<ul>
<li><a href="https://github.com/netwarps/libp2p-rs">libp2p-rs</a>，是一个模块化和可拓展的网络堆栈，专注于传输协议无关，模块化和可移植编码，最终实现无论设备所处的环境、运行的协议如何，libp2p 都能让设备的互联成为现实。由国内Netwarps 团队开发，该团队是一个致力于实现去中心化网络和存储技术的创业团队，目标在于使用去中心化技术支撑各类 IOT 应用，以及保障<a href="https://cloud.tencent.com/solution/data_protection?from=10680">数据安全</a>。基于此目标，Netwarps 开发了去中心化<a href="https://cloud.tencent.com/product/cfs?from=10680">文件存储</a>系统（DFS）和去中心化计算平台（DCP）。</li>
</ul>
<h3><a class="header" href="#云原生" id="云原生">云原生</a></h3>
<p>云原生领域包括：机密计算、Serverless、分布式计算平台、容器、WebAssembly、运维工具等</p>
<h4><a class="header" href="#stratovirt-国内开源容器" id="stratovirt-国内开源容器"><strong>StratoVirt</strong> （国内/开源/容器）</a></h4>
<p>关键字：容器/ 虚拟化/ Serverless</p>
<p><a href="https://gitee.com/openeuler/stratovirt">StratoVirt</a> 是 <strong>华为 OpenEuler 团队</strong>研发的 基于Rust的下一代虚拟化平台。</p>
<p>Strato，取自stratosphere，意指地球大气层中的平流层，大气层可以保护地球不受外界环境侵害，而平流层则是大气层中最稳定的一层；类似的，虚拟化技术是操作系统平台之上的隔离层，既能保护操作系统平台不受上层恶意应用的破坏，又能为正常应用提供稳定可靠的运行环境；以Strato入名，寓意为保护openEuler平台上业务平稳运行的轻薄保护层。同时，Strato也承载了项目的愿景与未来： 轻量、灵活、 安全和完整的保护能力。</p>
<p>StratoVirt是计算产业中面向云数据中心的企业级虚拟化平台，实现了一套架构统一支持虚拟机、容器、Serverless三种场景，在轻量低噪、软硬协同、安全等方面具备关键技术竞争优势。StratoVirt在架构设计和接口上预留了组件化拼装的能力和接口，StratoVirt可以按需灵活组装高级特性直至演化到支持标准虚拟化，在特性需求、应用场景和轻快灵巧之间找到最佳的平衡点。</p>
<p><strong>代码与团队规模</strong></p>
<p>代码量大约是 27000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：4 人。</li>
<li>社区贡献：15人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>2020-09-23，发布 0.1.0 版本。</p>
<p>2021-03-25，发布 0.2.0 版本。</p>
<p>2021-05-28 ，发布 0.3.0 版本。</p>
<h4><a class="header" href="#firecracker-国外产品" id="firecracker-国外产品">Firecracker （国外/产品）</a></h4>
<p>关键字： 容器/ Serverless/ FaaS</p>
<p><a href="https://github.com/firecracker-microvm/firecracker">Firecracker</a> 由 AWS 发布并将firecracker开源， 它的定位是面向Serverless计算业务场景。 Firecracker本质上是基于KVM的轻量级的microVM， 可以同时支持多租户容器和FaaS场景。 Security和Fast是firecracker的首要设计目标。 它的设计理念可以概括为：</p>
<ul>
<li>基于KVM</li>
<li>精简的设备集（极简主义）</li>
<li>基于Rust语言（Builtin Safety）</li>
<li>定制的guest kernel（快速启动）</li>
<li>优化内存开销（使用musl c）</li>
</ul>
<p>Firecracker使用了极为精简的设备模型（仅有几个关键的模拟设备），目的是减少攻击面已提升安全性。 同时这irecracker使用了一个精简的内核（基于Apline Linux），这使得Firecracker可以做在125ms内拉起一个虚拟机。 Firecracker使用musl libc而不是gnu libc，能够将虚拟机的最低内存开销小到5MB。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 75000 多行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：7人</li>
<li>社区贡献：140 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>从 2018年 3月5号 发布 0.1.0 开始，基本上是每个月发一个小版本。</p>
<p>截止到上个月，刚发布了 0.24.0 版本。</p>
<h4><a class="header" href="#krustlet-国外产品" id="krustlet-国外产品">Krustlet （国外/产品）</a></h4>
<p>关键字： Kubernetes/ WebAssembly/ 容器</p>
<p><strong>介绍</strong></p>
<p>微软 <a href="https://deislabs.io/posts/hello-world/">Deis Labs</a>发布了<a href="https://deislabs.io/posts/introducing-krustlet/">Krustlet</a>，它是使用 Rust 实现的一种 Kubernetes kubelet。它监听 Kubernetes API，以获取新的 Pod 请求（在集群中运行基于 WASI 的应用程序），只要请求事件与节点选择器是匹配的。因此，要在 Krustlet 节点上运行应用程序，用户可以使用 taints、tolerations 和节点选择器。此外，用户必须为应用程序生成 WebAssembly 二进制文件。如果应用程序是用 C 语言开发的，就用<a href="https://00f.net/2019/04/07/compiling-to-webassembly-with-llvm-and-clang/">clang</a>，如果应用程序是用 Rust 开发的，就用<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm">cargo</a>。然后，用户必须使用<a href="https://github.com/engineerd/wasm-to-oci">wasm-to-oci</a>打包，并将容器镜像推送到容器注册中心。要部署应用程序，用户需要定义一个 Kubernetes 清单，其中包含 tolerations。</p>
<p>目前该项目还未到 1.0，有很多实验性特性，但是它的存在证明了 WebAssembly 在容器方面的应用方向。但现在 微软加入了 字节码联盟 ，该项目也会连同字节码联盟的其他成员，一起发展 WebAssembly，特别是即将到来的WASI规范工作和模块链接。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 21000 多行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 7人</li>
<li>社区贡献： 32人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>自从 2020 年 4月7日，0.1.0 发布以来，大约每一两个月发布一次新版本，目前发布到 0.7.0 版本。</p>
<p>团队有计划在未来几个月内达到 1.0 版本。</p>
<h4><a class="header" href="#linkerd2-proxy-国外产品" id="linkerd2-proxy-国外产品">linkerd2-proxy （国外/产品）</a></h4>
<p>关键字： 服务网格/ k8s </p>
<p><strong>介绍</strong></p>
<p>Linkerd 算是 服务网格的鼻祖，但是由于 Linkerd-proxy 运行需要 Java 虚拟机的支持，在启动时间、预热、内存消耗等方面，相比起晚它半年发布的挑战者 Envoy 均处于全面劣势。后来才重写了 Linkerd2 。</p>
<p>Linkerd2 （曾命名为 <a href="https://conduit.io/">Conduit</a>） 是 Buoyant 公司推出的下一代轻量级服务网格框架。与 linkerd 不同的是，它专用于 Kubernetes 集群中，并且比 linkerd 更轻量级（基于 Rust 和 Go，没有了 JVM 等大内存的开销），可以以 sidecar 的方式把代理服务跟实际服务的 Pod 运行在一起（这点跟 Istio 类似）。</p>
<p><a href="https://github.com/linkerd/linkerd2-proxy">linkerd2-proxy </a> 是 Linkerd2 中的底层代理。代理可以说是服务网格中最关键的组件。它可以随应用程序的部署而扩展，因此低附加延迟和低资源消耗至关重要。它也是处理应用程序所有敏感数据的地方，因此安全性至关重要。如果代理速度慢、臃肿或不安全，那么服务网格也是如此。使用 Rust 重写后，<a href="https://github.com/linkerd/linkerd2-proxy">Linkerd2-proxy</a>的性能与资源消耗方面都已不输 Envoy。</p>
<p>Rust是Linkerd2-proxy的唯一选择。它提供了闪电般的性能、可预见的低延迟和我们知道服务网格代理需要的安全属性。它还提供了现代语言特性，如模式匹配和富有表现力的静态类型系统，以及工具，如内置的测试框架和包管理器，使在其中编程变得非常愉快。</p>
<p>Linkerd2-proxy 构建在 Rust 异步生态之上，使用了<a href="https://github.com/tokio-rs/tokio">Tokio</a>, <a href="https://github.com/hyperium/hyper">Hyper</a>, and <a href="https://github.com/tower-rs">Tower</a> 等框架和库。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 43000 多行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：3 人。</li>
<li>社区贡献：37 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>目前该项目已经是 V2.148.0 版本。发布周期大约是每周一个小版本。</p>
<h4><a class="header" href="#lucet-国外产品" id="lucet-国外产品">Lucet （国外/产品）</a></h4>
<p>关键字： Faas/ Serverless/ WebAssembly / Compiler</p>
<p><a href="https://github.com/bytecodealliance/lucet">Lucet</a> 是一个本机 Webassembly 编译器和运行时。 它旨在安全地在您的应用程序内执行不受信任的 WebasseMbly 程序。由 Fastly 公司开发，属于 字节码联盟 的子项目。Fastly 于 2020 年从 Mozilla 招募了 WebAssembly Server side 团队，目前 lucet 团队已经和 <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> 团队合并。</p>
<p>Fastly 庞大的 CDN 业务催生了它们进军边缘计算的想法，并逐渐成为其中最具竞争力和投入度最高的头部公司。</p>
<p>关于边缘计算，另外一家头部公司是Cloudflare(NET.US)。从技术角度看，Fastly和Cloudflare在其无服务器边缘计算解决方案中采用了两种不同的方法。</p>
<p>Cloudflare选择在Chromium V8引擎上构建其解决方案。这使得他们可以利用Google(GOOG.US) Chrome团队已经完成的工作，在2018年便将边缘计算产品快速推向市场。</p>
<p>这是对当时由云供应商(如Amazon(AMZN.US) Lambda)提供的无服务器解决方案的重大改进。Cloudflare的工作者将冷启动时间减少了100倍，进入到毫秒阶段。并将内存使用量减少了10倍，从而可以更有效地利用硬件资源。</p>
<p>但Fastly决定不依赖现有技术来进行无服务器计算，例如可重复使用的容器或V8引擎，而是决定全心投入WebAssembly，并构建了自己的Lucet编译器和运行时，对性能、安全性和紧凑性进行了优化。</p>
<p>自2017年以来，Fastly一直在幕后进行这项工作，它为Compute@Edge产品线提供了坚实的基础，该平台现在为多个客户运行生产代码。</p>
<p>Lucet将WebAssembly编译为快速、有效的二进制文件以便执行，还可以通过内存分配来增强安全性，并且不会从先前的请求中产生任何残留。Lucet还包括一个经过严格优化的简化运行时环境，Fastly团队在该环境上花费了大部分开发时间。结果获得了比V8引擎更好的性能。</p>
<p>Fastly冷启动时间完全进入微秒级别--官方宣称为35微秒。这至少比V8引擎快100倍，后者需要3-5毫秒才能启动(3,000到5,000微秒)。</p>
<p>同样，由于Lucet仅包含运行已编译的汇编代码所需的代码模块，因此它只需要几千字节的内存。这大约是V8引擎使用的3MB的千分之一。</p>
<p><strong>代码与团队规模</strong></p>
<p>lucet 代码量为 29000 多行， wasmtime 总代码量为 27万多行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发 ： 16 人。</li>
<li>社区贡献：200 多人 （wasmtime 贡献者居多）</li>
</ul>
<p><strong>项目周期</strong></p>
<p>lucet 目前进入维护期，wasmtime在高速重构。</p>
<p>评价迭代周期为 每个月发一个小版本。</p>
<h4><a class="header" href="#wasmcloud-国外开源产品" id="wasmcloud-国外开源产品">wasmcloud （国外/开源/产品）</a></h4>
<p>关键字： WebAssembly/ 分布式计算</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/wasmCloud/wasmCloud">WasmCloud</a> 运行时可以用于云、浏览器和嵌入式等场景。wasmcloud 是一个基于 WebAssembly 的分布式计算平台。比较有创新的地方在于，它制定了一个 waPC 标准，用于 Guest 和 Host 的安全过程调用，来解决当前 WASI 等特性不完善的问题。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 11000 多行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：2 人。</li>
<li>社区贡献：11 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目从 2021 年 2月17 启动，迭代周期大约是每两周一个小版本。</p>
<h4><a class="header" href="#habitat-国外开源运维工具" id="habitat-国外开源运维工具">Habitat （国外/开源/运维工具）</a></h4>
<p>关键字：Chef/ DevOps/ 运维工具</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/habitat-sh/habitat">Habitat</a> 让应用团队能够在任何环境中构建、部署、管理任何应用 ，不管是传统的数据中心，还是容器化的微服务。 </p>
<ul>
<li>“Lift &amp; Shift” 遗留应用到现代平台 。把已有的、对商业至关重要的应用迁移到现代平台上对许多机构来说 是一个痛点。 </li>
<li>通过云原生（云、容器）的策略来交付 应用 。许多机构在移居和部署云原生平台的 过程中备受阻碍。</li>
</ul>
<p>特点：</p>
<ol>
<li>
<p>Habitat 把管理界面和应用构建在一起，使得自 动化更加简便。 </p>
</li>
<li>
<p>Habitat Operator：让你的所有应用仅需一个 Kubernetes Operator，不需 要每个应用都有特制的 Operator。</p>
</li>
<li>
<p>不管你的应用在不在 Kubernetes 上，Habitat 的 Open Service Broker 都能通过 Kubernetes 的原生界面让它们共存。</p>
</li>
</ol>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 74000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：5 人。</li>
<li>社区贡献：140人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>迭代周期为每周一个小版本，目前版本为 1.6.342。</p>
<h4><a class="header" href="#其他一些项目-1" id="其他一些项目-1">其他一些项目</a></h4>
<ul>
<li><a href="https://github.com/datenlord/datenlord">DatenLord</a> 是用 Rust 实现的新一代开源分布式存储，面向云原生场景提供高性能存储解决方案。为了提高 IO 性能，DatenLord 采用绕过内核 (bypass Kernel) 的方式，主要在用户态实现 IO 功能，避免内核执行 IO 任务带来的额外开销，从而实现高性能分布式存储。Datenlord 是国内创业团队，<a href="https://datenlord.github.io/">点此</a>查看更多信息。</li>
<li><a href="https://github.com/datafuselabs/datafuse">Datafuse</a>，是一种实时数据处理和分析DBMS，基于 Apache Arrow-rs开发，受 ClickHouse 启发。该项目属于 Datafuse labs，是由中国开发者领头的项目，但不清楚公司是在国内还是国外。</li>
</ul>
<h3><a class="header" href="#操作系统" id="操作系统">操作系统</a></h3>
<p>操作系统领域包括使用 Rust 实现的各种操作系统。</p>
<h4><a class="header" href="#rust-for-linux-国外-rust-进入-linux-支持项目-" id="rust-for-linux-国外-rust-进入-linux-支持项目-">Rust for Linux （国外/ Rust 进入 Linux 支持项目 ）</a></h4>
<p>关键字： Linux</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/Rust-for-Linux/linux">Rust for Linux</a> 项目旨在推动 Rust 成为 Linux 内核第二编程语言。</p>
<p>Linux内核是现代互联网的核心，从服务器到客户端设备。它处于处理网络数据和其他形式的输入的第一线。因此，Linux内核中的漏洞会产生广泛的影响，使人们、组织和设备的安全和隐私面临风险。由于它主要是用C语言编写的，而C语言不是内存安全的，所以内存安全漏洞，如缓冲区溢出和使用后赋值，是一个持续的问题。通过使Linux内核的部分内容用Rust语言编写成为可能，这是内存安全的，我们可以完全消除某些组件的内存安全漏洞，比如驱动程序。</p>
<p>当前进展：Google 赞助 且 由 ISRG 组织雇佣 Miguel Ojeda （核心开发），让他全职从事Rust for Linux和其他安全工作，为期一年。希望能通过让他全职从事这项工作，为支持数字基础设施尽一份力。</p>
<p><strong>团队规模</strong></p>
<p>核心开发： 1 ～ 6人。</p>
<p>暂未有其他信息。</p>
<h4><a class="header" href="#coreutils" id="coreutils">Coreutils</a></h4>
<p>关键字： GNU/ Shell/ Rust for Linux</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/uutils/coreutils">Coreutils</a> 是GNU Shell 的核心实用程序的 Rust 实现。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 77000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：8人</li>
<li>社区贡献：250人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目于2020年底启动，迭代周期平均一月一个小版本，目前 0.0.6 版本。目前状态，足以通过 GNOME 启动 Debian 系统。</p>
<h4><a class="header" href="#occulum-国内开源tee-库操作系统" id="occulum-国内开源tee-库操作系统">Occulum （国内/开源/TEE 库操作系统）</a></h4>
<p>关键字： 机密计算/ 可信计算/  TEE / 库操作系统</p>
<p><a href="https://github.com/occlum/occlum">Occulum</a> 是蚂蚁开源的 TEE 操作系统，也是 CCC 机密计算联盟中第一个由中国公司发起的开源项目。</p>
<p>Occlum 提供 POSIX 编程接口，支持多种主流语言（C/C++, Java, Python, Go, Rust 等），支持多种安全文件系统。可以说，Occlum 提供了一个兼容 Linux 的 Enclave 运行环境，使得机密计算可以轻松支持已有的应用，也使得机密应用开发者复用原有开发技能。Occlum 不但在工业界场景中得到了广泛的应用，而且也在系统顶会 ASPLOS 2020 发表了学术论文，代表了机密计算业界的领先水平。</p>
<p>从架构上来看，Occlum 不但提供基本的类似 Linux 的操作系统能力，而且提供一个类似 Docker 的用户使用接口，比如这里的 Occlum build 和 Occlum run 等都跟 docker 的命令类似。</p>
<p><strong>代码与团队规模：</strong></p>
<p>Occulum 代码量大约  28000 多行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 5人。</li>
<li>社区贡献：22 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>迭代周期是每六周发一个新版。</p>
<h4><a class="header" href="#rcore-和-zcore-国内-教育-学术-开源-操作系统" id="rcore-和-zcore-国内-教育-学术-开源-操作系统">rCore 和 zCore （国内/ 教育/ 学术/ 开源/ 操作系统）</a></h4>
<p>关键字： 清华大学/ rCore/ zCore/ 操作系统/ 教学</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/rcore-os/rCore">rCore</a> 是用 Rust 重新实现的 Linux 内核，诞生于 2018 年，目前已在清华计算机系的操作系统教学实验中试点应用。</p>
<p><a href="https://github.com/rcore-os/zCore">zCore</a> 是用 Rust 语言重新实现的 Zircon （Google Fuchsia OS 的微内核）微内核。它运行在内核态，对外提供与 Zircon 完全相同的系统调用，因此<strong>能够运行原生的 Fuchsia 用户程序</strong>。不仅如此，它还可以<strong>作为一个普通的用户进程运行在 Linux 或 macOS 的用户态</strong>，我们一般把这种模式称为 LibOS 或 User-Mode OS。你甚至无需安装 QEMU 模拟器，只需装上 Rust 官方工具链，就可以编译运行体验 zCore！</p>
<p>一些相关学习资源：</p>
<ul>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/137733625">下一代 Rust OS：zCore 正式发布</a> </p>
</li>
<li>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_1/rcore_intro.html#%E7%94%A8rust%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%B8%85%E5%8D%8E-rcore-os-%E6%95%99%E7%A8%8B%E4%BB%8B%E7%BB%8D">用<code>Rust</code>写操作系统 | 清华 rCore OS 教程介绍</a></p>
</li>
</ul>
<p><strong>代码及团队规模</strong></p>
<p>rCore 代码量大约为  26000 行 Rust 代码，zCore 代码量大约为 27000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：3～5人</li>
<li>社区贡献：30 人左右</li>
</ul>
<p><strong>项目周期</strong></p>
<p>两个项目都已进入维护期，没有对外发布版本。</p>
<h4><a class="header" href="#redox-国外-开源-操作系统" id="redox-国外-开源-操作系统">Redox （国外/ 开源/ 操作系统）</a></h4>
<p>关键字：操作系统</p>
<p><strong>介绍</strong></p>
<p><strong>Redox</strong>是一个用<a href="https://www.rust-lang.org/"><strong>Rust</strong></a>语言编写的类UNIX操作系统 , 它的目标是把Rust语言的创新带入到一个现代的微内核和全系列的应用程序。Redox 幕后公司应该是 System 76 公司。主要项目放在 GitLab 中。</p>
<p><strong>代码及团队开发</strong></p>
<p>代码量目前大约为 <strong>134 万行 Rust 代码</strong>，算得上是 Rust 生态中重量级项目了。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 21人</li>
<li>社区贡献：79 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>Redox 从 2016 年开始立项，直到 2017 年 0.3 版本开始，每年发布一个小版本，到今年已经发布到 0.5 版本。</p>
<h4><a class="header" href="#tockos-国外开源嵌入式实时操作系统" id="tockos-国外开源嵌入式实时操作系统">tockOS （国外/开源/嵌入式实时操作系统）</a></h4>
<p>关键字：嵌入式操作系统/实时</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/tock/tock">Tock</a> 是一个嵌入式操作系统，设计用于在基于Cortex-M和RISC-V的嵌入式平台上运行多个并发的、互不信任的应用程序。Tock的设计以保护为中心，既可以防止潜在的恶意应用程序，也可以防止设备驱动程序。Tock使用两种机制来保护操作系统的不同组件。首先，内核和设备驱动程序是用Rust编写的，Rust是一种提供compile-time内存安全、类型安全和严格别名的系统编程语言。Tock使用Rust来保护内核（例如调度程序和硬件抽象层）不受特定于平台的设备驱动程序的影响，并将设备驱动程序彼此隔离。其次，Tock使用内存保护单元将应用程序彼此和内核隔离开来。</p>
<p>Google发布的这个 OpenSK 是跑在 Tock上面的！<a href="https://github.com/google/OpenSK">OpenSK </a>是用Rust编写的安全密钥的开源实现，该密钥同时支持FIDO U2F和FIDO2标准。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 15万 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：4 人。</li>
<li>社区贡献：123 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目目前已进入维护期。</p>
<p>目前 1.6 版本发布，以往迭代周期大概是每半年发布一个小版本。</p>
<h4><a class="header" href="#theseus-国外开源高端嵌入式操作系统研究项目" id="theseus-国外开源高端嵌入式操作系统研究项目">Theseus (国外/开源/高端嵌入式操作系统/研究项目)</a></h4>
<p>关键字： 嵌入式操作系统/研究型</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/theseus-os/Theseus">Theseus</a> 是美国莱斯大学多年实验的结果，也有其他大学参与，比如耶鲁大学。它通过减少一个组件对另一个组件持有的状态来重新设计和改进操作系统的模块化，并利用一种安全的编程语言 Rust，将尽可能多的操作系统责任转移给编译器。</p>
<p>Theseus 体现了两个主要贡献。 </p>
<ul>
<li>一个操作系统结构。其中许多微小的组件具有明确定义的、运行时持久的界限，它们之间的互动不需要彼此持有状态。</li>
<li>一种使用语言级机制实现操作系统本身的内部语言方法。这样编译器就可以执行关于操作系统语义的不变性。</li>
</ul>
<p>Theseus 的结构、内部语言设计和状态管理以超越现有作品的方式实现了核心操作系统组件的实时演进和故障恢复。</p>
<p>更多资料：<a href="https://www.usenix.org/conference/osdi20/presentation/boos">《Theseus: an Experiment in Operating System Structure and State Management》</a></p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 56000 行代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1 人。</li>
<li>社区贡献：17人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目自 2017 年 3月启动，目前已经进入维护期。</p>
<h3><a class="header" href="#工具软件" id="工具软件">工具软件</a></h3>
<p>工具软件包括使用 Rust 实现的一些 命令行工具、桌面软件等。</p>
<h4><a class="header" href="#rustdesk-国内部分开源远程桌面软件" id="rustdesk-国内部分开源远程桌面软件">RustDesk （国内/部分开源/远程桌面软件）</a></h4>
<p><a href="https://github.com/rustdesk/rustdesk">rustdesk</a>，是一款远程桌面软件，开箱即用，无需任何配置，替代TeamViewer和AnyDesk。您完全掌控数据，不用担心安全问题。rustdesk 是一款商业开源软件，开源度 90%。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 35000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 1人。</li>
<li>社区贡献： 8 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>2021 年 3 月 27 发布 1.1 版本，之前的版本迭代无从知晓。</p>
<p>自此之后基本每月迭代一两个小版本。</p>
<h4><a class="header" href="#spotify-tui-国外终端音乐软件" id="spotify-tui-国外终端音乐软件">spotify-tui （国外/终端音乐软件）</a></h4>
<p>关键字：Terminal UI/ Spotify</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/Rigellute/spotify-tui.git">spotify-tui</a> 是一款终端 Spotify 音乐客户端，基于 Rust 终端 UI 开发框架 <a href="https://github.com/fdehau/tui-rs">Tui-rs</a> 开发。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 12000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1人。</li>
<li>社区贡献：84 人。</li>
</ul>
<p><strong>开发周期</strong></p>
<p>已经进入维护期，平均每月一个小版本。</p>
<h4><a class="header" href="#ripgrep-国外终端文本搜索" id="ripgrep-国外终端文本搜索">Ripgrep （国外/终端文本搜索）</a></h4>
<p>关键字：文本处理/ 终端工具</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> 是一个以行为单位的搜索工具， 它根据提供的 pattern 递归地在指定的目录里搜索。它是由 Rust 语言写成，相较与同类工具，它的特点就是无与伦比地快。ripgrep 目前已经成为 Linux 下最快的文本搜索工具。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约 35000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1 人。</li>
<li>社区贡献：287 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目于 2016 年开始启动，在 2018年之前迭代比较频繁，后面进入稳定维护期，基本一年一个大版本，目前版本为 13.0.0 。</p>
<h4><a class="header" href="#nushell-国外开源shell工具" id="nushell-国外开源shell工具">nushell （国外/开源/shell工具）</a></h4>
<p>关键字：shell </p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/nushell/nushell">NuShell </a> 是使用 Rust 语言编写的跨 Unix, Windows, macOS 系统的现代 Shell 程序。</p>
<p>NuShell 不像传统的 Unix Shell，它从 PowerShell 汲取灵感，将每个命令产生的结果视作具有结构的对象，而不是传统的原始字节。但和 PowerShell 相比，它的速度要快得多。</p>
<p>NuShell 的特色在于结构化数据以及类似 SQL 的二维表操作， 在处理大量结构化数据时具有一定优势，几乎相当于一个针对本地文件、数据的 SQL 解析器。不过其缺少流程控制语句的特点，让它难以胜任逻辑化的系统管理工作。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 10万行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 2人。</li>
<li>社区贡献：231 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目于 2019年 5月启动，迭代周期为每个月一个小版本，目前为 0.32.0 版本。</p>
<h4><a class="header" href="#alacritty-国外开源模拟终端" id="alacritty-国外开源模拟终端">alacritty (国外/开源/模拟终端)</a></h4>
<p>关键字：模拟终端/OpenGL</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/alacritty/alacritty">**Alacritty **</a>是一个免费的开源，快速，跨平台的终端仿真器，它使用<strong>GPU</strong> （ <strong>图形处理单元</strong> ）进行渲染，实现<a href="https://www.howtoing.com/linux-terminal-emulators/">了Linux</a>中许多其他<a href="https://www.howtoing.com/linux-terminal-emulators/">终端仿真器</a>所不具备的某些优化。</p>
<p><strong>Alacritty</strong>专注于<strong>简单</strong>和<strong>性能</strong>两个目标。 <strong>性能</strong>目标意味着，它应该比任何其他可用的终端仿真器快。 <strong>简单性</strong>目标意味着，它不支持Linux中的<strong>选项卡</strong>或<strong>分割</strong> （可以由其他<a href="https://www.howtoing.com/tmux-to-access-multiple-linux-terminals-inside-a-single-console/">终端多路复用器 - tmux</a>轻松提供）等功能。</p>
<p>性能上已经秒杀Linux 上同类工具了。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 22000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发： 2人</li>
<li>社区贡献：330人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目启动于 2016 年，目前迭代周期平均每三个月发布一个新的小版本。目前版本号 0.8.0。虽然还未稳定1.0版本，但已经成为很多人日常开发工具了。</p>
<h4><a class="header" href="#gitui-国外开源git终端ui" id="gitui-国外开源git终端ui">Gitui (国外/开源/Git终端UI)</a></h4>
<p>关键字：Git/ Terminal UI</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/extrawurst/gitui">Gitui</a> 是一个速度很快的 Git 终端界面。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 29000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1 人。</li>
<li>社区贡献：42 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目于 2020 年3 月 15日启动，迭代周期平均为每两周一个小版本发布。目前 0.16.1 版本。</p>
<h4><a class="header" href="#其他优秀的终端工具" id="其他优秀的终端工具">其他优秀的终端工具</a></h4>
<ul>
<li><a href="https://github.com/ogham/exa">exa</a>，Rust 重写 ls  工具。</li>
<li><a href="https://crates.io/crates/bottom">bottom</a>，Rust 重写 Top 工具。</li>
<li><a href="https://starship.rs/">starship</a> 超级快、支持各种订制的极简命令行提示符，支持任意 shell</li>
<li><a href="https://github.com/sharkdp/bat">bat</a> 支持更多特性的 <code>cat</code> 克隆</li>
<li><a href="https://github.com/dandavison/delta">delta</a> git、diff 输出查看器</li>
<li><a href="https://github.com/ajeetdsouza/zoxide">zoxide</a> 更快捷地浏览文件系统</li>
<li><a href="https://github.com/sharkdp/fd">fd</a>简单、快速、用户友好的 <code>find</code> 替代品</li>
<li><a href="https://github.com/dbrgn/tealdeer">tealdeer</a>  众人一起编写的终端命令速查卡</li>
</ul>
<h3><a class="header" href="#机器学习" id="机器学习">机器学习</a></h3>
<p>机器学习领域包括，基于 Rust 实现的机器学习框架、科学计算库等等。</p>
<h4><a class="header" href="#linfa-国外开源机器学习工具包" id="linfa-国外开源机器学习工具包">linfa （国外/开源/机器学习工具包）</a></h4>
<p>关键字：scikit-learn/ sklearn/ 基础工具包</p>
<p><strong>介绍</strong></p>
<p><a href="https://rust-ml.github.io/linfa/">Linfa</a> 是一个 Rust 实现的 类似于 python  scikit-learn 的库，旨在提供一个全面的工具包，可以使用 Rust 构建机器学习应用程序。该团队还创建了 Rust-ML 组织。</p>
<blockquote>
<p>scikit-learn，又写作sklearn，是一个开源的基于python语言的机器学习工具包。 它通过NumPy, SciPy和Matplotlib等python数值计算的库实现高效的算法应用，并且涵盖了几乎所有主流机器学习算法。</p>
</blockquote>
<p>更多资料：<a href="https://rust-ml.github.io/book/">Rust 机器学习之书</a></p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 23000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：6人</li>
<li>社区贡献：12人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目 2018年就立项了，但是正式动工是 2020年10月，2021年进入迭代期。基本每月一个小版本，最近的版本在4月份发布的，0.4.0版本。项目开发状态还是比较活跃的。</p>
<h4><a class="header" href="#tokenizers-国外开源自然语言处理分词库" id="tokenizers-国外开源自然语言处理分词库">tokenizers (国外/开源/自然语言处理分词库)</a></h4>
<p>关键字：自然语言处理/ 分词库</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/huggingface/tokenizers">tokenizers</a> 是 Hugging Face 公司开源的一款 Rust 实现的分词库。</p>
<p>Hugging Face  是一家总部位于美国纽约的聊天机器人初创服务商。该公司在 NLP界鼎鼎大名，三月份刚刚完成4000万美元B轮融资。在GitHub上发布了开源 NLP 库 Transformers。</p>
<p>基于深度学习的现代 NLP 管道中的瓶颈之一就是tokenization，尤其是通用性强且独立于框架的实现。</p>
<p>所以，该分词器的核心是用Rust编写的，并且存在Node和Python的绑定。提供当今最常用的分词器的实现，重点是性能和通用性。</p>
<p>特点：</p>
<ul>
<li>使用当今最常用的分词器（tokenize），训练新的词汇并进行标记。</li>
<li>由于采用Rust实现，速度极快（包括训练和标记化）。在服务器的CPU上对一GB的文本进行标记化只需不到20秒。</li>
<li>易于使用，但也非常通用。</li>
<li>为研究和生产而设计。</li>
<li>正则化带有对齐性跟踪。总是可以得到与给定标记相对应的原始句子的部分。</li>
<li>做所有的预处理。截断、填充、添加你的模型需要的特殊标记。</li>
</ul>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约 28000 行 Rust 代码。占总项目的 68%，该项目还有部分 Python 代码。</p>
<p><strong>项目周期</strong></p>
<p>该项目自 2019 年10月开始启动，迭代周期平均为每月一个小版本，目前版本为 <code>Python V0.10.3</code>。</p>
<h4><a class="header" href="#tch-rs-国外开源pytorch-绑定" id="tch-rs-国外开源pytorch-绑定">tch-rs (国外/开源/PyTorch 绑定)</a></h4>
<p>关键字：PyTorch/ cpp api 绑定</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/LaurentMazare/tch-rs">tch-rs</a>是Pytorch的Cpp API的 Rust 绑定。 Tch Crate的目标是围绕 Cpp Pytorch API 提供一些薄的包装器。 它旨在尽可能接近原始的Cpp API。 然后可以在此之上开发更加惯用的 Rust 绑定。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 58000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1 人</li>
<li>社区贡献：36 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目从 2019 年 2月启动，截止到今天，还没有正式发布任何版本。目前还在活跃维护中，但可能是 个人项目。</p>
<h4><a class="header" href="#ndarray-国外开源科学计算" id="ndarray-国外开源科学计算">ndarray （国外/开源/科学计算）</a></h4>
<p>关键字：科学计算/ N 维数组</p>
<p><a href="https://github.com/rust-ndarray/ndarray">ndarray</a> 是一个由Rust官方团队中资深科学计算专家bluss开发的开源项目，实现了基于rust的矩阵和线性运算。目标是在Rust中建立类似于numpy和openblas的科学计算社区。它是机器视觉、数据挖掘、生物信息等多类科学计算库的基础，社区中的主要用户为一些相关技术的高校或者研究所。</p>
<p>目前 华为 也在深度参与该基础库的研发，参见 <a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_3/hw_ndarray.html">华为 | Rust 科学计算多维数组运算库的分析与实践</a>。</p>
<p>另外还有线性代数相关库：<a href="https://github.com/rust-ndarray/ndarray-linalg">ndarray-linalg</a> 。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 29000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1人</li>
<li>社区贡献：57 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>该项目自 2015 年11 月启动，平均每半年 1 ～ 2 个小版本发布。 </p>
<h4><a class="header" href="#tvm-rs-国外开源-tvm-rust-绑定" id="tvm-rs-国外开源-tvm-rust-绑定">TVM-rs （国外/开源/ TVM rust 绑定）</a></h4>
<p>关键字：Apache/ TVM</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/apache/tvm/tree/main/rust">tvm-rs</a> 是 TVM 的 Rust 绑定。</p>
<p>TVM 是由华盛顿大学在读博士陈天奇等人提出的深度学习自动代码生成方法，去年 8 月<a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650729915&amp;idx=1&amp;sn=2c75c059166a9f00942d9cc3326afb65&amp;chksm=871b29c5b06ca0d3e16dc3e82397af9c076931185ce55b018a0b001a1ba6bb131148416bc05f&amp;scene=21#wechat_redirect">机器之心曾对其进行过简要介绍</a>。该技术能自动为大多数计算硬件生成可部署优化代码，其性能可与当前最优的供应商提供的优化计算库相比，且可以适应新型专用加速器后端。</p>
<p>简单来说，TVM可以称为许多工具集的集合，其中这些工具可以组合起来使用，来实现我们的一些神经网络的加速和部署功能。这也是为什么叫做<strong>TVM Stack</strong>了。TVM的使用途径很广，几乎可以支持市面上大部分的神经网络权重框架(ONNX、TF、Caffe2等)，也几乎可以部署在任何的平台，例如Windows、Linux、Mac、ARM等等。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 1 万多行。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：3人</li>
<li>社区贡献： 7～10人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>不定时维护。</p>
<h4><a class="header" href="#neuronika-国外开源机器学习框架" id="neuronika-国外开源机器学习框架">Neuronika （国外/开源/机器学习框架）</a></h4>
<p>关键字：PyTorch/ 机器学习框架</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/neuronika/neuronika">Neuronika</a> 是一个用 Rust 编写的机器学习框架，与 PyTorch 类似，现已实现最常见的层组件（dense 层、dropout 层等），速度堪比 PyTorch。其构建重点在于易用性、快速原型开发和高效性能。</p>
<p>Neuronika 是由 Francesco Iannelli 等人开发，他们现在是计算机科学的硕士生。该框架提供了自动微分和动态神经网络，非常像 Pytorch。目前已经实现了最常见的层组件，如 dense 层、dropout 层、GRU、LSTM 和 1d-2d-3d CNN，然而，缺少池化层等等。Neuronika 还提供了损失函数、优化器、计算图、张量和数据实用程序。</p>
<p>速度方面，项目作者表示 Neuronika 的表现可与 PyTorch 媲美。你可以对它进行基准测试。但目前还不能支持 GPU。想要进行基准测试，可以参考测试文档。</p>
<p>Neuronika 的核心机制是一种叫做反向模式自动微分机制（ reverse-mode automatic differentiation），这种机制允许用户在改变动态神经网络时可以轻松实现，没有任何开销，可通过 API 运行。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 26000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：2 人</li>
<li>社区贡献：0 人</li>
</ul>
<p>新项目，目前还未有人贡献。</p>
<p><strong>项目周期</strong></p>
<p>还未迭代出初始版本，但开发动态比较活跃。</p>
<h4><a class="header" href="#其他" id="其他">其他</a></h4>
<ul>
<li><a href="https://github.com/tensorflow/rust">TensorFlow-rs</a>，TensorFlow Rust 绑定，2021 年维护状态，不太活跃。</li>
<li><a href="https://whatlang.org/">Whatlang</a>，基于 Rust 实现的 自然语言 识别项目。</li>
<li><a href="https://github.com/vaaaaanquish/Awesome-Rust-MachineLearning">Awesome-Rust-MachineLearning</a>，Rust 机器学习相关生态项目列表。</li>
</ul>
<h3><a class="header" href="#游戏" id="游戏">游戏</a></h3>
<p>游戏领域包括，使用 Rust 制作的游戏、Rust 游戏引擎、Rust 游戏生态建设等。</p>
<h4><a class="header" href="#veloren-国外沙盒游戏开源" id="veloren-国外沙盒游戏开源"><strong>veloren</strong> (国外/沙盒游戏/开源)</a></h4>
<p>关键字：沙盒游戏/ 我的世界</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/veloren/veloren">Veloren</a> 是用 Rust 开发的开源免费多玩家 voxel RPG。它的灵感来自诸如《魔方世界》，《塞尔达传说：旷野之息》，《矮人要塞》和《我的世界》等游戏。支持多人、单人，可以在Windows、Mac、Linux上游玩。点击 <a href="https://veloren.net/">官网</a> 了解更多。</p>
<p>Veloren 应该是最早使用 Rust 的项目了，该项目在 2013 年就开始使用 Rust 开发，当时 Rust 还未 1.0 。截止到2021年的今天，该项目还保持着活跃更新。</p>
<p>Veloren 的创始人，也是 Rust 官方游戏开发组成员之一。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 20 万行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：15 人。</li>
<li>社区贡献：175 人。</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目迭代周期平均每三月发一个小版本。目前是 0.10.0 版。</p>
<h4><a class="header" href="#a--b-street-国外开源街景交通探索游戏" id="a--b-street-国外开源街景交通探索游戏">A / B Street (国外/开源/街景交通探索游戏)</a></h4>
<p>关键字： </p>
<p><a href="https://github.com/a-b-street/abstreet">A / B Street</a> 是一个游戏，探索城市对驾驶员，骑自行车者，过境用户和行人的运动的小变化。</p>
<p>游戏最终目标是让玩家成为调整西雅图（默认）基础设施的真正建议，A/B Street 使用<a href="https://www.openstreetmap.org/about">OpenStreetMap</a> ，所以游戏可以是世界上任何一个地方。 A / B街当然是一个游戏，使用简化的交通建模方法，所以城市政府仍然必须使用现有方法来评估提案。 A / B Street旨在作为与交互式可视化传达想法的对话启动器和工具，或者给城市规划专家做参考。</p>
<p><strong>代码量及团队规模</strong></p>
<p>代码量大约为 10 万 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1 人</li>
<li>社区贡献：24 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目从2018年3月11 启动，截止到当前 2021年6月，一直高速迭代。迭代周期平均是每周一个小版本。</p>
<h4><a class="header" href="#embark-公司-与-rust-游戏生态" id="embark-公司-与-rust-游戏生态">Embark 公司 与 Rust 游戏生态</a></h4>
<p>关键字： Rust Game Ecosystem</p>
<p><strong>介绍</strong></p>
<p>Embark 公司是 Johan Andersson （游戏界知名人物）创建的游戏工作室，在创建之初就选择 Rust 作为主要语言。</p>
<blockquote>
<p>我们相信，通过与社区公开分享我们的工作、问题和想法，我们将创造更多的合作和讨论机会，使我们走向Rust和整个游戏行业的伟大未来。 -- Johan Andersson (@repi), CTO, Embark</p>
<p><em>在Embark，我们一直用 Rust 从头开始构建自己的游戏引擎。 我们在RLSL原型的内部开发方面拥有先前的经验，我们拥有一支由出色的渲染工程师组成的团队，他们熟悉游戏，游戏引擎和其他行业中当今着色器语言的问题。 因此，我们认为我们处于解决这一问题的独特位置。</em></p>
<p>我们希望使用一种出色的语言简化我们自己的内部开发，建立一个开源图形社区和生态系统，促进GPU和CPU之间的代码共享，最重要的是-使我们（未来的）用户和其他开发人员拥有更多快速创建引人入胜的体验。</p>
</blockquote>
<p>创建 Rust 游戏生态并非口号，Embark 公司也加入了 Rust 游戏工作组，并且创建了一系列打造 Rust 游戏生态的库。</p>
<p>这些库都罗列在 <a href="https://github.com/EmbarkStudios/rust-ecosystem">rust-ecosystem</a> 仓库中。</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>🌋 <a href="https://github.com/EmbarkStudios/ash-molten.git"><code>ash-molten</code></a></td><td>Statically linked MoltenVK for Vulkan on Mac using Ash</td></tr>
<tr><td>👷 <a href="https://github.com/EmbarkStudios/buildkite-jobify"><code>buildkite-jobify</code></a></td><td>Kubekite, but in Rust, using configuration from your repos</td></tr>
<tr><td>📜 <a href="https://github.com/EmbarkStudios/cargo-about"><code>cargo-about</code></a></td><td>Cargo plugin to generate list of all licenses for a crate</td></tr>
<tr><td>❌ <a href="https://github.com/EmbarkStudios/cargo-deny"><code>cargo-deny</code></a></td><td>Cargo plugin to help you manage large dependency graphs</td></tr>
<tr><td>🎁 <a href="https://github.com/EmbarkStudios/cargo-fetcher"><code>cargo-fetcher</code></a></td><td><code>cargo fetch</code> alternative for use in CI or other &quot;clean&quot; environments</td></tr>
<tr><td>⚙️ <a href="https://github.com/EmbarkStudios/cfg-expr"><code>cfg-expr</code></a></td><td>A parser and evaluator for Rust <code>cfg()</code> expressions</td></tr>
<tr><td>⛴️ <a href="https://github.com/EmbarkStudios/discord-sdk"><code>discord-sdk</code></a></td><td>An open implementation of the Discord Game SDK in Rust</td></tr>
<tr><td>🚙 <a href="https://github.com/EmbarkStudios/gsutil"><code>gsutil</code></a></td><td>A small, incomplete replacement for the official gsutil</td></tr>
<tr><td>📦 <a href="https://github.com/EmbarkStudios/krates"><code>krates</code></a></td><td>Creates graphs of crates from cargo metadata</td></tr>
<tr><td>🆙 <a href="https://github.com/EmbarkStudios/octobors"><code>octobors</code></a></td><td>GitHub action for automerging PRs based on a few rules</td></tr>
<tr><td>🎳 <a href="https://github.com/EmbarkStudios/physx-rs"><code>physx</code></a></td><td>Use <a href="https://github.com/NVIDIAGameWorks/PhysX">NVIDIA PhysX</a> in Rust</td></tr>
<tr><td>🐦 <a href="https://github.com/EmbarkStudios/puffin"><code>puffin</code></a></td><td>Simple instrumentation profiler for Rust</td></tr>
<tr><td>📓 <a href="https://github.com/EmbarkStudios/relnotes"><code>relnotes</code></a></td><td>Automatic GitHub release notes</td></tr>
<tr><td>🐏 <a href="https://github.com/EmbarkStudios/rpmalloc-rs"><code>rpmalloc-rs</code></a></td><td>Cross-platform Rust global memory allocator using <a href="https://github.com/rampantpixels/rpmalloc">rpmalloc</a></td></tr>
<tr><td>🐉 <a href="https://github.com/EmbarkStudios/rust-gpu"><code>rust-gpu</code></a></td><td>Making Rust a first-class language &amp; ecosystem for GPU code</td></tr>
<tr><td>🆔 <a href="https://github.com/EmbarkStudios/spdx"><code>spdx</code></a></td><td>Helper crate for SPDX expressions</td></tr>
<tr><td>🛠 <a href="https://github.com/EmbarkStudios/spirv-tools-rs"><code>spirv-tools-rs</code></a></td><td>An unofficial wrapper for SPIR-V Tools</td></tr>
<tr><td>🔆 <a href="https://github.com/EmbarkStudios/superluminal-perf-rs"><code>superluminal-perf</code></a></td><td><a href="http://superluminal.eu/">Superluminal Performance</a> profiler integration</td></tr>
<tr><td>📂 <a href="https://github.com/EmbarkStudios/tame-gcs"><code>tame-gcs</code></a></td><td>Google Cloud Storage functions that follows the sans-io approach</td></tr>
<tr><td>🔐 <a href="https://github.com/EmbarkStudios/tame-oauth"><code>tame-oauth</code></a></td><td>Small OAuth crate that follows the sans-io approach</td></tr>
<tr><td>🧬 <a href="https://github.com/EmbarkStudios/tame-oidc"><code>tame-oidc</code></a></td><td>Small OIDC crate that follows the sans-io approach</td></tr>
<tr><td>🎨 <a href="https://github.com/EmbarkStudios/texture-synthesis"><code>texture-synthesis</code></a></td><td>Example-based texture synthesis generator and CLI example</td></tr>
<tr><td>💫 <a href="https://github.com/EmbarkStudios/tryhard"><code>tryhard</code></a></td><td>Easily retry futures</td></tr>
</tbody></table>
<p>其中最重要的一个库是 <a href="https://github.com/EmbarkStudios/rust-gpu">rust-gpu</a>，旨在让 Rust 成为建立GPU代码的一流语言和生态系统。</p>
<p><strong>使用Rust的愿望</strong> 为GPU编写程序 <strong>不仅源于安全功能和高性能，</strong> 而且还需要获得与软件包和模块一起使用的现代工具，以提高开发过程的效率。</p>
<p><strong>历史上，在游戏中，GPU编程是通过编写HLSL完成的</strong> 或在较小程度上包括GLSL。 这些是简单的编程语言，这些年来随着渲染API一起发展。</p>
<p>但是，随着游戏引擎的发展，这些语言还没有提供处理大型代码库的机制，总的来说， <strong>与其他编程语言相比，它们已经落后了。</strong></p>
<p>虽然一般来说，两种语言都有更好的替代方法，但是都无法代替HLSL或GLSL。</p>
<p><strong>是因为它们被提供程序阻止，还是因为它们不受支持</strong> 与传统的图形管道。 <strong>这样的示例包括CUDA和OpenCL。</strong> 尽管已尝试在此空间中创建语言，但没有一个在gamedev社区中获得明显的吸引力。</p>
<p><strong>Rust GPU继续根据RLSL项目开发思想</strong>，其中尝试为SPIR-V通用着色器中间件创建Rust编译器，该编译器在Vulkan API中提出，并在OpenGL 4.6中得到支持。在目前的开发阶段，Rust GPU已经允许您运行简单的图形着色器并编译Rust基本标准库的重要部分。 同时，该项目还没有为广泛使用做好准备，例如，着色器尚不支持循环。</p>
<p>基于Rust语言的代码，形成了SPIR-V着色器的表示形式，为此开发了一个Rust编译器的特殊后端，该类后端类似于用来编译成表示形式的Cranelift代码生成器WebAssembly。</p>
<p><strong>当前的方法是支持Vulkan图形API和SPIR-V视图，</strong> 但是计划在未来的DXIL（DirectX）和WGSL（WebGPU）着色器视图中使用生成器。 基于Cargo和crates.io，正在开发工具来开发和发布带有SPIR-V格式的着色器的程序包。</p>
<p><strong>目前还属于非常早期，以平均每周一个小版本迭代，现在发布 0.3 版。主力开发大约六人，社区贡献 35 人。</strong></p>
<h4><a class="header" href="#bevy-国外游戏引擎开源" id="bevy-国外游戏引擎开源">Bevy （国外/游戏引擎/开源）</a></h4>
<p>关键字：游戏引擎/ ECS</p>
<p><strong>介绍</strong></p>
<p>Bevy 是一个基于 Rust 实现的 数据驱动游戏引擎。</p>
<blockquote>
<p>Bevy完整实践了时下比较热门的data-driven开发理念， 也就是ECS模式。相比于其他架构比较老的开源引擎，比如Godot等，Bevy有一整套的从造轮子到游戏开发落地的ECS开发模式。而和商业引擎相比，Bevy的历史包袱也很少，不用像unity的DOTS开发一样还需要兼容传统的GameObject模式。此外，得益于Rust语言强大的表达能力，整个引擎在接口上看起来比用C++造的那些data-driven的轮子要简洁明了的多。 -- <a href="https://zhuanlan.zhihu.com/p/356881497">《安利一个Rust Game Engine：Bevy--ECS部分》</a></p>
</blockquote>
<p>相比于 Rust 实现的其他游戏引擎，比如 Amethyst， Bevy 属于后来着居上。Bevy 在 API 设计方面独具匠心，充分利用 Rust 语言特点，让开发者上手非常简单方便。得力于其 Plugin 机制，目前 Bevy 已经逐渐形成自己的生态，逐步涌现出很多基于 Bevy 的 Plugin 。</p>
<p><strong>代码及团队模式</strong></p>
<p>代码量大约为 65000 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：1 人</li>
<li>社区贡献：244 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>项目启动自 2019 年 11 月 10 号，目前发布 0.5 版本，还处于高速迭代期。Bevy 项目也经历过一次大的重构，重构了底层 ECS 系统。</p>
<h4><a class="header" href="#其他动态" id="其他动态">其他动态</a></h4>
<ul>
<li><a href="https://gamedev.rs/">https://gamedev.rs/</a>  是 Rust 游戏工作组的官方站点，定期发布 Rust 在游戏生态中的动态。</li>
<li><a href="https://github.com/godot-rust/godot-rust">godot-rust</a>，Godot 3.2 引擎的 </li>
</ul>
<h3><a class="header" href="#客户端开发" id="客户端开发">客户端开发</a></h3>
<h4><a class="header" href="#飞书-app-国内商业" id="飞书-app-国内商业">飞书 App （国内/商业）</a></h4>
<p>关键字： lark/ 字节跳动</p>
<p><strong>介绍</strong></p>
<p>字节跳动旗下 飞书（lark）App ，应该属于国内最大的 Rust 开发团队，全职写 Rust 的开发人员大约在 30 ～ 60 人。</p>
<p>飞书在 客户端跨平台组件中使用 Rust ，代码量据说超过 55 万行代码 （包括测试和生成代码）。</p>
<p>其他信息目前不详细。</p>
<p>飞书团队还开源了几个 Rust 项目，可以在其<a href="https://github.com/larksuite?q=&amp;type=&amp;language=rust&amp;sort="> GitHub 仓库</a>中查阅。</p>
<h3><a class="header" href="#区块链数字货币" id="区块链数字货币">区块链/数字货币</a></h3>
<p>区块链/数字货币领域包括，区块链基础设施、数字货币项目等。</p>
<h4><a class="header" href="#diem-国外开源libra-超主权货币" id="diem-国外开源libra-超主权货币">Diem (国外/开源/Libra/ 超主权货币)</a></h4>
<p>关键字：libra/ Facebook</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/diem/diem">Diem</a> 前身是 Libra，其使命是建立一套简单的、无国界的货币和为数十亿人服务的金融基础设施。他们努力打造一个新的去中心化区块链、一种低波动性加密货币和一个智能合约平台的计划，以期为负责任的金融服务创新开创新的机遇。</p>
<p>他们认为，应该让更多人享有获得金融服务和廉价资本的权利，每个人都享有控制自己合法劳动成果的固有权利。他们相信，开放、即时和低成本的全球性货币流动将为世界创造巨大的经济机遇和商业价值，并坚信人们将会越来越信任分散化的管理形式。全球货币和金融基础设施应该作为一种公共产品来设计和管理。所有人都有责任帮助推进金融普惠，支持遵守网络道德规范的用户，并持续维护这个生态系统的完整性。</p>
<p>最新状态：Facebook旗下数字货币项目Diem放弃申请瑞士支付牌照：专注美国市场 （2021年05月13日 ）。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 30 万 行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：5～ 20 人</li>
<li>社区贡献：150 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>平均每月一个小版本，目前主框架 1.2.0 版，sdk 0.0.2 版。</p>
<h4><a class="header" href="#substrate-国外-开源-区块链框架" id="substrate-国外-开源-区块链框架">Substrate （国外/ 开源/ 区块链框架）</a></h4>
<p>关键字： parity/substrate</p>
<p><strong>介绍</strong></p>
<p><a href="https://github.com/paritytech/substrate">Substrate</a> 是Parity Polkadot 旗下的项目。 Polkadot 是基于 Substrate 构建的。</p>
<p>Substrate 框架被称为下一代区块链框架，类似于Java的Spring、Python的Django，只不过后者创建的是网站，前者创建的是区块链。它由Parity团队基于Rust语言开发而成，是一个开箱即用的区块链构造器。基于Substrate创建区块链可以让开发者专注于业务需求，不需从头实现底层的P2P网络和共识逻辑。</p>
<p><strong>代码及团队规模</strong></p>
<p>代码量大约为 35 万行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：4～10人</li>
<li>社区贡献：243 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>Substrate 经过两次大的版本迭代，已发展到了 V3.0 版。目前迭代周期平均每月一个小版本。</p>
<h4><a class="header" href="#nervos-ckb-国内-区块链公链" id="nervos-ckb-国内-区块链公链">Nervos CKB （国内/ 区块链公链）</a></h4>
<p>关键字：nervos/ ckb/ cita</p>
<p><strong>介绍</strong></p>
<p>Nervos Network 是一个开源的公链生态，包含以区块链技术为核心、相互兼容的一组分层协议，来解决区块链可扩展性上的困境。</p>
<p><strong><a href="https://github.com/nervosnetwork/ckb">Nervos CKB</a></strong>（Common Knowledge Base 共同知识库）是一个无需许可的公有区块链，在区块链中，这里提到的共同知识库通常指的是经过全球节点共同验证并确认的状态。 和比特币类似，<strong>Nervos CKB</strong> 是一个状态验证系统。由杭州秘猿科技研发。</p>
<p>秘猿也算国内 Rust 开发人员众多的公司之一，Rust 全职开发大约是 30 + 人。</p>
<p><strong>代码量及团队规模</strong></p>
<p>单 ckb 项目代码量，大约 11 万行 Rust 代码。</p>
<p>团队规模：</p>
<ul>
<li>主力开发：6 ～ 8 人（单ckb项目）</li>
<li>社区贡献：22 人</li>
</ul>
<p><strong>项目周期</strong></p>
<p>开发周期大约每周一个小版本。</p>
<h4><a class="header" href="#其他区块链项目" id="其他区块链项目">其他区块链项目</a></h4>
<ul>
<li><a href="https://github.com/near">Near</a></li>
<li><a href="https://github.com/solana-labs/solana">Solana</a></li>
</ul>
<h3><a class="header" href="#其他-rust-正在革新的领域" id="其他-rust-正在革新的领域">其他 Rust 正在革新的领域</a></h3>
<ul>
<li>
<p>机器人：</p>
<ul>
<li><a href="https://github.com/eclipse-zenoh/zenoh">zenoh</a> ，zenoh 将动态数据、使用中数据、静态数据与计算整合。它巧妙地将传统的发布/订阅与地理上分散的储存、查询和计算融合，同时保有远胜任何主流堆栈的时间和空间效率。zenoh 可作为 ROS2 中间件 DDS 替代品，也可以和 DDS 无缝集成。</li>
</ul>
</li>
<li>
<p>航天航空：</p>
<ul>
<li>新西兰 公司<a href="https://www.rocketlabusa.com/"> Rocket Lab </a>是小型卫星发射领域的全球领导者，和 NASA 、xSpace 都是合作伙伴。团队有500人，而且每周都在增加。目前在使用 Rust 。</li>
<li>非官方 航空航天工作组 <a href="https://github.com/AeroRust">AeroRust</a> 创建了 <a href="http://areweinspaceyet.org/">Are we <strong>in space</strong> yet?</a> 网站，跟踪 Rust 在航空航天领域的开源项目。</li>
</ul>
</li>
<li>
<p>汽车/自动驾驶：</p>
<ul>
<li><a href="https://github.com/erdos-project/erdos">erdos</a>，用于构建自动驾驶汽车和机器人应用的数据流系统。</li>
</ul>
</li>
<li>
<p>编程语言：</p>
<ul>
<li><a href="https://github.com/rust-lang/rust">Rust</a>，Rust 语言早已实现了自举，算得上是世界上最大的 Rust 项目之一了。其代码量大约 179 万行 Rust 代码。</li>
<li><a href="https://github.com/alilleybrinker/langs-in-rust">langs-in-rust</a> 这个网站罗列了 几十种 用 Rust 实现的新编程语言。其中也不乏优秀之作。比如 <a href="https://github.com/gleam-lang/gleam">Gleam</a> / <a href="https://github.com/pistondevelopers/dyon">Dyon</a> / <a href="https://github.com/koto-lang/koto">Koto</a></li>
<li><a href="https://github.com/denoland/deno">deno</a>，严格来说，deno 不算语言，只是 typescript/javascript 运行时。但是它的 Rust 成分占了 58.5%。比较有意思的是，作者最早使用 Cpp/ Golang 来实现 deno，最终都已换成了 Rust 。</li>
</ul>
</li>
<li>
<p>艺术：</p>
<ul>
<li><a href="https://nannou.cc/">nannou</a>，旨在让艺术家创作自己的艺术。在德国 <a href="https://mindbuffer.net/">mindbuffer</a> 公司就是基于 nannou 和 koto 来创建实体艺术项目：使用486步进电机，86,000个LED和5通道颗粒式合成引擎，<a href="https://t.me/rust_daily_news/4863">创建可以变换形状绚丽多彩的电子艺术品</a>。</li>
</ul>
</li>
<li>
<p>VR 领域：</p>
<ul>
<li><a href="https://github.com/makepad/makepad">makepad</a>，是一个 VR，Web和本机渲染UI框架 和 IDE，基于 Rust 和 WebAssembly （WebGL） 技术。 作者是 Cloud9 IDE 的创始人。该项目也包含<a href="https://github.com/makepad/makepad_docs">白皮书</a>，阐述了它的愿景。</li>
</ul>
</li>
<li>
<p>安全领域：</p>
<ul>
<li>
<p><strong><a href="https://github.com/rustscan/rustscan">rustscan</a></strong>，是一个现代化高性能的端口扫描器，并且提供脚本引擎来支持运行 Python，Lua，Shell。支持 自适应学习（Adaptive learning）。用的越多，RustScan 越智能，不是基于臃肿的机器学习，主要是基于基本数学。</p>
</li>
<li>
<p><strong><a href="https://github.com/epi052/feroxbuster">feroxbuster</a></strong>，一款高性能的内容发现工具，用于渗透测试。feroxbuster 使用蛮力结合单词列表在目标目录中搜索未链接的内容，这是一种攻击行为。这些资源可能存储有关 Web 应用程序和操作系统的敏感信息，例如源代码，凭据，内部网络寻址等。此攻击也称为可预测资源位置，文件枚举，目录枚举和资源枚举。</p>
</li>
<li>
<p><strong><a href="https://github.com/zero-gear/rusty-tor">rusty-tor</a></strong>，一个概念验证的 Tor 客户端。不过有两年没有维护了。</p>
</li>
<li>
<p><a href="https://github.com/enarx">Enarx</a>，这是一个组织，由红帽公司牵头其他知名企业来做可信执行环境的应用部署系统。</p>
</li>
<li>
<p><a href="https://github.com/kpcyrd/sn0int">sn0int</a>， 半自动高级公开资源情报（OSINT）框架和程序包管理器，用于扫描目标IP地址、电子邮件、网站和组织信息，并从不同消息源收集各种情报信息。</p>
</li>
<li>
<p><a href="https://github.com/kpcyrd/sniffglue">sniffglue</a>，多线程网络嗅探器。Kpcyrd 经常使用tcpdump，但他认为输出更友好的话会更好，并且 wireshark 也经常存在漏洞，tcpdump 有时也有漏洞，所以他用 Rust 实现了这个工具。</p>
</li>
<li>
<p><a href="https://github.com/kpcyrd/badtouch">badtouch</a>， 可编写脚本的网络身份验证破解程序。</p>
</li>
<li>
<p><a href="https://github.com/kpcyrd/rshijack">rshijack</a>，用 Rust 重写了 shijack，实现 TCP 会话劫持。</p>
</li>
<li>
<p><a href="https://github.com/rust-fuzz/cargo-fuzz">Cargo Fuzz</a>，Rust 官方开发的 Fuzz 工具。</p>
</li>
<li>
<p><a href="https://github.com/rust-fuzz/honggfuzz-rs">honggfuzz-rs</a>，Google 开发的 Fuzz 工具。</p>
</li>
<li>
<p><a href="https://github.com/phayes/sidefuzz">Sidefuzz</a>， 侧信道漏洞检测工具。</p>
</li>
<li>
<p><a href="https://github.com/RustSec/advisory-db/">RustSec/advisory-db</a>，通过<a href="https://github.com/RustMagazine/rust_magazine_2021/blob/main/src/chapter_5/crates.io">crates.io</a>发布的Rust Crate 的安全咨询数据库。</p>
</li>
<li>
<p><a href="https://github.com/RustSec/cargo-audit">cargo-audit</a>，<code>Cargo.lock</code>中依赖审查工具。</p>
</li>
<li>
<p><a href="https://github.com/crev-dev/cargo-crev">cargo-crev</a>，代码 Review 工具。</p>
</li>
<li>
<p><a href="https://github.com/cortex/ripasso/">ripasso</a>，一款密码管理工具。</p>
</li>
<li>
<p><a href="https://github.com/arvancloud/libinjection-rs">libinjection-rs</a>， 对 libinjection 的 Rust 绑定，libinjection 是一款 SQL 注入工具。</p>
</li>
<li>
<p><a href="https://github.com/kostassoid/lethe">lethe</a>，安全，免费，跨平台和开源的驱动擦除工具。</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#盘点在生产环境使用-rust-的公司" id="盘点在生产环境使用-rust-的公司">盘点在生产环境使用 Rust 的公司</a></h2>
<h3><a class="header" href="#国内-1" id="国内-1">国内</a></h3>
<h4><a class="header" href="#华为" id="华为">华为</a></h4>
<blockquote>
<p>可信编程的愿景之旅，才刚刚开始。我们希望与 Rust 社区，以及即将成立的 Rust 基金会合作，为电信软件行业带来一场平稳的革命。</p>
</blockquote>
<p>华为于 2021 年加入 Rust 基金会，旨在为 Rust 在全球推广和发展做贡献。目前在一些开源项目和内部试点项目使用了 Rust ，以及为 Rust 生态做了一些贡献。目前正在为大规模使用 Rust 做准备。</p>
<p>华为也是 Rust Conf China 2020 战略级赞助商。</p>
<h4><a class="header" href="#pingcap-及其-客户" id="pingcap-及其-客户">PingCAP 及其 客户</a></h4>
<p>PingCAP 公司创造的 分布式数据库 TiDB，底层TiKV分布式存储是基于 Rust 实现的。</p>
<p><a href="https://pingcap.com/cases-cn/">TiDB 现已被 <strong>1500</strong> 多家不同行业的领先企业应用在实际生产环境</a>。客户包括：中国移动/ 中通快递/ 伴鱼/ 知乎/ 网易游戏/ 美团/ 京东云/ 360云/ 今日头条 等等公司。</p>
<p>PingCAP 也是 Rust Conf China 2020 银牌赞助商。</p>
<h4><a class="header" href="#阿里蚂蚁集团" id="阿里蚂蚁集团">阿里/蚂蚁集团</a></h4>
<p>阿里云/ 钉钉团队，以及蚂蚁集团 机密计算 和 数据库团队，都在使用 Rust 。</p>
<h4><a class="header" href="#字节跳动" id="字节跳动">字节跳动</a></h4>
<p>字节跳动 飞书团队 使用 Rust 进行跨平台客户端组件开发。</p>
<p>字节跳动/飞书 也是 Rust Conf China 2020 钻石赞助商。</p>
<h4><a class="header" href="#知乎" id="知乎">知乎</a></h4>
<p>知乎搜索引擎团队在使用 Rust 。</p>
<h4><a class="header" href="#收钱吧" id="收钱吧">收钱吧</a></h4>
<p>上海收钱吧团队在生产环境使用 Rust 做消息队列服务。</p>
<h4><a class="header" href="#吉利集团" id="吉利集团">吉利集团</a></h4>
<p>吉利集团数字科技板块在使用 Rust 构建区块链。</p>
<h4><a class="header" href="#上海息未信息科技" id="上海息未信息科技">上海息未信息科技</a></h4>
<p>上海息未信息科技有限公司专注于航天及航空训练装备的研发生产，是由国内顶级基金投资的科技企业，主要服务于中国航天、军队以及航空公司。其公司部分产品使用 Rust 。</p>
<h4><a class="header" href="#杭州秘猿科技" id="杭州秘猿科技">杭州秘猿科技</a></h4>
<p>CBK 公链项目就是该公司产品。还有其兄弟公司 溪塔 也是 Rust 生产级用户。</p>
<p>秘猿和溪塔同是 Rust China Conf 2020 金牌赞助商。</p>
<h4><a class="header" href="#国内其他区块链公司" id="国内其他区块链公司">国内其他区块链公司</a></h4>
<p><strong>Bitfrost</strong> </p>
<p>Bitfrost 也是区块链项目，为 Staking 提供流动性的跨链网络。Rust China Conf 2020 银牌赞助商。</p>
<p><strong>达尔文网络</strong></p>
<p>达尔文网络是基于Substrate开发的去中心化桥接网络，也是区块链行业。Rust China Conf 2020 银牌赞助商。</p>
<p><strong>还有很多其他区块链公司，都在使用 Rust ，这里就不一一罗列了。</strong></p>
<h4><a class="header" href="#豆瓣" id="豆瓣">豆瓣</a></h4>
<p>豆瓣使用了 Rust 开源库 Vector ，应该属于被动使用 Rust 。其他团队是否在其他项目使用 Rust 犹未可知。</p>
<h3><a class="header" href="#国外-1" id="国外-1">国外</a></h3>
<h4><a class="header" href="#google" id="google">Google</a></h4>
<p>Google Fuchsia OS 内 Rust 使用量大约为 137 万行 Rust 代码，算的上是 Rust 生态圈内除 Rust  之外第二大 Rust 项目了。</p>
<p>并且 Google 极力支持 Rust for Linux 项目，还出资金赞助了核心开发。</p>
<p>Google 也是 Rust 基金会成员之一。</p>
<blockquote>
<p><strong><a href="https://security.googleblog.com/2021/04/rust-in-android-platform.html">Android</a></strong>：<em>“在过去的 18 个月里，我们一直在为 Android 开源项目添加对 Rust 的支持。我们有几个早期采用 Rust 开发的项目，我们将在未来几个月内分享。将 Rust 扩展到更多操作系统，是我们的一个多年项目。”</em></p>
</blockquote>
<h4><a class="header" href="#微软" id="微软">微软</a></h4>
<p>Rust 基金会成员之一。目前 Windwos 已经全面支持 Rust 开发。</p>
<blockquote>
<p>有没有注意到 VS Code 的搜索速度有多快？原因是 VS Code 正在使用 <a href="https://github.com/BurntSushi/ripgrep"><code>ripgrep</code></a> 来<a href="https://code.visualstudio.com/updates/v1_11#_text-search-improvements">增强它的搜索能力</a>  。</p>
</blockquote>
<h4><a class="header" href="#aws" id="aws">AWS</a></h4>
<p>Rust 基金会成员之一。AWS 应该是最早支持 Rust 社区的公司了，连续几年赞助 Rust Conf。</p>
<blockquote>
<p>在 AWS，我们喜欢 Rust，因为它帮助 AWS 编写高性能、安全的基础设施级网络和其他系统软件。我们使用 Rust 提供的服务产品有很多，比如 Amazon 简单存储服务（Amazon S3）、Amazon 弹性计算云（Amazon EC2）、Amazon CloudFront、Amazon Route 53 等等。最近我们推出了 Bottlerocket，这是一个基于 Linux 的容器操作系统，也是用 Rust 开发的。</p>
</blockquote>
<h4><a class="header" href="#facebook" id="facebook">Facebook</a></h4>
<p>Rust 基金会成员之一。 Facebook 内部 Rust 项目综合起来代码已超 百万行。著名的项目是 Diem 及其 MOVE 语言。</p>
<p>Facebook 目前也拥有一个团队，专门为 Rust 编译器和库做贡献。</p>
<h4><a class="header" href="#mozilla" id="mozilla">Mozilla</a></h4>
<p>Rust 语言的诞生之地。Servo 浏览器内核项目使用 Rust 开发，代码量大约为 30万 行 。</p>
<h4><a class="header" href="#apple" id="apple">Apple</a></h4>
<p>苹果在招聘公告中写到：“我们构建的系统的性能和安全性至关重要。目前使用异步 I/O 和线程来分配工作负载，直接与底层 Linux 内核接口进行交互。首次成功使用 Rust 之后，我们正在将已建立的代码库从 C 迁移到 Rust，并计划未来主要使用 Rust 构建新功能。”</p>
<p>苹果目前没有加入 Rust 基金会。</p>
<h4><a class="header" href="#1password" id="1password">1Password</a></h4>
<blockquote>
<p>我们在 1Password 的生产环境中，使用 Rust 已有几年了。我们的 Windows 团队是这项工作的领跑者，Windows 中所用的 1Password 7，大约 70% 都是用 Rust 开发的。在 2019 年底，我们还将 1Password Brain（驱动浏览器填充逻辑的引擎）从 Go 移植到了 Rust。这样，我们就可以在浏览器扩展中，发挥将 Rust 程序部署到 WebAssembly 应用的性能优势。</p>
</blockquote>
<h4><a class="header" href="#cloudflare" id="cloudflare">Cloudflare</a></h4>
<blockquote>
<p>随着我们 Rust 开发经验的增长，Rust 语言在另外两个方面显示出了优势：作为一种具有强大内存安全性语言，它是边缘计算的一个绝好选择；作为一种具有极大热情的语言，它成为一种流行于组件重新开发（de novo）的语言。</p>
</blockquote>
<h4><a class="header" href="#discord" id="discord">Discord</a></h4>
<blockquote>
<p>当开始一个新的项目或组件时，我们首先考虑使用 Rust。当然，我们只在适合的地方使用。除了性能之外，Rust 对工程团队也有很多优势。例如，它的类型安全性和借用/引用检查器，使重构代码变得非常容易。此外，Rust 的生态系统和工具都非常出色，背后有着巨大的动力。</p>
</blockquote>
<h4><a class="header" href="#ibm" id="ibm">IBM</a></h4>
<blockquote>
<p>IBM 的一个团队使用 WebAssembly 和 Rust，实现了难以置信的性能改进。</p>
</blockquote>
<h4><a class="header" href="#dropbox" id="dropbox">Dropbox</a></h4>
<blockquote>
<p>我们用 Rust 开发了 <code>Nucleus</code>！Rust 帮助我们团队力量倍增，选择 Rust 是我们做出的最好决定之一。Rust 的人机工程学和正确原则，不仅有助于我们驯服 <code>sync</code> 的复杂性。而且，我们可以在类型系统中，对系统进行复杂的不变量编码，并让编译器为我们检查它们。</p>
</blockquote>
<h4><a class="header" href="#npm" id="npm">npm</a></h4>
<blockquote>
<p>npm 的第一个 Rust 程序，在一年半的生产环境中，没有发生任何警报。‘我对 Rust 最大的赞美，是它很无聊’，Dickinson说，‘这是一个令人惊奇的赞美’。部署新的 Rust 服务的过程是直接的，很快，他们就能够忘记这项 Rust 服务，因为它只引起很少的操作问题。</p>
</blockquote>
<h4><a class="header" href="#onesignal" id="onesignal">OneSignal</a></h4>
<blockquote>
<p>就在这个月，我们突破了每天发送 70亿 条通知的门槛，并创下了每秒 175 万条的记录。</p>
</blockquote>
<h4><a class="header" href="#qovery" id="qovery">Qovery</a></h4>
<blockquote>
<p>随着公司意识到云计算的好处，Rust 的势头就越来越强劲。Dropbox 使用 Rust 重写了它的一些核心系统，而 Mozilla 使用 Rust 构建了 Firefox 浏览器引擎，展示了 Rust 强大的优势。在 Qovery，我们相信 Rust 能够云构建的未来。</p>
</blockquote>
<h4><a class="header" href="#astropad" id="astropad">Astropad</a></h4>
<blockquote>
<p>有了 Rust，我们将拥有一个高性能、可移植的平台，可以轻松地在 Mac、iOS、Linux、Android，以及 Windows 上运行。这不仅极大地扩大了我们潜在的市场规模，而且还看到了我们的 <code>LIQUID</code> 技术的许多有趣的新用途。我们有信心用以强大的代码、更好的产品和对 Astropad 未来的乐观展望，以完成我们的 Rust 之旅。</p>
</blockquote>
<h4><a class="header" href="#coursera" id="coursera">Coursera</a></h4>
<blockquote>
<p>我们在增强的 Docker 容器中，高效、可靠、安全地为提交的作业评分。虽然我们将集群调度到 Amazon EC2 容器服务（ECS）上，但许多程序之间协同工作，是用 Rust 开发的。</p>
</blockquote>
<h4><a class="header" href="#三星" id="三星">三星</a></h4>
<blockquote>
<p><em>我们想向 Rust 语言的 5 个核心团队、Mozilla，以及 Rust 语言生态系统中众多软件包的贡献者们公开道谢：我们正在利用 Rust 开发新的更新客户端和服务器，以及其他一些软件的主干，并希望随着时间的推移，继续扩大我们对该语言的使用。”</em></p>
</blockquote>
<h4><a class="header" href="#system76" id="system76">System76</a></h4>
<blockquote>
<p>像我们今天的所有项目一样，它是用 Rust 编写的，并且遵循当前的最佳实践。该项目被配置为一个工作区，核心 crate 提供了一个通用库，用于从多个固件服务中发现和管理固件。支持 <code>fwupd</code> 和 <code>system76-firmware</code>。</p>
</blockquote>
<h4><a class="header" href="#clever-cloud" id="clever-cloud">Clever Cloud</a></h4>
<blockquote>
<p>对我们来说，这些好处有力地证明了 Rust 是生产平台的可靠构建块。这是一段我们不必担心的代码，它将使其它服务能够安全地运行。</p>
</blockquote>
<h4><a class="header" href="#rapid7" id="rapid7">Rapid7</a></h4>
<blockquote>
<p>我们在 Rust 部署中，看到的主要加速点是，不同平台上的部署工具，能够很容易地适应该语言。代理开发人员，能够很快地学习该语言，并开发与托管运行时的集成。</p>
</blockquote>
<h4><a class="header" href="#figma" id="figma">Figma</a></h4>
<blockquote>
<p>虽然我们有一些挫折，但我想强调的是，我们在 Rust 方面的经验，总体上是非常积极的。这是一个非常有前途的项目，我们拥有坚实的核心和健康的社区。</p>
</blockquote>
<h4><a class="header" href="#flyio" id="flyio">Fly.io</a></h4>
<blockquote>
<p>我们基础设施中的每台服务器，都在运行一个名为 fly-proxy 的基于信任的代理。此代理负责接受客户端连接、将其与客户应用程序匹配、应用处理程序（例如：TLS终止）以及服务器之间的回程处理。</p>
</blockquote>
<h4><a class="header" href="#everlane" id="everlane">Everlane</a></h4>
<blockquote>
<p>Rust 给予我们锻造性。这项服务已经在生产环境运行 4 个月了，它平均每秒处理 40 个请求，响应时间为 10ms。它的内存使用量很少超过 100MB。</p>
</blockquote>
<p><strong>还有很多公司，可以在 Rust 官网里看到介绍 ：<a href="https://www.rust-lang.org/production/users">Rust Production users</a></strong></p>
<h2><a class="header" href="#作者介绍-2" id="作者介绍-2">作者介绍</a></h2>
<p>张汉东，《Rust 编程之道》作者，独立企业咨询顾问，开源爱好者。喜欢读书、写作、分享，欢迎交流。</p>
<h1><a class="header" href="#华为--webassembly-安全性调研" id="华为--webassembly-安全性调研">华为 | WebAssembly 安全性调研</a></h1>
<p>作者：华为可信软件工程和开源2012实验室</p>
<hr />
<p>2015年4月，W3C成立WebAssembly工作组，用于监督与规范WebAssembly提案，倡导浏览器厂商使用一致性的规范。WebAssembly 技术虽脱胎于浏览器，但截至到2021年的今天，早已经走出浏览器，大有让计算无处不在的趋势。</p>
<p>WebAssembly 天生具备安全、可移植、高效率，轻量化等特点，所以非常适于应用安全沙箱场景。除了浏览器领域，WebAssembly 还得到了容器、函数计算、IoT / 边缘计算等社区的广泛关注。WebAssembly 沙箱甚至可以安全地在与其他代码相同的进程中运行，这与软件故障隔离(SFI)非常相似。</p>
<p>本文将从 WebAssembly 的特性、安全、性能、应用领域四个方面探讨其应用价值。</p>
<h2><a class="header" href="#webassembly-特性" id="webassembly-特性">WebAssembly 特性</a></h2>
<p>WebAssembly（或wasm）是一种适用于Web的可移植编译格式，提供更小的文件尺寸和更快的加载速度。WebAssembly旨在成为高级语言的编译目标。目前可以使用C、C++、Rust、Go、Java、C#编译器（还有更多）来创建wasm模块。</p>
<h3><a class="header" href="#webassembly-当前状态" id="webassembly-当前状态">WebAssembly 当前状态</a></h3>
<p>截止 2021 年的今天，WebAssembly 的阶段目标还没有完全实现。从 <a href="https://webassembly.org/roadmap/">WebAssembly 官方 Roadmap</a> 可以了解到当前状态。</p>
<p><img src="chapter_6/./image/wasm-security/wasm-roadmap.png" alt="1" /></p>
<p>看得出来，三大主流浏览器，以及浏览器之外的主流 wasm 运行时基本都已支持 WebAssembly的一半特性 。对于异常处理，模块链接（Module Linking），尾调用，线程，接口类型（Interface Types）等还未得到完整支持。</p>
<p>2021 年，模块链接和接口类型有望得到支持。</p>
<p>模块链接提案旨在运行时声明标准中链接两个或更多个模块，而不是靠开发人员手动编写代码将一个模块导出给另一个模块，这很耗时且容易出错。如果其中一个模块被修改，则Webassembly 引擎可以处理将它们连接在一起，也可能会优化它们。</p>
<p>接口类型提议将有助于在模块（guest）或主机（host）之间进行通信。 这是因为WebAssembly 模块本地支持四个数据类型（32位整数，64位整数，32位浮点和64位浮点）。 为了让不同语言编写的 WebAssembly 模块相互通信，接口类型提供某种类似接口的映射方式，可以正确映射要通信的类型，这样就可以使用更富表达力的高级类型来相同通信了。</p>
<p>为 WebAssembly 在 Server Side 提供 Runtime 的 wasmtime 和 wasmer ，目前基本都已经进入 GA 状态。</p>
<h3><a class="header" href="#webassembly-内存模型" id="webassembly-内存模型">WebAssembly 内存模型</a></h3>
<p>WebAssembly 只提供一个沙盒化的线性内存，并不提供托管内存（堆）和 垃圾回收器。</p>
<p>线性内存是一个连续的、字节可寻址的内存范围，从偏移量 0 一直延伸到不同的内存大小。此大小始终是 WebAssembly 页面大小的倍数，固定为 64KiB。每个 WebAssembly 实例都有一个专门指定的默认线性内存。</p>
<p>线性内存有以下特点：</p>
<ul>
<li>线性内存中的所有数据始终是可写的，不存在只读内存。</li>
<li>线性内存始终为零初始化。</li>
<li>线性内存每个指针都是有效的。</li>
<li>线性内存是确定性排列的，即栈位置可以从编译器和程序中预测。</li>
<li>线性内存可以请求 VM 使用 memory.growin 指令增加线性内存。</li>
</ul>
<p><strong>数据管理</strong></p>
<ul>
<li>非托管数据：指在线性内存中驻留的数据。不受 vm 保护，完全受程序内存写入指令的控制。</li>
<li>托管数据：即局部变量、全局变量、栈上的执行的值和返回地址，都驻留在由 VM 直接处理的专用存储中。WebAssembly 代码只能通过指令隐式地与托管数据进行交互，而不能直接修改其底层存储。并且托管数据没有地址。</li>
</ul>
<p>由于WebAssembly 只有四种基本类型，所以托管数据只能保留这四种基本类型实例。而其他的诸如字符串、数组、列表等非标量（复合）类型数据都必须存储在线性内存。</p>
<p>因为托管数据中没有地址，所以在源程序中取过地址的任何变量也必须存储在线性内存中。</p>
<p><strong>内存布局</strong></p>
<p>因为 源代码中有很多作为函数作用域、全局或动态生命周期的数据，所以编译器会在线性内存中创建分别用于调用栈、堆（动态分配内存）和静态数据的区域。</p>
<p>所以分为：</p>
<ul>
<li>非托管栈：编译器在线性内存上创建的调用栈。</li>
<li>托管evaluation栈：用于保存指令的中间值，由 VM 管理。</li>
<li>托管 调用栈：保存局部变量和返回地址等，由 VM 管理。</li>
</ul>
<p>相比 elf 二进制文件，<code>.data</code>、<code>.rodata</code> 和 <code>.bss</code> 在 WebAssembly 中没有明确区分，因为 线性内存 并没有只读区域，并且始终零初始化。</p>
<p><img src="chapter_6/./image/wasm-security/memory-layout.png" alt="2" /></p>
<p>不同的编译器会产生不同的内存布局。上图展示了 Emscripten 的 fastcomp backend 和 upstream backend，以及 clang 和 rustc 编译出的 Wasm 二进制文件内存布局。其中 clang和rustc 的内存布局相似：静态数据在栈和堆之间。</p>
<h3><a class="header" href="#导入导出" id="导入导出">导入导出</a></h3>
<p>Wasm 模块可以提供 Host 可以读取以便与 Wasm 模块链接的符号信息，包括：导出（Export）/ 导入（Import）/ 入口点（Entry Point）。</p>
<p>导出符号是指 Host 可以访问的 wasm 模块组件，包括：</p>
<ul>
<li>函数</li>
<li>全局变量</li>
<li>内存</li>
<li>表（table）</li>
</ul>
<p>Wasm 模块导出函数是类型安全的。函数导出信息由目标函数的函数签名组成。因此，宿主环境可以在函数调用之前验证函数参数。它消除了无效的参数传递，从而提高了整体程序的安全性。</p>
<p>Wasm 模块还可以导出全局变量和内存。它可以在不调用Wasm函数的情况下实现主机和Wasm模块之间的信息交换。全局变量导出也是类型安全的，但它只提供了Wasm 基本类型。</p>
<p>对于较大的数据，内存导出是更好的选择，因为它允许在 Wasm 模块和主机之间有效传输原始数据。然而，内存导出是无类型和非结构化的。宿主代码在通过内存导出操作数据时需要慎重考虑。</p>
<p>同样，导入是指从Host环境或其他模块的函数/  内存/ 表。但必须在 Host 实例化 wasm 模块之前提过所需的元素，Host 环境要确保Host 代码提供所有必须的元素，包括正确的内存分配、表分配和函数。模块实例化过程类似于编译中的链接过程，其中代码在执行之前链接到所有必需的符号。</p>
<h3><a class="header" href="#控制流安全" id="控制流安全">控制流安全</a></h3>
<p>WebAssembly 不允许跳转到任意指令点。</p>
<p>wasm 模块中 指令 被分组为 块（block），分为三类块：</p>
<ul>
<li>常规块</li>
<li>条件块</li>
<li>循环块 </li>
</ul>
<p>一个块以block关键字开始，以end指令结束。end指令是一个伪指令，标志着块的结束。块内不能访问块外中的操作数。程序需要通过一个局部变量填充该值，以在块内传输该值。Wasm会根据块的结果类型来验证栈状态。</p>
<p>Wasm有三种类型的分支：</p>
<ul>
<li>无条件分支（br），总是被执行的，不考虑外部状态。</li>
<li>有条件分支（br_if），从栈中消耗一个操作数来确定是否需要进行分支。</li>
<li>表分支（br_table），需要一个整数操作数作为索引来选择目标块，分支指令对每个块类型的行为都不同。</li>
</ul>
<h3><a class="header" href="#wasm-表" id="wasm-表">Wasm 表</a></h3>
<p>Wasm 表用于交换 引用信息。</p>
<p><img src="chapter_6/./image/wasm-security/wasm-table.png" alt="3" /></p>
<p>Wasm 表存储对一个函数的引用，Wasm 程序可以使用该函数来执行动态或间接调用。通常，编译器会根据需要填充该表。 编译器使用函数指针检测动态函数调用是否需要表。 </p>
<p>另一种情况，例如使用函数指针作为返回值，也需要一个表。 编译器静态填充表并使用表索引作为指令的引用。 </p>
<p>目前，Wasm 不允许在 Wasm 程序中操作表。</p>
<h2><a class="header" href="#webassembly-安全性" id="webassembly-安全性">WebAssembly 安全性</a></h2>
<p>WebAssembly 生态安全性可以从两个维度看待：</p>
<ul>
<li>Host 安全性 ，在运行时环境能有效保护主机系统免受恶意 WebAssembly 代码的侵害。</li>
<li>Wasm二进制安全性，内置故障隔离机制防止利用其他良性 WebAssembly 代码作恶。</li>
</ul>
<h3><a class="header" href="#host-安全性分析" id="host-安全性分析">Host 安全性分析</a></h3>
<p>WASM虚拟机提供的的<a href="https://webassembly.org/docs/security/">沙箱和内存隔离机制</a>，可以有效减少安全攻击面。而当WebAssembly走出浏览器，面向更加通用的场景。WASM也面对更加复杂的安全挑战。</p>
<p>WASI 提供了<a href="https://en.wikipedia.org/wiki/Capability-based_security">基于能力的安全模型</a>。WASI应用遵循最小权限原则，应用只能访问其执行所需的确切资源。传统上，如果应用需要打开文件，它会带路径名字符串调用系统操作open。然后系统调用会检查应用是否具有访问该文件的相关权限，比如Linux实现了基于用户/组的权限模型。这样隐式的安全模型，依赖于正确的安全管理配置，比如一旦特权用户执行了一个恶意应用，它就可以访问系统中任意的资源。而对于WASI应用而言，如果它需要需要访问指定文件等系统资源，需要从外部显式传入加有权限的文件描述符引用，而不能访问任何其他未授权资源。这中依赖注入的方式可以避免传统安全模型的潜在风险。</p>
<p>WASI的安全模型与传统操作系统安全模型非常不同，而且还在持续演进中。比如字节码联盟提出了 <a href="https://hacks.mozilla.org/2019/11/announcing-the-bytecode-alliance/">nanoprocess</a> 来解决应用模块间的安全协同和信任传递。</p>
<p>WebAssembly/WASI的安全模型依然存在不足，比如：</p>
<ul>
<li>资源隔离： 
<ul>
<li>对于内存资源，WebAssembly实现了线性内存模型。WebAssembly应用只能利用索引访问传入的一段逻辑线性内存。而WASM虚拟机负责确定内存的实际物理地址，WASM应用无法获知内存的真实地址，也无法通过越界访问等方式发动攻击。所以理论上，可以对WASM应用进行资源容量限制。但是目前部分WASM虚拟机还无法对内存进行精确的隔离限制。</li>
<li>对于CPU资源，部分的WASM虚拟机实现可以对应用使用的CPU资源进行计量，但是大多无法实现精确的配额限制、优先级和抢占式调度。</li>
<li>I/O资源，比如IOPS等，WASM目前完全没有相关的隔离能力。</li>
</ul>
</li>
<li>网络安全： 
<ul>
<li>WASI的Capability模型对于文件系统访问相对比较容易保护。但是这个静态的安全模型无法适用于动态的网络应用场景。在微服务架构中，应用经常通过Service Registry进行服务发现，为服务的调用者和提供者实现动态的调用绑定。这个语义是无法用静态的capability模型描述和注入的。这也导致了WASI的网络部分API还处于讨论之中。现有的<a href="https://github.com/bytecodealliance/wasmtime/blob/master/docs/WASI-capabilities.md#berkeley-socket-rules">WASI网络安全模型</a>，以及相关<a href="https://github.com/bytecodealliance/wasmtime/issues/70">讨论</a>，</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#wasm-二进制安全性分析" id="wasm-二进制安全性分析">Wasm 二进制安全性分析</a></h3>
<p>论文 <a href="https://www.usenix.org/conference/usenixsecurity20/presentation/lehmann">《Everything Old is New Again:Binary Security of WebAssembly》</a> 专门研究了这个问题。</p>
<p>该论文针对 WebAssembly 当前特性，构建出了一组攻击原语。</p>
<p><img src="chapter_6/./image/wasm-security/attack.png" alt="4" /></p>
<p>如上图，可以通过构造上面三步攻击原语来进行攻击。</p>
<ol>
<li>获得写原语。</li>
<li>覆盖栈上或堆上的安全相关数据。</li>
<li>通过 控制流分发 或 操作宿主（Host ）环境来触发恶意行为。</li>
</ol>
<p>第一步，获得写原语。因为 WebAssembly 没有本地程序常见的 Fortify_source （用来编译时缓冲区检查）和 stack canary（栈溢出保护）安全机制，所以在 非托管栈上更容易受到利用。</p>
<p>有三种手段可以获得写原语：</p>
<ol>
<li>栈缓冲区溢出。因为线性内存是非 VM 托管的，所以缓冲区溢出可能覆盖其他函数调用里的局部变量。</li>
<li>栈溢出。假如给函数传一个能引起无限递归的特定数据可以引发栈溢出。栈溢出在 WebAssembly 并不会发生段错误，而是会覆盖栈区之外的敏感数据，比如 堆上的数据。</li>
<li>破坏堆元数据。通过内存分配器的缺陷，破坏 WebAssembly 二进制文件附带的内存分配器的堆上元数据。</li>
</ol>
<p>并非只有这三种方法可以获得写原语，还有一些其他传统的攻击方法可以用来利用，比如格式化字符串、UAF(use after free)等。</p>
<p>第二步，在获得写原语之后，就可以覆盖安全数据了。</p>
<p>能被覆盖的数据包括：</p>
<ul>
<li>线性内存中非托管栈包含的函数范围内的数据，比如函数表索引的函数指针或安全关键函数的参数。虽然缓冲溢出无法控制函数的执行路径，但是有能力可以覆盖掉当前溢出能到达的所有活动的调用栈帧。</li>
<li>堆数据。堆通常包含具有更长生命周期的数据，并将存储跨不同功能的复杂数据结构。并且由编译器在线性内存上分配的堆区域没有任何保护机制，缓冲区溢出或栈溢出可能会破坏堆数据。</li>
<li>常量数据。任意写入原语可以更改程序中任何非标量常量的值，包括例如所有字符串文字。从而破坏编程语言所预期的保证。</li>
</ul>
<p>甚至有的 wasm 运行时的实现还无法正确分离栈和堆，更加重了安全风险。</p>
<p>第三步，触发恶意行为。</p>
<ul>
<li>重定向间接调用。攻击者可以通过覆盖线性内存中的整数来重定向间接调用。这个整数值可能是非托管堆栈上的局部变量、堆对象的一部分、vtable 中，甚至是一个所谓的常量值。受限于 WebAssembly 间接调用的机制，攻击者只能在相同类型的函数的等价类内重定向调用。</li>
<li>代码注入宿主环境。例如，假设 WebAssembly 通常使用存储在线性内存中的“常量”代码字符串调用 eval，然后攻击者可以用恶意代码覆盖该常量。</li>
<li>特定于应用程序的数据覆盖取决于应用程序，可能会有其他敏感的数据覆盖目标。例如，一个 WebAssembly 模块通过一个导入的函数发出 Web 请求，可以通过覆盖目标字符串来联系不同的Host，以启动 cookie 窃取。</li>
</ul>
<p>总的来说，这些都是基于 WebAssembly 线性内存的天生的特性而构造的攻击方式。并且经过实验证明是可行的。</p>
<p>所以，应该使用安全的编程语言，比如 Rust ，来编写 WebAssembly 模块会更加安全。另外还需要独立的 wasm 模块验证装置，以确保每个 wasm 模块是符合规范的。</p>
<h3><a class="header" href="#利用-cpu-漏洞可绕过-wasm-沙箱隔离" id="利用-cpu-漏洞可绕过-wasm-沙箱隔离">利用 CPU 漏洞可绕过 WASM 沙箱隔离</a></h3>
<p>论文 <a href="https://cseweb.ucsd.edu/%7Edstefan/pubs/narayan:2021:swivel.pdf">《Swivel: Hardening WebAssembly against Spectre》</a>中介绍了 利用 CPU 漏洞幽灵攻击（spectre attacks ），可以绕过 WASM 沙箱隔离。</p>
<p>幽灵攻击利用CPU 分支预测器来诱导错误预测，从而导致错误执行指令。 有三种攻击分类：</p>
<ul>
<li>利用模式历史表（PHT）攻击。攻击者 污染 PHT 中的条目，从而将分支错误预测到错误的路径。 然后攻击者可以使用这种错误路径执行来绕过内存隔离保护或控制流完整性。</li>
<li>利用分支目标缓冲区（BTB）攻击。攻击者污染 BTB 中的条目，将推测控制流重定向到任意目标。</li>
<li>利用返回堆栈缓冲区（RSB）攻击。攻击者使用调用或保留指令链使 RSB 上溢或下溢，并依次重定向推测控制流。</li>
</ul>
<p>可以在 FaaS 平台上传任意恶意 wasm 模块，利用 幽灵漏洞 来绕过 wasm 沙箱隔离。</p>
<p>攻击类型也可以分为三种：</p>
<ol>
<li>沙箱突围攻击：攻击者定制模块内的控制流，以达到访问沙箱区域外的数据。比如，可以在访问间接调用表时使用 Spectre-PHT 绕过条件边界检查。 或者，他们可以使用 Spectre-BTB 将控制流转移到指令中间以执行不安全的代码。</li>
<li>沙箱投毒攻击：攻击者通过影响受害者沙箱的控制流，强迫受害者泄露私有数据。</li>
<li>主机投毒攻击：攻击者通过幽灵攻击影响主机的控制流，以便从主机或其他任意沙箱访问数据。</li>
</ol>
<p>为了防范幽灵攻击，论文中提出一种解决方案：构建线性块（linear block）。</p>
<p>通过自己实现的 Swivel-SFI的工具，将 wasm 代码编译为了 线性块。线性块是直线代码块，除了它们的终止符之外不包含任何控制流指令。与传统的基本块（Basic Block）形成对比，后者通常不将函数调用视为终止符。这个简单的区别很重要：它允许我们确保所有控制流传输 (顺序和推测) 落在线性块边界上。 然后，通过确保单个线性块是安全的，就可以确保整个 Wasm 程序在编译时受到限制并且不会违反 Wasm 的隔离保证。</p>
<p>所以，如果想利用 WebAssembly 的 SFI 机制，还必须防范类似于 幽灵攻击之类的恶意攻击。</p>
<h2><a class="header" href="#webassembly-沙箱性能" id="webassembly-沙箱性能">WebAssembly 沙箱性能</a></h2>
<p><strong>wasm 执行性能</strong></p>
<p>关于 Wasm 执行的性能，在 论文  <a href="https://cseweb.ucsd.edu/%7Edstefan/pubs/narayan:2021:swivel.pdf">《Swivel: Hardening WebAssembly against Spectre》</a> 中也有一些统计。Swivel-SFI工具执行 wasm 模块中函数调用性能基本是 5微秒左右。</p>
<p>另外在 2021 第一季度也有人测试过目前主流 wasm 运行时的性能：<a href="https://00f.net/2021/02/22/webassembly-runtimes-benchmarks/">Benchmark of WebAssembly runtimes - 2021 Q1</a></p>
<p>和本地代码执行性能相比，还是要差一个数量级。</p>
<p><strong>沙箱和主机上下文切换性能</strong></p>
<p>使用 WebAssembly 的沙箱机制，有一部分开销部分主要是存在于 主机（Host） 和 沙箱（Sandbox） 的上下文切换中。</p>
<p>如果在沙箱和主机切换中再加一些确保安全的指令，性能损耗就更多。</p>
<p>拿 lucet 来说，它的上下文切换成不就比较高，因为它要确保安全。上下文切换成本包括：</p>
<ul>
<li>Callee-Save寄存器完整性。</li>
<li>初始寄存器机密性。</li>
<li>栈帧封装。</li>
</ul>
<p>论文 <a href="https://arxiv.org/abs/2105.00033">《Isolation Without Taxation: Near Zero Cost Transitions for SFI》</a> 提供了一种接近零成本切换的WebAssembly SFI 的方案，并且基于 lucet 实现了该方案，修改后将 Firefox 中的字体和图像渲染速度提高了 29.7% 和 10%。因为 Firefox 的渲染组件使用了 WebAssembly SFI 功能，该 SFI 基于 lucet 实现，下文会有介绍。 </p>
<p>关于零成本切换的更多细节可以查看该论文。</p>
<h2><a class="header" href="#webassembly-与-sfi" id="webassembly-与-sfi">WebAssembly 与 SFI</a></h2>
<h3><a class="header" href="#firefox-中的应用" id="firefox-中的应用">Firefox 中的应用</a></h3>
<p>Firefox 中使用 RLBox 沙盒，在 论文 <a href="https://www.usenix.org/system/files/sec20-narayan.pdf">《Retrofitting Fine Grain Isolation in the Firefox Renderer》</a> 中有详细介绍。</p>
<p>RLBox 采用了直接在 C++ 类型系统中表达的静态信息流强制和轻量级动态检查。RLBox 通过基于软件的故障隔离（software-based-fault isolation）或多核进程隔离（multi-core process isolation）来支持有效的沙箱。性能开销适中且短暂，并且只有很小对页面延迟的影响。RLBox 使用 WebAssembly 沙盒，已集成到生产 Firefox 中。</p>
<p>RLBox 通过其类型系统和 API 使渲染器沙盒接口处的数据和控制流显式化，以便调解这些流并跨信任边界强制执行安全检查，确保在任何潜在的不安全使用之前验证沙箱数据。另一方面，API 设计用于限制渲染器和沙箱之间的控制传递。例如，渲染器必须使用<code>andbox_invoke()</code> 来调用沙箱中的函数； 沙箱对渲染器的任何回调必须首先由渲染器使用<code>sandbox_callback(callback_fn)</code>API 注册。</p>
<p>RLBox 通过提供一个 <code>tainted&lt;T&gt;</code>数据类型，来包装来自沙箱的任何数据，以此保障控制流和数据流安全：</p>
<ol>
<li>自动化安全检查：Swizzling 操作、执行检查以确保沙箱提供的指针指向沙箱内存，以及识别 tainted 数据的位置，都是自动完成的。</li>
<li>仅在必要时才执行 tainted 数据验证。</li>
<li>有效地共享数据结构：静态检查确保共享数据在沙盒内存中分配并通过 tainted 类型访问。</li>
</ol>
<p>另外，RLBox 通过编译时错误强制应用程序开发人员使用<code>sandbox_callback() </code>函数显式注册回调，因为在沙盒中允许回调任意函数是不安全的。</p>
<p>更多详细内容请查看该论文。</p>
<h2><a class="header" href="#小结-5" id="小结-5">小结</a></h2>
<p>因为 WebAssembly 的特性，和当前存在的安全风险，以及社区中的实践和验证，证明当前基于 WebAssemby 的 SFI 机制是可行的，但是还是有风险的。</p>
<p>并不能单纯依赖 WebAssembly 的沙盒机制来提供 SFI 机制，还需要从 加强 wasm 模块合法性验证、wasm 运行时安全机制、自定义 SFI 实现、减少性能损耗等等各种机制来进一步提供保证才可以。</p>
<h2><a class="header" href="#附录-webassembly-应用统计" id="附录-webassembly-应用统计">附录： WebAssembly 应用统计</a></h2>
<p>论文 <a href="https://software-lab.org/publications/www2021.pdf">《An Empirical Study of Real-World WebAssembly Binaries》</a> 从当前 WebAssembly 生态中抽取五万多个 wasm 二进制文件，从使用源语言、使用不安全语言传播的漏洞、是否还有wasm在浏览器中挖矿、WebAssembly 应用领域 这四个角度进行了一份统计。</p>
<h4><a class="header" href="#编写-webassembly-的语言占比" id="编写-webassembly-的语言占比">编写 WebAssembly 的语言占比</a></h4>
<p><img src="chapter_6/./image/wasm-security/wasm-source-lang.png" alt="5" /></p>
<p>虽然 Cpp 是最先支持 WebAssembly 的语言，但是 Rust 后来居上，成为第二个使用最多的 WebAssembly 源语言。</p>
<h4><a class="header" href="#使用不安全语言传播的漏洞" id="使用不安全语言传播的漏洞">使用不安全语言传播的漏洞</a></h4>
<p><img src="chapter_6/./image/wasm-security/wasm-unsafe-lang.png" alt="6" /></p>
<p>上图展示了，几乎 三分之二的 wasm 二进制文件使用 非托管栈（线性内存上）。图右 显示了二进制文件中有多少函数至少访问堆栈指针一次。所有二进制文件的 35% 中没有函数使用栈指针。已经有 33% 的函数使用栈指针，而在某些二进制文件中，几乎每个函数都使用非托管堆栈。</p>
<p>结合前文中对 wasm 安全的分析，其实已经得到结论了:  WebAssembly 并不会让不安全的语言变得安全。</p>
<h4><a class="header" href="#是否还有wasm在浏览器中挖矿" id="是否还有wasm在浏览器中挖矿">是否还有wasm在浏览器中挖矿</a></h4>
<p>经过分析，目前在浏览器中利用 wasm 挖矿的应用下降了 99%。可能都去研究如何利用  wasm 漏洞去了。</p>
<h4><a class="header" href="#webassembly-应用领域" id="webassembly-应用领域">WebAssembly 应用领域</a></h4>
<p><img src="chapter_6/./image/wasm-security/wasm-domain.png" alt="7" /></p>
<p>从五万个 wasm 二进制文件中，随机抽取 100 个样本，对 wasm 应用领域做了一份统计。</p>
<p>但我认为这个统计有点偏颇。目前 WebAssembly 最大的应用潜力在于 云计算/边缘计算/分布式计算/ VR领域，但这个统计并没有凸显这点。</p>
<p>目前围绕 WebAssembly 云计算/边缘计算/分布式计算/ VR 涌现出了一些非常优秀的项目。</p>
<ul>
<li><a href="chapter_6/wasmcloud.com">wasmcloud</a>，利用 wasm 构建的分布式/微服务平台，并创造了 waPC 协议来安全方便地进行 guest 和 host 的通信。</li>
<li><a href="https://github.com/deislabs/wagi">wagi</a>，利用 WebAssembly 构建 WebAssembly Gateway Interface 。</li>
<li><a href="https://github.com/makepad/makepad">makepad</a>， cloud9 IDE 作者创建的项目，它利用 wasm和webgl 技术为开发者提供一个 VR 开发平台。</li>
</ul>
<h1><a class="header" href="#华为--stratovirt---基于rust的-balloon-功能实践" id="华为--stratovirt---基于rust的-balloon-功能实践">华为 | StratoVirt - 基于Rust的 balloon 功能实践</a></h1>
<p>作者： 杨铭</p>
<hr />
<p>StratoVirt是计算产业中面向云数据中心的企业级虚拟化平台，实现了一套架构统一支持虚拟机、容器、Serverless三种场景。StratoVirt在轻量低噪、软硬协同、Rust语言级安全等方面具备关键技术竞争优势。</p>
<h3><a class="header" href="#背景介绍-2" id="背景介绍-2">背景介绍：</a></h3>
<p>通常，在同一台服务器上存在着不同的用户，而多数用户对内存的使用情况是一种间断性的使用。也就是说用户对内存的使用率并不是很高。在服务器这种多用户的场景中，如果很多个用户对于内存的使用率都不高的话，那么会存在服务器实际占用的内存并不饱满这样一种情况。实际上各个用户使用内存的分布图可能如下图所示（黄色部分表示used部分，绿色部分表示free的部分）。</p>
<p><img src="chapter_6/./image/hw/memory.png" alt="1" /></p>
<h3><a class="header" href="#解决方案-1" id="解决方案-1">解决方案：</a></h3>
<p>为了解决上述服务器上内存使用率低的问题，可以将虚拟机中暂时不用的内存回收回来给其他虚拟机使用。而当被回收内存的虚拟机需要内存时，由host再将内存归还回去。有了这样的内存伸缩能力，服务器便可以有效提高内存的使用率。在StratoVirt中，我们使用balloon设备来对虚拟机中的空闲内存进行回收和释放。下面详细了解一下StratoVirt中的balloon设备。</p>
<h3><a class="header" href="#balloon设备简介" id="balloon设备简介">balloon设备简介：</a></h3>
<p>由于StratoVirt只是负责为虚拟机分配内存，只能感知到每个虚拟机总的内存大小。但是在每个虚拟机中如何使用内存，内存剩余多少。StratoVirt是无法感知的，也就无法得知该从虚拟机中回收多少内存了。为此，需要在虚拟机中放置一个“气球（balloon）”设备。该设备通过virtio半虚拟化框架来实现前后端通信。当Host端需要回收虚拟机内部的空闲内存时，balloon设备“充气”膨胀，占用虚拟机内部内存。而将占用的内存交给Host使用。如果虚拟机的空闲内存被回收后，虚拟机内部由于业务要求突然需要内存时。位于虚拟机内部的balloon设备可以选择“放气”缩小。释放出更多的内存空间给虚拟机使用。</p>
<h3><a class="header" href="#balloon实现" id="balloon实现">balloon实现：</a></h3>
<p>balloon的具体代码实现位于StratoVirt项目的/virtio/src/balloon.rs文件中，相关细节可阅读代码理解。代码架构如下：</p>
<pre><code>virtio
├── Cargo.toml
└── src
    ├── balloon.rs
    ├── block.rs
    ├── console.rs
    ├── lib.rs
    ├── net.rs
    ├── queue.rs
    ├── rng.rs
    ├── vhost
    │   ├── kernel
    │   │   ├── mod.rs
    │   │   ├── net.rs
    │   │   └── vsock.rs
    │   └── mod.rs
    └── virtio_mmio.rs
</code></pre>
<p>由于balloon是一个virtio设备，所以在前后端通信时也使用了virtio框架提供的virtio queue。当前StratoVirt支持两个队列：inflate virtio queue（ivq）和deflate virtio queue（dvq）。这两个队列分别负责balloon设备的“充气”和“放气”。</p>
<p>气球的充放气时，前后端的信息是通过一个结构体来传递。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct VirtioBalloonConfig {
    /// Number of pages host wants Guest to give up.
    pub num_pages: u32,
    /// Number of pages we've actually got in balloon.
    pub actual: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>因此后端向前端要内存的时候，只需要修改这个结构体中的num_pages的数值，然后通知前端。前端读取配置结构体中的num_pages成员。并与本身结构体中的actual对比，判断是进行inflate还是deflate。</p>
<ul>
<li>inflate</li>
</ul>
<p>如果是inflate，那么虚拟机以4k页为单位去申请虚拟机内存，并将申请到的内存地址保存在队列中。然后通过ivq将保存了分配好的页面地址的数组分批发往后端处理（virtio queue队列长度最大256，也就是一次最多只能传输1M内存信息，对于大于1M的内存只能分批传输）。后端通过得到信息后，找到相应的MemoryRegion，将对应的page标记为”WILLNEED“。然后通知前端，完成配置。</p>
<ul>
<li>deflate</li>
</ul>
<p>如果是deflate则从保存申请到的内存地址队列中弹出一部分内存的地址。通过dvq分批次传输给后端处理。后端将page标记为“DONTNEED&quot;。</p>
<p>下面结合代码进行说明：</p>
<p>定义BalloonIoHandler结构体作为处理balloon事件的主体。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BalloonIoHandler {
    /// The features of driver.
    driver_features: u64,
    /// Address space.
    mem_space: Arc&lt;AddressSpace&gt;,
    /// Inflate queue.
    inf_queue: Arc&lt;Mutex&lt;Queue&gt;&gt;,
    /// Inflate EventFd.
    inf_evt: EventFd,
    /// Deflate queue.
    def_queue: Arc&lt;Mutex&lt;Queue&gt;&gt;,
    /// Deflate EventFd.
    def_evt: EventFd,
    /* 省略 */
}
<span class="boring">}
</span></code></pre></pre>
<p>其中包含上述的两个virtio队列<code>inf_queue</code>和<code>def_queue</code>，以及对应的触发事件描述符（EventFd）<code>inf_evt</code>和<code>def_evt</code>。两个队列均使用了<code>Mutex</code>锁，保证了队列在同一时刻只有一个使用者对该队列进行操作。保证了多线程共享的数据安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_balloon_queue(&amp;mut self, req_type: bool) -&gt; Result&lt;()&gt; {
    let queue = if req_type {
        &amp;mut self.inf_queue
    } else {
        &amp;mut self.def_queue
    }; //获得对应的队列
    let mut unlocked_queue = queue.lock().unwrap();
    while let Ok(elem) = unlocked_queue
        .vring
        .pop_avail(&amp;self.mem_space, self.driver_features)
    {
        match Request::parse(&amp;elem) {
            Ok(req) =&gt; {
                if !self.mem_info.has_huge_page() {
                    // 进行内存标记
                    req.mark_balloon_page(req_type, &amp;self.mem_space, &amp;self.mem_info);
                }
                /* 省略 */
            }
            Err(e) =&gt; {
                /* 省略错误处理 */
            }
        }
    }
    /* 省略 */
}
<span class="boring">}
</span></code></pre></pre>
<p>当相应的<code>EventFd</code>被触发后<code>process_balloon_queue</code>函数将会被调用。通过判断请求类型确定是“充气”还是”放气“，然后再从相应的队列中取数据进行内存标记。其中<code>while let</code>是Rust语言提供的一种循环模式匹配机制。借助该语法可以将队列中pop出来的所有数据遍历取出到<code>elem</code>中。</p>
<h3><a class="header" href="#内存标记及优化" id="内存标记及优化">内存标记及优化：</a></h3>
<p>标记内存在<code>mark_balloon_page</code>函数中进行实现，起初的实现思路为：将虚拟机传送过来的地址逐个进行标记。即，从队列中取出一个元素，转化为地址后立即进行标记。后来经过测试发现：balloon设备在对页地址进行一页一页标记内存时花费时间巨大。而同时也发现通过虚拟机传回来的地址中有大段的连续内存段。于是通过改变标记方法：由原来的一页一页标记改为将这些连续的内存统一标记。大大节省了标记时间。下面代码为具体实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mark_balloon_page(
        &amp;self,
        req_type: bool,
        address_space: &amp;Arc&lt;AddressSpace&gt;,
        mem: &amp;BlnMemInfo,
    ) {
        let advice = if req_type {
            libc::MADV_DONTNEED
        } else {
            libc::MADV_WILLNEED
        };
        /* 略 */
        for iov in self.iovec.iter() {
            let mut offset = 0;
            let mut hvaset = Vec::new();
            while let Some(pfn) = iov_to_buf::&lt;u32&gt;(address_space, iov, offset) {
                offset += std::mem::size_of::&lt;u32&gt;() as u64;
                let gpa: GuestAddress = GuestAddress((pfn as u64) &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT);
                let hva = match mem.get_host_address(gpa) {
                    Some(addr) =&gt; addr,
                    None =&gt; {
                        /* 略 */
                    }
                };
                //将hva地址保存在hvaset的vec中
                hvaset.push(hva);
            }
            //对hvaset进行从小到大排序。
            hvaset.sort_by_key(|&amp;b| Reverse(b));
            /* 略 */
                //将hvaset中连续的内存段进行标记
                while let Some(hva) = hvaset.pop() {
                    if last_addr == 0 {
                        free_len += 1;
                        start_addr = hva;
                    } else if hva == last_addr + BALLOON_PAGE_SIZE {
                        free_len += 1;
                    } else {
                        memory_advise(
                            start_addr as *const libc::c_void as *mut _,
                            (free_len * BALLOON_PAGE_SIZE) as usize,
                            advice,
                        );
                        free_len = 1;
                        start_addr = hva;
                    }

                    if count_iov == iov.iov_len {
                        memory_advise(
                            start_addr as *const libc::c_void as *mut _,
                            (free_len * BALLOON_PAGE_SIZE) as usize,
                            advice,
                        );
                    }
                    count_iov += std::mem::size_of::&lt;u32&gt;() as u64;
                    last_addr = hva;
                }
            /* 略 */
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先将virtio队列中的地址全部取出，并保存在vec中，然后将该vec进行从小到大的排序。有利于快速找出连续的内存段并进行标记。由于hvaset中的地址是按照从小到大排列的，因此可以从头开始遍历hvaset，遇到不连续的地址后将前面的连续段进行标记。这样就完成了由原来逐页标记到连续内存段统一标记的优化。</p>
<p>经过测试，StratoVirt的balloon速度也有了极大的提高。</p>
<h2><a class="header" href="#关注我们-3" id="关注我们-3">关注我们</a></h2>
<p>StratoVirt当前已经在openEuler社区（openEuler是一个开源、免费的Linux发行版平台，将通过开放的社区形式与全球的开发者共同构建一个开放、多元和架构包容的软件生态体系）开源。在未来的一段时间我们将开展一系列主题的分享，让大家更加详细的了解StratoVirt实现，非常期待您的围观和加入！</p>
<p>项目地址：https://gitee.com/openeuler/stratovirt</p>
<p>项目wiki：https://gitee.com/openeuler/stratovirt/wikis</p>
<p>项目交流：<a href="https://mailweb.openeuler.org/postorius/lists/virt.openeuler.org/">virt邮件列表</a>或是提交一个<a href="https://gitee.com/openeuler/stratovirt/issues">issue</a>。</p>
<h1><a class="header" href="#蚂蚁集团--rust-数据内存布局" id="蚂蚁集团--rust-数据内存布局">蚂蚁集团 ｜ Rust 数据内存布局</a></h1>
<p>作者：worcsrcsgg</p>
<hr />
<h2><a class="header" href="#背景-4" id="背景-4">背景</a></h2>
<p>我们团队同学 Jiacai Liu 在之前<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_trait.html">文章</a>提到指向 trait obj 的指针为一个胖指针: 
&gt;Rust 使用 fat pointer（即两个指针） 来表示 trait object 的引用，分别指向 data 与 vtable。
<img src="chapter_6/./image/ant/1.jpeg" alt="1" /> </p>
<p>另外团队中使用了一些调用 C 库 lib，比如 <a href="https://github.com/rust-rocksdb/rust-rocksdb">rust-rocksdb</a> 库，里面封装 C 的数据结构会频繁出现 #[repr(C)]。</p>
<p>本文是在以上两个问题引申下展开的，学习探讨下 Rust 数据类型的内存布局。</p>
<p>主要分为两个部分，一是 Rust 中基本的数据类型内存布局，二是内存布局的表示。</p>
<h2><a class="header" href="#常用类型" id="常用类型">常用类型</a></h2>
<p>类型的布局是其大小（size）、对齐方式（align）及其字段的相对偏移量。对于枚举，如何布局和解释判别式也是类型布局的一部分。
对于 Sized 的数据类型，可以在编译时知道内存布局，可以通过 <a href="https://doc.rust-lang.org/stable/std/mem/fn.size_of.html">size_of</a> 和 <a href="https://doc.rust-lang.org/stable/std/mem/fn.align_of.html">align_of</a> 获得其 size 和 align。</p>
<pre><code>The layout of a type is its size, alignment, and the relative offsets of its fields. 
For enums, how the discriminant is laid out and interpreted is also part of type layout.
Type layout can be changed with each compilation.
</code></pre>
<h3><a class="header" href="#数字类型" id="数字类型">数字类型</a></h3>
<h4><a class="header" href="#整数类型" id="整数类型">整数类型</a></h4>
<table><thead><tr><th>Type</th><th>Minimum</th><th>Maximum</th><th>size(bytes)</th><th>align(bytes)</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td>0</td><td>2<sup>8</sup>-1</td><td>1</td><td>1</td></tr>
<tr><td><code>u16</code></td><td>0</td><td>2<sup>16</sup>-1</td><td>2</td><td>2</td></tr>
<tr><td><code>u32</code></td><td>0</td><td>2<sup>32</sup>-1</td><td>4</td><td>4</td></tr>
<tr><td><code>u64</code></td><td>0</td><td>2<sup>64</sup>-1</td><td>8</td><td>8</td></tr>
<tr><td><code>u128</code></td><td>0</td><td>2<sup>128</sup>-1</td><td>16</td><td>16</td></tr>
</tbody></table>
<table><thead><tr><th>Type</th><th>Minimum</th><th>Maximum</th><th>size(bytes)</th><th>align(bytes)</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>-(2<sup>7</sup>)</td><td>2<sup>7</sup>-1</td><td>1</td><td>1</td></tr>
<tr><td><code>i16</code></td><td>-(2<sup>15</sup>)</td><td>2<sup>15</sup>-1</td><td>2</td><td>2</td></tr>
<tr><td><code>i32</code></td><td>-(2<sup>31</sup>)</td><td>2<sup>31</sup>-1</td><td>4</td><td>4</td></tr>
<tr><td><code>i64</code></td><td>-(2<sup>63</sup>)</td><td>2<sup>63</sup>-1</td><td>8</td><td>8</td></tr>
<tr><td><code>i128</code></td><td>-(2<sup>127</sup>)</td><td>2<sup>127</sup>-1</td><td>16</td><td>16</td></tr>
</tbody></table>
<h4><a class="header" href="#浮点数" id="浮点数">浮点数</a></h4>
<p>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are <code>f32</code> and
<code>f64</code>, respectively.</p>
<table><thead><tr><th>Type</th><th>size(bytes)</th><th>align(bytes)</th></tr></thead><tbody>
<tr><td>f32</td><td>4</td><td>4</td></tr>
<tr><td>f64</td><td>8</td><td>8</td></tr>
</tbody></table>
<p>f64 在 x86 系统上对齐到 4 bytes。</p>
<h3><a class="header" href="#usized--isized" id="usized--isized">usized &amp; isized</a></h3>
<p>usize 无符号整形，isize 有符号整形。
在 64 位系统上，长度为 8 bytes，在 32 位系统上长度为 4 bytes。</p>
<h3><a class="header" href="#bool" id="bool">bool</a></h3>
<p>bool 类型，取值为 true 或 false，长度和对齐长度都是 1 byte。</p>
<h3><a class="header" href="#array" id="array">array</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [i32; 3] = [1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>数组的内存布局为系统类型元组的有序组合。</p>
<pre><code>size 为 n*size_of::&lt;T&gt;()
align 为 align_of::&lt;T&gt;()
</code></pre>
<h3><a class="header" href="#str" id="str">str</a></h3>
<h4><a class="header" href="#char-类型" id="char-类型">char 类型</a></h4>
<p>char 表示：一个 32 位长度字符，Unicode 标量值 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode Scalar Value</a> 范围为 in the 0x0000 - 0xD7FF 或者是 0xE000 - 0x10FFFF。</p>
<h4><a class="header" href="#str-类型" id="str-类型">str 类型</a></h4>
<p>str 与 [u8] 一样表示一个 u8 的 slice。Rust 中标准库中对 str 有个假设：符合 UTF-8 编码。内存布局与 [u8] 相同。</p>
<h3><a class="header" href="#slice" id="slice">slice</a></h3>
<p>slice 是 DST 类型，是类型 T 序列的一种视图。
slice 的使用必须要通过指针，&amp;[T] 是一个胖指针，保存指向数据的地址和元素个数。
slice 的内存布局与其指向的 array 部分相同。</p>
<h4><a class="header" href="#str-和-string-的区别" id="str-和-string-的区别">&amp;str 和 String 的区别</a></h4>
<p>下面给出 &amp;str String 的内存结构比对：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_name = &quot;Pascal&quot;.to_string();
my_name.push_str( &quot; Precht&quot;);

let last_name = &amp;my_name[7..];
<span class="boring">}
</span></code></pre></pre>
<p>String</p>
<pre><code>                     buffer
                   /   capacity
                 /   /  length
               /   /   /
            +–––+–––+–––+
stack frame │ • │ 8 │ 6 │ &lt;- my_name: String
            +–│–+–––+–––+
              │
            [–│–––––––– capacity –––––––––––]
              │
            +–V–+–––+–––+–––+–––+–––+–––+–––+
       heap │ P │ a │ s │ c │ a │ l │   │   │
            +–––+–––+–––+–––+–––+–––+–––+–––+

            [––––––– length ––––––––]
</code></pre>
<p>String vs &amp;str</p>
<pre><code>         my_name: String   last_name: &amp;str
            [––––––––––––]    [–––––––]
            +–––+––––+––––+–––+–––+–––+
stack frame │ • │ 16 │ 13 │   │ • │ 6 │ 
            +–│–+––––+––––+–––+–│–+–––+
              │                 │
              │                 +–––––––––+
              │                           │
              │                           │
              │                         [–│––––––– str –––––––––]
            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+
       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │
            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+
</code></pre>
<h3><a class="header" href="#struct" id="struct">struct</a></h3>
<p>结构体是带命名的复合类型，有以下几种 struct：
StructExprStruct</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
}
<span class="boring">}
</span></code></pre></pre>
<p>StructExprTuple</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Position(i32, i32, i32);
<span class="boring">}
</span></code></pre></pre>
<p>StructExprUnit</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Gamma;
<span class="boring">}
</span></code></pre></pre>
<p>详细内存布局见第二部分数据布局-数据对齐。</p>
<h3><a class="header" href="#tuple" id="tuple">tuple</a></h3>
<p>元组是匿名的复合类型，有以下几种 tuple：</p>
<pre><code>() (unit)
(f64, f64)
(String, i32)
(i32, String) (different type from the previous example)
(i32, f64, Vec&lt;String&gt;, Option&lt;bool&gt;)
</code></pre>
<p>tuple 的结构和 Struct 一致，只是元素是通过 index 进行访问的。</p>
<h3><a class="header" href="#closure" id="closure">closure</a></h3>
<p>闭包相当于一个捕获变量的结构体，实现了 FnOnce 或 FnMut 或 Fn。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!(&quot;{}&quot;, g());
}

let mut s = String::from(&quot;foo&quot;);
let t = String::from(&quot;bar&quot;);

f(|| {
    s += &amp;t;
    s
});
// Prints &quot;foobar&quot;.
<span class="boring">}
</span></code></pre></pre>
<p>生成一个闭包类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Closure&lt;'a&gt; {
    s : String,
    t : &amp;'a String,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    fn call_once(self) -&gt; String {
        self.s += &amp;*self.t;
        self.s
    }
}
f(Closure{s: s, t: &amp;t});
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#union" id="union">union</a></h3>
<p>union 的关键特性是 union 的所有字段共享公共存储。因此，对 union 的一个字段的写入可以覆盖其其他字段，union 的大小由其最大字段的大小决定。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>每个 union 访问都只是在用于访问的字段的类型上解释存储。读取并集字段读取字段类型处的并集位。字段可能具有非零偏移量（除非使用C表示法）；在这种情况下，从字段偏移量开始的位被读取。程序员有责任确保数据在字段的类型上是有效的。否则会导致未定义的行为。比如读取整数 3，但是需要转换为 bool 类型，则会出错。</p>
<h3><a class="header" href="#enum" id="enum">enum</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog(String, f64),
    Cat { name: String, weight: f64 },
}

let mut a: Animal = Animal::Dog(&quot;Cocoa&quot;.to_string(), 37.2);
a = Animal::Cat { name: &quot;Spotty&quot;.to_string(), weight: 2.7 };
<span class="boring">}
</span></code></pre></pre>
<p>枚举项声明类型和许多变体，每个变体都独立命名，并且具有struct、tuple struct或unit-like struct的语法。
enum 是带命名的标签联合体，因此其值消耗的内存是对应枚举类型的最大变量的内存，以及存储判别式所需的大小。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum Foo { A(&amp;'static str), B(i32), C(i32) }

assert_eq!(mem::discriminant(&amp;Foo::A(&quot;bar&quot;)), mem::discriminant(&amp;Foo::A(&quot;baz&quot;)));
assert_eq!(mem::discriminant(&amp;Foo::B(1)), mem::discriminant(&amp;Foo::B(2)));
assert_ne!(mem::discriminant(&amp;Foo::B(3)), mem::discriminant(&amp;Foo::C(3)));
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    A(u32),
    B(u64),
    C(u8),
}
struct FooRepr {
    data: u64, // 根据tag的不同，这一项可以为u64，u32，或者u8
    tag: u8, // 0 = A, 1 = B, 2 = C
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#trait-obj" id="trait-obj">trait obj</a></h3>
<p>官方定义：</p>
<pre><code>A trait object is an opaque value of another type that implements a set of traits. 
The set of traits is made up of an object safe base trait plus any number of auto traits.  
</code></pre>
<p>trait obj 是 DST 类型，指向 trait obj 的指针也是个胖纸针，分别指向 data 和 vtable。更详细描述可以<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_trait.html">参考</a> 
<img src="chapter_6/./image/ant/2.jpeg" alt="2" /> </p>
<h2><a class="header" href="#dynamically-sized-typesdst" id="dynamically-sized-typesdst">Dynamically Sized Types（DST）</a></h2>
<p>一般来说大多数类型，可以在编译阶段确定大小和对齐属性，<a href="https://doc.rust-lang.org/stable/reference/special-types-and-traits.html#sized">Sized trait</a> 就是保证了这种特性。非 size (?Sized）及 DST 类型。DST 类型有 slice 和 trait obj。DST 类型必须通过指针来使用。
需要注意：</p>
<ol>
<li>DST 可以作为泛型参数，但是需要注意泛型参数默认是 Sized，如果是 DST 类型需要特别的指定为 ?Sized。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">struct S {
    s: i32
}

impl S {
    fn new(i: i32) -&gt; S {
        S{s:i}
    }
}

trait T {
    fn get(&amp;self) -&gt; i32;
}

impl T for S {
    fn get(&amp;self) -&gt; i32 { 
        self.s
    }
}

fn test&lt;R: T&gt;(t: Box&lt;R&gt;) -&gt; i32 {
    t.get()
}


fn main() {
    let t: Box&lt;T&gt; = Box::new(S::new(1));
    let _ = test(t);
}
</code></pre></pre>
<p>编译报错</p>
<pre><code>error[E0277]: the size for values of type `dyn T` cannot be known at compilation time
   |
21 | fn test&lt;R: T&gt;(t: Box&lt;R&gt;) -&gt; i32 {
   |         - required by this bound in `test`
...
28 |     let _ = test(t);
   |                  ^ doesn't have a size known at compile-time
   |
   = help: the trait `Sized` is not implemented for `dyn T`
help: consider relaxing the implicit `Sized` restriction
   |
21 | fn test&lt;R: T + ?Sized&gt;(t: Box&lt;R&gt;) -&gt; i32 {
   |              ^^^^^^^^
</code></pre>
<p>fix it</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test&lt;R: T + ?Sized&gt;(t: Box&lt;R&gt;) -&gt; i32 {
    t.get()
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>trait 默认实现了 ?Sized.</li>
<li>结构体实际上可以直接存储一个DST作为它们的最后一个成员字段，但这也使该结构体成为DST。可以参考<a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-sized-types-dsts">DST</a> 进一步了解自定义 DST。</li>
</ol>
<h2><a class="header" href="#零尺寸类型-zst-zero-sized-type" id="零尺寸类型-zst-zero-sized-type">零尺寸类型 (ZST, Zero Sized Type)</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Nothing; // No fields = no size

// All fields have no size = no size
struct LotsOfNothing {
    foo: Nothing,
    qux: (),      // empty tuple has no size
    baz: [u8; 0], // empty array has no size
}
<span class="boring">}
</span></code></pre></pre>
<p>ZST 的一个最极端的例子是 Set 和 Map。已经有了类型 <code>Map&lt;Key, Value&gt;</code>，那么要实现 <code>Set&lt;Key, Value&gt;</code>的通常做法是简单封装一个 <code>Map&lt;Key, UselessJunk&gt;</code>。很多语言不得不给 UselessJunk 分配空间，还要存储、加载它，然后再什么都不做直接丢弃它。编译器很难判断出这些行为实际是不必要的。
但是在 Rust 里，我们可以直接认为 <code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code>。Rust 静态地知道所有加载和存储操作都毫无用处，也不会真的分配空间。结果就是，这段范型代码直接就是 HashSet 的一种实现，不需要 HashMap 对值做什么多余的处理。</p>
<h2><a class="header" href="#空类型empty-types" id="空类型empty-types">空类型（Empty Types）</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {} // No variants = EMPTY
<span class="boring">}
</span></code></pre></pre>
<p>空类型的一个主要应用场景是在类型层面声明不可到达性。假如，一个 API 一般需要返回一个 Result，但是在特殊情况下它是绝对不会运行失败的。这种情况下将返回值设为 Result&lt;T, Void&gt;，API 的调用者就可以信心十足地使用 unwrap，因为不可能产生一个 Void 类型的值，所以返回值不可能是一个 Err。</p>
<h2><a class="header" href="#数据布局" id="数据布局">数据布局</a></h2>
<h3><a class="header" href="#数据对齐" id="数据对齐">数据对齐</a></h3>
<p>数据对齐对 CPU 操作及缓存都有较大的好处。Rust 中结构体的对齐属性等于它所有成员的对齐属性中最大的那个。Rust 会在必要的位置填充空白数据，以保证每一个成员都正确地对齐，同时整个类型的尺寸是对齐属性的整数倍。例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
    b: u32,
    c: u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>打印下变量地址，可以根据结果看到对齐属性为 4.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = A {
        a: 1,
        b: 2,
        c: 3,
    };
    println!(&quot;0x{:X} 0x{:X} 0x{:X}&quot;, &amp;a.a as *const u8 as usize, &amp;a.b as *const u32 as usize , &amp;a.c as *const u16 as usize )
}

0x7FFEE6769276 
0x7FFEE6769270 
0x7FFEE6769274
</code></pre></pre>
<p>Rust 中数据对齐</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    b: u32,
    c: u16,
    _pad1: [u8; 2], 
    a: u8,
    _pad2: [u8; 3],
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#编译器优化" id="编译器优化">编译器优化</a></h3>
<p>来看下面这个结构</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T, U&gt; {
    count: u16,
    data1: T,
    data2: U,
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let foo1 = Foo::&lt;u16, u32&gt; {
        count: 1,
        data1: 2,
        data2: 3,
    };

    let foo2 = Foo::&lt;u32, u16&gt; {
        count: 1,
        data1: 2,
        data2: 3,
    };

    println!(&quot;0x{:X} 0x{:X} 0x{:X}&quot;, &amp;foo1.count as *const u16 as usize, &amp;foo1.data1 as *const u16 as usize, &amp;foo1.data2 as *const u32 as usize);
    println!(&quot;0x{:X} 0x{:X} 0x{:X}&quot;, &amp;foo2.count as *const u16 as usize, &amp;foo2.data1 as *const u32 as usize, &amp;foo2.data2 as *const u16 as usize);
}
0x7FFEDFDD61C4 0x7FFEDFDD61C6 0x7FFEDFDD61C0
0x7FFEDFDD61CC 0x7FFEDFDD61C8 0x7FFEDFDD61CE
</code></pre></pre>
<p>foo1字段顺序：data2(0), count(4), data1(6)
foo1字段顺序：data1(8), count(c), data2(e)
可以看到编译器会改变 Foo&lt;T, U&gt; 中成员顺序。内存优化原则要求不同的范型可以有不同的成员顺序。
如果不优化的可能会造成如下情况，造成大量内存开销：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;u16, u32&gt; {
    count: u16,
    data1: u16,
    data2: u32,
}

struct Foo&lt;u32, u16&gt; {
    count: u16,
    _pad1: u16,
    data1: u32,
    data2: u16,
    _pad2: u16,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#reprc" id="reprc">repr(C)</a></h3>
<p>repr(C) 目的很简单，就是为了内存布局和 C 保持一致。需要通过 FFI 交互的类型都应该有 repr(C)。而且如果我们要在数据布局方面玩一些花活的话，比如把数据重新解析成另一种类型，repr(C) 也是很有必要的。更深入了解可以参考<a href="https://doc.rust-lang.org/stable/reference/type-layout.html#the-c-representation">repr(C)</a></p>
<h3><a class="header" href="#repru--repri" id="repru--repri">repr(u)  repr(i)</a></h3>
<p>这两个可以指定无成员枚举的大小。包括：u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, and isize.</p>
<pre><pre class="playground"><code class="language-rust">enum Enum {
    Variant0(u8),
    Variant1,
}

#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

fn main() {
    assert_eq!(std::mem::size_of::&lt;Enum&gt;(), 2);
    // The size of the C representation is platform dependant
    assert_eq!(std::mem::size_of::&lt;EnumC&gt;(), 8);
    // One byte for the discriminant and one byte for the value in Enum8::Variant0
    assert_eq!(std::mem::size_of::&lt;Enum8&gt;(), 2);
    // Two bytes for the discriminant and one byte for the value in Enum16::Variant0
    // plus one byte of padding.
    assert_eq!(std::mem::size_of::&lt;Enum16&gt;(), 4);
}
</code></pre></pre>
<h3><a class="header" href="#repralignx-reprpackx" id="repralignx-reprpackx">repr(align(x)) repr(pack(x))</a></h3>
<p>align 和 packed 修饰符可分别用于提高或降低结构和联合的对齐。packed 还可能改变字段之间的填充。
align 启用了一些技巧，比如确保数组的相邻元素之间永远不会共享同一缓存线（这可能会加速某些类型的并发代码）。
pack 不能轻易使用。除非有极端的要求，否则不应使用。</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
struct A {
    a: u8,
    b: u32,
    c: u16,
}

#[repr(C, align(8))]
struct A8 {
    a: u8,
    b: u32,
    c: u16,
}

fn main() {
    let a = A {
        a: 1,
        b: 2,
        c: 3,
    };
    println!(&quot;{}&quot;, std::mem::align_of::&lt;A&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;A&gt;());
    println!(&quot;0x{:X} 0x{:X} 0x{:X}&quot;, &amp;a.a as *const u8 as usize, &amp;a.b as *const u32 as usize, &amp;a.c as *const u16 as usize);


    let a = A8 {
        a: 1,
        b: 2,
        c: 3,
    };
    println!(&quot;{}&quot;, std::mem::align_of::&lt;A8&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;A8&gt;());
    println!(&quot;0x{:X} 0x{:X} 0x{:X}&quot;, &amp;a.a as *const u8 as usize, &amp;a.b as *const u32 as usize, &amp;a.c as *const u16 as usize);
}
  
 结果：
4
12
0x7FFEE7F0B070 0x7FFEE7F0B074 0x7FFEE7F0B078
8
16
0x7FFEE7F0B1A0 0x7FFEE7F0B1A4 0x7FFEE7F0B1A8
  
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
struct A {
    a: u8,
    b: u32,
    c: u16,
}

#[repr(C, packed(1))]
struct A8 {
    a: u8,
    b: u32,
    c: u16,
}

fn main() {
    let a = A {
        a: 1,
        b: 2,
        c: 3,
    };
    println!(&quot;{}&quot;, std::mem::align_of::&lt;A&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;A&gt;());
    println!(&quot;0x{:X} 0x{:X} 0x{:X}&quot;, &amp;a.a as *const u8 as usize, &amp;a.b as *const u32 as usize, &amp;a.c as *const u16 as usize);


    let a = A8 {
        a: 1,
        b: 2,
        c: 3,
    };
    println!(&quot;{}&quot;, std::mem::align_of::&lt;A8&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;A8&gt;());
    println!(&quot;0x{:X} 0x{:X} 0x{:X}&quot;, &amp;a.a as *const u8 as usize, &amp;a.b as *const u32 as usize, &amp;a.c as *const u16 as usize);
}

结果：
4
12
0x7FFEED627078 0x7FFEED62707C 0x7FFEED627080
1
7
0x7FFEED6271A8 0x7FFEED6271A9 0x7FFEED6271AD
</code></pre></pre>
<h3><a class="header" href="#reprtransparent" id="reprtransparent">repr(transparent)</a></h3>
<p>repr(transparent) 使用在只有单个 field 的 struct 或 enum 上，旨在告诉 Rust 编译器新的类型只是在 Rust 中使用，新的类型（struc 或 enum）需要被 ABI 忽略。新的类型的内存布局应该当做单个 field 处理。</p>
<pre><code>The attribute can be applied to a newtype-like structs that contains a single field. 
It indicates that the newtype should be represented exactly like that field's type, i.e., 
the newtype should be ignored for ABI purpopses: not only is it laid out the same in memory, it is also passed identically in function calls.

Structs and enums with this representation have the same layout and ABI as the single non-zero sized field.
</code></pre>
<h2><a class="header" href="#总结-13" id="总结-13">总结</a></h2>
<p>以上内容为 Rust 中常见数据类型内存布局描述，如有错误，欢迎指正~</p>
<h2><a class="header" href="#参考-6" id="参考-6">参考</a></h2>
<ol>
<li><a href="https://doc.rust-lang.org/stable/reference/type-system.html">Type system</a></li>
<li><a href="https://doc.rust-lang.org/stable/nomicon/repr-rust.html">Data Layout</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/items.html">Item</a></li>
<li><a href="https://blog.thoughtram.io/string-vs-str-in-rust/">String vs &amp;str in Rust</a></li>
<li><a href="https://learnku.com/docs/nomicon/2018/20-data-layout/4707">数据布局</a></li>
<li><a href="https://doc.rust-lang.org/1.26.2/unstable-book/language-features/repr-transparent.html#enter-reprtransparent">enter-reprtransparent</a></li>
</ol>
<h2><a class="header" href="#关于我们-4" id="关于我们-4">关于我们</a></h2>
<p>我们是蚂蚁智能监控技术中台的时序存储团队，我们正在使用 Rust 构建高性能、低成本并具备实时分析能力的新一代时序数据库，欢迎加入或者推荐，请联系：jiachun.fjc@antgroup.com</p>
<h1><a class="header" href="#datenlord--rust-语言无锁数据结构的内存管理" id="datenlord--rust-语言无锁数据结构的内存管理">Datenlord | Rust 语言无锁数据结构的内存管理</a></h1>
<p>作者： 施继成 </p>
<hr />
<h1><a class="header" href="#无锁数据结构内存管理" id="无锁数据结构内存管理">无锁数据结构内存管理</a></h1>
<p>正如大家所熟知的，无锁数据结构在并发访问中往往具有更好的访问效率和并发度。无锁数据结构的性能优势主要来自于以下两点：</p>
<ol>
<li>数据结构的锁设计往往比较粗粒度，在很多可以并发访问的情况下，访问者被锁阻塞，无法实现并发访问。</li>
<li>无锁数据结构访问不需要进行上下文切换，有锁数据结构在并发度高的时候往往会触发操作系统上下文切换。</li>
</ol>
<p>但是无锁数据结构也带来了新的问题，即内存管理问题。举个例子：当线程 A 读取一块数据的时候，线程 B 要释放该数据块。在有锁数据结构中，这两个操作被串行了起来；无锁数据结构由于缺乏锁的保护，这两个操作可能同时进行。为了保证线程 A 访问数据的正确性，线程 B 的释放操作必须要延后执行，直到 A 完成了读取操作。为了达到上述延后释放内存的目的，大家一般采用下列的几种方法：</p>
<ol>
<li>语言本身的 GC 支持，如带有虚拟机 runtime 的语言，如 Java。</li>
<li>引用计数（Reference Count)。</li>
<li>基于代际的内存释放机制（Epoch-Based Reclamation)，本文之后简称EBR。</li>
</ol>
<p>语言本身的 GC 机制一方面有语言的限制，另外一方面全局的 GC 往往会造成一定的性能损失，程序执行Latency不稳定。引用计数本身的性能开销不可忽视，特别是在读取操作较多的场景下，仅仅为了保护数据安全，每次读取都需要进行计数增加，读完了再进行计数减少，高并发的情况下效率不乐观。EBR则规避了上述问题，一方面不需要语言层面的规约，另外一方面执行效率也相对更好。这里为大家简单介绍一下 EBR, 更加详细的解释请参见论文《 <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Practical lock-freedom</a> 》。</p>
<h1><a class="header" href="#epoch-based-reclamation" id="epoch-based-reclamation">Epoch-Based Reclamation</a></h1>
<p>在 EBR 的概念中有代际（Epoch）的概念，Epoch 为数字，其代表了当前处于第几世代，该数字单调递增。全局具有一个Global Epoch, 代表全局当前是第几世代。每个线程的每次数据结构的访问都包含一个Epoch，即Local Epoch，表示当前线程处在第几代。有了这些概念我们来看一下下面的例子，就能够理解 EBR 的工作原理了。</p>
<p>如下图中的例子，线程 A 和 B 并发地访问无锁数据中的内存块，自上而下为时间的流逝方向。在时间点 1 之前 Global Epoch 为 0。</p>
<p><img src="chapter_6/./image/datenlord/epoch-example.jpg" alt="epoch example" /></p>
<ul>
<li>时间节点1：线程 A 发现没有其他线程正在发给访问该数据结构，将Global Epoch 加 1，变成 1。同时线程 A Local Epoch 设置为 1.</li>
<li>时间节点2：线程 B 删除数据块 M，因为 B 发现只有线程 A 在访问数据结构，且 A 的Epoch 和 Global Epoch相等，都是1。线程 B 将 Global Epoch 再加 1，变成 2。B 线程 Local Epoch 和 Global Epoch 同步，也为 2. 由于 Epoch 的删除操作是延后的，需要放到一个收集器里，于是数据块 M 被放到收集器中，标记为 Epoch 1，意味着这个数据只有可能在Epoch 1中被使用，从 Epoch 2 开始数据结构中在没有数据块M（被线程 B 删除）。</li>
<li>时间节点3：线程 B 访问数据块 N，发现 Global Epoch 为2，线程 A 的 Epoch 为 1，则 B 标记自己的 Local Epoch 为2，与 Global Epoch 一致。</li>
<li>时间节点4 和 5：线程 A 和 B 都表示自己已经结束了数据访问，不再被数据结构追溯。</li>
<li>时间节点6：线程 A 也开始访问数据块 N，当前 Global Epoch 为 2，且没有其他线程访问该数据块，则线程 A 增加 Global Epoch 到 3，标记自己Local Epoch 为 3。同时线程 A 发现收集器中有一个 Epoch 为 1 的数据块 M，比当前Global Epoch相差了两个世代，可以被删除，数据块 M 被释放。</li>
<li>时间节点7：线程 A 表示自己结束了数据访问，不再被数据结构追溯。</li>
</ul>
<p>通过上面的例子我们不难发现，被访问的数据只可能存在于两个 Epoch 中，一个为当前 Epoch，即 Global Epoch，另一个为前一个 Epoch，即 （Global Epoch - 1）。所有被标记了更早 Epoch 的数据都可以被删除，即收集器中被标记为小于 （Global Epoch - 1）的数据块。</p>
<p>分析一下 EBR 的算法，我们能够发现其性能优越性的根本原因在于数据回收的粗粒度管理。在 Reference Count 的方法中，并发度越高，对 Counter 的修改就越密集，竞争越大，性能越差。在 EBR 中，并发度高会造成几乎所有线程都处于一个 Epoch，并不需要对 Global Epoch 进行修改，也就避免了这方面的竞争，性能也就更好。当然 EBR 也存在其自身的问题，当某些原因导致一个访问操作无法结束时，则 Global Epoch 永远无法向前推进，也就永远无法触发垃圾回收，内存泄露就不可避免了。</p>
<p>综上所述，即使存在一些缺陷，EBR 极好的性能优势使其成为了高性能无锁数据结构实现的首选。</p>
<h1><a class="header" href="#rust-语言实现-ebr" id="rust-语言实现-ebr">Rust 语言实现 EBR</a></h1>
<p>通过上述对 EBR 的分析，我们不难看出， EBR 需要知道数据访问起始点，配合起始点控制 Epoch 的迭代。其他语言有自己的封装和实现方法，而 Rust 的生命周期的概念则从语言层面提供了帮助。基于这个优势，Rust 语言天生适合实现EBR，并且已经有了一个成熟的实现版本，即 <a href="https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-epoch">crossbeam epoch</a>。这里不会对该实现做源码级的分析，而是会尝试将框架 API 和 EBR 的相关概念进行对应，帮助大家理解。</p>
<p>这里是示范代码，是无锁数据结构使用 epoch 最简单的方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let guard = epoch::pin();
    guard.defer(move || mem.release());
}
<span class="boring">}
</span></code></pre></pre>
<p>第一行表示当前线程开始访问访问该数据结构，可能是读取可能是写入。第二行表示，延迟释放一块内存，具体何时释放，由 EBR 算法来决定。当整个代码块执行完成，表示退出数据结构访问，guard 的 drop 方法会将当前线程从监测的队列中注销。</p>
<p>再例如，Datenlord 中实现和使用的无锁Hashmap, <a href="https://github.com/datenlord/lockfree-cuckoohash">cuckoohash</a>，其接口为:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let guard = pin();
    let value = map.get(&amp;key, &amp;guard);
    /// ... Use the value
}
<span class="boring">}
</span></code></pre></pre>
<p>第一行和前面的例子类似，第二行的语义为从 map 中寻找 key 对应的 value，获取 value 的引用，其生命周期不超过 guard 的生命周期。通过生命周期的方法，我们限定了 value 引用的使用范围为 guard 的存活范围。</p>
<h1><a class="header" href="#总结-14" id="总结-14">总结</a></h1>
<p>本文简单介绍了 Epoch-Based Reclamation 内存管理方法，并且从接口层面介绍了 Rust 的实现和使用。同时本文也分析了 EBR 在性能上的优越性，以及 Rust 语言从语言实现的优势。之后我们还会从 crossbeam epoch 的实现细节给大家带来深入的 Rust EBR 实现的分析。</p>
<h1><a class="header" href="#second-state--用-docker-工具管理-rust-函数" id="second-state--用-docker-工具管理-rust-函数">Second State ｜ 用 Docker 工具管理 Rust 函数</a></h1>
<p>作者：夏歌</p>
<hr />
<p>开发者可以通过 DockerHub 和 CRI-O 等 Docker 工具在 WasmEdge 中部署、管理和运行轻量级 WebAssembly 应用程序。</p>
<blockquote>
<p><a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a>  是由 <a href="https://www.cncf.io/sandbox-projects/">CNCF (Cloud Native Computing Foundation) 托管的</a> WebAssembly 运行时，是边缘计算应用程序的执行沙箱。</p>
</blockquote>
<p>虽然 WebAssembly 最初是作为浏览器应用程序的运行时而发明的，但其轻量级和高性能的沙箱设计使其成为通用应用程序容器的一个极具吸引力的选择。</p>
<blockquote>
<p>如果在 2008 年已经有了 WASM + WASI，那么我们压根无需创始 Docker 这个项目了。 — Docker 联合创始人 Solomon Hykes</p>
</blockquote>
<p>与 Docker 相比， <a href="https://www.infoq.com/articles/arm-vs-x86-cloud-performance/">WebAssembly 在启动时快一百倍</a>, 占用更小的内存和磁盘空间，并且具有更优定义的安全沙箱。然而，缺点是 WebAssembly 需要自己的语言 SDK 和编译器工具链，使其作为开发者环境比 Docker 更受限制。WebAssembly 越来越多地用于边缘计算场景，通常这些场景中，部署 Docker 比较困难，或是应用程序的性能至关重要。</p>
<p>Docker 的一大优势是其丰富的工具生态系统。我们希望为 WasmEdge 开发者带来类似 Docker 的工具。为了实现这一点，我们为 CRI-O 创建了一个名为 <a href="https://github.com/second-state/runw">runw</a> 的替代 runner 来加载并运行 WebAssembly 字节码程序，如同他们是 Docker 镜像文件一样。</p>
<h2><a class="header" href="#在-cri-o-中安装-webassembly-runner" id="在-cri-o-中安装-webassembly-runner">在 CRI-O 中安装 WebAssembly runner</a></h2>
<p>为了在 CRI-O 中支持 WebAssembly，您只需下载 <code>runw</code> 二进制码发布并将其安装到您的 CRI-O 中。</p>
<blockquote>
<p>因为 <code>runw</code> 二进制码已经包括了 WasmEdge，无需单独安装 WasmEdge 或任何其它 WebAssembly VM。</p>
</blockquote>
<p>首先，确保你使用的是安装了 LLVM-10 的 Ubuntu 20.04。如果你使用的是不同的平台，请参阅<a href="https://github.com/second-state/runw#build-from-source">如何为你的操作系统创建 <code>runw</code> 项目文档。</a></p>
<pre><code>sudo apt install -y llvm-10-dev liblld-10-dev
</code></pre>
<p>确保你安装了 <a href="https://cri-o.io/">cri-o</a>、 <a href="https://github.com/kubernetes-sigs/cri-tools">crictl</a>、 <a href="https://github.com/containernetworking/plugins">containernetworking-plugins</a> 和 <a href="https://github.com/containers/buildah">buildah</a> 或者 <a href="https://github.com/docker/cli">docker</a> 。</p>
<p>下一步，下载 <code>runw</code> binary build</p>
<pre><code>wget https://github.com/second-state/runw/releases/download/0.1.0/runw
</code></pre>
<p>现在，你可以安装 <code>runw</code> 进 CRI-O 作为 WebAssembly 的备选方案。</p>
<pre><code># Get the wasm-pause utility
sudo crictl pull docker.io/beststeve/wasm-pause

# Install runw into cri-o
sudo cp -v runw /usr/lib/cri-o-runc/sbin/runw
sudo chmod +x /usr/lib/cri-o-runc/sbin/runw
sudo sed -i -e 's@default_runtime = &quot;runc&quot;@default_runtime = &quot;runw&quot;@' /etc/crio/crio.conf
sudo sed -i -e 's@pause_image = &quot;k8s.gcr.io/pause:3.2&quot;@pause_image = &quot;docker.io/beststeve/wasm-pause&quot;@' /etc/crio/crio.conf
sudo sed -i -e 's@pause_command = &quot;/pause&quot;@pause_command = &quot;pause.wasm&quot;@' /etc/crio/crio.conf
sudo tee -a /etc/crio/crio.conf.d/01-crio-runc.conf &lt;&lt;EOF
[crio.runtime.runtimes.runw]
runtime_path = &quot;/usr/lib/cri-o-runc/sbin/runw&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/runw&quot;
EOF
</code></pre>
<p>最后，重启 <code>cri-o</code> ，从而使新的 WebAssembly runner 开始生效。</p>
<pre><code>sudo systemctl restart crio
</code></pre>
<h2><a class="header" href="#用-rust-构建-wasm-应用程序" id="用-rust-构建-wasm-应用程序">用 Rust 构建 Wasm 应用程序</a></h2>
<p>下面案例中的 Wasm 应用程序是 Rust 写的。为了让这些程序工作，确保你安装了 <a href="https://www.rust-lang.org/tools/install">Rust</a> 和 <a href="https://www.secondstate.io/articles/rustwasmc/">rustwasmc</a> 工具链。</p>
<blockquote>
<p>你需要 Rust 编译器和 rustwasmc 来构建 Rust 源成为 wasm 字节码文件。如果你已经有一个 wasm字节码程序，且只是想要用 cri-o 跑一遍，你可以跳过这个部分。</p>
</blockquote>
<p>应用程序源代码仅为一个 <a href="http://main.rs/"><code>main.rs</code></a> 函数。<a href="https://github.com/second-state/wasm-learning/tree/master/ssvm/wasi">在此处。</a>该应用程序演示了如何使用标准 Rust API 从 WasmEdge 访问文件系统和其它操作系统资源。</p>
<pre><code>fn main() {
  println!(&quot;Random number: {}&quot;, get_random_i32());
  println!(&quot;Random bytes: {:?}&quot;, get_random_bytes());
  println!(&quot;{}&quot;, echo(&quot;This is from a main function&quot;));
  print_env();
  create_file(&quot;/tmp.txt&quot;, &quot;This is in a file&quot;);
  println!(&quot;File content is {}&quot;, read_file(&quot;/tmp.txt&quot;));
  del_file(&quot;/tmp.txt&quot;);
}

pub fn get_random_i32() -&gt; i32 {
  let x: i32 = random();
  return x;
}

pub fn get_random_bytes() -&gt; Vec&lt;u8&gt; {
  let mut rng = thread_rng();
  let mut arr = [0u8; 128];
  rng.fill(&amp;mut arr[..]);
  return arr.to_vec();
}

pub fn echo(content: &amp;str) -&gt; String {
  println!(&quot;Printed from wasi: {}&quot;, content);
  return content.to_string();
}

pub fn print_env() {
  println!(&quot;The env vars are as follows.&quot;);
  for (key, value) in env::vars() {
    println!(&quot;{}: {}&quot;, key, value);
  }

  println!(&quot;The args are as follows.&quot;);
  for argument in env::args() {
    println!(&quot;{}&quot;, argument);
  }
}

pub fn create_file(path: &amp;str, content: &amp;str) {
  let mut output = File::create(path).unwrap();
  output.write_all(content.as_bytes()).unwrap();
}

pub fn read_file(path: &amp;str) -&gt; String {
  let mut f = File::open(path).unwrap();
  let mut s = String::new();
  match f.read_to_string(&amp;mut s) {
    Ok(_) =&gt; s,
    Err(e) =&gt; e.to_string(),
  }
}

pub fn del_file(path: &amp;str) {
  fs::remove_file(path).expect(&quot;Unable to delete&quot;);
}
</code></pre>
<p>你可以通过下面的命令行将应用程序构建到一个 wasm 字节码文件中。</p>
<pre><code>rustwasmc build
</code></pre>
<p>wasm 字节码文件 <a href="https://github.com/second-state/wasm-learning/blob/master/ssvm/wasi/wasi_example_main.wasm">在这里。</a> </p>
<h2><a class="header" href="#为-wasm-app-构建并发布一个-docker-hub-镜像" id="为-wasm-app-构建并发布一个-docker-hub-镜像">为 Wasm app 构建并发布一个 Docker Hub 镜像</a></h2>
<p>您现在可以将整个 wasm 字节码文件发布到 Docker hub 中，就好像这是一个 Docker 镜像一样。</p>
<p>首先，在  <code>pkg/</code> 目录中创建一个 Dockerfile，如下所示。</p>
<pre><code>FROM scratch
ADD wasi_example_main.wasm .
CMD [&quot;wasi_example_main.wasm&quot;]
</code></pre>
<p>创建一个镜像并发布到 Docker hub。</p>
<pre><code>sudo buildah bud -f Dockerfile -t wasm-wasi-example
sudo buildah push wasm-wasi-example docker://registry.example.com/repository:tag

# Example: the following command publishes the wasm image to the public Docker hub under user account &quot;hydai&quot;
sudo buildah push wasm-wasi-example docker://docker.io/hydai/wasm-wasi-example:latest
</code></pre>
<p>现在，你可以使用 Docker 工具（例如 <code>crictl</code>）将发布的 wasm 文件拉为镜像。 下面是我们发布的 wasm 文件镜像的示例。</p>
<pre><code>sudo crictl pull docker.io/hydai/wasm-wasi-example
</code></pre>
<h2><a class="header" href="#使用-cri-o-启动-wasm-app" id="使用-cri-o-启动-wasm-app">使用 CRI-O 启动 Wasm app</a></h2>
<p>要启动并运行 wasm 文件，您需要为 CRI-O 创建两个配置文件。 创建一个 <code>container_wasi.json</code> 文件，如下所示。 它告诉 CRI-O 运行时应该从 Docker 存储库的哪里提取 wasm 文件映像。</p>
<pre><code>{
  &quot;metadata&quot;: {
    &quot;name&quot;: &quot;podsandbox1-wasm-wasi&quot;
  },
  &quot;image&quot;: {
    &quot;image&quot;: &quot;hydai/wasm-wasi-example:latest&quot;
  },
  &quot;args&quot;: [
    &quot;wasi_example_main.wasm&quot;, &quot;50000000&quot;
  ],
  &quot;working_dir&quot;: &quot;/&quot;,
  &quot;envs&quot;: [],
  &quot;labels&quot;: {
    &quot;tier&quot;: &quot;backend&quot;
  },
  &quot;annotations&quot;: {
    &quot;pod&quot;: &quot;podsandbox1&quot;
  },
  &quot;log_path&quot;: &quot;&quot;,
  &quot;stdin&quot;: false,
  &quot;stdin_once&quot;: false,
  &quot;tty&quot;: false,
  &quot;linux&quot;: {
    &quot;resources&quot;: {
      &quot;memory_limit_in_bytes&quot;: 209715200,
      &quot;cpu_period&quot;: 10000,
      &quot;cpu_quota&quot;: 20000,
      &quot;cpu_shares&quot;: 512,
      &quot;oom_score_adj&quot;: 30,
      &quot;cpuset_cpus&quot;: &quot;0&quot;,
      &quot;cpuset_mems&quot;: &quot;0&quot;
    },
    &quot;security_context&quot;: {
      &quot;namespace_options&quot;: {
        &quot;pid&quot;: 1
      },
      &quot;readonly_rootfs&quot;: false,
      &quot;capabilities&quot;: {
        &quot;add_capabilities&quot;: [
          &quot;sys_admin&quot;
        ]
      }
    }
  }
}
</code></pre>
<p>接下来，创建一个 <code>sandbox_config.json</code> 文件，如下所示。 它定义了运行 wasm 应用程序的沙箱环境。</p>
<pre><code>{
  &quot;metadata&quot;: {
    &quot;name&quot;: &quot;podsandbox12&quot;,
    &quot;uid&quot;: &quot;redhat-test-crio&quot;,
    &quot;namespace&quot;: &quot;redhat.test.crio&quot;,
    &quot;attempt&quot;: 1
  },
  &quot;hostname&quot;: &quot;crictl_host&quot;,
  &quot;log_directory&quot;: &quot;&quot;,
  &quot;dns_config&quot;: {
    &quot;searches&quot;: [
      &quot;8.8.8.8&quot;
    ]
  },
  &quot;port_mappings&quot;: [],
  &quot;resources&quot;: {
    &quot;cpu&quot;: {
      &quot;limits&quot;: 3,
      &quot;requests&quot;: 2
    },
    &quot;memory&quot;: {
      &quot;limits&quot;: 50000000,
      &quot;requests&quot;: 2000000
    }
  },
  &quot;labels&quot;: {
    &quot;group&quot;: &quot;test&quot;
  },
  &quot;annotations&quot;: {
    &quot;owner&quot;: &quot;hmeng&quot;,
    &quot;security.alpha.kubernetes.io/seccomp/pod&quot;: &quot;unconfined&quot;
  },
  &quot;linux&quot;: {
    &quot;cgroup_parent&quot;: &quot;pod_123-456.slice&quot;,
    &quot;security_context&quot;: {
      &quot;namespace_options&quot;: {
        &quot;network&quot;: 0,
        &quot;pid&quot;: 1,
        &quot;ipc&quot;: 0
      },
      &quot;selinux_options&quot;: {
        &quot;user&quot;: &quot;system_u&quot;,
        &quot;role&quot;: &quot;system_r&quot;,
        &quot;type&quot;: &quot;svirt_lxc_net_t&quot;,
        &quot;level&quot;: &quot;s0:c4,c5&quot;
      }
    }
  }
}
</code></pre>
<p>现在可以创建一个 CRI-O pod 如下：</p>
<pre><code># 创建 POD，输出将会和示例不同。
sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# 设置一个辅助变量供以后使用。
POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
</code></pre>
<p>自 pod ，您可以创建一个容器以隔离方式运行 wasm 字节码程序。</p>
<pre><code># 创建容器实例，输出将会和示例不同。
sudo crictl create $POD_ID container_wasi.json sandbox_config.json
1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>最后，启动容器并查看 wasm 应用程序的输出。</p>
<pre><code># 列出容器，状态应该是 `Created`
sudo crictl ps -a

CONTAINER           IMAGE                           CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:latest   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 启动容器
sudo crictl start 1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f

# 再次检查容器状态。#如果容器没有完成工作，你会看到运行状态。 #因为这个例子很小。此时您可能会看到 Exited。
sudo crictl ps -a
CONTAINER           IMAGE                           CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:latest   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 当容器完成。你能看到状态变为 Exited。
sudo crictl ps -a
CONTAINER           IMAGE                           CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:latest   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# 查看容器记录 
sudo crictl logs 1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f

Test 1: 打印随机数
Random number: 960251471

Test 2: 打印随机字节
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: 调用 echo 函数
Printed from wasi: This is from a main function
This is from a main function

Test 4: 打印环境变量
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: 创建文件 `/tmp.txt` 包含内容 `This is in a file`

Test 6: 从之前文件读取内容
File content is This is in a file

Test 7: 删除之前文件
</code></pre>
<h2><a class="header" href="#下一步-1" id="下一步-1">下一步</a></h2>
<p>在本文中，我们看到了如何使用类似 Docker 的 CRI-O 工具启动、运行和管理 WasmEdge 应用程序。</p>
<p>我们的下一步是使用 Kubernetes 来管理 WasmEdge 容器。 为此，我们需要在 Kubernetes 中安装一个 runner 二进制文件，以便它可以同时支持常规 Docker 镜像和 wasm 字节码镜像。</p>
<h2><a class="header" href="#second-state-介绍" id="second-state-介绍">Second State 介绍</a></h2>
<p>Second State 专注 WebAssembly 生态，其开源项目 <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> 已经成为 CNCF 沙箱项目。WasmEdge 是为边缘计算优化的 mission critical、实时、轻量级、高性能软件执行环境（也称 runtime 或者虚拟机）。</p>
<h1><a class="header" href="#华为--如何定制-rust-clippy" id="华为--如何定制-rust-clippy">华为 | 如何定制 Rust Clippy</a></h1>
<p>作者：华为可信软件工程和开源2012实验室</p>
<hr />
<h2><a class="header" href="#clippy-是什么" id="clippy-是什么">Clippy 是什么</a></h2>
<p>Clippy 是 Rust 官方提供的 代码检查 lint 工具，通过静态分析，来检查代码中有问题或不符合指定规范的代码。</p>
<p>项目地址：<a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a> </p>
<h3><a class="header" href="#安装" id="安装">安装</a></h3>
<blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rustup component add clippy
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<h3><a class="header" href="#使用" id="使用">使用</a></h3>
<blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo clippy
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<h3><a class="header" href="#配置" id="配置">配置</a></h3>
<p>可以在项目中添加 <code>clippy.toml</code> 或 <code>.clippy.toml</code> 来指定使用的 Lints 。</p>
<p>类似于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>avoid-breaking-exported-api = false
blacklisted-names = [&quot;toto&quot;, &quot;tata&quot;, &quot;titi&quot;]
cognitive-complexity-threshold = 30
<span class="boring">}
</span></code></pre></pre>
<p>Cargo Clippy 中目前包含<a href="https://rust-lang.github.io/rust-clippy/master/index.html">超过 450 个 Lint</a> 。</p>
<h3><a class="header" href="#rust-编译器内置-lint-介绍" id="rust-编译器内置-lint-介绍">Rust 编译器内置 Lint 介绍</a></h3>
<p>在 Rust 编译器 中 lint 包含四种级别：</p>
<ul>
<li>allow ，编译器</li>
<li>warn</li>
<li>deny</li>
<li>forbid</li>
</ul>
<p>每个 lint 都有一个 默认级别。下面是一个分类：</p>
<ul>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#allowed-by-default-lints">默认允许的  Lints</a> : 默认情况下，编译器允许的 Lints 。</li>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html">默认警告Lints</a> : 默认情况下，编译器会警告的 LInts 。</li>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html">默认拒绝的  Lints</a> ： 默认情况下，编译器会拒绝的lints。</li>
</ul>
<p>编译器内置 Lint 主要是围绕 Rust 语言特性。开发者可以通过配置文件来修改 Lints 等级。</p>
<h3><a class="header" href="#clippy-中的-lints" id="clippy-中的-lints">Clippy 中的 Lints</a></h3>
<p><strong>Clippy 中的 Lints 级别包括：</strong></p>
<ul>
<li>Allow</li>
<li>Warn</li>
<li>Deny</li>
<li>Deprecated</li>
</ul>
<p><strong>Clippy 中的 lints 分类如下表：</strong></p>
<table><thead><tr><th>分类</th><th>描述</th><th>默认级别</th></tr></thead><tbody>
<tr><td><code>clippy::all</code></td><td>all lints that are on by default (correctness, style, complexity, perf)<br />所有默认的 Lints 都会被开启（正确性、风格、复杂性、性能）</td><td><strong>warn/deny</strong></td></tr>
<tr><td><code>clippy::correctness</code></td><td>code that is outright wrong or very useless<br />代码是完全错误或根本无用的</td><td><strong>deny</strong></td></tr>
<tr><td><code>clippy::style</code></td><td>code that should be written in a more idiomatic way<br />代码应该用更惯用的方式来写</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::complexity</code></td><td>code that does something simple but in a complex way<br />代码把简单的事情写复杂了</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::perf</code></td><td>code that can be written to run faster<br />代码的写法在性能上还可以改进</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::pedantic</code></td><td>lints which are rather strict or might have false positives<br />这些 lints 相当严格或可能有误报</td><td>allow</td></tr>
<tr><td><code>clippy::nursery</code></td><td>new lints that are still under development<br />仍然在开发中的新 lints</td><td>allow</td></tr>
<tr><td><code>clippy::cargo</code></td><td>lints for the cargo manifest<br />用于cargo manifest 的 lints</td><td>allow</td></tr>
</tbody></table>
<p>总的来说，Clippy 对代码的检查主要是包括下面五个方面：</p>
<ul>
<li>
<p>代码正确性（Correctness）。检查代码中不正确的写法。</p>
</li>
<li>
<p>代码风格（Style）。相比于 rustfmt，clippy 更偏向于代码实践中的惯用法检查。</p>
</li>
<li>
<p>代码复杂性（Complexity）。检查过于复杂的写法，用更简洁的写法代替。</p>
</li>
<li>
<p>代码不灵动 （Pedantic）。写法过于教条。</p>
</li>
<li>
<p>代码性能（Perf）。</p>
</li>
</ul>
<p><strong>代码正确性</strong></p>
<p>Lint 示例：  <a href="https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons">absurd_extreme_comparisons</a> (荒谬的极值比较)</p>
<blockquote>
<p>检查关系中的一方是其类型的最小值或最大值的比较，如果涉及到永远是真或永远是假的情况，则发出警告。只有整数和布尔类型被检查。</p>
</blockquote>
<p>代码示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec: Vec&lt;isize&gt; = Vec::new();
if vec.len() &lt;= 0 {}
if 100 &gt; i32::MAX {} // 这里会报错：Deny ，因为 100 不可能大于 i32::MAX
<span class="boring">}
</span></code></pre></pre>
<p><strong>代码风格</strong></p>
<p>Lint 示例： <a href="https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants">assertions_on_constants</a> （对常量的断言）</p>
<blockquote>
<p>用于检查 assert!(true) 和 assert!(false)  的情况。</p>
</blockquote>
<p>代码示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(false)
assert!(true)
const B: bool = false;
assert!(B) // 会被编译器优化掉。
<span class="boring">}
</span></code></pre></pre>
<p><strong>代码复杂性</strong></p>
<p>Lint 示例：  <a href="https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map">bind_instead_of_map</a></p>
<blockquote>
<p>检查 <code>_.and_then(|x| Some(y))</code>, <code> _.and_then(|x| Ok(y))</code> or <code>_.or_else(|x| Err(y))</code> 这样的用法，建议使用更简洁的写法 <code>_.map(|x| y)</code> or <code>_.map_err(|x| y) </code>。</p>
</blockquote>
<p>代码示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// bad
let _ = opt().and_then(|s| Some(s.len()));
let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });
let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });

// good
let _ = opt().map(|s| s.len());
let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });
let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });
<span class="boring">}
</span></code></pre></pre>
<p><strong>代码不灵动</strong></p>
<p>Lints 示例： <a href="https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless">cast_lossless</a></p>
<blockquote>
<p>用于检查可以被安全转换（conversion）函数替代的数字类型之间的转换（ cast ）。</p>
</blockquote>
<p><code>as</code>强制转换与<code>From</code>转换从根本上不同。 <code>From</code>转换是“<strong>简单</strong>和安全”，而<code>as</code>强制转换纯粹是“安全”。在考虑数字类型时，仅在保证输出相同的情况下才存在<code>From</code>转换，即，不会丢失任何信息(不会出现截断或下限或精度下降)。 <code>as</code>强制转换没有此限制。</p>
<p>代码示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// bad
fn as_u64(x: u8) -&gt; u64 {
    x as u64
}

// good
fn as_u64(x: u8) -&gt; u64 {
    u64::from(x) // from内部其实也是as，但只要是实现 from 的，都是无损转换，在代码可读性、语义上更好
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>代码性能</strong></p>
<p>Lints 示例： <a href="https://rust-lang.github.io/rust-clippy/master/#append_instead_of_extend">append_instead_of_extend</a></p>
<blockquote>
<p>检查动态数组中是否出现 <code>extend</code>，建议使用 <code>append</code>代替。</p>
</blockquote>
<p>代码示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = vec![1, 2, 3];
let mut b = vec![4, 5, 6];

// Bad
a.extend(b.drain(..));

// Good
a.append(&amp;mut b); // 用 append 代替 extend 更加高效和简洁。
<span class="boring">}
</span></code></pre></pre>
<p>还有一些其他分类，比如包括一些「约束性（Restriction）」建议、对 cargo.toml 的检查、以及正在开发中的Lints 等。</p>
<h3><a class="header" href="#如何定制-clippy-lint" id="如何定制-clippy-lint">如何定制 Clippy Lint</a></h3>
<p><strong>定制 Clippy Lint 有两种办法：</strong></p>
<ol>
<li>方法一：fork <a href="https://github.com/rust-lang/rust-clippy">rust-clippy</a> 项目，自己维护。因为使用了不稳定的接口，所以维护和使用不太方便。</li>
<li>方法二：使用第三方  <a href="https://github.com/trailofbits/dylint">Dylint</a> 工具。维护自定义 lint 比方法一更方便。</li>
</ol>
<h4><a class="header" href="#方法一fork-clippy" id="方法一fork-clippy">方法一：fork clippy</a></h4>
<p>在 fork Clippy 定制自己的 LInt 之前，还需要了解 Clippy 的 工作机制。</p>
<h5><a class="header" href="#clippy-工作机制" id="clippy-工作机制">Clippy 工作机制</a></h5>
<p><img src="chapter_6/./image/clippy/clippy.png" alt="clippy" /></p>
<p>Clippy 通过 <code>rust_driver</code> 和 <code>rustc_interface</code> 这两个库，可以把 <code>rustc</code> 作为库来调用。</p>
<p><code>rustc_driver</code> 本质上就像是整个<code>rustc</code> 编译器的<code>main函数</code>（入口）。它使用在<code>rustc_interface crate</code>中定义的接口以正确的顺序运行编译器。</p>
<p><code>rustc_interface crate</code>为外部用户提供了一个（未稳定的）API，用于在编译过程中的特定时间运行代码，允许第三方（例如<code>RLS</code>或<code>rustdoc</code>）有效地使用<code>rustc</code>的内部结构作为分析<code>crate</code> 或 模拟编译器过程的库。</p>
<p>对于那些使用 <code>rustc</code> 作为库的人来说，<code>rustc_interface::run_compiler() </code>函数是进入编译器的主要入口。它接收一个编译器的配置和一个接收编译器的闭包。<code>run_compiler</code>从配置中创建一个编译器并将其传递给闭包。在闭包中，你可以使用编译器来驱动查询，以编译一个 crate 并获得结果。这也是 <code>rustc_driver</code> 所做的。</p>
<p><code>rustc_interface</code> 组件库中定义了<code>Compiler</code> 结构体，持有 <code>register_lints</code> 字段。该 <code>Compiler</code>结构体就是编译器会话实例，可以通过它传递编译器配置，并且运行编译器。</p>
<p><code>register_lints</code> 是 持有 <code>LintStore</code> 可变借用的闭包，其类型签名是 <code>Option&lt;Box&lt;dyn Fn(&amp;Session, &amp;mut LintStore) + Send + Sync&gt;&gt;</code>。</p>
<p><code>LintStore</code> 是 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_lint/src/context.rs#L55">rustc_lint</a> 组件库中定义的类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LintStore {
    /// Registered lints.
    lints: Vec&lt;&amp;'static Lint&gt;,

    // 构造不同种类的 lint pass
    /// Constructor functions for each variety of lint pass.
    ///
    /// These should only be called once, but since we want to avoid locks or
    /// interior mutability, we don't enforce this (and lints should, in theory,
    /// be compatible with being constructed more than once, though not
    /// necessarily in a sane manner. This is safe though.)
    pub pre_expansion_passes: Vec&lt;Box&lt;dyn Fn() -&gt; EarlyLintPassObject + sync::Send + sync::Sync&gt;&gt;,
    pub early_passes: Vec&lt;Box&lt;dyn Fn() -&gt; EarlyLintPassObject + sync::Send + sync::Sync&gt;&gt;,
    pub late_passes: Vec&lt;Box&lt;dyn Fn() -&gt; LateLintPassObject + sync::Send + sync::Sync&gt;&gt;,
    /// This is unique in that we construct them per-module, so not once.
    pub late_module_passes: Vec&lt;Box&lt;dyn Fn() -&gt; LateLintPassObject + sync::Send + sync::Sync&gt;&gt;,

    /// Lints indexed by name.
    by_name: FxHashMap&lt;String, TargetLint&gt;,

  	// lint group，通过一个名字触发多个警告，把lint分组
    /// Map of registered lint groups to what lints they expand to.
    lint_groups: FxHashMap&lt;&amp;'static str, LintGroup&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>可以注册的 <code>lint pass</code> 还分好几类：</p>
<ul>
<li>early_passes：表示该类型的 <code>lint pass</code>对应的是 <code>EarlyContext</code>，是在 AST 层级的 lint 检查，还未到 HIR 层面。</li>
<li>late_passes：表示该类型的 <code>lint pass</code>对应的是 <code>LateContext</code>，是在 类型检查之后的 lint 检查。意味着这样的检查需要获取类型信息。类型检查是在 HIR 层级做的。</li>
</ul>
<p>在 <code>rust_interface</code> 中，还定义了相应的 check 方法：<a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_lint/src/passes.rs#L156">early_lint_methods! 定义的很多check方法</a> 和 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_lint/src/passes.rs#L12">late_lint_methods</a>。</p>
<p>声明一个 <code>lint pass</code> 需要使用 <code>declare_late_lint_pass!</code> 宏 中定义的 <code>rustc_lint::LateLintPass trait</code>。</p>
<p>再来看 <code>run_compiler</code>函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn run_compiler&lt;R: Send&gt;(mut config: Config, f: impl FnOnce(&amp;Compiler) -&gt; R + Send) -&gt; R {
    tracing::trace!(&quot;run_compiler&quot;);
    let stderr = config.stderr.take();
    util::setup_callbacks_and_run_in_thread_pool_with_globals(
        config.opts.edition,
        config.opts.debugging_opts.threads,
        &amp;stderr,
        || create_compiler_and_run(config, f), // 设置一个回调函数
    )
}

// 回调函数
pub fn create_compiler_and_run&lt;R&gt;(config: Config, f: impl FnOnce(&amp;Compiler) -&gt; R) -&gt; R {
    let registry = &amp;config.registry;
    let (mut sess, codegen_backend) = util::create_session(
        config.opts,
        config.crate_cfg,
        config.diagnostic_output,
        config.file_loader,
        config.input_path.clone(),
        config.lint_caps,
        config.make_codegen_backend,
        registry.clone(),
    );
    // 。。。省略
  	let compiler = Compiler {
        sess,
        codegen_backend,
        input: config.input,
        input_path: config.input_path,
        output_dir: config.output_dir,
        output_file: config.output_file,
        register_lints: config.register_lints, // 配置 register_lints
        override_queries: config.override_queries,
    };

}
<span class="boring">}
</span></code></pre></pre>
<p>再看看 <code>rustc_driver</code>库，其中定义了 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_driver/src/lib.rs#L84"><code>Callbacks trait</code></a> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Callbacks {
    /// Called before creating the compiler instance
    fn config(&amp;mut self, _config: &amp;mut interface::Config) {}
    /// Called after parsing. Return value instructs the compiler whether to
    /// continue the compilation afterwards (defaults to `Compilation::Continue`)
    fn after_parsing&lt;'tcx&gt;(
        &amp;mut self,
        _compiler: &amp;interface::Compiler,
        _queries: &amp;'tcx Queries&lt;'tcx&gt;,
    ) -&gt; Compilation {
        Compilation::Continue
    }
    /// Called after expansion. Return value instructs the compiler whether to
    /// continue the compilation afterwards (defaults to `Compilation::Continue`)
    fn after_expansion&lt;'tcx&gt;(
        &amp;mut self,
        _compiler: &amp;interface::Compiler,
        _queries: &amp;'tcx Queries&lt;'tcx&gt;,
    ) -&gt; Compilation {
        Compilation::Continue
    }
    /// Called after analysis. Return value instructs the compiler whether to
    /// continue the compilation afterwards (defaults to `Compilation::Continue`)
    fn after_analysis&lt;'tcx&gt;(
        &amp;mut self,
        _compiler: &amp;interface::Compiler,
        _queries: &amp;'tcx Queries&lt;'tcx&gt;,
    ) -&gt; Compilation {
        Compilation::Continue
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>该trait中定义了在编译不同阶段要执行的回调函数。</p>
<p>所以，在 Clippy 的 <code>driver.rs</code> 中就做了如下定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClippyCallbacks {
    clippy_args_var: Option&lt;String&gt;,
}

// 为 ClippyCallbacks 实现 rustc_driver::Callbacks ，定义 config 方法
// 该 config 方法创建编译器实例之前被执行的
impl rustc_driver::Callbacks for ClippyCallbacks {
    fn config(&amp;mut self, config: &amp;mut interface::Config) {
        let previous = config.register_lints.take();
        let clippy_args_var = self.clippy_args_var.take();
        config.parse_sess_created = Some(Box::new(move |parse_sess| {
            track_clippy_args(parse_sess, &amp;clippy_args_var);
        }));
        // 注册 lints
        config.register_lints = Some(Box::new(move |sess, lint_store| {
            // technically we're ~guaranteed that this is none but might as well call anything that
            // is there already. Certainly it can't hurt.
            if let Some(previous) = &amp;previous {
                (previous)(sess, lint_store);
            }

            let conf = clippy_lints::read_conf(sess);
            clippy_lints::register_plugins(lint_store, sess, &amp;conf);
            clippy_lints::register_pre_expansion_lints(lint_store);
            clippy_lints::register_renamed(lint_store);
        }));

        // FIXME: #4825; This is required, because Clippy lints that are based on MIR have to be
        // run on the unoptimized MIR. On the other hand this results in some false negatives. If
        // MIR passes can be enabled / disabled separately, we should figure out, what passes to
        // use for Clippy.
        config.opts.debugging_opts.mir_opt_level = Some(0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>所以，Clippy 通过 <code>ClippyCallbacks </code> 的 <code>config</code> 来注册 lints 。在 <code>config</code> 函数内部，通过调用 <code>clippy_lints::read_conf(sess)</code> 来读取 clippy 配置文件里的lint。在 <code>clippy_lints</code> 里还定义了 <a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lib.rs#L426">register_plugins</a>，使用 <code>rustc_lint::LintStore</code> 来注册 clippy 里定义的 lints。</p>
<p>以上就是 Clippy 的工作机制。</p>
<h5><a class="header" href="#自定义-clippy-lints" id="自定义-clippy-lints">自定义 Clippy lints</a></h5>
<p>通过了解 Clippy 工作机制，可以看得出来，如果要自定义 Clippy lints，是需要严重依赖 <code>rustc</code> 版本的，因为 <code>rustc_interface</code> 提供的接口并不稳定。所以维护成本比较高。</p>
<p>如果一定要通过这种方式自定义 Clippy lints ，需要按以下步骤开发。</p>
<h6><a class="header" href="#安装配置-clippy" id="安装配置-clippy"><strong>安装配置 Clippy</strong></a></h6>
<ol>
<li>下载 Clippy 源码。</li>
<li>执行 <code>cargo build</code> 和 <code>cargo test</code> 。因为Clippy 测试套件非常大，所以可以只测试部分套件，比如，<code>cargo uitest</code>，或 <code>cargo test --test dogfood</code>。如果 UITest 和预期不符，可以使用 <code>cargo dev bless</code>更新相关文件。</li>
<li>Clippy 提供了一些开发工具，可以通过 <code>cargo dev --help</code> 查看。</li>
</ol>
<blockquote>
<p>UI测试的目的是捕捉编译器的完整输出，这样我们就可以测试演示的所有方面。</p>
</blockquote>
<p>测试正常的话，修改Clippy 生成二进制的名字，防止影响我们开发环境中安装的 Clippy命令。</p>
<ol>
<li>在 <code>Cargo.toml</code>中修改 </li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[[bin]]
name = &quot;cargo-myclippy&quot; // 此处原本是 &quot;cargo-clippy&quot;
test = false
path = &quot;src/main.rs&quot;

[[bin]]
name = &quot;clippy-mydriver&quot; //  此处原本是 &quot;clippy-mydriver&quot;
path = &quot;src/driver.rs&quot;
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>修改 <code>src/main.rs</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_file_name(&quot;clippy-mydriver&quot;); // 将使用 `clippy-driver` 的地方修改为 `clippy-mydriver`
<span class="boring">}
</span></code></pre></pre>
<h6><a class="header" href="#起一个有意义的名字" id="起一个有意义的名字"><strong>起一个有意义的名字</strong></a></h6>
<p>定义 lints 需要先起一个符合<a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints"> Lints 命名规范</a> 的名字。</p>
<p>Lints 命名规范的首要原则就是：lint 名字要有意义。比如 <code>allow dead_code</code>，这是有意义的，但是<code>allow unsafe_code</code>这个就有点过分了。</p>
<p>具体来说，有几条注意事项：</p>
<ol>
<li>Lint 名称应该标明被检查的「坏东西」。比如 <code>deprecated</code>，所以，<code>#[allow(deprecated)](items)</code>是合法的。但是 <code>ctypes</code>就不如<code>improper_ctypes</code> 更明确。</li>
<li>命名要简洁。比如 <code>deprecated</code>，就比 <code>deprecated_item</code>更简洁。</li>
<li>如果一个 lint 应用于特定的语法，那么请使用复数形式。比如使用 <code>unused_variables</code>而不是<code>unused_variable</code>。</li>
<li>捕捉代码中不必要的、未使用的或无用的方面的行文应该使用术语<code>unused</code>，例如<code>unused_imports</code>、<code>unused_typecasts</code>。</li>
<li>lint 命名请使用蛇形（snake case）命名，与函数名的方式相同。</li>
</ol>
<h6><a class="header" href="#设置样板代码" id="设置样板代码"><strong>设置样板代码</strong></a></h6>
<p>假如新的 lint 叫 <code>foo_functions</code>，因为该lint不需要用到类型信息（比如某结构体是否实现 Drop），所以需要定义 EarlyLintPass。</p>
<p>在 Clippy 项目根目录下，通过以下命令创建 Lint:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo dev new_lint --name=foo_functions --pass=early --category=pedantic
<span class="boring">}
</span></code></pre></pre>
<p>如果没有提供 category ，则默认是 nursery 。</p>
<p>执行完该命令以后，在 <code>Clippy-lint/src/</code> 目录下就会多一个 <code>foo_functions.rs </code>的文件，文件中包含了样板代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_lint::{EarlyLintPass, EarlyContext};
use rustc_session::{declare_lint_pass, declare_tool_lint};
use rustc_ast::ast::*;

// 此宏用于定义 lint
declare_clippy_lint! {
    /// **What it does:**
    ///
    /// **Why is this bad?**
    ///
    /// **Known problems:** None.
    ///
    /// **Example:**
    ///
    /// ```rust
    /// // example code where clippy issues a warning
    /// ```
    /// Use instead:
    /// ```rust
    /// // example code which does not raise clippy warning
    /// ```
    pub FOO_FUNCTIONS, // lint 名字大写
    pedantic, // lint 分类
    &quot;default lint description&quot; // lint 描述
}

// 定义 lint pass。 注意，lint 和 lint pass 并不一定成对出现
declare_lint_pass!(FooFunctions =&gt; [FOO_FUNCTIONS]);

// 因为不需要使用类型信息，此处实现 EarlyLintPass
impl EarlyLintPass for FooFunctions {}


<span class="boring">}
</span></code></pre></pre>
<p>除了此文件，还会创建 <code>test/ui/foo_functions.rs</code> 测试文件。</p>
<p>接下来，需要执行 <code> cargo dev update_lints</code> 命令来注册新 lint。</p>
<h6><a class="header" href="#添加-lint-pass-内容" id="添加-lint-pass-内容"><strong>添加 Lint pass 内容</strong></a></h6>
<p>先来写一些测试代码。</p>
<p>Clippy使用UI测试进行测试。UI测试检查Clippy的输出是否与预期完全一致。每个测试都是一个普通的Rust文件，包含我们要检查的代码。Clippy的输出与一个.stderr文件进行比较。注意，你不需要自己创建这个文件，我们将进一步讨论生成.stderr文件。</p>
<p>我们首先打开在test/ui/foo_functions.rs创建的测试文件。</p>
<p>用一些例子来更新该文件，以便开始使用。</p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::foo_functions)]

// Impl methods
struct A;
impl A {
    pub fn fo(&amp;self) {}
    pub fn foo(&amp;self) {}
    pub fn food(&amp;self) {}
}

// Default trait methods
trait B {
    fn fo(&amp;self) {}
    fn foo(&amp;self) {}
    fn food(&amp;self) {}
}

// Plain functions
fn fo() {}
fn foo() {}
fn food() {}

fn main() {
    // We also don't want to lint method calls
    foo();
    let a = A;
    a.foo();
}
</code></pre></pre>
<p>可以使用 <code>TESTNAME=foo_functions cargo uitest</code>来执行测试。</p>
<p>可以看到输出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test [ui] ui/foo_functions.rs ... ok
<span class="boring">}
</span></code></pre></pre>
<p>接下来，打开 <code>src/foo_functions.rs</code> 编写 Lint 代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_clippy_lint! {
    /// **What it does:**
    ///
    /// **Why is this bad?**
    ///
    /// **Known problems:** None.
    ///
    /// **Example:**
    ///
    /// ```rust
    /// // example code
    /// ```
    pub FOO_FUNCTIONS,
    pedantic, // 该类型的lint 等级 默认是 Allow
    &quot;function named `foo`, which is not a descriptive name&quot; // 修改 lint 声明的描述内容
}
<span class="boring">}
</span></code></pre></pre>
<p>可以通过执行 <code>cargo dev serve</code>在本地打开网页服务，可以查到 <code>foo_functions</code>显示的描述。</p>
<p><img src="chapter_6/./image/clippy/foo-fn.png" alt="foo-fn" /></p>
<p>`<code>Pedantic</code>的默认lint 等级是<code>allow\</code>，定义于 <a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lib.rs#L119">https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lib.rs#L119</a></p>
<p>通常在声明了lint之后，我们必须运行<code>cargo dev update_lints</code> 来更新一些文件，以便 Clippy 知道新的 Lint。由于上面是用<code>cargo dev new_lint ... </code>命令来生成lint声明，所以这是自动完成的。</p>
<p>虽然 update_lints自动完成了大部分工作，但它并没有自动完成所有工作。我们必须在<code>clippy_lints/src/lib.rs</code>的<code>register_plugins</code>函数中手动注册我们的<code>lint pass</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span> 
<span class="boring">fn main() {
</span>pub fn register_plugins(store: &amp;mut rustc_lint::LintStore, sess: &amp;Session, conf: &amp;Conf) {
    // 此处省略 2000 行代码
		// foo_functions
    store.register_early_pass(|| box foo_functions::FooFunctions);

}
<span class="boring">}
</span></code></pre></pre>
<p>该函数有 2000 多行代码，维护起来可想而知多么麻烦了。</p>
<p>因为此 lint pass 只是检查函数名字，不涉及类型检查，所以只需要 AST 层面的处理即可。关于 EarlyLintPass 和 LateLintPass 的区别前文已经介绍过。EarlyLintPass 比 LateLintPass 更快一些，然而 Clippy 的性能并不是关注的重点。</p>
<p>由于我们在检查函数名时不需要类型信息，所以在运行新的lint自动化时，我们使用了<code>--pass=early</code>，所有的样板导入都相应地被添加了。</p>
<p>下一步就可以实现 Lint 的检查逻辑了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/foo_functions.rs 
impl EarlyLintPass for FooFunctions {
  	// 此处 check_fn 是内置 EarlyLintPass trait 包含方法，前文介绍过
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        // TODO: Emit lint here 此处编写检查逻辑
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>对于如何检查函数名字，在 <code>clippy_utils/src/diagnostics.rs</code>中定义了一些帮助函数。经过查找，<code>span_lint_and_help</code>函数在此处使用比较适合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/foo_functions.rs 
use clippy_utils::diagnostics::span_lint_and_help;
use rustc_span::Span;
use rustc_ast::{ast::NodeId, visit::FnKind};

impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        span_lint_and_help(
            cx,
            FOO_FUNCTIONS,
            span,
            &quot;function named `foo`&quot;,
            None,
            &quot;consider using a more meaningful name&quot;
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>执行测试代码，输出如下：</p>
<p><img src="chapter_6/./image/clippy/uitest.jpeg" alt="uitest" /></p>
<p><img src="chapter_6/./image/clippy/uitest2.jpeg" alt="uitest2" /></p>
<p>诊断信息是有效果了，但是缺乏一些lint检测逻辑。所以进一步修改：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        // 增加判断逻辑
        fn is_foo_fn(fn_kind: FnKind&lt;'_&gt;) -&gt; bool {
            match fn_kind {
                FnKind::Fn(_, ident, ..) =&gt; {
                    // check if `fn` name is `foo`
                    ident.name.as_str() == &quot;foo&quot;
                }
                // ignore closures
                FnKind::Closure(..) =&gt; false
            }
        }
        // 增加判断逻辑
        if is_foo_fn(fn_kind) {
            span_lint_and_help(
                cx,
                FOO_FUNCTIONS,
                span,
                &quot;function named `foo`&quot;,
                None,
                &quot;consider using a more meaningful name (考虑使用一个更有意义的函数名字)&quot;
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>再次执行测试输出：</p>
<p><img src="chapter_6/./image/clippy/uitest3.png" alt="uitest3" /></p>
<p>接下来执行：</p>
<ol>
<li><code>cargo dev bless</code> 更新 <code>.stderr</code>文件。这个 <code>.stderr</code>文件是需要提交的。如果测试出现错误，记得执行这一步。</li>
<li><code>cargo test</code>。</li>
</ol>
<p>执行 <code>cargo test</code> 失败，因为 clippy 不允许出现 中文描述。所以，修改：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if is_foo_fn(fn_kind) {
    span_lint_and_help(
      cx,
      FOO_FUNCTIONS,
      span,
      &quot;function named `foo`&quot;,
      None,
      &quot;consider using a more meaningful name (考虑使用一个更有意义的函数名字)&quot; // 此处不允许中文，当然你也可以修改 clippy 自身的 lint 配置
    );
}

// 修改为

if is_foo_fn(fn_kind) {
    span_lint_and_help(
      cx,
      FOO_FUNCTIONS,
      span,
      &quot;function named `foo`&quot;,
      None,
      &quot;consider using a more meaningful name&quot;
    );
}

<span class="boring">}
</span></code></pre></pre>
<p>测试成功。</p>
<p>最后执行 <code>cargo dev fmt</code>，格式化代码。</p>
<p>到目前为止，自定义 clippy lint 已经完成。</p>
<h6><a class="header" href="#测试-clippy-lint-效果" id="测试-clippy-lint-效果">测试 Clippy lint 效果</a></h6>
<p>因为我们自定义的 Clippy 二进制名字已经被修改了，所以可以直接安装，不怕和已安装的clippy有冲突了。</p>
<p>执行以下命令安装自定义的Clippy:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo install --bin=cargo-myclippy --bin=clippy-mydriver --path=.
<span class="boring">}
</span></code></pre></pre>
<p>然后重新使用 <code>cargo new clippytest</code>创建一个新项目。</p>
<p>将 <code>src/main.rs</code>修改为：</p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::foo_functions)]

// Impl methods
struct A;
impl A {
    pub fn fo(&amp;self) {}
    pub fn foo(&amp;self) {}
    pub fn food(&amp;self) {}
}

// Default trait methods
trait B {
    fn fo(&amp;self) {}
    fn foo(&amp;self) {}
    fn food(&amp;self) {}
}

// Plain functions
fn fo() {}
fn foo() {}
fn food() {}

fn main() {
    // We also don't want to lint method calls
    foo();
    let a = A;
    a.foo();
}
</code></pre></pre>
<p>【如有必要】然后在 <code>clippytest</code>项目目录下创建 <code>rust-toolchain</code> 文件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[toolchain]
channel = &quot;nightly-2021-06-17&quot;
components = [&quot;llvm-tools-preview&quot;, &quot;rustc-dev&quot;, &quot;rust-src&quot;]
<span class="boring">}
</span></code></pre></pre>
<p>这个文件里的配置，要和 官方 rust-clippy 下一致，也就是你fork的那个原项目。</p>
<p>然后命令行执行：<code>cargo myclippy</code>，输出：</p>
<p><img src="chapter_6/./image/clippy/myclippy.png" alt="myclippy" /></p>
<p>成功！</p>
<p>然后回去 <code>src/main.rs</code>中，将 <code>#![warn(clippy::foo_functions)]</code> 改为 <code>#![error(clippy::foo_functions)]</code>，再次执行 <code>cargo myclippy</code>，输出：</p>
<p><img src="chapter_6/./image/clippy/myclippy-error.jpeg" alt="myclippy-error" /></p>
<p>成功！</p>
<p>到此为止，自定义 Clippy Lint 成功！</p>
<h6><a class="header" href="#小结-6" id="小结-6">小结</a></h6>
<p>通过 fork clippy，完全可以定制自己的 Lint 。但是也有很明显的缺陷：</p>
<ol>
<li>Clippy 内置 lint 很多，需要手工注册自定义lint，想想那个 2000 行的函数就头疼。</li>
<li>Clippy 依赖 rustc_interface 是未稳定的 API 。<strong>clippy_utils</strong> 里提供的helper方法也是依赖于编译器这个未稳定接口，这样不同编译器版本就会难以兼容。导致不能通用。</li>
<li>需要命名为自己的 Clippy 二进制文件，避免和原本的 Clippy 冲突。</li>
</ol>
<p>如果自定义 Lint 可以 PR 更好，但并不是所有自定义 Lint 都可以提交到官方 PR ，必然需要维护自己的/团队的特殊场景的 Lint。就会面对上面的缺陷。</p>
<p>有没有更好的办法呢？</p>
<h4><a class="header" href="#方法二使用-dylint" id="方法二使用-dylint">方法二：使用 Dylint</a></h4>
<p>参考：<a href="https://www.trailofbits.com/post/write-rust-lints-without-forking-clippy">Write Rust lints without forking Clippy</a></p>
<p>社区有人开发了一个工具：  <a href="https://github.com/trailofbits/dylint">Dylint</a> 。它的特点：</p>
<ol>
<li>以动态库的方式来提供 lint 。而 Clippy 是静态库。Clippy 的所有 lint 都使用相同的编译器版本，因此只需要 <code>rustc_driver</code> 。</li>
<li>Dylint 用户可以选择从不同编译器版本的库中加载 lint。</li>
</ol>
<p><img src="chapter_6/./image/clippy/dylint.png" alt="dylint" /></p>
<p>Dylint 可以动态构建 <code>rustc_driver</code>。换句话说，如果用户想要 A 版本的编译器库中加载 lint，并且找不到 A 版本的 <code>rustc_driver</code>，Dylint 将构建一个新的 A 版本的<code>rustc_driver</code>。<code>rustc_driver</code>缓存在用户的主目录中，因此仅在必要时重建它们。</p>
<p>Dylint 根据它们使用的编译器版本对库进行分组，使用相同编译器版本的库一起加载，并和它们的 lint 一起运行。这允许在 lint 之间共享中间编译结果(如：符号解析，类型检查，trait求解等)。</p>
<p>在上图中，如果库 U 和 V 都使用了 A 版本的编译器，这两个库将被放到同一个分组中。A 版本编译器的<code>rustc_driver</code>将只被调用一次。<code>rustc_driver</code>在将控制权移交给 Rust 编译器之前会在库 U 和库 V 中注册 lint。</p>
<h6><a class="header" href="#安装和配置" id="安装和配置">安装和配置</a></h6>
<p>通过下面命令安全 dylint：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo install cargo-dylint
cargo install dylint-link
<span class="boring">}
</span></code></pre></pre>
<p>然后获取模版项目：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>git clone https://github.com/trailofbits/dylint-template
<span class="boring">}
</span></code></pre></pre>
<p>或者使用 <code>cargo-generate</code>来创建模版</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo generate --git https://github.com/trailofbits/dylint-template
<span class="boring">}
</span></code></pre></pre>
<p>将项目命名为 ：<code>mylints</code></p>
<p>然后进入到项目根目录，执行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo build
cargo dylint fill_me_in --list
<span class="boring">}
</span></code></pre></pre>
<h6><a class="header" href="#编写-lint" id="编写-lint">编写 lint</a></h6>
<p>因为生成的模版其实和 上面 fork clippy 自定义生成的代码模版类似，所以直接将上面的 lint 代码复制过来。</p>
<p>创建新文件 <code>src/foo_functions.rs</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::diagnostics::span_lint_and_help;
use rustc_ast::{ast::NodeId, visit::FnKind};
use rustc_lint::{EarlyContext, EarlyLintPass};
use rustc_span::Span;
use rustc_lint::LateLintPass;
use rustc_session::{declare_lint, declare_lint_pass};

declare_lint! {
    /// **What it does:**
    ///  检查 以 foo 命名的函数，并给予警告
    /// **Why is this bad?**
    ///    因为该命名没有意义
    /// **Known problems:** None.
    ///
    /// **Example:**
    ///
    /// ```rust
    /// // example code where clippy issues a warning
    /// ```
    /// Use instead:
    ///   考虑使用一个更有意义的函数名字
    /// ```rust
    /// // example code which does not raise clippy warning
    /// ```
    pub FOO_FUNCTIONS,
    Warn, //  注意：这里和  fork Clippy 略有不同
    &quot;function named `foo`, which is not a descriptive name&quot;
}

declare_lint_pass!(FooFunctions =&gt; [FOO_FUNCTIONS]);


impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        fn is_foo_fn(fn_kind: FnKind&lt;'_&gt;) -&gt; bool {
            match fn_kind {
                FnKind::Fn(_, ident, ..) =&gt; {
                    // check if `fn` name is `foo`
                    ident.name.as_str() == &quot;foo&quot;
                },
                // ignore closures
                FnKind::Closure(..) =&gt; false,
            }
        }

        if is_foo_fn(fn_kind) {
            span_lint_and_help(
                cx,
                FOO_FUNCTIONS,
                span,
                &quot;function named `foo`&quot;,
                None,
                &quot;consider using a more meaningful name&quot;,
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>代码复制完毕之后，在 <code>src/lib.rs</code> 中添加：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo_functions;

#[no_mangle]
pub fn register_lints(_sess: &amp;rustc_session::Session, lint_store: &amp;mut rustc_lint::LintStore) {
    lint_store.register_lints(&amp;[foo_functions::FOO_FUNCTIONS]);
    lint_store.register_early_pass(|| Box::new(foo_functions::FooFunctions));
}
<span class="boring">}
</span></code></pre></pre>
<p>注意：需要配置当前项目下 <code>.cargo/config.toml</code> 中针对当前架构平台的 target 指定的链接器，否则会报 找不到库 之类的错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[target.aarch64-apple-darwin]
linker = &quot;dylint-link&quot;

[target.x86_64-apple-darwin]
linker = &quot;dylint-link&quot;

[target.x86_64-unknown-linux-gnu]
linker = &quot;dylint-link&quot;
<span class="boring">}
</span></code></pre></pre>
<p>然后执行 <code>cargo build</code> 编译成功。</p>
<p>接下来需要设置几个环境变量：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>export MY_LINTS_PATH=/Work/Projects/myworkspace/mylints
export DYLINT_LIBRARY_PATH=$MY_LINTS_PATH/target/debug
<span class="boring">}
</span></code></pre></pre>
<p>然后执行 <code>cargo test</code>。可以看到 uitest 的输出。</p>
<p>但是 dylint 有个缺点，就是 uitest 无法像 clippy那样（<code>cargo dev bless</code>） 更新引用。所以 cargo test 会测试失败。</p>
<p>但是可以在 <code>src/lib.rs</code> 中，添加：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>然后在 mylints项目下执行： <code>cargo dylint --all</code> 。就能看到 lint 生效了。</p>
<p>以上是我们编写了独立的 lints。</p>
<h6><a class="header" href="#测试独立项目" id="测试独立项目">测试独立项目</a></h6>
<p>随便创建一个 新的项目 <code>myproject</code>，将 <code>src/main.rs</code> 换成和前面测试 clippy 时候用的代码。</p>
<p>基于前面设置好的 mylints ，我们只需要直接使用 <code>cargo dylint --all </code> 命令即可。</p>
<p>然后在该项目根目录下执行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo dylint --all -- --manifest-path=/Work/Projects/myproject/Cargo.toml
<span class="boring">}
</span></code></pre></pre>
<p>然后就可以正常执行 lint 检测了。</p>
<h6><a class="header" href="#小结-7" id="小结-7"><strong>小结</strong></a></h6>
<p>使用 dylint 比较麻烦的是，文档不是很全，测试不支持更新引用，不如 fork clippy 方便测试。</p>
<p>但是 dylint 确实比较小巧，只需要维护我们自定义的lint 即可，不再需要维护 2000 多行的注册lint代码。</p>
<p>使用 dylint 的时候，因为也依赖了 clippy 的 clippy_utils，所以需要和 clippy 的 rustc 版本保持一致。</p>
<h4><a class="header" href="#总结-15" id="总结-15">总结</a></h4>
<p>上面总结了两种定制 Clippy Lints 的方法，各有优劣。</p>
<p>一个观点：</p>
<ul>
<li>
<p>第一种方法比较适合 大公司/大团队，因为第一种方法比较完善，功能齐备，只是需要一个专门的团队来维护这个 lints。并且还有可能给上游去发 PR （如果需要），形成正向反馈，让工具更加完善。另外，也许可以给 Clippy 提供一个 Plugin 机制，方便维护定制的 Lint。</p>
</li>
<li>
<p>第二种方法适合小团队，没有多余的人力去维护，只需要定制自己的一些 lints 使用即可。</p>
</li>
</ul>
<p>欢迎在评论区留言交流。</p>
<h3><a class="header" href="#有用的参考资源" id="有用的参考资源">有用的参考资源：</a></h3>
<p>以下资源对你编写 lint 将很有帮助：</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md">添加一个新的 lint</a> (针对 Clippy 但依然很有用)</li>
<li><a href="https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md">编写 lint 的常用工具</a></li>
<li><a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_hir/index.html">rustc_hir 文档</a></li>
</ul>
<h1><a class="header" href="#定制静态分析-lint-检查规则" id="定制静态分析-lint-检查规则">定制静态分析 lint 检查规则</a></h1>
<p>作者: 吴翱翔@pymongo / 后期编辑： 张汉东</p>
<blockquote>
<p>原文: <a href="https://pymongo.github.io/#/2021/06/custom_rust_lint.md">custom Rust lint</a></p>
</blockquote>
<p>需求: vscode-ra 的 tfn 会生成 <code>fn feature</code> 的函数，我希望静态分析能帮我检查出来，不让 feature 函数提交到 github 上</p>
<h2><a class="header" href="#静态分析的可行性" id="静态分析的可行性">静态分析的可行性</a></h2>
<p>由于 Intellij-Rust 是用 kotlin 写的，好处是不依赖 rustc，坏处暂时还不能分析 rustc 源码</p>
<p>由于做静态分析/过程宏/编译原理相关的研究都需要深入研究编译器源码，所以我只考虑用 Rust 静态分析 Rust 代码的解决方案，不考虑 Intellij-Rust</p>
<ul>
<li>过程宏: 被过程宏标记的函数可以在编译时进行AST静态分析，但是每个函数都得打上标记很不方便</li>
<li>改 rustc 源码: 例如 <a href="https://github.com/rust-lang/rust/pull/61883/files">non_ascii_idents lint</a>，但 rustc 编译太慢</li>
<li>cargo clippy: 改 clippy 源码后可以 <code>cargo install</code> 编译成 cargo 子命令</li>
<li>cargo dylint: 可行性待考察</li>
</ul>
<h2><a class="header" href="#lint-对公司的重大意义" id="lint-对公司的重大意义">lint 对公司的重大意义</a></h2>
<p>例如公司团队禁止项目代码使用递归调用，因为 Rust 对非线性递归的优化有限，而且递归用的不好容易爆栈导致生产服务器 panic</p>
<p>但毕竟有很多用 Rust 算法实现时用到了递归，所以不可能提 PR 让 clippy 官方加入「禁止递归」的 lint</p>
<p>如果让公司人工 code review 有没有递归代码，不仅效率低而且不能保证 100% 准确</p>
<p>这时候如果把自定义的 lint 加到公司的 CI/CD 流程中，就能自动检测不符合公司 coding_style 的代码</p>
<p><img src="chapter_6/./image/clippy/static_analysis_custom_clippy_lint.png" alt="" /></p>
<h2><a class="header" href="#cargo-lint-可执行文件" id="cargo-lint-可执行文件">cargo-lint 可执行文件</a></h2>
<p>为了跟 clippy 的可执行文件命名区分，我把 fork 的 clippy 代码做出以下改动:</p>
<pre><code>diff --git a/Cargo.toml b/Cargo.toml
index 9b5d9b2ad..17e13950d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -12,13 +12,15 @@ publish = false
 [[bin]]
-name = &quot;cargo-clippy&quot;
+name = &quot;cargo-lint&quot;
 
 [[bin]]
-name = &quot;clippy-driver&quot;
+name = &quot;lint-driver&quot;
 
 [dependencies]
diff --git a/src/main.rs b/src/main.rs
index 7bb80b119..3df9e40d5 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -107,7 +107,7 @@ impl ClippyCmd {
-            .with_file_name(&quot;clippy-driver&quot;);
+            .with_file_name(&quot;lint-driver&quot;);
</code></pre>
<p>首先 clippy 需要 cargo-clippy 和 clippy-driver 两个可执行文件，所以我是通过以下方式安装 cargo-lint 的:</p>
<blockquote>
<p>cargo install --bin=cargo-lint --bin=lint-driver --path=.</p>
</blockquote>
<h2><a class="header" href="#添加新的-lint" id="添加新的-lint">添加新的 lint</a></h2>
<p>参考: <a href="https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md#setup">addling_lints</a>的文档</p>
<p><code>cargo dev</code>是 clippy 项目的 cargo alias，可以通过 cargo dev 创建新的 lint</p>
<blockquote>
<p>cargo dev new_lint --name=my_lint_function_name_is_feature --pass=early --category=correctness</p>
</blockquote>
<pre><code>diff --git a/clippy_lints/src/lib.rs b/clippy_lints/src/lib.rs
index f5082468a..005f99895 100644
--- a/clippy_lints/src/lib.rs
+++ b/clippy_lints/src/lib.rs
@@ -276,6 +276,7 @@ mod mut_mutex_lock;
 mod mutex_atomic;
+mod my_lint_function_name_is_feature;
 mod needless_arbitrary_self_type;
@@ -822,6 +823,7 @@ pub fn register_plugins(store: &amp;mut rustc_lint::LintStore, sess: &amp;Session, conf:
         mutex_atomic::MUTEX_INTEGER,
+        my_lint_function_name_is_feature::my_lint_function_name_is_feature,
@@ -1345,6 +1347,7 @@ pub fn register_plugins(store: &amp;mut rustc_lint::LintStore, sess: &amp;Session, conf:
         LintId::of(mutex_atomic::MUTEX_ATOMIC),
+        LintId::of(my_lint_function_name_is_feature::my_lint_function_name_is_feature),
@@ -1702,6 +1705,7 @@ pub fn register_plugins(store: &amp;mut rustc_lint::LintStore, sess: &amp;Session, conf:
         LintId::of(mut_key::MUTABLE_KEY_TYPE),
+        LintId::of(my_lint_function_name_is_feature::my_lint_function_name_is_feature),
</code></pre>
<p>新增了两个文件:</p>
<ol>
<li>clippy_lints/src/my_lint_function_name_is_feature.rs</li>
<li>tests/ui/my_lint_function_name_is_feature.rs</li>
</ol>
<p>改动了一个文件: clippy_lints/src/lib.rs</p>
<p>但是这样会把 <code>CHANGELOG.md</code> 改掉，也把 <code>clippy_lints/src/lib.rs</code> 改掉，导致我很难合并 clippy upstream 的改动</p>
<h2><a class="header" href="#lint-的单元测试" id="lint-的单元测试">lint 的单元测试</a></h2>
<p>我将我的 lint 命名为: my_lint_function_name_is_feature</p>
<p>所以单元测试的重点是只有函数名是 feature 时，才会报错，如果变量名是 feature 则不会</p>
<blockquote>
<p>TESTNAME=my_lint_function_name_is_feature cargo uitest</p>
</blockquote>
<p><code>cargo dev bless</code>会将上次运行的<code>cargo uitest</code>的错误生成为<code>my_lint_function_name_is_feature.stderr</code>文件</p>
<p>这时候报错: error: unknown lint: <code>clippy::my_lint_function_name_is_feature</code></p>
<h2><a class="header" href="#unknown-lint" id="unknown-lint">Unknown lint</a></h2>
<p>clippy 的 CONTRIBUTE.md 的 <code>How clippy works</code> 和 <code>Syncing changes between Clippy and rust-lang/rust</code></p>
<p>章节提醒 clippy 跟 rustc 版本似乎是强绑定的，要等 rust 更新 clippy 子仓库后才能让新的 lint 生效?</p>
<p>2021-06-19 clippy 加入的 lint <code>nonstandard_macro_braces</code> 用 2021-06-16 的 rustc 就会报错 <code>Unknown lint</code></p>
<p>由于用 clippy 添加新的 lint 时各种报错读了几遍文档依然没解决，所以我寻求更可行的静态分析方案</p>
<h2><a class="header" href="#cargo-dylint" id="cargo-dylint">cargo dylint</a></h2>
<p>由于 Rust 自定义 lint 静态分析检查的资料很少，我搜索全网只能找到这篇文章: <a href="https://www.trailofbits.com/post/write-rust-lints-without-forking-clippy">https://www.trailofbits.com/post/write-rust-lints-without-forking-clippy</a></p>
<p>幸运的是 cargo dylint 跟 clippy/rustc 新增 lint 的写法完全一样，看 rustc 的学习资料足以学习 dylint</p>
<p>首先需要安装 dylint 工具以及 dylint 的 linker:</p>
<blockquote>
<p>cargo install cargo-dylint dylint-link</p>
</blockquote>
<h2><a class="header" href="#dylint-模板" id="dylint-模板">dylint 模板</a></h2>
<p>虽然 dylint 跟 clippy 极其相似，但还是建议学习下 dylint 的示例</p>
<ol>
<li><a href="https://github.com/trailofbits/dylint-template">dylint-template</a></li>
<li>dylint 代码仓库下 examples 每个示例都可以参考下</li>
<li>我基于 path_separator 改的模板: <a href="https://github.com/pymongo/my_lints">https://github.com/pymongo/my_lints</a></li>
</ol>
<p><strong>⚠注意由于 dylint 工作原理跟 clippy 相似，所以 dylint/rustc/clippy_utils 三者的版本必须互相兼容</strong></p>
<p>修改 rustc 或 clippy 版本很可能让 dylint 编译失败或不生效，<strong>不要轻易修改依赖版本</strong>!</p>
<h2><a class="header" href="#dylint-运行方法" id="dylint-运行方法">dylint 运行方法</a></h2>
<p>假设我们自定义 lint 的源码文件夹目录是 MY_LINTS_PATH</p>
<blockquote>
<p>export MY_LINTS_PATH=/home/w/repos/my_repos/my_lints</p>
</blockquote>
<p>假设公司项目代码的路径是 /home/w/temp/other_rust_project</p>
<p><strong>⚠注意!: 如果发现新加的 lint 不生效，那就 cargo clean 清理下 MY_LINTS_PATH 再重新编译</strong></p>
<p>¶ 1. 在自己写 lint 的文件夹运行 dylint</p>
<blockquote>
<p>cd $MY_LINTS_PATH</p>
<p>cargo dylint --all -- --manifest-path=/home/w/temp/other_rust_project/Cargo.toml</p>
</blockquote>
<p>¶ 2. 在项目文件夹内引入</p>
<blockquote>
<p>DYLINT_LIBRARY_PATH=$MY_LINTS_PATH/target/debug cargo dylint --all</p>
</blockquote>
<p>¶ 3. 在项目 Cargo.toml 中 package.metadata.dylint</p>
<p>该方法我一直报错: <code>Warning: No libraries were found</code>，故放弃</p>
<h2><a class="header" href="#earlylate-lint-的概念" id="earlylate-lint-的概念">early/late lint 的概念</a></h2>
<p>按照 <a href="https://rustc-dev-guide.rust-lang.org/overview.html">Overview of the Compiler - rustc-dev-guide</a> 的介绍</p>
<p>我把 Rust 编译过程大致概括为以下流程: </p>
<p>(rustc_args_and_env -rustc_driver-&gt; rustc_interface::Config)</p>
<ol>
<li>source_code_text(bytes) -rustc_lexer-&gt; TokenStream</li>
<li>TokenStream -rustc_parse-&gt; AST</li>
<li>AST analysis: macro_expand, name_resolution, feature_gating, checking/early_lint</li>
<li>AST convert to HIR</li>
<li>HIR analysis: type/trait checking, late_lint</li>
<li>HIR convert to MIR</li>
<li>MIR analysis: ownership/lifetime/borrow checking</li>
<li>MIR Optimizations</li>
<li>MIR convert to LLVM IR</li>
<li>LLVM backend compile LLVM IR to executable or library</li>
</ol>
<p>所以 early_lint 能分析 AST 代码， late_lint 则是分析 HIR 代码</p>
<p>宏和过程宏则是输入 token_stream ，宏输出则是展开后的 token_stream (参考 <a href="https://github.com/dtolnay/syn/blob/master/examples/heapsize/heapsize_derive/src/lib.rs">heapsize 过程宏</a>)</p>
<h2><a class="header" href="#dylint-添加新的-lint" id="dylint-添加新的-lint">dylint 添加新的 lint</a></h2>
<p>假设公司需要一个 lint，函数名字带 todo 的都要抛出警告</p>
<p>§ fn_name_contains_todo-step_1: 新建 lint 文件</p>
<p>我把这个 lint 命名为 fn_name_contains_todo，注意 lint 的命名不能跟 rustc 自带的 lint 冲突</p>
<p>首先复制我写的 dylint 简易模板: git clone https://github.com/pymongo/my_lints</p>
<p>然后在 src/ 目录下 新增一个 fn_name_contains_todo.rs 的文件</p>
<p>并且在 src/lib.rs 下加一行 <code>mod fn_name_contains_todo;</code> 加新文件加入到模块树中</p>
<p>§ fn_name_contains_todo-step_2: lint 实现</p>
<p>首先要在 fn_name_contains_todo.rs 中定义 lint 的结构体和常量，这步跟 clippy 创建新的 lint完全一样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rustc_session::declare_lint! {
    pub FN_NAME_CONTAINS_TODO,
    Warn,
    &quot;fn_name_contains_todo&quot;
}

rustc_session::declare_lint_pass!(FnNameContainsTodo =&gt; [FN_NAME_CONTAINS_TODO]);
<span class="boring">}
</span></code></pre></pre>
<p>由于分析变量名或函数名只需要 AST 就足够了，不需要带类型信息的 HIR，因此只用 early lint</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl rustc_lint::EarlyLintPass for FnNameContainsTodo {
    fn check_fn(
        &amp;mut self,
        cx: &amp;rustc_lint::EarlyContext&lt;'_&gt;,
        fn_kind: rustc_ast::visit::FnKind&lt;'_&gt;,
        span: rustc_span::Span,
        _: rustc_ast::NodeId,
    ) {
        // Ignore FnKind::Closure
        if let rustc_ast::visit::FnKind::Fn(_, ident, ..) = fn_kind {
            if ident.as_str().contains(&quot;todo&quot;) {
                clippy_utils::diagnostics::span_lint(
                    cx,
                    FN_NAME_CONTAINS_TODO,
                    span,
                    &quot;fn name with todo is not allow to commit&quot;,
                );
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>§ fn_name_contains_todo-step_3: 注册 lint</p>
<p>lint 的实现写完后，在 lib.rs 的 <code>pub fn register_lints</code> 内</p>
<ol>
<li>lint_store.register_lints 的入参数组内追加 fn_name_contains_todo::FN_NAME_CONTAINS_TODO</li>
<li>加入 early_pass 一行 lint_store.register_early_pass(|| Box::new(fn_name_contains_todo::FnNameContainsTodo));</li>
</ol>
<p>第二点很好理解，如果 lint 用了 EarlyLintPass 就加 register_early_pass，用了 LateLIntPass 就加 register_late_pass</p>
<p>⚠注意: lint_store.register_lints 加入的是 lint 常量， 而 lint_store.register_early_pass 则是传入 lint 结构体</p>
<p>于是重新编译代码后，新加的 lint 就生效了</p>
<p>§ fn_name_contains_todo-step_4: (可选) 测试 lint</p>
<p>粗糙的测试方法是，我们在 src/lib.rs 中加入以下内容:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
fn todo() {

}
<span class="boring">}
</span></code></pre></pre>
<p>然后运行 dylint 分析当前项目(也就是 lint 源码项目):</p>
<blockquote>
<p>cargo clean &amp;&amp; cargo b &amp;&amp; cargo dylint --all</p>
</blockquote>
<pre><code>    Checking my_lints v0.1.0 (/home/w/repos/my_repos/my_lints)
warning: fn name with todo is not allow to commit
  --&gt; src/lib.rs:26:1
   |
26 | / fn todo() {
27 | |
28 | | }
   | |_^
   |
   = note: `#[warn(fn_name_contains_todo)]` on by default

warning: 1 warning emitted
</code></pre>
<p>如果觉得 lib.rs 其他代码污染了 cargo expand 或者 TokenSteam/HIR 代码的展开</p>
<p>例如我只想看两个函数的HIR代码，那么可以新建一个 examples/fn_name_contains_todo.rs 文件或者用 --tests 指定静态分析的文件</p>
<p>例如 <code>cargo clean &amp;&amp; cargo b &amp;&amp; cargo dylint --all -- --examples</code></p>
<p>至于 ui 测试方法，建议去读 clippy 文档，本文不做演示</p>
<p>⚠注意!: 跑 ui 测试时不能加 RUST_LOG=info 日志级别的环境变量，否则会把日志输出导致测试比较失败</p>
<h2><a class="header" href="#禁止递归代码的-lint" id="禁止递归代码的-lint">禁止递归代码的 lint</a></h2>
<p>由于自己对 AST/HIR 解析不是很熟练，我参考了以下代码:</p>
<ul>
<li>rustc_lint::builtin::UNCONDITIONAL_RECURSION: 没找到实现代码(好像在MIR)</li>
<li>clippy 的 main_recursion lint</li>
</ul>
<p>仿照 main_recursion 不难写出静态分析检测递归的代码:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl rustc_lint::LateLintPass&lt;'_&gt; for MyLintRecursiveCode {
    fn check_expr_post(&amp;mut self, cx: &amp;rustc_lint::LateContext&lt;'_&gt;, expr: &amp;rustc_hir::Expr&lt; '_&gt;) {
        if let rustc_hir::ExprKind::Call(func_expr, _) = &amp;expr.kind {
            // 函数调用表达式 func_expr 的前一个函数调用**栈帧**函数的 defid
            let func_expr_owner_defid = func_expr.hir_id.owner.to_def_id();
            if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) = &amp;func_expr.kind {
                // path.res: The resolution of a path or export
                if let Some(func_expr_call_defid) = path.res.opt_def_id() {
                    if func_expr_owner_defid == func_expr_call_defid {
                        clippy_utils::diagnostics::span_lint(
                            cx,
                            MY_LINT_RECURSIVE_CODE,
                            expr.span,
                            &quot;our company forbid recursive code, Reference: company_code_style.pdf, page 17&quot;,
                        );
                    }
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>遗憾的是还不能检测a调用b且b调用a这种函数循环调用导致的无限递归</p>
<p>在 Rust 官方的 issue 57965, 70727 中也在讨论编译期要如何检测跨函数调用导致的无限递归</p>
<h2><a class="header" href="#更多的-lint-需求" id="更多的-lint-需求">更多的 lint 需求</a></h2>
<h3><a class="header" href="#f32_cast_to_f64" id="f32_cast_to_f64">f32_cast_to_f64</a></h3>
<p>公司业务上有个价格的参数需要保留两位小数，然后再从 f32 转换为 f64 进行传输，也就是 JavaScript 的 Number 类型</p>
<p>但是保留两位小数的 f32 转 f64 时会精度丢失: <code>0.1_f32 as f64 = 0.10000000149011612</code></p>
<p>但这是浮点数 IEEE 标准的正常行为，用 C/C++ 进行 float -&gt; double 的转换也会出现一样的问题</p>
<p>目前 Rust 浮点数的 lint 只有大小比较、i32 as f32 等 lint 并没有业务需要的这种精度丢失检测</p>
<p>所以很有必要根据自身业务定制一些浮点数的 lint ，避免前端展示的浮点数出现异常情况</p>
<hr />
<h2><a class="header" href="#结束语" id="结束语">结束语</a></h2>
<p>得益于 强大的调试宏 dbg! 和 AST/HIR 优秀的结构体设计，像作者这样非计算机专业没学过编译原理课程的水平也能轻松定制静态分析</p>
<p>本文的源码仓库: <a href="https://github.com/pymongo/my_lints">https://github.com/pymongo/my_lints</a> ，欢迎大家能贡献代码检查的需求或想法</p>
<h1><a class="header" href="#无需-fork-clippy-就可以编写-rust-lints" id="无需-fork-clippy-就可以编写-rust-lints">无需 fork Clippy 就可以编写 Rust lints</a></h1>
<p><a href="https://www.trailofbits.com/post/write-rust-lints-without-forking-clippy">原文</a></p>
<p>本文主要介绍 <a href="https://github.com/trailofbits/dylint">Dylint</a>，它是一个可以从动态库中加载 Rust lints 规则的工具。Dylint 可以让开发人员轻松维护自己的个人 lint 集合。</p>
<p>在此之前，编写一个新的 Rust lint 的最简单的方式就是 fork <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>，它是 Rust 事实上的 (de facto) lint 工具。但是这种方式在运行或维护新 lint 时存在缺陷 (drawback)。Dylint 最大程度的减少了这方面的干扰 (distraction)，让开发者可以专注于编写 lint。</p>
<p>首先，我们将回顾 (go over) Rust linting 的当前状态以及 Clippy 的工作原理。然后，我们将解释 Dylint 是如何改善现状 (quo) 并提供一些关于如何开始使用它的提示。如果你想直接编写 lint，请跳到最后一节。</p>
<h3><a class="header" href="#rust-linting-和-clippy" id="rust-linting-和-clippy">Rust linting 和 Clippy</a></h3>
<p>Clippy 等工具利用了 Rust 编译器对 linting 的专用支持。Rust linter 的核心组件(即“驱动程序”)可以链接到对应的库 (rustc_driver) 中。通过这种方式，驱动程序本质上是对 Rust 编译器做了封装。</p>
<p>为了运行 linter，环境变量 <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-reads">RUSTC_WORKSPACE_WRAPPER</a> 需要指向驱动程序并运行<code>cargo check</code>。Cargo 会注意到该环境变量已被赋值并调用该驱动程序，而不是调用 <strong>rustc</strong>。当驱动程序被调用时，它在 Rust 编译器中的 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Config.html">Config</a> 结构体中设置了一个 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Config.html#structfield.register_lints">callback</a>。该 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Config.html#structfield.register_lints">callback</a> 注册了一些 lint，它们将会与 Rust <a href="https://doc.rust-lang.org/rustc/lints/listing/index.html">内置的 lint</a> 一起运行。</p>
<p>Clippy 执行一些<a href="https://github.com/rust-lang/rust-clippy/blob/12fce557669a0de230399cf8e6eee4f5307bf87b/src/driver.rs#L329-L338">检查</a>以确保它已被启用，否则将以上述方式进行工作。(关于 Clippy 架构，请参阅图 1)。尽管它在安装之后人们对它的认识依旧不是那么的清晰，但是 Clippy 实际上有两个二进制文件：一个 Cargo 命令以及一个 <strong>rustc</strong> 驱动。你可以输入以下命令进行验证：</p>
<pre><code class="language-console">which cargo-clippy
which clippy-driver
</code></pre>
<center><img alt="dylint1" src="chapter_6/../image/dylint1.png"/></center>
<center><span style="font-size: 1em">图 1：Clippy 架构</span></center>
<p>现在假设你想编写自己的 lint。你该怎么办？你需要一个驱动程序来运行它们，而 Clippy 有一个驱动程序，因此 fork Clippy 看起来是一个合理的步骤。但是这个解决方案有一些缺陷，即 (namely) 运行和维护你将开发的 lint。</p>
<p>首先，你的 fork 将拥有两个二进制文件的副本，确保它们可以被找到是一件很麻烦 (hassle) 的事情。你必须确保至少 cargo 命令在你的<code>PATH</code>中，并且你可能必须将二进制文件重命名，以保证它们不会干扰 Clippy。虽然这些问题不是难以克服 (insurmountable)，但你可能会选择尽量避免它们。</p>
<p>其次，所有的 lint (包括 Clippy 的 lint) 都是在 <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_lint/index.html#note">unstable</a> 编译器 API 之上构建的。一起编译的 lint 必须使用相同版本的 API。为了理解为什么会出现这个问题，我们将参考 <a href="https://github.com/rust-lang/rust-clippy/tree/master/clippy_utils">clippy_utils</a> - Clippy 作者慷慨地公开的一组实用程序。请注意，<strong>clippy_utils</strong> 使用与 lint 相同的编译器 API，并且同样不提供稳定性保证(参见下文)。</p>
<p>假设你已经 fork Clippy，然后你希望添加一个新的 lint。很显然，你希望新的 lint 使用最新版本 <strong>clippy_utils</strong>。但是假设 <strong>clippy_utils</strong> 使用的编译器版本是 B，而你 fork 的 Clippy 使用的编译器版本是 A。然后你将面临一个困境 (dilemma)：你应该使用一个旧版本的 <strong>clippy_utils</strong> (使用的 A 版本的编译器)还是将 fork 中所有 lint 更新到 B 版本的编译器？两者都不是理想的选择。</p>
<p>Dylint 同时解决了这两个问题。首先，它提供了一个 Cargo 命令，使你不必管理多个这样的命令。其次，对于 Dylint，lint 是在一起编译的以生成动态库。因此在上述情况下，你可以简单地将新的 lint 存储在使用B 版本的编译器的新动态库中。你可以根据需要将这个新库与现有库一起使用，如果你愿意的话，可以将现有库升级到更新的库的编译器版本。</p>
<p>Dylint 提供了与重用中间编译结果相关的额外好处。要理解它，我们需要了解 Dylint 的工作原理。</p>
<h3><a class="header" href="#dylint-的工作原理" id="dylint-的工作原理">Dylint 的工作原理</a></h3>
<p>和 Clippy 一样，Dylint 提供了一个 cargo 命令。可以指定用户想要加载 lint 的动态库。Dylint 以确保在将控制权移交给 Rust 编译器之前注册 lint 的方式运行<code>cargo check</code>。</p>
<p>然而，Dylint 的 lint 注册过程比 Clippy 更复杂。Clippy 的所有 lint 都使用相同的编译器版本，因此只需要一个驱动程序。但是 Dylint 用户可以选择从不同编译器版本的库中加载 lint。</p>
<p>Dylint 按需即时 (on-the-fly) 构建驱动程序来处理此类情况。换句话说，如果用户想要 A 版本的编译器库中加载 lint，并且找不到 A 版本的驱动程序，Dylint 将构建一个新的 A 版本的驱动程序。驱动程序缓存在用户的主目录中，因此仅在必要时重建它们。</p>
<center><img alt="dylint1" src="chapter_6/../image/dylint2.png"/></center>
<center><span style="font-size: 1em">图 2：Dylint 架构</span></center>
<p>这给我们带来了上面暗指 (alluded to) 的额外好处。Dylint 根据它们使用的编译器版本对库进行分组，使用相同编译器版本的库一起加载，并在它们的 lint 一起运行。这允许在 lint 之间共享中间编译结果(如：符号解析，类型检查，特征求解等)。</p>
<p>举个例子，在图 2 中，如果库 U 和 V 都使用了 A 版本的编译器，这两个库将被放到同一个分组中。A 版本编译器的驱动程序将只被调用一次。驱动程序在将控制权移交给 Rust 编译器之前会在库 U 和库 V 中注册 lint。</p>
<p>为了理解为什么这种方式更好，可以做如下思考。假设 lint 由编译器驱动程序(而不是动态库)直接存储，并回顾一下驱动程序本质上是 Rust 编译器的封装。因此，如果在使用相同编译器版本的两个编译器的驱动程序中有两个 lint，则在同一代码上运行这两个驱动程序将等同于该代码进行了两次编译。通过将 lint 存储在动态库中并按照编译器版本对它们进行分组，Dylint 避免了这些低效的操作。</p>
<h3><a class="header" href="#应用特定项目的-lint" id="应用特定项目的-lint">应用：特定项目的 lint</a></h3>
<p>你是否知道 Clippy 包含 lint，其唯一目的是对 Clippy 的代码进行 lint？<a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/internal_lints.rs">这是真的</a>。Clippy 包含用于检查的 lint，例如：每个 lint 都有一个关联的 <strong>LintPass</strong>，它使用某些 Clippy 封装函数而不是它们自己封装的函数，并且每个 lint 都有一个非默认的描述。将这些 lint 应用于 Clippy 以外的代码是没有意义的。但是没有规定所有 lint 都必须是通用的，Clippy 就利用了这一点。</p>
<p>Dylint 包含 lint 的主要目的是对 Dylint 的代码进行 lint。例如：在开发 Dylint 时，我们发现自己编写了如下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rustup_toolchain = std::env::var(&quot;RUSTUP_TOOLCHAIN&quot;)?;
...
std::env::remove_var(&quot;RUSTUP_TOOLCHAIN&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>这么做不是很好。为什么？因为我们对字符串字面量进行 fat-fingered 只是时间问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::env::remove_var(&quot;RUSTUP_TOOLCHIAN&quot;); // Oops
<span class="boring">}
</span></code></pre></pre>
<p>更好的方法是使用常量而不是字符串字面量，就如下代码所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RUSTUP_TOOLCHAIN: &amp;str = &quot;RUSTUP_TOOLCHAIN&quot;;
...
std::env::remove_var(RUSTUP_TOOLCHAIN);
<span class="boring">}
</span></code></pre></pre>
<p>因此当使用 Dylint 时，我们编写了一个 lint 来检查这种不适当的做法并提出适当的建议。我们将该 lint 应用到 Dylint 源码。lint 称其为 <a href="https://github.com/trailofbits/dylint/tree/master/examples/env_literal">env_literal</a>，其当前的核心实现如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for EnvLiteral {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, expr: &amp;Expr&lt;'_&gt;) {
        if_chain! {
            if let ExprKind::Call(callee, args) = expr.kind;
            if is_expr_path_def_path(cx, callee, &amp;REMOVE_VAR)
            || is_expr_path_def_path(cx, callee, &amp;SET_VAR)
            || is_expr_path_def_path(cx, callee, &amp;VAR);
            if !args.is_empty();
            if let ExprKind::Lit(lit) = &amp;args[0].kind;
            if let LitKind::Str(symbol, _) = lit.node;
            let ident = symbol.to_ident_string();
            if is_upper_snake_case(&amp;ident);
            then {
            span_lint_and_help(
                cx,
                ENV_LITERAL,
                args[0].span,
                &quot;referring to an environment variable with a string literal is error prone&quot;,
                None,
                &amp;format!(&quot;define a constant `{}` and use that instead&quot;, ident),
            );
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以下是它可以产生的警告示例：</p>
<pre><code class="language-console">warning: referring to an environment variable with a string literal is error prone
--&gt; src/main.rs:2:27
|
2 |     let _ = std::env::var(&quot;RUSTFLAGS&quot;);
|                           ^^^^^^^^^^^
|
= note: `#[warn(env_literal)]` on by default
= help: define a constant `RUSTFLAGS` and use that instead
</code></pre>
<p>回顾之前所说的，编译器以及 <strong>clippy_utils</strong> 都没有为它的 API 提供稳定性保证，因此 <strong>env_literal</strong> 的未来版本可能看起来有点不同。(实际上，当本文还在撰写的过程中，<strong>clippy_utils</strong>  某个 API 的变更就已经导致 <strong>env_literal</strong> 某个实现发生改变!)。当前版本的 <strong>env_literal</strong> 总是可以在 Dylint 仓库中的 <a href="https://github.com/trailofbits/dylint/tree/master/examples">examples</a> 目录下找到。</p>
<p>但是 Clippy “自我 lint” 的方式与 Dylint 略有不同。Clippy 的内部 lint 被编译成启用了特定功能的 Clippy 版本。但是对于 Dylint，<strong>env_literal</strong> lint 被编译成了一个动态库。因此，<strong>env_literal</strong> 不是 Dylint 的一部分。它本质上是输入。</p>
<p>为什么这很重要？因为你可以为你的项目编写自定义 lint 并使用 Dylint 来运行它们，就像 Dylint 运行自己的 lint 一样。在 Dylint 仓库中 Dylint 运行的 lint 来源没有任何重要意义。Dylint 可以很轻易的在你的仓库中运行该仓库的 lint。</p>
<p>最重要的是 (The bottom line is this)：如果你发现不喜欢自己编写的代码，并且可以使用 lint 检测该代码，Dylint 可以帮助你清除该代码并防止重新引入。</p>
<h3><a class="header" href="#开始-linting" id="开始-linting">开始 linting</a></h3>
<p>使用以下命令安装 Dylint：</p>
<pre><code class="language-console">cargo install cargo-dylint
</code></pre>
<p>我们还推荐安装 <a href="https://github.com/trailofbits/dylint/tree/master/dylint-link">dylint-link</a> 来处理超链接：</p>
<pre><code class="language-console">cargo install dylint-link
</code></pre>
<p>编写 Dylint 库的最简单的方式是 fork <a href="https://github.com/trailofbits/dylint-template">dylint-template</a> 仓库。该仓库直接生成了一个可加载的库。你可以按如下方法进行验证：</p>
<pre><code class="language-console">git clone https://github.com/trailofbits/dylint-template
cd dylint-template
cargo build
cargo dylint fill_me_in --list
</code></pre>
<p>你只需实现 <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_lint/trait.LateLintPass.html">LateLintPass</a> 特征并容纳要求填写的符号即可。</p>
<p>以下资源对你编写 lint 将很有帮助：</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md">添加一个新的 lint</a> (针对 Clippy 但依然很有用)</li>
<li><a href="https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md">编写 lint 的常用工具</a></li>
<li><a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_hir/index.html">rustc_hir 文档</a></li>
</ul>
<p>也可以考虑使用上面提到的 <a href="https://github.com/rust-lang/rust-clippy/tree/master/clippy_utils">clippy_utils</a>。它包含许多底层任务的功能，如查找符号和打印诊断信息，可以让编写 lint 变得更加容易。</p>
<p>我们十分感谢 Clippy 作者将 <strong>clippy_utils</strong> 开放在 Rust
社区。我们也十分感谢 <a href="https://github.com/flip1995">Philipp Krones</a> 在本文的早期版本中提供了有用的建议。</p>
<h1><a class="header" href="#学习资源-2" id="学习资源-2">学习资源</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#programming-rust第二版已经官宣发行" id="programming-rust第二版已经官宣发行">《Programming Rust》第二版已经官宣发行</a></h2>
<p>摘要：</p>
<p>由O'Reilly出版的《Programming Rust》第二版的电子书和实体书都已经上市了：</p>
<ul>
<li>实体书直达链接： <a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/</a></li>
<li>电子书直达链接：<a href="https://www.ebooks.com/en-us/book/210313783/programming-rust/jim-blandy/">https://www.ebooks.com/en-us/book/210313783/programming-rust/jim-blandy/</a></li>
</ul>
<p>关于《Programming Rust》</p>
<p>《Programming Rust》是一本深入考察Rust语言设计思想以及如何将其应用于一系列系统编程问题的技术书籍。本书通过若干入门级的项目示例，深入研究了Rust语言具体的语言特性和各种特性相互作用的逻辑，从类型系统到如何根据类型系统建模现实中的问题，从unsafe rust的本质探讨、如何处理FFI外部函数调用到Rust异步编程等高级特性，无一不做到了深入浅出。</p>
<p>为什么编写第二版？</p>
<p>本书较之第一版，根据Rust编译器最新版本的特性完全进行了跟进，并且新增了一个详尽的讲述异步编程的机制和技巧的章节。 《Programming Rust》是一本适合想要了解Rust语言的C、C++、Python、Java或者其他语言的开发者，或者那些想要提升自己编程技巧的Rust编程人员的书籍。</p>
<h2><a class="header" href="#rust-in-action-新书发布" id="rust-in-action-新书发布">《Rust in Action》 新书发布</a></h2>
<ul>
<li><a href="https://www.manning.com/books/rust-in-action?a_aid=rust&amp;a_bid=0367c58f&amp;chan=github">Manning: Rust in Action</a></li>
<li><a href="https://github.com/rust-in-action/code">《Rust in Action》随书源码</a></li>
</ul>
<h2><a class="header" href="#新书使用-rust-进行系统编程" id="新书使用-rust-进行系统编程">新书：使用 Rust 进行系统编程</a></h2>
<p><a href="https://learning.oreilly.com/library/view/hands-on-systems-programming/9781098109424/">Hands-On Systems Programming with Rust</a></p>
<h2><a class="header" href="#rust-机器学习之书" id="rust-机器学习之书">Rust 机器学习之书</a></h2>
<p>由 Rust-ml 组织编写，目测正在完善中</p>
<p>该书内容目测是围绕 rust-ml/linfa 库，而/rust-ml/linfa 库 类似于 python  scikit-learn 库。</p>
<blockquote>
<p>scikit-learn，又写作sklearn，是一个开源的基于python语言的机器学习工具包。 它通过NumPy, SciPy和Matplotlib等python数值计算的库实现高效的算法应用，并且涵盖了几乎所有主流机器学习算法。</p>
</blockquote>
<ul>
<li><a href="https://rust-ml.github.io/book/">https://rust-ml.github.io/book/</a></li>
<li><a href="https://github.com/rust-ml/book">https://github.com/rust-ml/book</a></li>
<li><a href="https://github.com/rust-ml/linfa">https://github.com/rust-ml/linfa</a></li>
<li><a href="https://blog.logrocket.com/machine-learning-in-rust-using-linfa/">https://blog.logrocket.com/machine-learning-in-rust-using-linfa/</a></li>
</ul>
<h2><a class="header" href="#solana-season-hackathon-参赛项目之一" id="solana-season-hackathon-参赛项目之一">Solana Season Hackathon 参赛项目之一</a></h2>
<p>发个 Brian 的 Solana Season Hackathon 参赛项目，现在爆火的 NFT 方向。</p>
<p>Brian 也写了篇文章（First impressions of Rust programming on Solana）来介绍 Solana 的感受。</p>
<ul>
<li><a href="https://github.com/brson/treasuretree">https://github.com/brson/treasuretree</a></li>
<li><a href="https://brson.github.io/2021/06/08/rust-on-solana">First impressions of Rust programming on Solana</a></li>
</ul>
<h2><a class="header" href="#rust-社区朋友关于-actix-web-和-rocket-框架的观点" id="rust-社区朋友关于-actix-web-和-rocket-框架的观点">Rust 社区朋友关于 Actix-web 和 Rocket 框架的观点</a></h2>
<p>之前用 actix-web 寫了兩個小專案，覺得 actix 還行，但用起來沒有特別有熱情。這兩天藉機第一次試用了下 rocket 0.5.rc1，雖然還沒寫多少代碼，但個人感覺認為 rocket 的設計更 rusty。說真的稍微有點燃起來了，就是當初第一次認識 rust 時的那種愉悅感。</p>
<p>具體說來，rocket 感覺對於安全與正確性的追求非常徹底，幾乎所有東西都強型別且能編譯期進行驗證。</p>
<p>而且，在保證變強的同時，整體寫法也更簡單了；rocket 的設計會自然誘使開發者寫出強型別的代碼。就個人經驗來說，actix_web 沒有這種傾向，或至少傾向較弱。</p>
<p>此外，部份無法於編譯期驗證的項目，凡有注意到的，也都會在服務啟動瞬間驗證完畢。比方說部份 route handler 可能會依賴某些全域 State (等效於 actix_web 中的 web::Data，像是資料庫連接池之類的東西)，這些注入項如果沒有正確初始化，rocket 啟動瞬間就會報錯。而 actix_web 碰到 web::Data 忘記注入的狀況，會要等到呼叫了該 route 時才出錯。除此之外，像是 routing table 是否有衝突等問題，也會在服務啟動瞬間驗證完畢。而在內建服務以外如果有想驗證的東西，也有接口供用戶自定義自己的啟動時驗證方式。</p>
<p>還有很多方便寫碼的小特徵，比方說開發者只有明確需要控制 async 運行狀態時，才需要寫 async fn，否則只要和 fn 打交道即可。除非有東西想要 await 或想平行運行，否則不必然需要處理 Future 接口。</p>
<p>功能方面，我個人特別開心的是 rocket 完整支援了（包含處理檔案上傳在內）Multipart Form 的全部功能。Form 還可以傳輸任意完整的 json-like nested collections 資料格式，這表示不需要透過 javascript 轉成 Json 就能語意精確地發送複雜資料，或是方便地把複雜資料連同檔案合併傳輸。雖然我有點懷疑會有多少人真的這樣設計接口，喂這傢伙不會做過頭了嗎 XDDD</p>
<p>關於 Form 資料的騷操作可看官方說明：
<a href="https://rocket.rs/v0.5-rc/guide/requests/#collections">https://rocket.rs/v0.5-rc/guide/requests/#collections</a></p>
<p>Middleware 方面，rocket 的 Fairing 接口也遠比 actix_web 的 Service 容易寫。actix_web 的完整 Service 寫起來實在很整人，有興趣的話可以比較一下兩者 example 的複雜度：
[https://rocket.rs/v0.5-rc/guide/fairings/#example
https://actix.rs/docs/middleware/](https://rocket.rs/v0.5-rc/guide/fairings/#example
https://actix.rs/docs/middleware/)</p>
<p>不過得說一句，fairing 與 middleware 的功能不完全一樣，Rocket 的 Fairing 蓄意被設計得比傳統 middleware 更受限（因為許多問題的解決方案 rocket 不建議由 middleware 處理），因此這種比較可能不完全公平。如此設計的理由可見：</p>
<p><a href="https://github.com/SergioBenitez/Rocket/issues/55#issuecomment-274655441">https://github.com/SergioBenitez/Rocket/issues/55#issuecomment-274655441</a></p>
<p>舉例來說，Rocket 推薦透過一種叫 Custom Guard 的機制，控制每個 route 的用戶身份與存取權。如果 Guard 解析失敗當然無權進入對應的 route，反之如果解析成功，自然會得到已經經過強型別建模後的用戶身份。第一印象看起來非常清晰，之後打算更深入試試看。如果不清楚 Custom Guard 是什麼的話，可看官方範例：</p>
<p><a href="https://api.rocket.rs/v0.5-rc/rocket/request/trait.FromRequest.html#example-1">https://api.rocket.rs/v0.5-rc/rocket/request/trait.FromRequest.html#example-1</a></p>
<p>rocket 用了不少 macro，但是都是非常小且局部的，我認為反而提升了代碼的清晰度。我特別喜歡 <code>#[derive(Responder)]</code>，由此建構強型別 Response 非常容易，且單一一個就統整了 actix 的 ResponseError 與 HttpResponse 兩個用例。</p>
<p>在錯誤處理方面，rocket 除 Responder 可回傳 404 等錯誤外，還有額外一層 Catcher 層，能參考 StatusCode 與 Request 內容產生適當響應。這層看上去是通用錯誤如 404, 401 的解決方案，應該是設計來與 Custom Guard 組合使用的，這也表示並非所有錯誤都需要在 route 中手動組裝定義，會對編碼更方便。但關於此處 catcher 方面的想定說明，我還不是很有把握，需要再深入體會一下，此處說法僅供參考。</p>
<p>以上只是個人簡單用過後的印象，兩個框架距離精通都還遠得很，有錯請隨手斧正。</p>
<p>(如果大家想交流，可以在评论区回复)</p>
<h2><a class="header" href="#对-王垠对-rust-语言的分析的分析" id="对-王垠对-rust-语言的分析的分析">对 王垠《对 Rust 语言的分析》的分析</a></h2>
<p>时隔五年，回头看 王垠这篇文章 </p>
<ul>
<li>知乎阅读： <a href="https://zhuanlan.zhihu.com/p/382174889">https://zhuanlan.zhihu.com/p/382174889</a></li>
<li>微信阅读： <a href="https://mp.weixin.qq.com/s/wXKdrl_L65TH9bz_QQfGKw">https://mp.weixin.qq.com/s/wXKdrl_L65TH9bz_QQfGKw</a></li>
</ul>
<h2><a class="header" href="#rust-vs-c-for-game-development" id="rust-vs-c-for-game-development">Rust vs. C++ for game development</a></h2>
<p>本文在游戏开发的背景下比较Rust与C ++。 并介绍Rust和C++之间的相似性和差异以及使用每个编程语言进行游戏开发的优缺点和工具</p>
<p><a href="https://blog.logrocket.com/rust-vs-c-for-game-development/">https://blog.logrocket.com/rust-vs-c-for-game-development/</a></p>
<h2><a class="header" href="#使用-rust-和-react-构建桌面-app" id="使用-rust-和-react-构建桌面-app">使用 Rust 和 React 构建桌面 App</a></h2>
<p>基于 <a href="https://github.com/tauri-apps/tauri">Tauri</a> 框架</p>
<p><a href="https://kent.medium.com/get-started-making-desktop-apps-using-rust-and-react-78a7e07433ce">https://kent.medium.com/get-started-making-desktop-apps-using-rust-and-react-78a7e07433ce</a></p>
<h2><a class="header" href="#视频rust-无锁编程实现险象指针hazard-pointers-" id="视频rust-无锁编程实现险象指针hazard-pointers-">【视频】Rust 无锁编程｜实现险象指针（Hazard Pointers ）</a></h2>
<p>Jon Gjengset 的系列视频之一</p>
<p><a href="https://www.youtube.com/watch?v=fvcbyCYdR10">https://www.youtube.com/watch?v=fvcbyCYdR10</a></p>
<h2><a class="header" href="#微软发布-rust-新的学习视频" id="微软发布-rust-新的学习视频">微软发布 Rust 新的学习视频</a></h2>
<p><a href="https://channel9.msdn.com/Series/Beginners-Series-to-Rust?WT.mc_id=academic-29077-cxa">https://channel9.msdn.com/Series/Beginners-Series-to-Rust?WT.mc_id=academic-29077-cxa</a></p>
<h2><a class="header" href="#揭秘rust中的可变性和引用" id="揭秘rust中的可变性和引用">揭秘Rust中的可变性和引用</a></h2>
<ol>
<li>对于可变引用，不能出现在不可变引用的声明域和使用域之间；</li>
<li>对于可变/不可变引用，不能出现在在可变引用的声明域和使用域之间。</li>
</ol>
<p>这就是Rust的借用检查规则：在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。</p>
<p><a href="https://dev.to/arunanshub/demystifying-mutability-and-references-in-rust-caf">Demystifying Mutability and References in Rust</a></p>
<h2><a class="header" href="#给c程序员的rust入门系列文章" id="给c程序员的rust入门系列文章">给C程序员的Rust入门系列文章</a></h2>
<p><a href="https://cliffle.com/p/dangerust/">Learn Rust the Dangerous Way</a></p>
<h2><a class="header" href="#使用windbg调试非安全rust代码导致的崩溃" id="使用windbg调试非安全rust代码导致的崩溃">使用Windbg调试非安全Rust代码导致的崩溃</a></h2>
<p>作者在Windows平台写非安全Rust代码的时候遇到一个奔溃：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error: process didn't exit successfully: `target\debug\rustdesk.exe` (exit code: 0xc0000374, STATUS_HEAP_CORRUPTION)
<span class="boring">}
</span></code></pre></pre>
<p>因为这是一个与unsafe的Rust代码相关的分段故障崩溃，很难从控制台消息中得到任何线索，作者便使用了其它工具进行调试，并且记录在了这篇Blog中。</p>
<p>这篇blog的作者是大家最近比较热门的用Rust写的跨平台远程桌面开源软件 RustDesk 的作者。</p>
<p>Read More: <a href="https://dev.to/rustdesk/debugging-a-crash-in-unsafe-rust-with-windbg-2b39">https://dev.to/rustdesk/debugging-a-crash-in-unsafe-rust-with-windbg-2b39</a></p>
<h2><a class="header" href="#使用-rustwasm-的-webrtc-视频聊天教程" id="使用-rustwasm-的-webrtc-视频聊天教程">使用 Rust+WASM 的 WebRTC 视频聊天教程</a></h2>
<p>基于Rust+WASM构建的ewebrt信令服务器，结合chrome浏览器构建简单视频聊天应用程序</p>
<p>链接: <a href="https://charles-schleich.medium.com/webrtc-video-chat-tutorial-using-rust-wasm-fa340f7aeef9">https://charles-schleich.medium.com/webrtc-video-chat-tutorial-using-rust-wasm-fa340f7aeef9</a></p>
<h2><a class="header" href="#thealgorithms-rust" id="thealgorithms-rust">TheAlgorithms: Rust</a></h2>
<p>大名鼎鼎的 <a href="https://the-algorithms.com/">《The Algorithms》</a> 的 Rust 版本，使用 Rust 实现所有算法。</p>
<p><a href="https://github.com/TheAlgorithms/Rust">TheAlgorithms/Rust: All Algorithms implemented in Rust</a></p>
<h2><a class="header" href="#对比-java--rust-中的-面向对象特性" id="对比-java--rust-中的-面向对象特性">对比 Java ： Rust 中的 面向对象特性</a></h2>
<p><a href="https://blog.knoldus.com/object-oriented-programming-concepts-in-rust/">https://blog.knoldus.com/object-oriented-programming-concepts-in-rust/</a></p>
<h2><a class="header" href="#android-平台中的-rustc-互操作" id="android-平台中的-rustc-互操作">Android 平台中的 Rust/C++ 互操作</a></h2>
<p><a href="https://security.googleblog.com/2021/06/rustc-interop-in-android-platform.html">https://security.googleblog.com/2021/06/rustc-interop-in-android-platform.html</a></p>
<h2><a class="header" href="#使用nannou和rust-gpu进行实时光线追踪" id="使用nannou和rust-gpu进行实时光线追踪">使用nannou和rust-gpu进行实时光线追踪</a></h2>
<p>Peter Shirley 尝试实时实现“在周末做一个光线追踪”。这是一个个人实验，目的是了解更多关于 rust-gpu、光线追踪以及实时光线追踪的局限性。</p>
<p><a href="https://github.com/mitchmindtree/nannou-rustgpu-raytracer">https://github.com/mitchmindtree/nannou-rustgpu-raytracer</a></p>
<h2><a class="header" href="#cacao-020-发布使用-rust-构建-native-的-macos-应用" id="cacao-020-发布使用-rust-构建-native-的-macos-应用">cacao 0.2.0 发布，使用 Rust 构建 native 的 MacOS 应用</a></h2>
<p>该库为 macOS 上的 AppKit 和 iOS/tvOS 上的 UIKit（alpha 质量，请参阅 repo）提供安全的 Rust 绑定。 如果之前使用 Swift 或 Objective-C 为该框架进行过编程，cocao 会尝试提供一种熟悉的开发体验。</p>
<p>由于所有权模型，这在 Rust 中很棘手，但一些创造性的编码和假设可以让我们走得很远。crates.io 上存在 0.2.0 部分是为了使项目能够看到更广泛的使用，这可以为开发提供信息。 也就是说，这个库目前处于早期阶段，可能有错误——你使用它的风险由你自己承担。 但是，只要开发者遵守规则（关于内存/所有权），对于某些应用程序来说就可以了，核心存储库有丰富的示例可以帮助开发者入门。</p>
<p><a href="https://crates.io/crates/cacao">https://crates.io/crates/cacao</a></p>
<h2><a class="header" href="#rust中类型的未开发的潜力" id="rust中类型的未开发的潜力">Rust中类型的未开发的潜力</a></h2>
<p>Rust 的类型,除了可以用来检查属性外,还可以做一些更有意思的事情. 本文会涉及到很多动态类型.</p>
<p><a href="https://www.jakobmeier.ch/blogging/Untapped-Rust.html">https://www.jakobmeier.ch/blogging/Untapped-Rust.html</a></p>
<h2><a class="header" href="#使用rustwebassembly-加速webcola图可视化工具" id="使用rustwebassembly-加速webcola图可视化工具">使用Rust+WebAssembly 加速Webcola图可视化工具</a></h2>
<p>摘要：</p>
<p>作者最近从事的项目希望在web页面上展示Spotify上不同音乐家之间的联系。Spotify提供了可以获取数据的官方API，作者获取某个用户最喜欢的若干个音乐家，然后把他们之间的关系在浏览器上展示出来。受HTTP服务器性能调优的启发，借助一系列profile和分析工具，使用Rust+WebAssembly的方式优化了Webcola的调用，使得单机性能从&lt;10 FPS 提升到超过60 FPS。
详细博文可以参见：<a href="https://cprimozic.net/blog/speeding-up-webcola-with-webassembly/">https://cprimozic.net/blog/speeding-up-webcola-with-webassembly/</a></p>
<h2><a class="header" href="#教程用rust动手实现一个桌面跨平台gui项目" id="教程用rust动手实现一个桌面跨平台gui项目">【教程】用Rust动手实现一个桌面跨平台GUI项目</a></h2>
<p>使用iced构建一个Rust跨平台GUI项目，作者是我，因为有些地方比较仓促，可能有不少错别字，可以的话帮我提一下issue。</p>
<p>其实写到现在，前五章的内容都比较简单，如果目的主要是想要学一下iced怎么用，我的建议是看看官方的例子比较好。</p>
<p>本教程的受众偏向Rust新手，已经看过Rust的大部分概念，急需一个实战项目练手的小伙伴。</p>
<p>目前正在筹备的新章节是Canvas绘制图表，可能干货上比前几章多点。</p>
<p>后续还有多语言支持，多主题支持，以及如何自己构建一个iced的控件，感兴趣的一定不要错过。</p>
<p>0-5章: <a href="https://localnative.app/docs/tutorial0">https://localnative.app/docs/tutorial0</a></p>
<h2><a class="header" href="#rust中使用-mongodb-和-redis" id="rust中使用-mongodb-和-redis">Rust中使用 mongoDB 和 redis</a></h2>
<p>本文详细讲解了如果使用 Rust 来操作 mongo 和 redis, 并且使用 actix web 来构建一个简单的 web 应用. </p>
<p><a href="https://.com/blog/2021/06/mongodb-redis-rust/">https://.com/blog/2021/06/mongodb-redis-rust/</a></p>
<h2><a class="header" href="#totally-speedy-transmute-stdmemtransmute的安全替代" id="totally-speedy-transmute-stdmemtransmute的安全替代">Totally Speedy Transmute： <code>std::mem::transmute</code>的安全替代</a></h2>
<p>如果你想要一个标准库中transmute函数的安全替代，可以看看这个。</p>
<p><a href="https://docs.rs/totally-speedy-transmute/1.69.420/totally_speedy_transmute/">https://docs.rs/totally-speedy-transmute/1.69.420/totally_speedy_transmute/</a></p>
<h1><a class="header" href="#rust过程宏系列教程--proc-macro-workshop-之-debug" id="rust过程宏系列教程--proc-macro-workshop-之-debug">Rust过程宏系列教程 | Proc Macro Workshop 之 Debug</a></h1>
<p>作者：米明恒 / 后期编辑：张汉东</p>
<blockquote>
<p><a href="https://blog.ideawand.com/2021/06/26/rust_procedural_macro/rust_proc_marco_workshop_guide-03/">本文来自于 blog.ideawand.com 投稿 </a></p>
</blockquote>
<hr />
<p>本系列的上一篇文章中，我们实战了<code>proc_macro_workshop</code>项目的<code>builder</code>题目。并且介绍了<code>proc_macro_workshop</code>这个项目的概况，如果您是第一次阅读本系列文章，对<code>proc_macro_workshop</code>项目的结构还是不很熟悉的话，可以先阅读一下上一篇文章。</p>
<p>好了，不废话了，准备好一台电脑，开始我们的第二个挑战任务<code>debug</code></p>
<!--more-->
<p>首先打开<code>proc_macro_workshop</code>项目的<code>readme.md</code>文件，看一下<code>debug</code>这个项目要实现什么样的功能。根据其中的描述，这个题目的最终目标是实现一个可以输出指定格式调试信息的派生宏，他要实现的功能和rust自带的<code>Debug</code>派生宏是一样的，只不过我们要实现的这个宏比<code>Debug</code>更强大一些，可以指定每一个字段的输出格式。</p>
<p>我们之前提到过，Rust中的过程宏分为三种样式：派生样式的、属性样式的，还有函数样式的，上一篇和本篇要讨论的过程宏都是派生样式的，另外两种样式的过程宏会在后续文章中对另外三道题目讲解时介绍。如果你对派生样式的过程宏还不了解，请一定先阅读本系列的前一篇文章。本篇文章介绍的<code>debug</code>挑战题目，除了在大量使用上一篇<code>builder</code>项目使用的知识点之外，主要增加了对泛型的处理。</p>
<h3><a class="header" href="#第一关-1" id="第一关-1">第一关</a></h3>
<p>第一关视频版：<a href="https://www.bilibili.com/video/BV1vU4y187TR?zw">https://www.bilibili.com/video/BV1vU4y187TR?zw</a></p>
<p>第一关的工作和上一篇文章中介绍的<code>builder</code>题目的第一关一样，搭建一个框架，配置好<code>cargo.toml</code>，然后把输入的<code>TokenStream</code>转换为<code>syn::DeriveInput</code>类型即可。项目代码结构可以参考第一篇文章<a href="chapter_6/./rust_proc_marco_workshop_guide-02.html">Rust过程宏系列教程(2)--实现proc-macro-workshop项目之builder题目</a>，回忆一下上篇文章提到的知识点，我们要实现一个类似下面这种结构的框架，便于我们做错处处理：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;
use syn::{self, spanned::Spanned};
use quote::{ToTokens, quote};

#[proc_macro_derive(CustomDebug)]
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let st = syn::parse_macro_input!(input as syn::DeriveInput);
    match do_expand(&amp;st) {
        Ok(token_stream) =&gt; token_stream.into(),
        Err(e) =&gt; e.to_compile_error().into(),
    }
}

fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let ret = proc_macro2::TokenStream::new();
    return Ok(ret);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第二关-1" id="第二关-1">第二关</a></h3>
<p>第二关视频版：<a href="https://www.bilibili.com/video/BV1Kf4y1W7ss?zw">https://www.bilibili.com/video/BV1Kf4y1W7ss?zw</a></p>
<p>第二关要实现基本的<code>Debug</code> Trait，其原理是使用rust标准库提供的<code>std::fmt::DebugStruct</code>结构来实现，例如对于下面这个结构体</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GeekKindergarten {
    blog: String,
    ideawand: i32,
    com: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们要生成如下模式的代码,实现<code>Debug</code> Trait：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl fmt::Debug for GeekKindergarten {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt.debug_struct(&quot;GeekKindergarten&quot;)
           .field(&quot;blog&quot;, &amp;self.blog)
           .field(&quot;ideawand&quot;, &amp;self.ideawand)
           .field(&quot;com&quot;, &amp;self.com)
           .finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样，我们就可以在<code>println!</code>中使用<code>{:?}</code>来打印结构体中的各个字段。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let g = GeekKindergarten{blog:&quot;foo&quot;.into(), ideawand:123, com:true};
    println!(&quot;{:?}&quot;, g);
}
</code></pre></pre>
<p>所以，我们目标也很明确了，和上一篇的<code>builder</code>类似，我们要首先读取出被过程宏处理的结构体的每一个字段的名字，然后按照模板生成上面的代码即可，没有什么新的知识，所以我们直接给出代码即可：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_expand(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let ret = generate_debug_trait(st)?;
    return Ok(ret);
}

type StructFields = syn::punctuated::Punctuated&lt;syn::Field,syn::Token!(,)&gt;;
fn get_fields_from_derive_input(d: &amp;syn::DeriveInput) -&gt; syn::Result&lt;&amp;StructFields&gt; {
    if let syn::Data::Struct(syn::DataStruct {
        fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),
        ..
    }) = d.data{
        return Ok(named)
    }
    Err(syn::Error::new_spanned(d, &quot;Must define on a Struct, not Enum&quot;.to_string()))
}

fn generate_debug_trait(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let fields = get_fields_from_derive_input(st)?;
    let struct_name_ident = &amp;st.ident;
    let struct_name_literal = struct_name_ident.to_string();

    let mut fmt_body_stream = proc_macro2::TokenStream::new();

    fmt_body_stream.extend(quote!(
        fmt.debug_struct(#struct_name_literal) // 注意这里引用的是一个字符串，不是一个syn::Ident，生成的代码会以字面量形式表示出来
    ));
    for field in fields.iter(){
        let field_name_idnet = field.ident.as_ref().unwrap();
        let field_name_literal = field_name_idnet.to_string();
        
        fmt_body_stream.extend(quote!(
            .field(#field_name_literal, &amp;self.#field_name_idnet)  // 这行同样注意literal和ident的区别
        ));
    }

    fmt_body_stream.extend(quote!(
        .finish()
    ));

    let ret_stream = quote!(
        impl std::fmt::Debug for #struct_name_ident {
            fn fmt(&amp;self, fmt: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
<span class="boring">                fmt_body_stream
</span>            }
        }
    );

    return Ok(ret_stream)
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第三关-1" id="第三关-1">第三关</a></h3>
<p>第三关视频版：<a href="https://www.bilibili.com/video/BV1df4y1a73x?zw">https://www.bilibili.com/video/BV1df4y1a73x?zw</a></p>
<p>这一关要求我们可以为结构体中的每一个字段指定自己独立的格式化样式，也就是可以在结构体内部写下面这样的惰性属性标注：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(CustomDebug)]
struct GeekKindergarten {
    blog: String,
    #[debug = &quot;0b{:32b}&quot;]    // 在派生式过程宏中，这是个`惰性属性`，在上一篇文章中有介绍
    ideawand: i32,
    com: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>在上面代码中，<code>#[debug=xxx]</code>是我们编写的<code>CustomDebug</code>派生宏的惰性属性，派生宏惰性属性的概念在上一篇文章中介绍过了，因此我们可以参照一下前面文章中编写的提取惰性属性的函数，进行编写即可。一个提示是，在编写的过程中，可以继续使用print大法来分析属性的结构。</p>
<ul>
<li>在上一篇文章中，我们处理的惰性属性是<code>#[builder(each=xxxx)]</code>的形式，这个写法在解析成语法树时是两层的嵌套结构，外面的<code>builder(xxxx)</code>转换成语法树节点的<code>MetaList</code>类型结构，而内部的<code>each=xxxx</code>转换成语法树节点的<code>NameValue</code>类型结构</li>
<li>本篇文章处理的，直接就是<code>#[debug = xxxx]</code>的形式，所以处理起来，其实比上一题的简单一些</li>
</ul>
<p>在我们从惰性属性中拿到格式模板以后，接下来要做的就是使用<code>fmt</code>包中提供的相关方法，来格式化我们的结构，这部分只是与过程宏的开发无关，主要是<code>fmt</code>包中相关格式化工具的用法，参考资料在第三关的测试文件中也已经给出，我将其复制在下面，大家可以自行参阅：</p>
<ul>
<li>https://doc.rust-lang.org/std/macro.format_args.html</li>
</ul>
<p>通过阅读上面的参考资料，我们可以了解到，想在<code>debug_struct</code>工具方法里指定输出的格式，我们就要借助<code>format_args!</code>宏，生成例如下面这样的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 原来的样子是：
// .field(&quot;ideawand&quot;, &amp;self.ideawand)
// 现在的样子是：
.field(&quot;ideawand&quot;, &amp;format_args!(&quot;0b{:32b}&quot;, self.ideawand))
<span class="boring">}
</span></code></pre></pre>
<p>有了上述的分析，我们可以直接给出第三关的核心代码，首先是提取字段惰性属性的函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_custom_format_of_field(field: &amp;syn::Field) -&gt; syn::Result&lt;Option&lt;String&gt;&gt; {
    for attr in &amp;field.attrs {
        if let Ok(syn::Meta::NameValue(syn::MetaNameValue {
            ref path,
            ref lit,
            ..
        })) = attr.parse_meta()
        {
            if path.is_ident(&quot;debug&quot;) {
                if let syn::Lit::Str(ref ident_str) =lit {
                    return Ok(Some(
                        ident_str.value()
                    ));
                }
            }
        }
    }
    Ok(None)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后修改一下<code>generate_debug_trait()</code>函数，这里只给出了进行调整的核心循环体的代码片段</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_debug_trait(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    
    // &lt;此处省略未修改代码&gt; ................

    for field in fields.iter(){
        let field_name_idnet = field.ident.as_ref().unwrap();
        let field_name_literal = field_name_idnet.to_string();
        
        // 以下若干行代码直到循环体结束 是第三关进行修改的部分
        let mut format_str = &quot;{:?}&quot;.to_string();
        if let Some(format) = get_custom_format_of_field(field)? {
            format_str = format;
        } 
        // 这里是没有指定用户自定义的格式
        fmt_body_stream.extend(quote!(
            .field(#field_name_literal, &amp;format_args!(#format_str, self.#field_name_idnet))
        ));

    }

    // &lt;此处省略未修改代码&gt; ................

}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第四关-1" id="第四关-1">第四关</a></h3>
<p>第四关视频版：<a href="https://www.bilibili.com/video/BV1S64y1d7fc?zw">https://www.bilibili.com/video/BV1S64y1d7fc?zw</a></p>
<p>从这一关开始，我们接触一下泛型参数的处理，有点小激动~~</p>
<p>在前几关中我们生成的<code>Debug</code> Trait的代码是没有泛型参数的，因此，对于形如下面的带有泛型参数的结构体：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GeekKindergarten&lt;T&gt; {
    blog: T,
    ideawand: i32,
    com: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们生成的代码应该是形如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Debug for GeekKindergarten&lt;T&gt; {
    // .....
}
<span class="boring">}
</span></code></pre></pre>
<p>但由于我们在代码模板中只是用了结构体的标识符，也就是<code>GeekKindergarten</code>这一部分，而没有使用泛型参数信息，也就是丢掉了<code>&lt;T&gt;</code>这一部分，因此我们生成的代码会是下面这个样子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Debug for GeekKindergarten {
//  ^---- 这里丢掉了泛型参数 -----^
}
<span class="boring">}
</span></code></pre></pre>
<p>第四关的提示文档里，给出了泛型参数语法树节点的链接：</p>
<ul>
<li>https://docs.rs/syn/1.0/syn/struct.Generics.html</li>
</ul>
<p>这个语法树节点提供了一个工具函数，可以帮助我们把泛型参数切分成三个用于生成<code>impl</code>块的片段，这个函数是：</p>
<ul>
<li>https://docs.rs/syn/1.0/syn/struct.Generics.html#method.split_for_impl</li>
</ul>
<p>此外，他还给出了另一个示例程序的代码库地址，里面演示了如何处理泛型参数，推荐大家去看一下，不过毕竟这个链接只是纯代码，没什么讲解，所以大家还是要先读完我的文章，关注一下我的微信公众号【极客幼稚园】~ 示例项目地址：</p>
<ul>
<li>https://github.com/dtolnay/syn/tree/master/examples/heapsize</li>
</ul>
<p>我们重点来看一下<code>split_for_impl()</code>这个工具函数的用法，比如说我们有这样一个泛型结构体，泛型参数<code>T</code>，<code>U</code>分别受到<code>Blog</code>、<code>IdeaWand</code>、<code>Com</code>这三个Trait Bound的限制：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GeekKindergarten&lt;T, U&gt; where T: Blog + IdeaWand, U: Com {}
<span class="boring">}
</span></code></pre></pre>
<p>那么，我们生成的<code>Debug</code> Trait的形式应该是下面这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T,U&gt; Debug for GeekKindergarten&lt;T, U&gt; where T: Blog + IdeaWand + Debug, U: Com + Debug {
 // ^^^^^                           ^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^          ^^^^^^
 //  |                                 |            |                           |   
 //  |                                 |            +---------第三部分 ----------+
 //  |                                 +--第二部分
 //  +------第一部分
}
<span class="boring">}
</span></code></pre></pre>
<p>而<code>split_for_impl()</code>这个工具函数就是用来帮助我们生成上面这三个代码片段的，上面的限定在还出现了<code>Debug</code>，这个是我们要后面再手动加上去的，并不是<code>split_for_impl()</code>能帮我们生成的，所以我没有把他们标出来。</p>
<p>好了，我们总结一下第四关需要做的事情，然后给出示例代码：</p>
<ul>
<li>从<code>DeriveInput</code>语法树节点获取泛型参数信息</li>
<li>为每一个泛型参数都添加一个<code>Debug</code> Trait限定</li>
<li>使用<code>split_for_impl()</code>工具函数切分出用于模板生成代码的三个片段</li>
<li>修改<code>impl</code>块的模板代码，使用上述三个片段，加入泛型参数信息</li>
<li>此外由于目前<code>generate_debug_trait()</code>函数已经较为冗长，我们也对代码的结构进行微调，将其拆分为两个函数。</li>
</ul>
<p>接下来上代码,首先是拆分出的新函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_debug_trait_core(st :&amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
    let fields = get_fields_from_derive_input(st)?;
    let struct_name_ident = &amp;st.ident;
    let struct_name_literal = struct_name_ident.to_string();
    let mut fmt_body_stream = proc_macro2::TokenStream::new();

    fmt_body_stream.extend(quote!(
        fmt.debug_struct(#struct_name_literal) 
    ));
    for field in fields.iter(){
        let field_name_idnet = field.ident.as_ref().unwrap();
        let field_name_literal = field_name_idnet.to_string();
        
        let mut format_str = &quot;{:?}&quot;.to_string();
        if let Some(format) = get_custom_format_of_field(field)? {
            format_str = format;
        } 
        // 这里是没有指定用户自定义的格式
        fmt_body_stream.extend(quote!(
            .field(#field_name_literal, &amp;format_args!(#format_str, self.#field_name_idnet))
        ));
    }

    fmt_body_stream.extend(quote!(
        .finish()
    ));
    return Ok(fmt_body_stream)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后是我们生成impl块的代码,详细阅读一下其中的注释，添加<code>Debug</code> Trait限定的代码一开始我也不知道怎么写，是参考了第四关提示中的<code>heapsize</code>项目的范例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_debug_trait(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {

    let fmt_body_stream = generate_debug_trait_core(st)?;

    let struct_name_ident = &amp;st.ident;

    // 从输入的派生宏语法树节点获取被修饰的输入结构体的泛型信息
    let mut generics_param_to_modify = st.generics.clone();
    // 我们需要对每一个泛型参数都添加一个`Debug` Trait限定
    for mut g in generics_param_to_modify.params.iter_mut() {
        if let syn::GenericParam::Type(t) = g {
            t.bounds.push(parse_quote!(std::fmt::Debug));
        }
    }

    // 使用工具函数把泛型抽取成3个片段
    let (impl_generics, type_generics, where_clause) = generics_param_to_modify.split_for_impl();

    let ret_stream = quote!(
        // 注意下面这一行是如何使用三个与泛型参数有关的代码片段的
        impl #impl_generics std::fmt::Debug for #struct_name_ident #type_generics #where_clause {
            fn fmt(&amp;self, fmt: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
<span class="boring">                fmt_body_stream
</span>            }
        }
    );

    return Ok(ret_stream)
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第五关-1" id="第五关-1">第五关</a></h3>
<p>第五关视频版：<a href="https://www.bilibili.com/video/BV1v44y1z7eb?zw">https://www.bilibili.com/video/BV1v44y1z7eb?zw</a></p>
<p>这一关的关卡说明非常长，信息量不少，我们来仔细看看：</p>
<p>首先抛出了一个问题，例如对于下面这个结构体：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GeekKindergarten&lt;T&gt; {
    ideawand: PhantomData&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>这个结构体中使用了<code>PhantomData</code>这个类型，而<code>PhantomData</code>类型本身在标准库中实现了<code>Debug</code> Trait，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Debug for PhantomData&lt;T&gt; {...}
<span class="boring">}
</span></code></pre></pre>
<p>在这种情况下，我们没有必要限定<code>T</code>是<code>Debug</code>的。面对这类本身已经实现了<code>Debug</code>的泛型结构体，我们有一种应对办法，即我们在生成Trait限定时，不是针对每一个泛型参数去限制，而是对结构体中每一个字段的类型来添加限制，还是以下面这个结构体为例来说：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GeekKindergarten&lt;T, U&gt; {
    blog: Foo&lt;U&gt;,
    ideawand: PhantomData&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>原来我们代码生成的限定条件是:</p>
<ul>
<li><code>T: Debug, U: Debug</code>
而我们现在应该生成的是:</li>
<li><code>Foo&lt;U&gt;: Debug, PhantomData&lt;T&gt;: Debug</code></li>
</ul>
<p>但是，这样的限定会有很大的副作用，这些副作用在后续的关卡中大家会遇到，所以，解题提示中给我们指出了另一个方法：</p>
<ul>
<li>因为<code>PhantomData</code>类型的使用太常见了，所以我们就把<code>PhantomData</code>这个类型作为一个特例，我们检测是不是有<code>PhantomData</code>类型的字段，如果有，我们看看它所使用的泛型参数是不是只在<code>PhantomData</code>中出现过，如果是，我们就不为它添加<code>Debug</code>限定了。</li>
<li>在后续关卡中，我们会为<code>PhantomData</code>之外的情况，提供一个“逃生出口”(escape hatch)，用来标记某一个字段的类型限定。</li>
</ul>
<p>在给出上述提示之后，出题人还给我们介绍了一下Rust过程宏的一些设计上的取舍：</p>
<ul>
<li>在Rust过程宏中，你不可能获得到一个完全正确的Trait限定，这是因为假设要实现这个功能，就要在展开过程宏时做命名解析。而这样做会导致rust编译器复杂度急剧上升</li>
<li>Rust核心团队认为这样的取舍带来的收益非常大，因此没有任何计划打算在后续支持宏展开时的命名解析</li>
<li>使用escape hatch来解决问题是一种常用手段</li>
<li>另一种更加常见的手段是，通过Rust的Trait机制，将命名解析的执行时间推后到真正的编译阶段去处理
<ul>
<li>特别注意一下本关的测试用例代码，看看过程宏的调用是如何能够在不知道<code>S</code>指代的是<code>String</code>类型的情况下，产生出可以调用<code>String</code>类型的<code>Debug</code>Trait实现的。</li>
</ul>
</li>
</ul>
<p>第五关的解题提示到这里就分析完了，在我们开始写代码之前，我们先看看下面新增代码的主要逻辑，例如有这样一个泛型结构体,则我们的过程宏的行为应该是:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GeekKindergarten&lt;T, U, V, W&gt; {
    blog: T,
    ideawand: PhantomData&lt;U&gt;,
    com: U,
    foo: PhantomData&lt;V&gt;,
    bar: Baz&lt;W&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>对T，由于没有出现在<code>PhantomData</code>中，则需要对T增加<code>Debug</code>限定</li>
<li>对U，虽然出现在<code>PhantomData</code>中,但因为其同时直接作为<code>com</code>字段的类型，所以仍然需要加<code>Debug</code>限定</li>
<li>对于V，满足这一关设定的特殊条件，不添加<code>Debug</code>限定</li>
<li>对于W，因为其不在<code>PhantomData</code>的泛型参数中，所以需要加<code>Debug</code>限定</li>
</ul>
<p>可以看到，想实现上面的逻辑，我们需要获取<code>&lt;&gt;</code>之前的类型名称，以及<code>&lt;&gt;</code>内部的类型名称，剩下的就是各种判断这些类型名字对应的字符串是不是满足各种组合条件了。</p>
<p>下面开始撸代码，先定义一个获取<code>PhantomData</code>泛型参数名字的函数，这个函数的作用是把<code>PhantomData&lt;X&gt;</code>里面的<code>X</code>作为字符串提取出来：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_phantomdata_generic_type_name(field: &amp;syn::Field) -&gt; syn::Result&lt;Option&lt;String&gt;&gt; {
    if let syn::Type::Path(syn::TypePath{path: syn::Path{ref segments, ..}, ..}) = field.ty {
        if let Some(syn::PathSegment{ref ident, ref arguments}) = segments.last() {
            if ident == &quot;PhantomData&quot; {
                if let syn::PathArguments::AngleBracketed(syn::AngleBracketedGenericArguments{args, ..}) = arguments {
                    if let Some(syn::GenericArgument::Type(syn::Type::Path( ref gp))) = args.first() {
                        if let Some(generic_ident) = gp.path.segments.first() {
                            return Ok(Some(generic_ident.ident.to_string()))
                        }
                    }
                }
            }
        }
    }
    return Ok(None)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后再定义一个函数，用于把结构体定义中<code>foo: XXX</code>或<code>foo:XXX&lt;YYY&gt;</code>这种形式中，<code>XXX</code>所在位置的类型名字（即不包括泛型参数）作为字符串返回：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_field_type_name(field: &amp;syn::Field) -&gt; syn::Result&lt;Option&lt;String&gt;&gt; {
    if let syn::Type::Path(syn::TypePath{path: syn::Path{ref segments, ..}, ..}) = field.ty {
        if let Some(syn::PathSegment{ref ident,..}) = segments.last() {
            return Ok(Some(ident.to_string()))
        }
    }
    return Ok(None)
}
<span class="boring">}
</span></code></pre></pre>
<p>然后我们来修改<code>generate_debug_trait()</code>函数的代码，请仔细阅读其中的注释：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_debug_trait(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {

    let fmt_body_stream = generate_debug_trait_core(st)?;

    let struct_name_ident = &amp;st.ident;

    
    let mut generics_param_to_modify = st.generics.clone();

    // 以下代码构建两个列表，一个是`PhantomData`中使用到的泛型参数，另一个是输入结构体中所有字段的类型名称
    let fields = get_fields_from_derive_input(st)?;
    let mut field_type_names = Vec::new();
    let mut phantomdata_type_param_names = Vec::new();
    for field in fields{
        if let Some(s) = get_field_type_name(field)? {
            field_type_names.push(s);
        }
        if let Some(s) = get_phantomdata_generic_type_name(field)? {
            phantomdata_type_param_names.push(s);
        }
    }

    for mut g in generics_param_to_modify.params.iter_mut() {
        if let syn::GenericParam::Type(t) = g {
            let type_param_name = t.ident.to_string();
            // 注意这个判断条件的逻辑，精华都在这个条件里了，自己试着看看能不能把上面的4种情况整理成这个条件
            // 如果是PhantomData，就不要对泛型参数`T`本身再添加约束了,除非`T`本身也被直接使用了
            if phantomdata_type_param_names.contains(&amp;type_param_name) &amp;&amp; !field_type_names.contains(&amp;type_param_name) {
                continue;
            }
            t.bounds.push(parse_quote!(std::fmt::Debug));
        }
    }

    // &lt;省略未修改代码&gt; ............
    
}
<span class="boring">}
</span></code></pre></pre>
<p>在结束第五关之前，我们再来回想一下出题人给我们留下的思考题：</p>
<blockquote>
<p>在第五关的测试用例中，过程宏的调用是如何能够在不知道<code>S</code>指代的是<code>String</code>类型的情况下，产生出可以调用<code>String</code>类型的<code>Debug</code>Trait实现的？</p>
</blockquote>
<p>其实，这个问题很简单，大家只要记住一件事，过程宏，其实就是在玩“字符串替换拼接”的游戏，在过程宏执行的时候，虽然我们把它解析成了语法树，但语法也只是一种字符串排列形式上的约束，并没有类型的概念。你只要能生成出符合rust语法的字符串排列组合即可。真正的符号消解、类型检验等等，是在后面的编译阶段完成的。</p>
<h3><a class="header" href="#第六关-1" id="第六关-1">第六关</a></h3>
<p>这一关展示了第五关被舍弃掉的一个解决方案所存在的问题，比较绕，有兴趣的同学可以自己看看。我们的代码不需要修改就可以通过第六关。</p>
<h3><a class="header" href="#第七关-1" id="第七关-1">第七关</a></h3>
<p>第七关视频版：<a href="https://www.bilibili.com/video/BV1Gq4y1774f?zw">https://www.bilibili.com/video/BV1Gq4y1774f?zw</a></p>
<p>第七关我们要处理关联类型的问题。从第七关的提示里，我们了解到需要做的一个主要工作是寻找出同时满足如下要求的类型为<code>syn::TypePath</code>的语法树节点：</p>
<ul>
<li>其Path长度大于等于2</li>
<li>其Path的第一项为泛型参数列表中某一个</li>
</ul>
<p>根据Rust的语法，我们面临的关联类型可以有如下的形式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Trait {
    type Value;    // 定义一个关联类型
}

pub struct GeekKindergarten&lt;T:Trait&gt; {
    blog: T::Value,
    ideawand: PhantomData&lt;T::Value&gt;,
    com: Foo&lt;Bar&lt;Baz&lt;T::Value&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>也就是说，我们要寻找的形如<code>T::Value</code>的代码片段，可能嵌套在很深的地方，根据前面的经验，我们可能要写一个嵌套了几层if条件的递归函数来在整个语法树中遍历，有没有更优雅的写法呢，幸好<code>syn</code>库为我们提供了visit模式来访问语法树中你感兴趣的节点。</p>
<p>默认情况下，Visit访问模式在<code>syn</code>库中是没有开启的，根据<code>syn</code>官方文档首页中的描述，我们需要在cargo.toml里添加<code>visit</code>这个特性后才可以使用。所以我们首先需要更新一下cargo.toml。</p>
<p>Visit模式的使用说明可以参阅官方文档：https://docs.rs/syn/1.0.64/syn/visit/index.html</p>
<p>Visit模式的核心原理是，其定义了一个名为<code>Visit</code>的Trait，这个Trait中包含了上百个类型的语法树节点各自对应的回调函数，当其遍历语法树时，每遍历到一个类型的语法树节点，就会调用相应的回调函数。在第七关中，由于我们只希望筛选出所有<code>syn::TypePath</code>类型的节点，所以我们只需要实现这个节点对应的回调函数，然后在其中判断当前节点是否满足上述要求即可。大家可以看一下官方文档给出的实例，这里我就直接给出相关代码实现：</p>
<p>首先是Visitor的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use syn::visit::{self, Visit};

// 定义一个用于实现`Visit` Trait的结构体，结构体中定义了一些字段，用于存储筛选条件以及筛选结果
struct TypePathVisitor {
    generic_type_names: Vec&lt;String&gt;,  // 这个是筛选条件，里面记录了所有的泛型参数的名字，例如`T`,`U`等
    associated_types: HashMap&lt;String, Vec&lt;syn::TypePath&gt;&gt;,  // 这里记录了所有满足条件的语法树节点
}

impl&lt;'ast&gt; Visit&lt;'ast&gt; for TypePathVisitor {
    // visit_type_path 这个回调函数就是我们所关心的
    fn visit_type_path(&amp;mut self, node: &amp;'ast syn::TypePath) {
        
        if node.path.segments.len() &gt;= 2 {
            let generic_type_name = node.path.segments[0].ident.to_string();
            if self.generic_type_names.contains(&amp;generic_type_name) {
                // 如果满足上面的两个筛选条件，那么就把结果存起来
                self.associated_types.entry(generic_type_name).or_insert(Vec::new()).push(node.clone());
            }
        }
        // Visit 模式要求在当前节点访问完成后，继续调用默认实现的visit方法，从而遍历到所有的
        // 必须调用这个函数，否则遍历到这个节点就不再往更深层走了
        visit::visit_type_path(self, node);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后是我们初始化Visitor然后执行遍历访问，最终返回筛选结果的函数:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_generic_associated_types(st: &amp;syn::DeriveInput) -&gt; HashMap&lt;String, Vec&lt;syn::TypePath&gt;&gt; {
    // 首先构建筛选条件
    let origin_generic_param_names: Vec&lt;String&gt; = st.generics.params.iter().filter_map(|f| {
        if let syn::GenericParam::Type(ty) = f {
            return Some(ty.ident.to_string())
        }
        return None
    }).collect();

    
    let mut visitor = TypePathVisitor {
        generic_type_names: origin_generic_param_names,  // 用筛选条件初始化Visitor
        associated_types: HashMap::new(),
    };

    // 以st语法树节点为起点，开始Visit整个st节点的子节点
    visitor.visit_derive_input(st);
    return visitor.associated_types;
}
<span class="boring">}
</span></code></pre></pre>
<p>例如对于下面这样的关联类型和结构体：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait TraitA {
    type Value1;
    type Value2;
}

pub trait TraitB {
    type Value3;
    type Value4;
}

pub struct GeekKindergarten&lt;T: TraitA, U: TraitB&gt; {
    blog: T::Value1,
    ideawand: PhantomData&lt;U::Value3&gt;,
    com: Foo&lt;Bar&lt;Baz&lt;T::Value2&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>则我们上面函数将会返回这样一个结构，之所以用了一个字典，是为了后续检索方便，而字典的值又是一个列表的原因是，一个Trait里面可能有多个关联类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    &quot;T&quot;: [T::Value1, T::Value2],
    &quot;U&quot;: [U::Value3],
}
<span class="boring">}
</span></code></pre></pre>
<p>筛选出所有的关联类型后，我们再更新一下<code>impl</code>块的生成代码，与之前不同的是，对于关联类型的限定，只能放在where子句中，代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_debug_trait(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {

    // &lt;此处省略没有修改的代码&gt; ..........

    // 下面这一行是第七关新加的，调用函数找到关联类型信息
    let associated_types_map = get_generic_associated_types(st);
    for mut g in generics_param_to_modify.params.iter_mut() {
        if let syn::GenericParam::Type(t) = g {
            let type_param_name = t.ident.to_string();        
            
            if phantomdata_type_param_names.contains(&amp;type_param_name) &amp;&amp; !field_type_names.contains(&amp;type_param_name){
                continue;
            }

            // 下面这3行是本次新加的，如果是关联类型，就不要对泛型参数`T`本身再添加约束了,除非`T`本身也被直接使用了
            if associated_types_map.contains_key(&amp;type_param_name) &amp;&amp; !field_type_names.contains(&amp;type_param_name){
                continue
            }

            t.bounds.push(parse_quote!(std::fmt::Debug));
        }
    }

    // 以下6行是第七关新加的，关联类型的约束要放到where子句里
    generics_param_to_modify.make_where_clause();
    for (_, associated_types) in associated_types_map {
        for associated_type in associated_types {
            generics_param_to_modify.where_clause.as_mut().unwrap().predicates.push(parse_quote!(#associated_type:std::fmt::Debug));
        }
    }

    // &lt;此处省略没有修改的代码&gt; ..........
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第八关-1" id="第八关-1">第八关</a></h3>
<p>第八关视频版：<a href="https://www.bilibili.com/video/BV1vV41147ES?zw">https://www.bilibili.com/video/BV1vV41147ES?zw</a></p>
<p>这一关要实现的是之前提到的“逃生出口“(escape hatch)，由于前面介绍过的Rust过程宏展开机制的缺陷，在一些边界情况下我们无法正确推断出泛型的Trait限定，这时候，我们就需要提供一个人为干预的后门。本关分为两部分，一部分是必答题，提供一个全局的干预方式，还有一个是选做题，精确到对每个字段进行控制。因为这篇文章已经很长了，所以我们就只做必答题，选做题留给大家自己去实现了。</p>
<p>首先是要解析一个全局的属性标签，属性标签我们已经解析过很多次了，这次就直接给大家代码了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_struct_escape_hatch(st: &amp;syn::DeriveInput) -&gt; Option&lt;String&gt; {
    if let Some(inert_attr) = st.attrs.last() {
        if let Ok(syn::Meta::List(syn::MetaList { nested, .. })) = inert_attr.parse_meta() {
            if let Some(syn::NestedMeta::Meta(syn::Meta::NameValue(path_value))) = nested.last() {
                if path_value.path.is_ident(&quot;bound&quot;) {
                    if let syn::Lit::Str(ref lit) = path_value.lit {
                        return Some(lit.value());
                    }
                }
            }
        }
    }
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们拿到了用户输入的干预指令，其实就是一小段Rust的代码，我们要把这一小段Rust代码解析为语法树的节点后插入到where子句对应的节点中。解析用户的输入可以使用<code>syn::parse_str()</code>这个函数来实现。好了，直接上代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_debug_trait(st: &amp;syn::DeriveInput) -&gt; syn::Result&lt;proc_macro2::TokenStream&gt; {
   
    // &lt;此处省略没有修改的代码&gt; ..........


    // 判定是否设置了限定条件干预，如果设定了，则不进行推断，直接使用用户给出的限定条件放到where子句中
    if let Some(hatch) = get_struct_escape_hatch(st) {
        generics_param_to_modify.make_where_clause();
        generics_param_to_modify
                    .where_clause
                    .as_mut()
                    .unwrap()
                    .predicates
                    .push(syn::parse_str(hatch.as_str()).unwrap());
    } else {
        // 原来位于此处的代码，全部移动到else分支里面，其他不变，省略 ..........
    }

    let (impl_generics, type_generics, where_clause) = generics_param_to_modify.split_for_impl();

    // &lt;此处省略没有修改的代码&gt; ..........


}
<span class="boring">}
</span></code></pre></pre>
<p>最后，需要承认的一点是，上面写的这些代码肯定是不严谨的，或者说是漏洞百出的。一方面是这只是为了通过测试用例，并没有充分考虑测试用例没有覆盖到的场景；另一方面，大家也应该充分认识到，Rust的过程宏就是一个复杂的“字符串拼接”过程，他没有类型校验，我们通过字符串匹配来关联一些“类型”，因此你完全可以通过构造一些冲突的命名来迷惑我们的代码。这就是Rust的过程宏，充满了Trick。</p>
<h1><a class="header" href="#rust-学习笔记系列-part-4" id="rust-学习笔记系列-part-4">Rust 学习笔记系列｜ Part 4</a></h1>
<p>作者： 李大狗</p>
<p>本文是&quot;Rust 学习笔记&quot;系列的第四篇（除此之外还有两篇用 Rust 写智能合约的）。</p>
<p>在「Mapping 数据结构 | 用 Rust 写智能合约（二）」一文中，我们尝鲜了 FISCO BCOS 中的 Rust 智能合约，今天我们来看一看如何通过 Rust，和 FISCO BCOS 生态中的重要组件 —— Webase 进行交互。</p>
<blockquote>
<p><strong>WeBase：</strong></p>
<p>WeBASE（WeBank Blockchain Application Software Extension） 是在区块链应用和FISCO-BCOS节点之间搭建的一套通用组件。围绕交易、合约、密钥管理，数据，可视化管理来设计各个模块，开发者可以根据业务所需，选择子系统进行部署。WeBASE屏蔽了区块链底层的复杂度，降低开发者的门槛，大幅提高区块链应用的开发效率，包含节点前置、节点管理、交易链路，数据导出，Web管理平台等子系统。</p>
</blockquote>
<p>在本例中，为简单起见，我们仅需要安装部署WeBase系列中的WeBaseFront即可：</p>
<blockquote>
<p><strong>WeBaseFront：</strong></p>
<p>WeBASE-Front是和FISCO-BCOS节点配合使用的一个子系统。此分支支持FISCO-BCOS 2.0以上版本，集成web3sdk，对接口进行了封装，可通过HTTP请求和节点进行通信。另外，具备可视化控制台，可以在控制台上开发智能合约，部署合约和发送交易，并查看交易和区块详情。还可以管理私钥，对节点健康度进行监控和统计。</p>
</blockquote>
<p>安装文档：</p>
<blockquote>
<p>https://webasedoc.readthedocs.io/zh_CN/latest/docs/WeBASE-Front/index.html</p>
</blockquote>
<p>本文涉及知识点：</p>
<ul>
<li>reqwest 这个 Rust Http 库的使用</li>
<li>lib 的编写与使用</li>
</ul>
<h2><a class="header" href="#1-确保-webasefront-已启动" id="1-确保-webasefront-已启动">1 确保 WeBaseFront 已启动</a></h2>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq38yrd9sxj30vw0343z6.jpg" alt="image-20210430152702912" /></p>
<h2><a class="header" href="#2-创建新的-rust-项目" id="2-创建新的-rust-项目">2 创建新的 Rust 项目</a></h2>
<ol>
<li>创建项目<code>webase-interactor-example</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo new webase-interactor-example
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>更新目录结构</li>
</ol>
<p>在这次学习中，我们引入更复杂的项目结构，我们会在项目中创建一个lib并引用它，做到模块解耦。</p>
<p>我们进入项目目录并在项目下创建一个lib：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cd webase-interactor-example
cargo new webase-interactor --lib
<span class="boring">}
</span></code></pre></pre>
<p>我们再创建一个文件，在webase-interactor/src目录下创建<code>chain.rs</code>。</p>
<p>这样，我们得到了这样的目录结构：</p>
<pre><code>.
├── Cargo.toml
├── src
│   └── main.rs
└── webase-interactor
    ├── Cargo.toml
    └── src
        ├── chain.rs
        └── lib.rs
</code></pre>
<h2><a class="header" href="#3-编写webase-interactor库" id="3-编写webase-interactor库">3 编写<code>webase-interactor</code>库</a></h2>
<h3><a class="header" href="#31-编写webase-interactor的cargotoml" id="31-编写webase-interactor的cargotoml">3.1 编写<code>webase-interactor</code>的<code>Cargo.toml</code></a></h3>
<p><code>webase-interactor</code>的<code>Cargo.toml</code>如下：</p>
<pre><code>[package]
name = &quot;webase-interactor&quot;
version = &quot;0.1.0&quot;
authors = [&quot;leeduckgo &lt;albertschr@163.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
reqwest = { version = &quot;0.10&quot;, features = [&quot;blocking&quot;, &quot;json&quot;] }
tokio = { version = &quot;0.2&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>我们在此引入了<code>reqwest</code>这个<code>HTTP</code>库。</p>
<blockquote>
<p>An ergonomic, batteries-included HTTP Client for Rust.</p>
<p>https://github.com/seanmonstar/reqwest</p>
</blockquote>
<p><code>reqwest</code>支持同步/异步的<code>http</code>调用，在本实例中，我们使用同步方案。</p>
<h3><a class="header" href="#32-编写chainrs" id="32-编写chainrs">3.2 编写<code>chain.rs</code></a></h3>
<p><code>chain.rs</code>的内容如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Chain{
    ip: String,
}

impl Chain{
    pub fn new(ip: String) -&gt; Chain {
        Chain { ip }
    }
    pub fn get_ip(&amp;self) -&gt; String {
        self.ip.to_string()
    }

    pub fn get_block_number(&amp;self) -&gt; Result&lt;String, reqwest::Error&gt;{
        let mut url =self.ip.to_string();
        url += &amp;&quot;WeBASE-Front/1/web3/blockNumber/&quot;.to_string();
        let resp = 
            reqwest::blocking::get(&amp;url)?
            // .await?
            .text();
            // .await?;

        resp
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#321-结构体" id="321-结构体">3.2.1 结构体</a></h4>
<p>我们先定义了一个结构体，关于结构体更详细的介绍请见如下两个链接：</p>
<blockquote>
<p>https://www.runoob.com/rust/rust-struct.html</p>
<p>https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html</p>
</blockquote>
<p>在 Rust 中，Struct 语句仅用来定义，不能声明实例，结尾不需要<code>;</code>符号，而且每个字段定义之后用 <code>,</code>分隔。</p>
<p>如，定义一个矩形：</p>
<pre><code>struct Rectangle {
    width: u32,
    height: u32,
}
</code></pre>
<p>在本项目中，我们定义了一个结构体<code>Chain</code>，这个结构体有一个参数<code>ip</code>，我们可以通过这个参数定位到相应的<code>webase</code>。</p>
<h4><a class="header" href="#322-结构体方法" id="322-结构体方法">3.2.2 结构体方法</a></h4>
<p>如同在面向对象的编程语言中，函数挂载在类（Class）的里面一样，在 Rust 中，我们可以将函数挂载在结构体里面。</p>
<p>如，实现一个结构体函数<code>area</code>，计算出矩形的面积。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在本项目中，我们定义了如下方法：</p>
<ul>
<li><code>new</code>方法：创建一个新的Chain。</li>
<li><code>get_ip</code>方法：获取Chain实例的ip。</li>
<li><code>get_block_number</code>方法：通过和Webase交互，获取当前块高。</li>
</ul>
<p>在<code>get_block_number</code>方法中，我们拼接出url字符串，然后调用<code>reqwest</code>的<code>get</code>函数。</p>
<p><code>get</code>函数的返回值是<code>Result&lt;String, reqwest::Error&gt;</code>，所以我们的函数结构是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_block_number(&amp;self) -&gt; Result&lt;String, reqwest::Error&gt;{ //注意不要遗漏 &amp;self
  // do sth
  resp // 在 rust 中，我们无需return关键字，最后一行不带;，执行的结构即函数返回值。
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#33-编写librs" id="33-编写librs">3.3 编写<code>lib.rs</code></a></h3>
<p><code>lib.rs</code>内容如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # WeBase
//!
//! A library to interact with webase.
#![warn(unused_extern_crates)]

pub mod chain;
pub use self::chain::*;
<span class="boring">}
</span></code></pre></pre>
<p>这里我们把<code>chain</code>声明为一个命名空间。</p>
<p>mod还支持多级嵌套，如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// phrases.rs
pub mod english {
    pub mod greetings {
        pub fn hello() {
            println!(&quot;Hello!&quot;)
        }
        pub fn hey_guies() {
           println!(&quot;Hey, guies!&quot;)
        }
    }
    pub mod farewells {
        pub fn goodbye() {
            println!(&quot;Goodbye!&quot;)
        }
        pub fn see_you() {
            println!(&quot;See you!&quot;)
        }
    }
}

pub mod chinese {
    pub mod greetings {
        pub fn hello() {
            println!(&quot;你好!&quot;)
        }
        pub fn have_eaten() {
            println!(&quot;吃了么?&quot;)
        }
    }
    pub mod farewells {
        pub fn goodbye() {
            println!(&quot;再见!&quot;)
        }
        pub fn everyone_will_know_you() {
            println(&quot;天下谁人不识君!&quot;)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样来管理我们的模块，我们的代码在各种意义上都会更清晰。</p>
<h2><a class="header" href="#4-完成主项目" id="4-完成主项目">4 完成主项目</a></h2>
<h3><a class="header" href="#41-编写cargotoml" id="41-编写cargotoml">4.1 编写<code>Cargo.toml</code></a></h3>
<p>主项目的<code>Cargo.toml</code>如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;webase-interactor-example&quot;
version = &quot;0.1.0&quot;
authors = [&quot;leeduckgo &lt;albertschr@163.com&gt;&quot;]
edition = &quot;2018&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
pretty_env_logger = &quot;0.3&quot;
log = &quot;0.4&quot;

reqwest = { version = &quot;0.10&quot;, features = [&quot;json&quot;] }
tokio = { version = &quot;0.2&quot;, features = [&quot;full&quot;] }
webase-interacter = { path=&quot;./webase-interactor&quot;, version = &quot;0.1.0&quot;}
<span class="boring">}
</span></code></pre></pre>
<p>在本项目中，我们引入了<code>pretty_env_logger</code>，以便更好的进行输出。</p>
<p>除此之外，我们还引入了刚才创建的<code>webase-interactor</code>。</p>
<h3><a class="header" href="#42-编写mainrs" id="42-编写mainrs">4.2 编写<code>main.rs</code></a></h3>
<p><code>main.rs</code>的内容如下：</p>
<pre><pre class="playground"><code class="language-rust">extern crate pretty_env_logger;

use webase_interactor::Chain;

#[macro_use] extern crate log;

fn main(){
    pretty_env_logger::init(); 
    print_block_number();
    
}

pub fn print_block_number() {
    let ip = &quot;http://127.0.0.1:5002/&quot;.to_string();
    let chain = Chain::new(ip);
    let res = chain.get_block_number();
    match res {
        Err(e) =&gt; {
            println!(&quot;error: {}&quot;, e);
        }
        Ok(b_number) =&gt; {
            info!(&quot;last block height: {}&quot;, b_number);
        }
    }
}
</code></pre></pre>
<p>到此为止，我们的代码已经全部编写完成了。</p>
<p>编译：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo build
<span class="boring">}
</span></code></pre></pre>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq1uw72r7pj30x50aj0ue.jpg" alt="image-20210430163532957" /></p>
<p>执行：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RUST_LOG=info cargo run
<span class="boring">}
</span></code></pre></pre>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq1vdmzooaj30x20440tu.jpg" alt="image-20210430165231274" /></p>
<p>如期打印出当前块高。</p>
<p>我们在<code>cargo run</code>命令前加上<code>RUST_LOG=info</code>，所以我们在输出的时候仅会打印<code>info!</code>函数中的内容。</p>
<p>本系列所有源码见：</p>
<blockquote>
<p>https://github.com/leeduckgo/RustStudy</p>
</blockquote>
<h1><a class="header" href="#rust-学习笔记系列-part-5" id="rust-学习笔记系列-part-5">Rust 学习笔记系列｜ Part 5</a></h1>
<p>作者： 李大狗</p>
<hr />
<blockquote>
<p>本项目代码见：</p>
<p>https://github.com/leeduckgo/weid-rust-sample</p>
<p>本系列代码见：</p>
<p>https://github.com/leeduckgo/Rust-Study</p>
</blockquote>
<p>在上一篇文章中，我们使用 Rust 和 FISCO BCOS 开源框架中的 WeBase 进行了交互，使用了 reqwest 这个 Rust 中的 http 库，同时介绍了 Rust 项目中模块分离的设计。</p>
<p>今天，我们将结合 FISCO BCOS 生态中的数字身份组件 WeIdentity，来讲 Rust 中的数据库操作。</p>
<h2><a class="header" href="#1-什么是-数字身份标识与数字身份体系" id="1-什么是-数字身份标识与数字身份体系">1 什么是 数字身份标识与数字身份体系？</a></h2>
<p>首先，让我们来看下什么是分布式数字身份标识（DID）：</p>
<blockquote>
<p>分布式数字标识符（DID）是一种新型标识符，用以标识可验证的分布式的数字身份。 DID的控制者决定标识的主体（例如，人，组织，事物，数据模型，抽象实体等）。</p>
<p>— W3C DID规范</p>
</blockquote>
<p>围绕分布式数字身份标识，我们可以构建如下组件：</p>
<ul>
<li><strong>DID 文档</strong>——用以对该 DID 相关的地址、服务以及其它特性进行进一步的阐述。</li>
<li><strong>可验证声明</strong>——通过可验证声明，DID 控制者可以发放、持有、验证电子证书与电子凭证。</li>
<li><strong>选择型披露</strong>——结合隐私保护技术，DID 控制者可以在保障自己隐私的情况下，向需要的第三方选择性披露自己的数据，如证明自己的年龄大于 18 岁。</li>
<li><strong>数据存证</strong>——将可信数据和 DID 进行挂钩，便完整的形成了「数字身份—数字凭证—数据存证」的体系，如「学生身份—毕业证书—课堂表现」。</li>
</ul>
<p>这便是<strong>数字身份体系</strong>。</p>
<h2><a class="header" href="#2-什么是-weidentity" id="2-什么是-weidentity">2 什么是 WeIdentity？</a></h2>
<blockquote>
<p>WeIdentity是一套分布式多中心的技术解决方案，可承载实体对象（人或者物）的现实身份与链上身份的可信映射、以及实现实体对象之间安全的访问授权与数据交换。WeIdentity由微众银行自主研发并完全开源，秉承公众联盟链整合资源、交换价值、服务公众的理念，致力于成为链接多个垂直行业领域的分布式商业基础设施，促进泛行业、跨机构、跨地域间的身份认证和数据合作。</p>
<p>WeIdentity 目前主要包含两大模块：WeIdentity DID 以及 WeIdentity Credential。</p>
<p>WeIdentity 参考场景：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqonvch3gyj30pv0ea0tt.jpg" alt="roles-relation.png" /></p>
</blockquote>
<h2><a class="header" href="#3-weidentity-did规范" id="3-weidentity-did规范">3 WeIdentity DID规范</a></h2>
<p>WeIdentity 对基本的 DID 规范进行了扩展处理。</p>
<p>基本的 DID 规范：</p>
<p>DID是一个简单的文本字符串，由三部分组成：
1）DID过的URI方案标识符（Scheme，固定就是 did）
2）DID方法的标识符（DID Method）
3）DID方法生成的标识符（DID Method-Specific Identifier）
<img src="chapter_6//Users/liaohua/Documents/parts-of-a-did.png" alt="" /></p>
<p>扩展后的 WeIdentity：</p>
<p><img src="https://weidentity.readthedocs.io/zh_CN/latest/_images/weidentity-did-format1.png" alt="weidentity-did-format1.png" /></p>
<table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody>
<tr><td>did</td><td>遵循DID规范，使用固定字符“did”</td></tr>
<tr><td>weid</td><td>WeIdentity DID规范的method name字段，固定为“weid”</td></tr>
<tr><td>chain-id</td><td>链 ID，用于路由到不同的链网络（如果需要跟其他链打通，需要找 WeIdentity 开源项目的 owner 微众银行注册路由信息），例如同时使用 WeIdentity 的可能有多条区块链，可以使用这个字段作为标识信息，路由到特定区块链</td></tr>
<tr><td>bs-specific-string</td><td>基于底层区块链平台生成，代表Entity在链上的地址，保证全网唯一</td></tr>
</tbody></table>
<p>备注：bsSpecificString根据区块链底层平台和业务具体情况来确定生成规则，例如可以是随机字符串，或者区块链上的地址。</p>
<p>示例(这个例子中，chain-id是<code>101</code>: <code>&quot;did:weid:101:0x0086eb1f712ebc6f1c276e12ec21&quot;</code>。</p>
<h2><a class="header" href="#4-数据结构设计" id="4-数据结构设计">4 数据结构设计</a></h2>
<p>在今天的实践中，我们希望可以把weid保存到本地数据库中。</p>
<p>我们这次选择的是 Sqlite 数据库，在Rust - ORM 选择上，我们选择的是 Diesel，这个项目有 6.8k Stars。</p>
<blockquote>
<p>https://github.com/diesel-rs/diesel</p>
<p><strong>Tips：</strong> 接触新库时，我们可以通过学习 Repo 中的 Examples，来掌握 Repo 的用法。</p>
</blockquote>
<p>因为weid中，前半部分<code>did:weid</code>是不变的，所以我们只需保存<code>chain_id</code>和`<code>bs-specific-string\</code>即可。</p>
<p>在Rust中数据结构如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Weid {
    id: i32,
    chain_id: i32, //当然也可以同样设置为 String
    addr: String,

    created_at: NaiveDateTime, // 创建时间
    updated_at: NaiveDateTime, // 更新时间
}
<span class="boring">}
</span></code></pre></pre>
<p>数据库的创建语句如下：</p>
<pre><code class="language-sql">CREATE TABLE weids (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  addr TEXT NOT NULL,
  chain_id INTEGER, 
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
</code></pre>
<p>我们用标准规范创建数据库迁移文件夹<code>migration</code>：</p>
<pre><code>migrations
└── 2020-05-13-105400_create_weids
    ├── down.sql
    └── up.sql
</code></pre>
<p>其中，<code>up.sql</code>的内容即是上面的内容：</p>
<pre><code class="language-sql">CREATE TABLE weids (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  addr TEXT NOT NULL,
  chain_id INTEGER,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
</code></pre>
<p><code>down.sql</code>的内容就是移除<code>weids</code>表：</p>
<pre><code>DROP TABLE weids;
</code></pre>
<h2><a class="header" href="#5-数据库的创建与建表createmigrate" id="5-数据库的创建与建表createmigrate">5 数据库的创建与建表（Create&amp;Migrate）</a></h2>
<p>此处我们使用<code>diesel</code>使用的命令行工具。</p>
<p><strong>（1）复制必要文件到项目目录下</strong></p>
<p>从 Diesel 的代码仓库中 Clone 代码到本地。</p>
<blockquote>
<p>https://github.com/diesel-rs/diesel</p>
</blockquote>
<p>将 Repo 中的 <code>diesel</code>、<code>diesel_cli</code>、<code>diesel_derives</code>、<code>diesel_migrations</code>复制到项目根目录下。</p>
<p>在项目根目录下新建<code>bin</code>文件夹。</p>
<p>编译 Diesel Repo，将<code>target/debug/diesel</code>文件复制到<code>bin</code>目录下。</p>
<p><strong>（2）配置环境变量</strong></p>
<p>我们需要设置两个环境变量：</p>
<ul>
<li>DATABASE_URL——数据库路径</li>
<li>BACKEND———数据库类型</li>
</ul>
<p>直接执行如下命令即可：</p>
<pre><code class="language-bash">export DATABASE_URL=&quot;examples.db&quot;
export BACKEND=&quot;sqlite&quot;
</code></pre>
<p><strong>（3）创建数据库与建表</strong></p>
<p>执行如下命令：</p>
<pre><code class="language-bash">./bin/diesel database reset
</code></pre>
<p>顺利的话，会出现如下返回：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr1ve5v2z4j312m04odh4.jpg" alt="image-20210513171857371" /></p>
<p>同时根目录下出现<code>examples.db</code>文件。</p>
<h2><a class="header" href="#6-modelsrs" id="6-modelsrs">6 models.rs</a></h2>
<p>我们在<code>src</code>目录下创建<code>models.rs</code>文件，在其中定义结构体<code>Weid</code>与<code>NewWeid</code>，定义 schema（模式）<code>weids</code>。</p>
<blockquote>
<p>Scheme，可以简单的理解为我们告诉程序数据库中有哪些字段，这样程序才能顺利对接数据库。</p>
</blockquote>
<p><code>models.rs</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::NaiveDateTime;
#[cfg(test)]
use diesel::debug_query;
use diesel::insert_into;
use diesel::prelude::*;
#[cfg(test)]
use diesel::sqlite::Sqlite;
use serde_derive::Deserialize;
use std::error::Error;

pub mod schema {
    diesel::table! {
        weids {
            id -&gt; Integer,
            chain_id -&gt; Integer,
            addr -&gt; Text,

            created_at -&gt; Timestamp,
            updated_at -&gt; Timestamp,
        }
    }
}

use schema::weids;

#[derive(Insertable)]
#[table_name = &quot;weids&quot;]
pub struct NewWeid {
    pub chain_id: i32,
    pub addr: String,
}

#[derive(Queryable, PartialEq, Debug)]
pub struct Weid {
    pub id: i32,
    pub chain_id: i32,
    pub addr: String,

    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime, 
}

pub fn insert_default_values(conn: &amp;SqliteConnection) -&gt; QueryResult&lt;usize&gt; {
    use schema::weids::dsl::*;

    insert_into(weids).default_values().execute(conn)
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>代码解析：</strong></p>
<blockquote>
<p><strong>注：</strong> 以下内容对《Rust 程序设计语言（第一版）》有所参考。</p>
<p>https://kaisery.gitbooks.io/rust-book-chinese/content/content/Traits.html</p>
</blockquote>
<p>trait 是一个告诉 Rust 编译器一个类型必须提供哪些功能语言特性。</p>
<p>例如，我们可以为结构体<code>Circle</code>实现<code>HasArea</code>这个<code>trait</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如你所见，<code>trait</code>块与<code>impl</code>看起来很像，不过我们没有定义一个函数体，只是函数标记。当我们<code>impl</code>一个trait时，我们使用<code>impl Trait for Item</code>，而不是仅仅<code>impl Item</code>。</p>
<p>重复的实现像<code>Debug</code>和<code>Default</code>这样的 trait 会变得很无趣。为此，Rust 提供了一个[属性](https://kaisery.gitbooks.io/rust-book-chinese/content/content/Attributes 属性.md)来允许我们让 Rust 为我们自动实现 trait：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Foo;

fn main() {
    println!(&quot;{:?}&quot;, Foo);
}
</code></pre></pre>
<p><code>Rust 1.15</code>中引入了自定义<code>derive</code>特性，从而让<code>derive</code>有了更多的想象空间。</p>
<p>我们通过<code>#[derive(Insertable)]</code>与<code>#[derive(Queryable, PartialEq, Debug)]</code>，让该结构体具备可插入数据库，或从数据库查询的特性。</p>
<h2><a class="header" href="#7-mainrs" id="7-mainrs">7 main.rs</a></h2>
<p>main.rs 的内容如下所示：</p>
<pre><pre class="playground"><code class="language-rust">extern crate pretty_env_logger;

pub mod models;

use diesel::prelude::*;
use std::env;
use dotenv::dotenv;

use weid_light_client::WeIdRestService;
use models::*;

use models::schema::weids;
use models::schema::weids::dsl::*;

#[macro_use] extern crate log;

fn main(){
    pretty_env_logger::init(); 

    // create data
    let sqlite_conn = establish_connection();
    create_weid(&amp;sqlite_conn, 1, &quot;34be11396f3a91c5Ab5A1220e756C6300FB2b20a&quot;);
    
    // query data
    let results = weids.load::&lt;Weid&gt;(&amp;sqlite_conn)
        .expect(&quot;Error loading weids&quot;);
    // log weids
    info!(&quot;Displaying {} weids&quot;, results.len());
    for weid in results{
        info!(&quot;did:weid:{}:{}&quot;, weid.chain_id, weid.addr);
    }
}

pub fn establish_connection() -&gt; SqliteConnection {
    dotenv().ok();

    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);
    SqliteConnection::establish(&amp;database_url)
        .unwrap_or_else(|_| panic!(&quot;Error connecting to {}&quot;, database_url))
}

pub fn create_weid(conn: &amp;SqliteConnection, c_id: i32, address: &amp;str) -&gt; usize {
    

    let new_weid = NewWeid {chain_id: c_id, addr: address.to_string()};

    diesel::insert_into(weids::table)
        .values(&amp;new_weid)
        .execute(conn)
        .expect(&quot;Error saving new weid&quot;)
}
</code></pre></pre>
<p><strong>代码解析：</strong></p>
<p><code>establish_connection</code>直接拷贝自 Diesel 的Examples，作用是根据环境变量中的<code>DATABASE_URL</code>连接<code>sqlite</code>数据库。</p>
<p><code>create_weid</code>函数中，我们先创建一个 NewWeid 结构体对象，然后通过<code>diesel::insert_into</code>函数将新建的结构体对象插入数据库。</p>
<p>通过<code>loads</code>函数，我们从数据库中加载<code>Weid</code>结构体。</p>
<h2><a class="header" href="#8-运行" id="8-运行">8 运行</a></h2>
<p>执行<code>RUST_LOG=trace cargo run</code>。</p>
<p>我们成功向数据库插入一条 weid 数据，并读取 出weid 数据。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqonwobwtgj31cw076ac3.jpg" alt="image-20210513180708811" /></p>
<p>关于<code>diesel</code>的更多更详细的用法，见：</p>
<blockquote>
<p>https://diesel.rs/guides/getting-started</p>
</blockquote>
<h1><a class="header" href="#rust-学习笔记系列-part-6" id="rust-学习笔记系列-part-6">Rust 学习笔记系列｜ Part 6</a></h1>
<p>作者： 李大狗（李骜华）</p>
<hr />
<blockquote>
<p>**系列简介：**狗哥 Rust 学习笔记系列是大狗为对抗 Rust 陡峭的学习曲线而推出的 Rust 学习系列，具备如下原则：</p>
<ol>
<li><strong>循序渐进原则</strong></li>
</ol>
<p>按照阶梯法则（下一篇的难度是上一篇难度+1）原则进行设计，让学习 Rust 跟打游戏一样简单。</p>
<ol start="2">
<li><strong>单一知识点原则</strong></li>
</ol>
<p>一篇文章只讲一个一个知识点，保证简单性与专注性。</p>
<ol start="3">
<li><strong>实用原则</strong></li>
</ol>
<p>所有案例均是真实实践案例，实用性超强。</p>
</blockquote>
<p>在上一篇文章里，我们开启了<code>weid-rust-example</code>项目，学习了如何通过<code>diesel</code>项目玩转<code>SQLite</code>数据库。今天我们依然在这个项目的基础上往前推进。</p>
<h2><a class="header" href="#实现功能" id="实现功能">实现功能</a></h2>
<p>我们将围绕结构体<code>Struct WeId</code>，实现<code>create_weid_online</code>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct WeId{
    endpoint_url: String,
    weid: String, 
}

impl WeId{
	pub fn create_weid_online(&amp;self) -&gt; ... {
    
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>和以往我们实现过的函数不同的是，在这个函数中，我们可以遇到多种可能的错误（Error），因此，在返回值里我们就不能向过去一样，填写<code>Result&lt;Value, reqwest::Error&gt;</code>，我们需要通过一个枚举（Enum）把可能的错误打包在一起。</p>
<p>Let's Go!</p>
<h2><a class="header" href="#create_weid_online-函数拆解" id="create_weid_online-函数拆解">create_weid_online 函数拆解</a></h2>
<p>在函数式编程中，我们会遵循「单一职责原则」，简单来说，就是一个函数只做一件事。因此，即使<code>create_weid_online</code>是简单的函数，我们依然可以将其拆分：</p>
<pre><code>create_weid_online —— 子函数的组合
    |------ call_create_weid —— 通过weid-rest-service的接口注册托管型 weid 并获得返回值
    |------ str_to_json —— 将 &amp;str 值转换为 json 
</code></pre>
<h2><a class="header" href="#子函数的实现" id="子函数的实现">子函数的实现</a></h2>
<p><code>str_to_json</code>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn str_to_json(&amp;self, payload: &amp;str) -&gt; Result&lt;Value, serde_json::Error&gt; {
	serde_json::from_str(payload)
}
<span class="boring">}
</span></code></pre></pre>
<p>这个函数中使用了<code>serde_json</code>库，在<code>Cargo.toml</code>为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
...
serde_json = { version = &quot;1.0&quot; }
...
<span class="boring">}
</span></code></pre></pre>
<p><code>call_create_weid</code>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn call_create_weid(&amp;self) -&gt; Result&lt;String, reqwest::Error&gt; {
    let mut url =self.endpoint_url.to_string();
    url += &amp;&quot;/weid/api/invoke&quot;.to_string();
    // ::blocking:: to block
    let response = reqwest::blocking::Client::new()
    .post(&amp;url)
    .json(&amp;serde_json::json!({
        &quot;functionArg&quot;: {},
        &quot;transactionArg&quot;: {},
        &quot;v&quot;: &quot;1.0.0&quot;,
        &quot;functionName&quot;: &quot;createWeId&quot;
    }))
    .send()?
    .text();
    
    response
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>**注：**在前面的文章中我们介绍了用 reqwest 调用 get 接口，这次我们调用 post 接口。</p>
</blockquote>
<p>这个函数中使用了<code>reqwest</code>库，在<code>Cargo.toml</code>为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
...
reqwest = { version = &quot;0.10&quot;, features = [&quot;blocking&quot;, &quot;json&quot;] }
tokio = { version = &quot;0.2&quot;, features = [&quot;full&quot;] }
...
<span class="boring">}
</span></code></pre></pre>
<p>WeId-Rest-Service 的接口说明请见：</p>
<blockquote>
<p>https://weidentity.readthedocs.io/zh_CN/latest/docs/weidentity-rest-api.html</p>
</blockquote>
<h2><a class="header" href="#主函数的实现" id="主函数的实现">主函数的实现</a></h2>
<p>以下是<code>create_weid_online</code>函数的源码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_weid_online(&amp;self) -&gt; Result&lt;Value, GenerateWeIdError&gt;{
    let response = self.call_create_weid()?; // line1
    let resp = self.str_to_json(&amp;response)?; // line2
    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到，在返回值里的 Error 处，我们填的是自定义的错误类型<code>GenerateWeidError</code> 。</p>
<p>所以，在<code>line1</code>处可能发生的<code>reqwest::Error</code>错误，和<code>line2</code>处可能发生的<code>serde_json::Error</code>，会被汇集在<code>GenerateWeIdError</code>中。</p>
<h2><a class="header" href="#聚合错误处理的实现" id="聚合错误处理的实现">聚合错误处理的实现</a></h2>
<p>在这里我们使用<code>thiserror</code>这个库，这是目前的最佳处理方案。</p>
<p>在<code>Cargo.toml</code>中引用<code>thiserror</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
...
thiserror = &quot;1.0&quot;
...
<span class="boring">}
</span></code></pre></pre>
<p>官方的例子是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum DataStoreError {
    #[error(&quot;data store disconnected&quot;)]
    Disconnect(#[from] io::Error),
    #[error(&quot;the data for key `{0}` is not available&quot;)]
    Redaction(String),
    #[error(&quot;invalid header (expected {expected:?}, found {found:?})&quot;)]
    InvalidHeader {
        expected: String,
        found: String,
    },
    #[error(&quot;unknown data store error&quot;)]
    Unknown,
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里我们简单使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 记得 enum 要写在 Struct 外面。
#[derive(Error, Debug)]
pub enum GenerateWeIdError {
    #[error(&quot;req error&quot;)]
    RequestError(#[from] reqwest::Error),
    #[error(&quot;parse error&quot;)]
    ParseError(#[from] serde_json::Error),
}
<span class="boring">}
</span></code></pre></pre>
<p>这样，就能让<code>GenerateWeIdError</code>囊括这个函数中的所有可能 error 了。</p>
<blockquote>
<p>【补充资料】关于 Enum 枚举：</p>
<p>https://kaisery.github.io/trpl-zh-cn/ch06-01-defining-an-enum.html</p>
</blockquote>
<h2><a class="header" href="#main函数" id="main函数">main函数</a></h2>
<p>在<code>main</code>函数中，我们对结构体与函数进行调用：</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let weid = WeId::new(&quot;http://127.0.0.1:6001&quot;.to_string());
    let result = weid.create_weid_online();
    match result {
        Ok(payload) =&gt; println!(&quot;{:}&quot;, payload),
        Err(e) =&gt; println!(&quot;{}&quot;, e)
    }
</code></pre></pre>
<p>执行后，打印出了我们期待的结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr1vdgbq6jj30o501ut8y.jpg" alt="image-20210527142348963" /></p>
<blockquote>
<p>本项目代码见：</p>
<p>https://github.com/leeduckgo/weid-rust-sample</p>
<p>本系列代码见：</p>
<p>https://github.com/leeduckgo/Rust-Study</p>
</blockquote>
<h1><a class="header" href="#rust-学习笔记系列-part-7" id="rust-学习笔记系列-part-7">Rust 学习笔记系列｜ Part 7</a></h1>
<p>作者：李大狗</p>
<hr />
<blockquote>
<p>**系列简介：**狗哥 Rust 学习笔记系列是大狗为对抗 Rust 陡峭的学习曲线而推出的 Rust 学习系列，具备如下原则：</p>
<ol>
<li><strong>循序渐进原则</strong></li>
</ol>
<p>按照阶梯法则（下一篇的难度是上一篇难度+1）原则进行设计，让学习 Rust 跟打游戏一样简单。</p>
<ol start="2">
<li><strong>单一知识点原则</strong></li>
</ol>
<p>一篇文章只讲一个一个知识点，保证简单性与专注性。</p>
<ol start="3">
<li><strong>实用原则</strong></li>
</ol>
<p>所有案例均是真实实践案例，实用性超强。</p>
</blockquote>
<p>在之前的两篇文章中，我们分别介绍了：</p>
<ul>
<li>
<p>如何本地存储 WeId</p>
<p><a href="https://mp.weixin.qq.com/s/872b8pmCB-WJ_QcS_uUGAg">用 Sqlite 存储 WeId | Rust 学习笔记（五）</a></p>
</li>
<li>
<p>调用接口在链上生成 WeId</p>
<p><a href="https://mp.weixin.qq.com/s/heiZgabqzvBue4SOx0LjBg">链上注册WeId与错误处理 | Rust 学习笔记（六）</a></p>
</li>
</ul>
<p>将二者整合，我们可以得到 WeId 的链上生成 — 本地存储的完整闭环。这个项目我已推送到 Github 上并补充了 README，欢迎 STAR~</p>
<blockquote>
<p>https://github.com/leeduckgo/weid-rust-sample</p>
</blockquote>
<h2><a class="header" href="#项目结构-1" id="项目结构-1">项目结构</a></h2>
<pre><code class="language-bash">.
├── Cargo.lock
├── Cargo.toml
├── README.md
├── bin # bin 中放置的是 diesel 二进制软件体
├── diesel # diesel 开头均为数据库相关
├── diesel_cli
├── diesel_derives
├── diesel_migrations
├── ethereum # 以太坊包，为之后本地生成-链上注册做准备
├── model # 同上
├── examples.db # sqlite 数据库
├── migrations # 数据库记录文件
├── src # 主文件
|     ├── main.rs
|     └── models.rs
├── weid-light-client # 解耦轻客户端，对接 weid-rest-service 服务
└── target # 编译后的文件
</code></pre>
<h2><a class="header" href="#当前流程" id="当前流程">当前流程</a></h2>
<ol>
<li>调用 WeIdGenerator，在链上注册<code>WeIdentity</code>。</li>
</ol>
<p>借助了<code>reqwest</code>库，详细使用方法见：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/heiZgabqzvBue4SOx0LjBg">链上注册WeId与错误处理 | Rust 学习笔记（六）</a></p>
</blockquote>
<p><code>weid-light-client/src/weid_generator.rs</code>源码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::{Value};
use thiserror::Error;

/// Provide an implementation for the default() method:
/// https://doc.rust-lang.org/stable/core/default/trait.Default.html
#[derive(Default)]
pub struct WeIdGenerator{
    endpoint_url: String,
    weid: String, 
}

impl WeIdGenerator{
    pub fn new(endpoint_url: String) -&gt; WeIdGenerator {
        WeIdGenerator {endpoint_url, ..Default::default()}
    }
    /// String or &amp;str?
    /// Ref: https://zhuanlan.zhihu.com/p/123278299
    /// 显然，这取决于很多因素，但是一般地，保守来讲，如果我们正在构建的API不需要拥有或者修改使用的文本，
    /// 那么应该使用&amp;str而不是String。
    /// 等一下，但是如果这个API的调用者真的有一个String并且出于某些未知原因无法将其转换成&amp;str呢？完全没有问题。
    /// Rust有一个超级强大的特性叫做deref coercing，这个特性能够允许把传进来的带有借用操作符的String引用，
    /// 也就是&amp;String，在API执行之前转成&amp;str。我们会在另一篇文章里介绍更多地相关细节。
    pub fn generate_local(&amp;mut self, chain_id: i32, addr: &amp;str) -&gt; String {
        self.weid = &quot;did:weid:&quot;.to_string() + &amp;chain_id.to_string() + &quot;:&quot; + addr;
        // Ref: https://stackoverflow.com/questions/38304666/how-to-define-a-copyable-struct-containing-a-string
        // String is copyable, use .clone()
        // String is not implicitly copyable, because that would cause non-obvious memory allocations to occur
        self.weid.clone()
    }

    /// create weid online.
    pub fn create_weid_online(&amp;self) -&gt; Result&lt;Value, GenerateWeIdError&gt;{
        let response = self.call_create_weid()?;
        let resp = self.str_to_json(&amp;response)?;
        Ok(resp)
    }

    fn str_to_json(&amp;self, payload: &amp;str) -&gt; Result&lt;Value, serde_json::Error&gt; {
        serde_json::from_str(payload)
    }
    pub fn call_create_weid(&amp;self) -&gt; Result&lt;String, reqwest::Error&gt; {
        let mut url =self.endpoint_url.to_string();
        url += &amp;&quot;/weid/api/invoke&quot;.to_string();
        // ::blocking:: to block
        let response = reqwest::blocking::Client::new()
        .post(&amp;url)
        .json(&amp;serde_json::json!({
            &quot;functionArg&quot;: {},
            &quot;transactionArg&quot;: {},
            &quot;v&quot;: &quot;1.0.0&quot;,
            &quot;functionName&quot;: &quot;createWeId&quot;
        }))
        .send()?
        .text();
        
        response
    }
}
/// multi error handle:
/// https://my.oschina.net/jmjoy/blog/3190024
#[derive(Error, Debug)]
pub enum GenerateWeIdError {
    #[error(&quot;req error&quot;)]
    RequestError(#[from] reqwest::Error),
    #[error(&quot;parse error&quot;)]
    ParseError(#[from] serde_json::Error),
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li><code>create_weid_online()</code>函数结果处理，见<code>src/main.rs</code>：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gen_weid_online_and_save(weid_generator: WeIdGenerator) -&gt; Result&lt;Value, GenerateWeIdError&gt;{
  let result = weid_generator.create_weid_online();

  match result {
    Ok(payload) =&gt; {
      // TODO
      //weid = payload |&gt; to_weid
      //vec_weid = weid |&gt; vec
      // save to local sqlite
      // info
      Ok(payload)
    },
    Err(e) =&gt; {
      info!(&quot;{}&quot;, e);
      Err(e)
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>定义数据结构与数据 CRUD 操作</li>
</ol>
<p>详见：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/872b8pmCB-WJ_QcS_uUGAg">用 Sqlite 存储 WeId | Rust 学习笔记（五）</a></p>
</blockquote>
<p><code>src/models.rs</code>源码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::NaiveDateTime;
#[cfg(test)]
use diesel::debug_query;
use diesel::insert_into;
use diesel::prelude::*;

use std::env;
use dotenv::dotenv;

#[cfg(test)]
use diesel::sqlite::Sqlite;

pub mod schema {
    diesel::table! {
        weids {
            id -&gt; Integer,
            chain_id -&gt; Integer,
            addr -&gt; Text,

            created_at -&gt; Timestamp,
            updated_at -&gt; Timestamp,
        }
    }
}

use schema::weids;

#[derive(Insertable)]
#[table_name = &quot;weids&quot;]
pub struct NewWeId {
    pub chain_id: i32,
    pub addr: String,
}

#[derive(Queryable, PartialEq, Debug)]
pub struct WeId {
    pub id: i32,
    pub chain_id: i32,
    pub addr: String,

    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime, 
}

pub fn insert_default_values(conn: &amp;SqliteConnection) -&gt; QueryResult&lt;usize&gt; {
    use schema::weids::dsl::*;

    insert_into(weids).default_values().execute(conn)
}

pub fn establish_connection() -&gt; SqliteConnection {
    dotenv().ok();

    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);
    SqliteConnection::establish(&amp;database_url)
        .unwrap_or_else(|_| panic!(&quot;Error connecting to {}&quot;, database_url))
}

pub fn save_weid(conn: &amp;SqliteConnection, c_id: i32, address: &amp;str) -&gt; usize {
    
    let new_weid = NewWeId {chain_id: c_id, addr: address.to_string()};

    diesel::insert_into(weids::table)
        .values(&amp;new_weid)
        .execute(conn)
        .expect(&quot;Error saving new weid&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<ol start="4">
<li>补充 2 中的 TODO 部分</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gen_weid_online_and_save(weid_generator: WeIdGenerator) -&gt; Result&lt;Value, GenerateWeIdError&gt;{
    let result = weid_generator.create_weid_online();

    match result {
        Ok(payload) =&gt; {
          	// str handle
            let weid_str: String = 
                payload[&quot;respBody&quot;]
                .to_string()
                .replace(&quot;\&quot;&quot;, &quot;&quot;);
          	// str to vec
            let vec: Vec&lt;&amp;str&gt; = 
                weid_str
                .split(&quot;:&quot;)
                .collect();
          	

            let chain_id: i32 = vec[2].parse().unwrap();
            let addr: &amp;str = vec[3];
            // create data
            let sqlite_conn = models::establish_connection();
            
            models::save_weid(&amp;sqlite_conn, chain_id, addr);
            info!(&quot;gen and save weid to local {}.&quot;, weid_str);
            Ok(payload)
        },
        Err(e) =&gt; {
            info!(&quot;{}&quot;, e);
            Err(e)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="5">
<li>在 main 函数中调用</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main(){
    pretty_env_logger::init();
  	// 从环境变量中拿取 &quot;WEID_URL&quot;
    let url = env::var(&quot;WEID_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);
    let weid_generator = WeIdGenerator::new(url.to_string());
    gen_weid_online_and_save(weid_generator);
}
</code></pre></pre>
<h2><a class="header" href="#运行项目" id="运行项目">运行项目</a></h2>
<ol>
<li>初始化数据库</li>
</ol>
<pre><code class="language-bash">./bin/diesel database reset
</code></pre>
<ol start="2">
<li>设置环境变量</li>
</ol>
<pre><code class="language-bash"># 推荐使用direnv
export DATABASE_URL=&quot;examples.db&quot;
export BACKEND=&quot;sqlite&quot;
export WEID_URL=&lt;weid-rest-service url&gt;
</code></pre>
<ol start="3">
<li>运行项目</li>
</ol>
<pre><code>RUST_LOG=info cargo run
</code></pre>
<p>目前会在链上创建托管型<code>WeId</code>并存储在本地的<code>Sqlite</code>数据库中。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grmd7pdyzaj30ll0a2wfx.jpg" alt="image-20210617172840467" /></p>
<h2><a class="header" href="#升级方向" id="升级方向">升级方向</a></h2>
<ol>
<li>添加「私钥不出域」创建WeId的方式；</li>
<li>实现 <code>WeIdentity Document</code>的同步操作；</li>
<li>目前项目开发需要先启动<code>WeIdentity-Rest-Service</code>，考虑设计 Mock 接口，方便开发。</li>
</ol>
<h1><a class="header" href="#用-rust-学习解析器组合子-combinator" id="用-rust-学习解析器组合子-combinator">用 Rust 学习解析器组合子 (combinator)</a></h1>
<p><a href="https://bodil.lol/parser-combinators/">原文</a></p>
<blockquote>
<p>译者: <a href="https://github.com/iamazy">iamazy</a>, <a href="https://github.com/MATRIXKOO">Matrixtang</a></p>
</blockquote>
<p>本文向已是 Rust 程序员的人们传授解析器组合子的基础知识。它假定不涉及其他知识，并将解释与 Rust 没有直接关系的所有内容，以及为达到此目的使用 Rust 的一些令人意外的特性。如果你不了解 Rust，他不会教你 Rust 的内容，但是这样的话，同样也无法更好的教你解析器和组合子的知识。如果你想要学习 Rust 语言，我推荐 <a href="https://doc.rust-lang.org/book/">Rust 编程语言</a> 这本书。</p>
<h2><a class="header" href="#beginners-mind" id="beginners-mind">Beginner's Mind</a></h2>
<p>当每个程序员发现自己需要解析器时，它们的生活将变得有意义。</p>
<p>初级程序员将会问：“什么是解析器？”。<br />
中级程序员将会说：“这很简单，我将写一串正则表达式”。<br />
高级程序员将会说：“退一步考虑问题，我知道<code>Lex</code>(词法分析器)和<code>Yacc</code>(语法解析器)”</p>
<p>初级程序员的想法是正确的。</p>
<p>不是说正则表达式不好(但是请不要用正则表达式写复杂的解析器)。使用经过 <code>数千年 (millennia)</code> 磨练至完美的解析器和词法分析生成器之类的强大工具并不是没有乐趣可言。但是从头开始一点一点学习解析器将更有趣。这两者只是对当前实际问题的抽象，如果你直接选择正则表达式或者解析器生成工具，你将失去这一份乐趣。在初学者眼中，正如人们说的：本来(解决这个问题)有很多种方法，但是在专家眼里，已经形成思维定视，只会选择一种他们最习惯的方式。
在本文中我们将从头开始学习如何构建解析器，基于被称为解析器组合子的函数式编程语言的通用技术。一旦你掌握了它们的基本概念，它们的优势将非常巨大，同时又非常接近第一原理。因为这里唯一的抽象是你将在基础的组合子之上构建你自己的抽象。所有这些，你必须先构建它们，才能使用它们。</p>
<h2><a class="header" href="#how-to-work-through-this-article" id="how-to-work-through-this-article">How To Work Through This Article</a></h2>
<p>强烈建议你初始化一个 Rust 项目，并且在<code>src/lib.rs</code>中书写你阅读到的代码片段(你可以直接从页面上直接复制，但是最好还是自己手敲，因为这样会自动确保你完整阅读代码)。本文将按序介绍你需要的每段代码。请注意，有时会引入你先前编写功能的最新版本，这时，你需要将旧版本替换为新版本。</p>
<p>该代码是使用 2018 年语言版本的<code>rustc</code>的 1.34.0 版本编写的。你应该尽可能使用最新版本的编译器，只要你确保你使用的是 2018 的版本即可(检查<code>Cargo.toml</code>文件中是否包含<code>edition = &quot;2018&quot;</code>)。代码不需要任何的外部依赖。</p>
<p>如果要运行本文中的测试用例，请执行<code>cargo test</code>。</p>
<h2><a class="header" href="#the-xcruciating-markup-language" id="the-xcruciating-markup-language">The Xcruciating Markup Language</a></h2>
<p>我们将用简化的 XML 格式写一个解析器，如下所示：</p>
<pre><code class="language-xml">&lt;parent-element&gt;
  &lt;single-element attribute=&quot;value&quot; /&gt;
&lt;/parent-element&gt;
</code></pre>
<p>XML 元素使用<code>&lt;</code>符号开头和一个由字母组成的标志符开头，后面可以根任意数量的字母，数字和<code>-</code>。后面跟一些空格，以及一些属性对的可选列表：前面定义一个标识符，后面跟一个<code>=</code>符号和一个双引号字符串，最后以<code>/&gt;</code>结尾来表示一个没有子节点的单个元素。或者用<code>&gt;</code>表示后面跟了一串子节点，最终是一个以<code>&lt;/</code>开头的结束标签，后跟一个必须与开始标识匹配的标志符，然后以<code>&gt;</code>结束。</p>
<p>这就是我们将要支持的特性。没有命名空间，没有文本节点，其余的都没有，并且没有模式校验。我们甚至都不会自寻烦恼，去实现字符串的转义引号(<code>\&quot;</code>) - 它们由第一个双引号开始，到下一个双引号结束，就是这样。如果你想在实际字符串中使用双引号，你可以将这个不合理的要求转移到其他地方。</p>
<p>我们将用下面的结构体来解析这些元素。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String,
    attributes: Vec&lt;(String, String)&gt;,
    children: Vec&lt;Element&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>没有花哨的类型，仅仅用字符串表示名称(那是每个标签开始的标志符)，用字符串元组表示属性(标志符和对应的值)，还有一个看起来和父元素完全一样的子元素列表。</p>
<p>(如果你正在输入，请加上那一系列的<code>derive</code>，你将在后面用到它们)。</p>
<h2><a class="header" href="#defining-the-parser" id="defining-the-parser">Defining The Parser</a></h2>
<p>好了，是时候编写解析器了。</p>
<p>解析是从数据流中派生结构的过程。解析器就是要弄清楚该结构的工具。</p>
<p>在我们即将探索的知识中，解析器最简单的一种形式就是一个函数，该函数接受一些输入并返回解析后的输出以及输入的其余部分，或者是一个错误信息：“我无法解析该输入”。</p>
<p>事实证明，简而言之，更复杂的解析器看起来也是如此。如果你要获取友好的错误提示，你可能会使输入，输出和错误的含义复杂化，但是解析器的特征依然如此：消费输入并产生解析后的数据以及输入的其余部分，或者会让你知道无法将输入解析成输出。</p>
<p>让我们将其(解析器)写成函数的形式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Fn(Input) -&gt; Result&lt;(Input, Output), Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>更具体的说，就我们而言，我们希望可以填充这些类型，就像下面代码块所示。因为我们要做的是将一个字符串转化为<code>Element</code>结构体，并且在这方面我们不想陷入错综复杂的错误提示中，所以当我们不能够解析输入的字符串时，只需返回一段提示错误的字符串即可。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Fn(&amp;str) -&gt; Result&lt;(&amp;str, Element), &amp;str&gt;
<span class="boring">}
</span></code></pre></pre>
<p>我们使用字符串切片(<code>&amp;str</code>)，是因为他是指向字符串的有效指针。我们可以进一步对其进行切片，通过切掉已解析的部分来消耗输入，并将余下的输入和结果一起返回。</p>
<p>可能使用<code>&amp;[u8]</code>类型作为输入(一串字节数组，如果将输入的字节限制在<code>ASCII</code>范围内，则<code>u8</code>和<code>char</code>相对应)会看起来更加干净，尤其是字符串切片(<code>&amp;str</code>)的行为和大多数切片的行为有所不同。你不能够通过一个数字来检索它们，你必须使用一个分片<code>input[0..1]</code>。另一方面，它们对于解析字符串有很多有用的函数，而字节切片没有。</p>
<p>事实上，我们通常都需要依赖这些函数而不是像<code>input[0]</code>这样对他进行索引。因为 Rust 的字符串是<code>UTF-8</code>格式的，这些索引并不总是对应于单个字符，所以对于我们来说，让标准库为我们处理这些问题更好。</p>
<h2><a class="header" href="#our-first-parser" id="our-first-parser">Our First Parser</a></h2>
<p>让我们来一起写一个解析器，只需要关注字符串中的第一个字符并判断它是否是字母<code>a</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn the_letter_a(input: &amp;str) -&gt; Result&lt;(&amp;str, ()), &amp;str&gt; {
  match input.chars().next() {
      Some('a') =&gt; Ok((&amp;input['a'.len_utf8()..], ())),
      _ =&gt; Err(input),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们来看一下输入和输入和输出的类型：和上面讨论的一样，我们让字符串切片作为输入，并返回携带<code>(&amp;str, ())</code>元组或者错误类型<code>&amp;str</code>的<code>Result</code>。<code>(&amp;str, ())</code>元组比较有趣：正如我们所说的，我们想要返回一个包含下一次待解析的输入和输出。<code>&amp;str</code>是下一次输入，解析返回的结果仅仅是一个单元类型<code>()</code>。因为如果解析成功，只可能有一种结果(我们找到了字母<code>a</code>)，但是这里我们并不需要返回字母<code>a</code>，我们只需要告诉调用者我们成功发现了字母<code>a</code>即可。</p>
<p>然后，让我们看下解析器本身的代码。我们从提取输入的第一个字符开始：<code>input.chars().next()</code>。依靠标准库来避免带来的 Unicode 编码问题并不是在开玩笑 - 我们要求它为字符串的字符提供一个<code>chars()</code>迭代器，然后从中取出第一项。该项是封装在<code>Option</code>中的<code>char</code>类型，因此是<code>Option&lt;char&gt;</code>，如果它的值为<code>None</code>则表示我们尝试在空字符串中提取一个<code>char</code>。</p>
<p>更糟的是，<code>char</code>可能并不是你想的那样是 Unicode 字符。它很可能就是 Unicode 所说的“<a href="http://www.unicode.org/glossary/#grapheme_cluster">字素簇</a>”，它可以由几个<code>char</code>组成，实际上代表“<a href="http://www.unicode.org/glossary/#unicode_scalar_value">标量值</a>”，大约比字素簇低两级。但是这种方式太疯狂了，出于我们(讲解)的目的，我们可能根本不会看到除 ASCII 之外的字符集，所以这种情况我们不做讨论。</p>
<p>我们模式匹配上了<code>Some('a')</code>，这是我们正在寻找的特定结果，如果匹配上，则返回结果<code>Ok((&amp;input['a'.len_utf8()..], ()))</code>。也就是说，我们在字符串切片中删除了刚刚解析的<code>'a'</code>并返回剩余部分以及我们的解析结果(一个空的<code>()</code>)。考虑到 Unicode 怪物，我们在切片之前向标准库询问了<code>'a'</code>在 UTF-8 编码中的长度，但是，请永远不要假设 Unicode 怪物。</p>
<p>如果我们匹配到其他的<code>Some(char)</code>或者<code>None</code>，我们将返回一个错误。你可能还记得，我们的错误类型目前还是解析失败时的字符串切片，也就是作为<code>input</code>传入的字符串切片。它不以<code>'a'</code>开头，因此这是我们的错误。但这不是一个大的错误，但是至少比“其他地方出了问题”要好一些。</p>
<p>虽然我们不需要使用此解析器解析 XML，但是我们要做的第一件事就是查找<code>&lt;</code>，因此我们可能需要一些相似的东西。我们还需要专门解析<code>&gt;</code>，<code>/</code>，<code>=</code>，因此我们可以创建一个函数为我们想要的字符构建一个解析器？</p>
<h2><a class="header" href="#a-parser-builder" id="a-parser-builder">A Parser Builder</a></h2>
<p>我们想象一下：编写一个函数，可以为任意长度的静态字符串(而不仅仅是单个字符)生成一个解析器。这种方式甚至更容易，因为一个字符串切片已经是一个合法的 UTF-8 字符串切片，我们不需要再去考虑 Unicode 怪物。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn match_literal(expected: &amp;'static str)
    -&gt; impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, ()), &amp;str&gt;
{
    move |input| match input.get(0..expected.len()) {
        Some(next) if next == expected =&gt; {
            Ok((&amp;input[expected.len()..], ()))
        }
        _ =&gt; Err(input),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个函数看起来有点不同。</p>
<p>我们先看下类型。我们的函数看起来不再像是一个解析器，它将我们期望的字符串作为参数，并返回一个看似解析器的东西。它是一个返回函数的函数 - 换言之，是一个高阶函数。基本上，我们在编写一个函数，该函数可以构建一个类似之前的<code>the_letter_a</code>函数。</p>
<p>因此，我们不是在函数体中完成工作，而是返回一个闭包用来处理这些事情，该闭包与我们之前解析器的类型签名相匹配。</p>
<p>模式匹配看起来是一样的，除了我们不能直接匹配字符串字面量，因为我们不知道它具体是什么，所以我们使用匹配条件<code>if next == expected</code>代替。否则它和以前完全一样，只是在闭包的主体内。</p>
<h2><a class="header" href="#testing-our-parser" id="testing-our-parser">Testing Our Parser</a></h2>
<p>我们来为它编写测试用例，确保这个函数没有问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn literal_parser() {
    let parse_joe = match_literal(&quot;Hello Joe!&quot;);
    assert_eq!(
        Ok((&quot;&quot;, ())),
        parse_joe(&quot;Hello Joe!&quot;)
    );
    assert_eq!(
        Ok((&quot; Hello Robert!&quot;, ())),
        parse_joe(&quot;Hello Joe! Hello Robert!&quot;)
    );
    assert_eq!(
        Err(&quot;Hello Mike!&quot;),
        parse_joe(&quot;Hello Mike!&quot;)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们构建了一个解析器：<code>match_literal(&quot;Hello Joe!&quot;)</code>。它应该消耗字符串<code>&quot;Hello Joe!&quot;</code>并返回字符串的剩余部分，或者失败并返回整个字符串。</p>
<p>在第一种情况下，我们为它提供了它期望的确切字符串，并看到它返回了一个空字符串以及<code>()</code>值，这表示“我们解析了期望的字符串，并且不需要将它真的返回”。</p>
<p>在第二种情况下，我们提供了字符串<code>&quot;Hello Joe! Hello Robert!&quot;</code>，并且我们看到它确实消耗了字符串<code>&quot;Hello Joe!&quot;</code>并且返回了输入字符串的剩余部分：<code>&quot;Hello Robert!&quot;</code>(包括空格)。</p>
<p>在第三种情况下，我们提供了一个不正确的输入<code>&quot;Hello Mike!&quot;</code>，并注意到该函数拒绝了这个输入并返回了一个错误。不是说 Mike 作为一般规则是不正确的，而是它不是此解析器所需要的。</p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<ul>
<li>你能在标准库中找到一个关于<code>str</code>类型的方法，让你编写<code>match_literal()</code>时不必做麻烦的<code>get</code>索引吗？</li>
</ul>
<h2><a class="header" href="#a-parser-for-something-less-specific" id="a-parser-for-something-less-specific">A Parser For Something Less Specific</a></h2>
<p>我们可以继续解析<code>&lt;</code>，<code>&gt;</code>，<code>=</code>以及<code>&lt;/</code>和<code>/&gt;</code>。我们几乎已经完成了。</p>
<p><code>&lt;</code>之后需要识别的部分是元素名称。我们不能通过简单的字符串比较做到这一点。但是我们可以使用正则表达式。</p>
<p>但是我们需要克制一下自己，这将是一个很容易在简单代码中复用的正则表达式，我们不需要为此引入<code>regex</code>库。让我们尝试一下是否可以只使用 Rust 标准库来编写自己的解析器。</p>
<p>回顾元素名称标志符的规则：首位是字母，后跟零个或多个字母，数字或<code>-</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn identifier(input: &amp;str) -&gt; Result&lt;(&amp;str, String), &amp;str&gt; {
    let mut matched = String::new();
    let mut chars = input.chars();

    match chars.next() {
        Some(next) if next.is_alphabetic() =&gt; matched.push(next),
        _ =&gt; return Err(input),
    }

    while let Some(next) = chars.next() {
        if next.is_alphanumeric() || next == '-' {
            matched.push(next);
        } else {
            break;
        }
    }

    let next_index = matched.len();
    Ok((&amp;input[next_index..], matched))
}
<span class="boring">}
</span></code></pre></pre>
<p>与往常一样，我们首先查看类型。这次我们不是编写函数来构建解析器，只需要编写解析器本身，就像第一次一样。这里显著的区别是，我们返回元组中的<code>String</code>和剩余的输入，而不是<code>()</code>的结果类型。这个<code>String</code>将包含我们刚刚解析的标志符。</p>
<p>考虑到这一点，我们首先创建一个空字符串并将称之为<code>matched</code>。它是我们将要返回的结果值。我们在<code>input</code>中获取一个字符的迭代器，我们将对其进行拆解。</p>
<p>第一步是查看前面是否有字母。我们从迭代器中取出第一个字符并检查它是否是一个字母：<code>next.is_alphabetic()</code>。Rust 标准库当然是帮我们来处理 Unicode 的 - 这将匹配任何字母表中的字母，而不仅仅是 ASCII。如果它是一个字母，我们将它放入我们的<code>matched</code>字符串中，如果不是，显然我们不是在查看元素标志符，所以我们立即返回一个错误。</p>
<p>第二步，我们不断从迭代器中取出字符，将它们放入我们正在构建的字符串中，直到我们找到一个既不是<code>is_alphanumeric()</code>(就像是<code>is_alphabetic()</code>，它只是不能匹配字母表中的任何数字)也不是破折号<code>'-'</code>的字符。</p>
<p>当我们第一次看到不符合这些条件的字符时，意味着我们已经完成了解析，所以我们跳出循环并返回我们构建的<code>String</code>，记住去掉我们在<code>input</code>中消耗的字符。如果迭代器用完了字符，意味着我们到达了<code>input</code>的末尾。</p>
<p>值得注意的是，当我们看到不是字母数字 (alphanumeric) 或破折号(<code>-</code>)的内容时，我们不会返回错误。一旦我们匹配了第一个字母，我们就已经有足够的东西来创建一个有效的标志符。而且在我们解析完标志符以后，输入字符串中有更多待解析的字符是非常正常的，所以我们只是停止解析并返回我们的结果，只有当我们找不到第一个字母时，我们才真正的返回错误，因为在这种情况下，肯定没有标志符。</p>
<p>还记得我们要将 XML 文档解析成的<code>Element</code>结构吗？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Element {
    name: String,
    attributes: Vec&lt;(String, String)&gt;,
    children: Vec&lt;Element&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们实际上只是完成了解析器的第一部分，<code>name</code>字段。我们解析器返回的字符串就在那里。它也是解析每个<code>attribute</code>第一部分需要的解析器。</p>
<p>让我们对其进行测试。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn identifier_parser() {
    assert_eq!(
        Ok((&quot;&quot;, &quot;i-am-an-identifier&quot;.to_string())),
        identifier(&quot;i-am-an-identifier&quot;)
    );
    assert_eq!(
        Ok((&quot; entirely an identifier&quot;, &quot;not&quot;.to_string())),
        identifier(&quot;not entirely an identifier&quot;)
    );
    assert_eq!(
        Err(&quot;!not at all an identifier&quot;),
        identifier(&quot;!not at all an identifier&quot;)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以在第一种情况中看到，字符串<code>&quot;i-am-an-identifier&quot;</code>被完整解析，只留下空的字符串。在第二种情况中，解析器返回<code>&quot;not&quot;</code>作为标志符，并且字符串的剩余部分作为剩余的输入返回。在第三种情况中，解析彻底 (outright) 失败，因为它找到的第一个字符不是字母。</p>
<h2><a class="header" href="#combinators" id="combinators">Combinators</a></h2>
<p>现在，我们已经可以解析<code>&lt;</code>，以及之后的标志符了，但是我们需要同时将它们进行解析，以便在这里可以取得进展。因此接下来将编写另一个解析器的构造函数，它将两个解析器作为输入并返回一个新的解析器，并按顺序解析它们。换言之，它是一个解析器组合子，因为它将两个解析器组合成一个新的解析器。让我们看看我们是否能够做到这一点。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pair&lt;P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, (R1, R2)), &amp;str&gt;
where
    P1: Fn(&amp;str) -&gt; Result&lt;(&amp;str, R1), &amp;str&gt;,
    P2: Fn(&amp;str) -&gt; Result&lt;(&amp;str, R2), &amp;str&gt;,
{
    move |input| match parser1(input) {
        Ok((next_input, result1)) =&gt; match parser2(next_input) {
            Ok((final_input, result2)) =&gt; Ok((final_input, (result1, result2))),
            Err(err) =&gt; Err(err),
        },
        Err(err) =&gt; Err(err),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里有点复杂，但是你知道该怎么做：从查看类型开始。</p>
<p>首先，我们有四种类型变量：<code>P1</code>，<code>P2</code>，<code>R1</code>以及<code>R2</code>。这是 Parser1，Parser2，Result1，Result2 的缩写。<code>P1</code>，<code>P2</code>是函数，你会注意到它们遵循解析器函数的既定模式 (established pattern)：就像返回值，它们将<code>&amp;str</code>作为输入并返回一个<code>Result</code>类型，该<code>Result</code>类型可能是一个包含剩余输入以及解析结果的二元组，或者是一个错误。</p>
<p>但是查看每个函数的结果类型：<code>P1</code>如果解析成功，将会产生<code>R1</code>，<code>P2</code>同理会产生<code>R2</code>。最终解析器的结果 - 从我们的函数返回的结果 - 是<code>(R1, R2)</code>。因此该解析器的工作是先在输入上运行解析器<code>P1</code>，然后在<code>P1</code>返回的剩余输入上运行<code>P2</code>，如果这两个解析器都执行成功，则我们将两个解析器返回的结果组合进元组<code>(R1, R2)</code>。</p>
<p>查看代码，我们看到这也正是它所做得。我们首先在输入上运行第一个解析器，然后是第二个解析器，接着将两个结果组合成一个元组并返回。如果这些解析器中的任何一个执行失败，我们会立即返回它给出的错误。</p>
<p>这样，我们应该能够结合之前的两个解析器<code>match_literal</code>和<code>identifier</code>来实际解析 XML 标签的第一部分(<code>&lt;my-first-element/&gt;</code>)。让我们编写测试用例看它是否正确。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn pair_combinator() {
    let tag_opener = pair(match_literal(&quot;&lt;&quot;), identifier);
    assert_eq!(
        Ok((&quot;/&gt;&quot;, ((), &quot;my-first-element&quot;.to_string()))),
        tag_opener(&quot;&lt;my-first-element/&gt;&quot;)
    );
    assert_eq!(Err(&quot;oops&quot;), tag_opener(&quot;oops&quot;));
    assert_eq!(Err(&quot;!oops&quot;), tag_opener(&quot;&lt;!oops&quot;));
}
<span class="boring">}
</span></code></pre></pre>
<p>它看起来成功了！但是看下结果类型：<code>((), String)</code>。很明显，我们只关心右边的值 - <code>String</code>。这种情况相当普遍 - 我们的一些解析器只匹配输入中的模式但不产生值，因此可以安全的忽略他们的输出。为了适应这种模式，我们将使用<code>pair</code>组合子编写另外两个组合子<code>left</code>，它丢弃第一个解析器的结果，只返回第二个，以及它的相反数<code>right</code>，我们想在上面的测试中使用<code>right</code>而不是<code>pair</code> - 它可以丢弃二元组左边的<code>()</code>只保留右边的<code>String</code>。</p>
<h2><a class="header" href="#enter-the-functor" id="enter-the-functor">Enter The Functor</a></h2>
<p>在我们深入讨论之前，先介绍另一个组合子：<code>map</code>，它将使编写这两个解析器更加简单。</p>
<p>这个组合子有一个目的：改变结果的类型。例如，假设你有一个解析器返回<code>((), String)</code>，但是你希望能够将其返回值类型修改为<code>String</code>。</p>
<p>为了做到这点，我们传入一个函数，该函数知道如何将原始类型转换成新的类型。在我们的示例中，该函数十分简单：<code>|(_left, right)| right</code>。它的一般格式就像<code>Fn(A) -&gt; B</code>，其中<code>A</code>是解析器的原始类型，<code>B</code>是期望的新类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, B), &amp;str&gt;
where
    P: Fn(&amp;str) -&gt; Result&lt;(&amp;str, A), &amp;str&gt;,
    F: Fn(A) -&gt; B,
{
    move |input| match parser(input) {
        Ok((next_input, result)) =&gt; Ok((next_input, map_fn(result))),
        Err(err) =&gt; Err(err),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这些类型说明什么？<code>P</code>是我们的解析器。它在成功时将返回<code>A</code>。<code>F</code>是我们将用于将<code>P</code>映射到我们的返回值中的函数，它看起来和<code>P</code>很像，但是它的返回值类型是<code>B</code>而不是<code>A</code>。</p>
<p>在代码中，我们运行<code>parser(input)</code>，如果执行成功，我们将拿到<code>result</code>并在其上运行函数<code>map_fn(result)</code>，然后将<code>A</code>转换成<code>B</code>。</p>
<p>实际上，我们可以稍微放纵 (indulge) 一下自己并缩短一下这个函数，因为<code>map</code>实际上是处理<code>Result</code>的一种常见模式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, B), &amp;str&gt;
where
    P: Fn(&amp;str) -&gt; Result&lt;(&amp;str, A), &amp;str&gt;,
    F: Fn(A) -&gt; B,
{
    move |input|
        parser(input)
            .map(|(next_input, result)| (next_input, map_fn(result)))
}
<span class="boring">}
</span></code></pre></pre>
<p>这种模式在 Haskell 以及范畴论 (category theory) 中被称为”函子 (functor)“。如果你在其中有一个类型为<code>A</code>的东西，并且有一个可用的<code>map</code>函数，你可以将某个函数从<code>A</code>传递到<code>B</code>以将其转换成相同类型的东西，但是在其中使用类型<code>B</code>，这就是一个函子。你可以在 Rust 中很多地方见到它，如在 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map">Option</a> 中，<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map">Result</a> 中，<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map">Iterator</a> 甚至在 <a href="https://docs.rs/futures/0.1.26/futures/future/trait.Future.html#method.map">Future</a> 中，但它没有被明确命名。因为在 Rust 的类型系统中，你不能真正的将函子表示为泛化的东西，因为它缺乏更高级的类型，但那是另一回事了，所以我们只需关注这些函子，寻找<code>map</code>函数即可。</p>
<h2><a class="header" href="#time-for-a-trait" id="time-for-a-trait">Time For A Trait</a></h2>
<p>你可能已经注意到，我们不断重复解析器类型签名的格式：<code>Fn(&amp;str) -&gt; Result&lt;(&amp;str, Output), &amp;str&gt;</code>。你可能已经厌倦了像我写的那样完整的阅读它，所以我认为是时候引入一个 trait，让这些更具有可读性，还可以为解析器添加一些扩展性。</p>
<p>但是首先，我们先为一直使用的返回值类型创建一个类型别名：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type ParseResult&lt;'a, Output&gt; = Result&lt;(&amp;'a str, Output), &amp;'a str&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们可以不用一直输入那串冗长的类型，可以直接使用<code>ParseResult&lt;String&gt;</code>。我们可以在这里添加一个生命周期，因为类型的声明需要它，但是大多数时候 Rust 编译器可以帮你推断。通常，可以尝试不添加生命周期，并观察 rustc 是否报错，如果报错则添加生命周期。</p>
<p>在此例中，<code>'a</code>特指<code>input</code>的生命周期。</p>
<p>现在，对于 trait，我们也需要在这里声明生命周期，并且当你使用该 trait 时，生命周期通常也是必须的。这是一个额外的输入，但它击败了以前的版本。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser&lt;'a, Output&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; ParseResult&lt;'a, Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>它目前只有一个方法：<code>parse()</code>方法，它看起来似曾相识：它和我们之前编写的解析器函数基本相同。</p>
<p>为了让它更加简单，我们实际上可以为任何匹配解析器签名的函数实现这个 trait。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, F, Output&gt; Parser&lt;'a, Output&gt; for F
where
    F: Fn(&amp;'a str) -&gt; ParseResult&lt;Output&gt;,
{
    fn parse(&amp;self, input: &amp;'a str) -&gt; ParseResult&lt;'a, Output&gt; {
        self(input)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过这种方式，我们不仅可以传递迄今为止已传递的相同函数作为解析器，并完全实现<code>Parser</code> trait，还可以使用其他类型作为解析器。</p>
<p>但是，更重要的是，它把我们从必须一直输入这些函数签名的噩梦中解救了出来。让我们重写<code>map</code>函数，并看它是如何工作的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map&lt;'a, P, F, A, B&gt;(parser: P, map_fn: F) -&gt; impl Parser&lt;'a, B&gt;
where
    P: Parser&lt;'a, A&gt;,
    F: Fn(A) -&gt; B,
{
    move |input|
        parser.parse(input)
            .map(|(next_input, result)| (next_input, map_fn(result)))
}
<span class="boring">}
</span></code></pre></pre>
<p>这里需要特别注意的一件事是：我们现在必须执行<code>parser.parse(input)</code>，而不是将解析器作为函数调用，因为我们不知道类型<code>P</code>是否是函数，我们只知道它实现了<code>Parser</code>，并且我们必须使用<code>Parser</code>提供的接口。但是函数体看起来完全一样，类型看起来也更加简洁。只是有一个新的额外噪音：生命周期<code>'a</code>，但总的来说是一个很大的改进。</p>
<p>如果我们以相同的方式重新编写<code>pair</code>函数，会看起来更加简洁：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pair&lt;'a, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; impl Parser&lt;'a, (R1, R2)&gt;
where
    P1: Parser&lt;'a, R1&gt;,
    P2: Parser&lt;'a, R2&gt;,
{
    move |input| match parser1.parse(input) {
        Ok((next_input, result1)) =&gt; match parser2.parse(next_input) {
            Ok((final_input, result2)) =&gt; Ok((final_input, (result1, result2))),
            Err(err) =&gt; Err(err),
        },
        Err(err) =&gt; Err(err),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>和之前一样，这里唯一的改变就是类型签名更加简洁，并且需要执行<code>parser.parse(input)</code>而不是<code>parse(input)</code>。</p>
<p>实际上，我们还可以简化<code>pair</code>函数的主题，通过使用<code>map</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pair&lt;'a, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; impl Parser&lt;'a, (R1, R2)&gt;
where
    P1: Parser&lt;'a, R1&gt;,
    P2: Parser&lt;'a, R2&gt;,
{
    move |input| {
        parser1.parse(input).and_then(|(next_input, result1)| {
            parser2.parse(next_input)
                .map(|(last_input, result2)| (last_input, (result1, result2)))
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Result</code>的<code>and_then</code>方法和<code>map</code>类似，不同之处在于<code>map</code>函数不会返回新值到<code>Result</code>内部，而是返回一个新的<code>Result</code>。上面的代码与先前使用<code>match</code>块的版本效果相同。稍后我们将回到<code>and_then</code>，但是现在，既然我们有一个干净简洁的<code>map</code>，我们可以真正实现<code>left</code>，<code>right</code>组合子。</p>
<h2><a class="header" href="#left-and-right" id="left-and-right">Left And Right</a></h2>
<p>有了<code>pair</code>和<code>map</code>，我们可以非常简洁的编写<code>left</code>和<code>right</code>组合子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn left&lt;'a, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; impl Parser&lt;'a, R1&gt;
where
    P1: Parser&lt;'a, R1&gt;,
    P2: Parser&lt;'a, R2&gt;,
{
    map(pair(parser1, parser2), |(left, _right)| left)
}

fn right&lt;'a, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; impl Parser&lt;'a, R2&gt;
where
    P1: Parser&lt;'a, R1&gt;,
    P2: Parser&lt;'a, R2&gt;,
{
    map(pair(parser1, parser2), |(_left, right)| right)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们使用<code>pair</code>组合子将两个解析器组合成一个解析器，然后使用<code>map</code>组合子选择其结果元组中我们想要保留的部分。</p>
<p>现在我们需要为元素标签的前两部分重写测试，使它更简洁一些，在此过程中，我们将获得了一些重要的新解析器组合子功能。</p>
<p>不过，我们必须先更新我们的两个解析器以使用<code>Parser</code>和<code>ParseResult</code>。<code>match_literal</code>是更复杂的一个：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn match_literal&lt;'a&gt;(expected: &amp;'static str) -&gt; impl Parser&lt;'a, ()&gt; {
    move |input: &amp;'a str| match input.get(0..expected.len()) {
        Some(next) if next == expected =&gt; Ok((&amp;input[expected.len()..], ())),
        _ =&gt; Err(input),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>除了改变返回值类型之外，我们还必须确保闭包的输入类型是<code>&amp;'a str</code>，否则 rustc 会报错。</p>
<p>对于<code>identifier</code>，只需更改返回值类型即可，编译器会自动为你推断生命周期。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn identifier(input: &amp;str) -&gt; ParseResult&lt;String&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>接下来进行测试，可以看见在结果中没有那个笨拙 (ungainly) 的<code>()</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn right_combinator() {
    let tag_opener = right(match_literal(&quot;&lt;&quot;), identifier);
    assert_eq!(
        Ok((&quot;/&gt;&quot;, &quot;my-first-element&quot;.to_string())),
        tag_opener.parse(&quot;&lt;my-first-element/&gt;&quot;)
    );
    assert_eq!(Err(&quot;oops&quot;), tag_opener.parse(&quot;oops&quot;));
    assert_eq!(Err(&quot;!oops&quot;), tag_opener.parse(&quot;&lt;!oops&quot;));
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#one-or-more" id="one-or-more">One Or More</a></h2>
<p>让我们继续解析元素标签。我们已经解析了<code>&lt;</code>和标志符。然后呢？应该是我们的第一个属性对。</p>
<p>实际上这些属性对是可选的。我们需要找到一种方式来处理这种可选的标记。</p>
<p>等等，实际上在我们得到第一个可选属性对之前我们必须处理一些事情：空格。</p>
<p>在元素名称的末尾以及第一个属性名称(如果存在的话)的开头之间，存在一个空格。我们需要处理这个空格。</p>
<p>甚至更糟的是，我们需要处理一个或多个空格，因为<code>&lt;element attribute=&quot;value&quot;/&gt;</code>也是一个合法的语法，即使它的空格很多。所以这似乎是我们考虑是否可以编写一个组合子来表示一个或多个解析器想法的好时机。</p>
<p>我们在<code>identifier</code>解析器中已经处理过这个问题，但是一切都是在那里手动完成的。毫不奇怪，总体思路的代码并没有什么不同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn one_or_more&lt;'a, P, A&gt;(parser: P) -&gt; impl Parser&lt;'a, Vec&lt;A&gt;&gt;
where
    P: Parser&lt;'a, A&gt;,
{
    move |mut input| {
        let mut result = Vec::new();

        if let Ok((next_input, first_item)) = parser.parse(input) {
            input = next_input;
            result.push(first_item);
        } else {
            return Err(input);
        }

        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们构建的解析器返回值类型是<code>A</code>，组合解析器的返回值类型是<code>Vec&lt;A&gt;</code> - 任意数量的<code>A</code>。</p>
<p>这个代码看起来确实和<code>identifier</code>很像。首先，我们解析第一个元素，如果不存在，则返回一个错误。然后我们尽可能多的解析元素，直到解析失败，此时我们返回包含收集元素的向量。</p>
<p>将上述代码修改为支持解析零次或多次的解析器也很简单，只需删除前部分<code>if</code>判断即可：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn zero_or_more&lt;'a, P, A&gt;(parser: P) -&gt; impl Parser&lt;'a, Vec&lt;A&gt;&gt;
where
    P: Parser&lt;'a, A&gt;,
{
    move |mut input| {
        let mut result = Vec::new();

        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们编写测试用例以验证这两个解析器的功能符合预期。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn one_or_more_combinator() {
    let parser = one_or_more(match_literal(&quot;ha&quot;));
    assert_eq!(Ok((&quot;&quot;, vec![(), (), ()])), parser.parse(&quot;hahaha&quot;));
    assert_eq!(Err(&quot;ahah&quot;), parser.parse(&quot;ahah&quot;));
    assert_eq!(Err(&quot;&quot;), parser.parse(&quot;&quot;));
}

#[test]
fn zero_or_more_combinator() {
    let parser = zero_or_more(match_literal(&quot;ha&quot;));
    assert_eq!(Ok((&quot;&quot;, vec![(), (), ()])), parser.parse(&quot;hahaha&quot;));
    assert_eq!(Ok((&quot;ahah&quot;, vec![])), parser.parse(&quot;ahah&quot;));
    assert_eq!(Ok((&quot;&quot;, vec![])), parser.parse(&quot;&quot;));
}
<span class="boring">}
</span></code></pre></pre>
<p>请注意两者的不同之处：对于<code>one_or_more</code>，解析空字符串时会返回错误，因为它需要找到至少一个满足其子解析器的输入，但是对于<code>zero_or_more</code>，一个空字符串只是意味着没有满足条件的输入，它并不是一个错误。</p>
<p>鉴于此，可以考虑将这两个方法进行泛化，因为一个是另一个的副本，只是移除了一部分功能。用<code>zero_or_more</code>来表示<code>one_or_more</code>可能会很诱人 (tempt)。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn one_or_more&lt;'a, P, A&gt;(parser: P) -&gt; impl Parser&lt;'a, Vec&lt;A&gt;&gt;
where
    P: Parser&lt;'a, A&gt;,
{
    map(pair(parser, zero_or_more(parser)), |(head, mut tail)| {
        tail.insert(0, head);
        tail
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们遇到了 Rust 的一个问题，我甚至不是指<code>Vec</code>没有<code>cons</code>方法的问题，但我知道每个阅读那段代码的 Lisp 程序员都在思考这个问题：那就是所有权。</p>
<p>我们拥有这个解析器，所以我们不能将其作为参数传递两次，编译器会试图对你大喊，因为你试图移动一个已经移动的值。那么我们可以让组合子代替引用吗？不，事实证明，我们还遇到另一整套借用检查器的问题 - 我们目前不会试图解决这些问题。并且因为这些解析器是函数，所以它们不会实现<code>Clone</code>，该 trait 本来可以帮我们节省一整天的时间，所以我们被困在一个约束中，我们不能在组合子中轻易地复用我们的解析器。</p>
<p>不过，这不是一个大问题。它只是说明我们不能使用组合子来表达<code>one_or_more</code>，但事实证明，这两个通常是你需要的唯一组合子，它们往往会重用解析器，而且，如果你想变得非常花哨，除了解析器，你还可以编写一个带有<code>RangeBound</code>的组合子，并在一个范围内对其进行重复：<code>zero_or_more</code>使用<code>range(0..)</code>，<code>one_or_more</code>使用<code>range(1..)</code>，<code>five_or_six</code>使用<code>range(5..=6)</code>，依此类推。</p>
<p>不过，让我们把它留给读者作为练习。现在我们只需使用<code>zero_or_more</code>和<code>one_or_more</code>即可。</p>
<p>另一个练习可能是找到解决这些所有权问题的方法 - 也许可以通过将解析器包装在<code>Rc</code>中使其支持克隆？</p>
<h2><a class="header" href="#a-predicate-combinator-a-hrefhttpsbodillolparser-combinatorsa-predicate-combinatora" id="a-predicate-combinator-a-hrefhttpsbodillolparser-combinatorsa-predicate-combinatora">A Predicate Combinator <a href="https://bodil.lol/parser-combinators/#a-predicate-combinator">#</a></a></h2>
<p>我们现在有了需要用 <code>one_or_more</code> 解析空白的 <code>xml</code> 块，并用 <code>zero_or_more</code> 解析属性对。 其实，稍等一下。我们其实不想先解析空格 <em>然后</em> 解析属性 (<code>attributes</code>)。如果你考虑一下，如果没有属性，空格是可选的，我们可能会遇到直接的 <code>&gt;</code> 或 <code>/&gt;</code>。但是如果有一个属性，那么<em>必须</em>是空格。幸运的是，每个属性之间也必须有空格，如果有多个，所以我们在这里真正看到的是一系列<em>零或更多</em>出现的<em>一个或多个</em>空格项，然后是属性。</p>
<p>我们首先需要一个解析单个空白项的解析器。我们可以选择下列三种方式之一。</p>
<p>一，我们可以愚蠢地使用我们的 <code>match_literal</code> 解析器和一个只包含一个空格的字符串。为什么这么傻？因为空格也是换行符、制表符和大量呈现为空格的奇怪 Unicode 字符。我们将不得不再次依赖 Rust 的标准库，当然 <code>char</code> 有一个 <code>is_whitespace</code> 方法，就像它有 <code>is_alphabetic</code> 和 <code>is_alphanumeric</code> 一样。</p>
<p>二，我们可以使用 <code>is_whitespace</code> Predicate 写出另外一个解析器，它消耗任意数量的空白字符，就像我们之前编写的 <code>identifier</code> 一样。</p>
<p>三，我们可以写的更加巧妙。编写一个解析器 <code>any_char</code>，它返回一个单一的 <code>char</code>，只要输入中还剩下一个，以及一个组合子 <code>pred</code>，它接受一个解析器和一个谓词 (Predicate）函数，并像这样将两者结合起来：<code>pred (any_char, |c| c.is_whitespace())</code>。这有一个额外的好处，通过它，编写我们将需要的最终的解析器变得非常容易：属性值的引用字符串。 <code>any_char</code> 解析器写起来很简单，但我们得记得注意那些 UTF-8 问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn any_char(input: &amp;str) -&gt; ParseResult&lt;char&gt; {
    match input.chars().next() {
        Some(next) =&gt; Ok((&amp;input[next.len_utf8()..], next)),
        _ =&gt; Err(input),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>对 <code>经验丰富</code> 的我们来说， <code>pred</code> 组合子也并没有给我们太多惊喜 。 我们调用解析器，然后我们在解析器成功的情况下调用我们的谓词函数，并且只有当它返回 true 时，我们才真正返回 <code>success</code>，否则我们将返回与解析器失败一致的错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pred&lt;'a, P, A, F&gt;(parser: P, predicate: F) -&gt; impl Parser&lt;'a, A&gt;
where
    P: Parser&lt;'a, A&gt;,
    F: Fn(&amp;A) -&gt; bool,
{
    move |input| {
        if let Ok((next_input, value)) = parser.parse(input) {
            if predicate(&amp;value) {
                return Ok((next_input, value));
            }
        }
        Err(input)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>写一个快速测试以确保一切正常：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn predicate_combinator() {
    let parser = pred(any_char, |c| *c == 'o');
    assert_eq!(Ok((&quot;mg&quot;, 'o')), parser.parse(&quot;omg&quot;));
    assert_eq!(Err(&quot;lol&quot;), parser.parse(&quot;lol&quot;));
}
<span class="boring">}
</span></code></pre></pre>
<p>有了这两个组件，我们可以用一个快速的单行代码编写我们的 <code>whitespace_char</code> 解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whitespace_char&lt;'a&gt;() -&gt; impl Parser&lt;'a, char&gt; {
    pred(any_char, |c| c.is_whitespace())
}
<span class="boring">}
</span></code></pre></pre>
<p>并且，现在我们有了<code>whitespace_char</code>，我们也可以用它实现我们之前的想法，<em>一个或多个空白</em>，以及它的姊妹想法，<em>零个或多个空白</em>。 让我们专注于几个简单的地方，并分别称它们为<code>space1</code>和<code>space0</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn space1&lt;'a&gt;() -&gt; impl Parser&lt;'a, Vec&lt;char&gt;&gt; {
    one_or_more(whitespace_char())
}

fn space0&lt;'a&gt;() -&gt; impl Parser&lt;'a, Vec&lt;char&gt;&gt; {
    zero_or_more(whitespace_char())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#quoted-strings" id="quoted-strings">Quoted Strings</a></h2>
<p>完成所有这些组件后，我们现在终于可以解析这些属性了吗？ 当然啦，我们只需要确保我们拥有所有这些属性组件的单独的解析器。 我们已经为属性名称提供了 <code>identifier</code>（尽管使用 <code>any_char</code> 和 <code>pred</code> 加上我们的 <code>*_or_more</code> 组合子来重写它是很诱人的）。 <code>=</code> 只是 <code>match_literal(&quot;=&quot;)</code>。 不过，我们只有一个带引号的字符串解析器，所以让我们把它组合起来。 幸运地是，我们已经拥有了完成它所需的所有组合子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quoted_string&lt;'a&gt;() -&gt; impl Parser&lt;'a, String&gt; {
    map(
        right(
            match_literal(&quot;\&quot;&quot;),
            left(
                zero_or_more(pred(any_char, |c| *c != '&quot;')),
                match_literal(&quot;\&quot;&quot;),
            ),
        ),
        |chars| chars.into_iter().collect(),
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>组合子的嵌套在这一点上变得有点烦人，但我们暂时不会重构所有代码来修复它，而是专注于这里发生的事情。</p>
<p>最外面的组合子是一个 <code>map</code>，因为前面提到的烦人的嵌套，从这开始理解代码是很让人困惑的，所以让我们试着找出它真正开始的地方：第一个引号字符。在<code>map</code>里面，有一个<code>right</code>，而<code>right</code>的第一部分就是我们要找的：<code>match_literal(&quot;\&quot;&quot;)</code>。那是我们的引号的开始 。</p>
<p><code>right</code> 的第二部分是字符串的其余部分。在 <code>left</code> 里面，我们很快注意到那个 <code>left</code> 的 <em>right</em> 参数，我们一直忽视的那个: 是另一个 <code>match_literal(&quot;\&quot;&quot;)</code> - 引号的结束。所以左手部分是我们用引号包裹的字符串。</p>
<p>我们在这里利用新的 <code>pred</code> 和 <code>any_char</code> 来获得一个接受<em>除另一个引号之外的任何内容</em>的解析器，并将其放入 <code>zero_or_more</code> 中，因此我们所说的实现如下：</p>
<ul>
<li>
<p>一个引号</p>
</li>
<li>
<p>后跟零个或多个<em>不是</em>另一个引号的内容</p>
</li>
<li>
<p>接着是另一个引号</p>
<p>并且，在 <code>right</code> 和 <code>left</code> 之间，我们丢弃结果值中的引号并取回引用的字符串。</p>
<p>但是等等，这不是一个字符串。还记得 <code>zero_or_more</code> 返回什么吗？内部解析器的返回类型 A 的 <code>Vec&lt;A&gt;</code>。对于<code>any_char</code>来说，就是<code>char</code>。那么，我们得到的不是字符串而是<code>Vec&lt;char&gt;</code>。这就是 <code>map</code> 的用武之地：我们使用它把 <code>Vec&lt;char&gt;</code> 转换为 <code>String</code>，因为你可以从 <code>Iterator&lt;Item = char&gt;</code> 构建一个 <code>String</code>，所以我们可以调用 <code>vec_of_chars.into_iter().collect()</code>，并且由于类型推断的强大功能，我们有了 <code>String</code>。</p>
<p>在我们继续之前，让我们编写一个快速测试以确保一切正常，因为如果我们需要这么多词来解释它，这可能不是我们作为程序员对自己有信心的样子。</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn quoted_string_parser() {
    assert_eq!(
        Ok((&quot;&quot;, &quot;Hello Joe!&quot;.to_string())),
        quoted_string().parse(&quot;\&quot;Hello Joe!\&quot;&quot;)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>所以, 终于, 我们可以解析点属性了.</p>
<h2><a class="header" href="#at-last-parsing-attributes" id="at-last-parsing-attributes">At Last, Parsing Attributes</a></h2>
<p>我们现在可以解析空格、标识符、<code>=</code> 符号和带引号的字符串。 最后，这就是我们解析属性所需的全部内容。</p>
<p>首先，让我们为一个属性对编写一个解析器。 我们将把它们存储为 <code>Vec&lt;(String, String)&gt;</code>，你可能还记得，所以我们需要一个解析器来处理 <code>(String, String)</code> 元组,来提供给我们值得信赖的 <code>zero_or_more</code> 组合子。 让我们看看我们是否可以写出一个。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attribute_pair&lt;'a&gt;() -&gt; impl Parser&lt;'a, (String, String)&gt; {
    pair(identifier, right(match_literal(&quot;=&quot;), quoted_string()))
}
<span class="boring">}
</span></code></pre></pre>
<p>易如反掌！ 总结一下：我们已经有一个方便的组合子来解析一个值的元组，<code>pair</code>，所以我们将它与 <code>identifier</code> 解析器一起使用，产生一个 <code>String</code> 和一个带有 <code>=</code> 符号的 <code>right</code>， 它包括了我们不想保留的值，以及我们新的 <code>quoted_string</code> 解析器，它给了我们另一个 <code>String</code>。</p>
<p>现在，让我们将其与 <code>zero_or_more</code> 结合起来构建该 <code>vector</code> - 但不要忘记它们之间的空白。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attributes&lt;'a&gt;() -&gt; impl Parser&lt;'a, Vec&lt;(String, String)&gt;&gt; {
    zero_or_more(right(space1(), attribute_pair()))
}
<span class="boring">}
</span></code></pre></pre>
<p>零次或多次出现以下内容：一个或多个空白字符，然后是一个属性对。 我们使用<code>right</code>来丢弃空格并保留属性对。</p>
<p>让我们测试一下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn attribute_parser() {
    assert_eq!(
        Ok((
            &quot;&quot;,
            vec![
                (&quot;one&quot;.to_string(), &quot;1&quot;.to_string()),
                (&quot;two&quot;.to_string(), &quot;2&quot;.to_string())
            ]
        )),
        attributes().parse(&quot; one=\&quot;1\&quot; two=\&quot;2\&quot;&quot;)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>测试通过! 起飞!</p>
<p>实际上，并没有，在叙述者点上, 我的 <code>rustc</code> 抱怨我的类型变得非常复杂，我需要增加最大允许的类型大小才能继续。你也可能遇到这种情况，如果发生了, 你需要知道如何处理它。 幸好，在这些情况下，<code>rustc</code> 通常会给出很好的建议，所以当它告诉你将 <code>#![type_length_limit = &quot;...some big number...&quot;]</code> 添加到文件顶部时，就按照它说的去做。 实际上，只需将其设为 <code>#![type_length_limit = &quot;16777216&quot;]</code>，这将使我们进一步深入复杂类型的平流层。 全力以赴，我们现在是宇航员！</p>
<h2><a class="header" href="#so-close-now" id="so-close-now">So Close Now</a></h2>
<p>这个时候，事情似乎即将开始合为一体，这让人松了一口气，因为我们的类型正在快速接近 NP 完整性。 我们只需要处理两个版本的元素标签：单个元素和带有子元素的父元素，但是我们非常有信心，一旦我们有了这些，解析子元素将只是 <code>zero_or_more</code> 的问题， 对吧？</p>
<p>所以让我们先从单一元素开始，把孩子的问题推迟一点。 或者，更好的是，让我们首先为两者的所有共同点编写一个解析器：开头的 <code>&lt;</code>、元素名称和属性。 让我们看看我们是否可以从几个组合子中得到 <code>(String, Vec&lt;(String, String)&gt;)</code>类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn element_start&lt;'a&gt;() -&gt; impl Parser&lt;'a, (String, Vec&lt;(String, String)&gt;)&gt; {
    right(match_literal(&quot;&lt;&quot;), pair(identifier, attributes()))
}
<span class="boring">}
</span></code></pre></pre>
<p>有了它，我们可以快速地给它打上标签，为单个元素创建一个解析器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn single_element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    map(
        left(element_start(), match_literal(&quot;/&gt;&quot;)),
        |(name, attributes)| Element {
            name,
            attributes,
            children: vec![],
        },
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>万岁，感觉我们的目标已经触手可及了——我们现在实际上正在构建一个 <code>Element</code>！</p>
<p>让我们来测试一下这个现代科技的奇迹吧。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn single_element_parser() {
    assert_eq!(
        Ok((
            &quot;&quot;,
            Element {
                name: &quot;div&quot;.to_string(),
                attributes: vec![(&quot;class&quot;.to_string(), &quot;float&quot;.to_string())],
                children: vec![]
            }
        )),
        single_element().parse(&quot;&lt;div class=\&quot;float\&quot;/&gt;&quot;)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>...我想我们才刚刚突破大气层。</p>
<p><code>single_element</code> 的返回类型非常复杂，编译器会花费很长时间，直到遇到我们之前给它的非常大的类型大小限制 (<code>#![type_length_limit = &quot;&quot;]</code>)，要求更大的类型。 很明显我们不能再忽视这个问题，因为它是一个相当简单的解析器和(应该只需要)几分钟的编译时间——对于成品来说甚至可能是几个小时——似乎有点不合理。</p>
<p>在继续之前，你最好在我们修复问题时注释掉这两个函数和测试......</p>
<h2><a class="header" href="#to-infinity-and-beyond" id="to-infinity-and-beyond">To Infinity And Beyond</a></h2>
<p>如果你曾经尝试过在 Rust 中编写递归类型，你可能已经知道我们的小问题的解决方案。</p>
<p>递归类型的一个非常简单的例子是单向链表。 原则上，可以将其表示为这样的枚举：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List&lt;A&gt; {
    Cons(A, List&lt;A&gt;),
    Nil,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>rustc</code> 会非常明智地反对你的递归类型 <code>List&lt;A&gt;</code> ,因为它具有无限大小，因为在每个 <code>List::&lt;A&gt;::Cons</code> 内部是另一个 <code>List&lt;A&gt;</code>，这意味着它也是一个 <code>List&lt;A&gt;</code>......直到无穷大。就 <code>rustc</code> 而言，我们要求一个无限列表，我们要求它能够<em>分配</em>一个无限列表。</p>
<p>在许多语言中，无限列表原则上对于类型系统来说不是问题，实际上对于 Rust 也不是问题。问题是在 Rust 中，如前所述，我们需要能够<em>分配</em>它，或者更确切地说，我们需要能够在我们构造它时预先确定类型的 <em>大小</em>，以及当类型是无限的，这意味着大小也必须是无限的。</p>
<p>解决方案是使用一点间接性。我们的<code>List::Cons</code> 不是<code>A</code> 的一个元素和<code>A</code> 的另一个<em>list</em>，而是我们使它成为<code>A</code> 的一个元素和一个指向<code>A</code> 列表的<em>指针</em>。我们知道指针的大小，不管它指向什么都是一样的，所以我们的 List::Cons 现在有一个固定的和可预测的大小，无论列表的大小如何。在 Rust 中，将一个拥有的东西变成指向堆上拥有的东西的指针的方法是用 <code>box</code> 包裹它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List&lt;A&gt; {
    Cons(A, Box&lt;List&lt;A&gt;&gt;),
    Nil,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Box</code> 的另一个有趣的特性是它里面的类型可以是抽象的。 这意味着我们可以让类型检查器处理一个非常简洁的 <code>Box&lt;dyn Parser&lt;'a, A&gt;&gt;</code>，而不是我们现在非常复杂的解析器函数类型。</p>
<p>听起来不错。 有什么缺点？ 好吧，我们可能会因为必须遵循该指针而失去一两个指令周期，也可能是编译器失去了一些优化解析器的机会。 但回想一下 Knuth 关于过早优化(1)的告诫：它会没事的。 你完全可以负担得起这些周期。 来这里是为了解 解析器组合子，而不是了解手写的超专业化 <a href="https://github.com/lemire/simdjson">SIMD 解析器</a>（尽管它们本身就很令人兴奋）。 因此，除了迄今为止我们一直在使用的裸函数之外，让我们继续为 <em>boxed</em> 解析器函数实现 <code>Parser</code>。</p>
<blockquote>
<p>译者注: 1: 过早优化是万恶之源</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BoxedParser&lt;'a, Output&gt; {
    parser: Box&lt;dyn Parser&lt;'a, Output&gt; + 'a&gt;,
}

impl&lt;'a, Output&gt; BoxedParser&lt;'a, Output&gt; {
    fn new&lt;P&gt;(parser: P) -&gt; Self
    where
        P: Parser&lt;'a, Output&gt; + 'a,
    {
        BoxedParser {
            parser: Box::new(parser),
        }
    }
}

impl&lt;'a, Output&gt; Parser&lt;'a, Output&gt; for BoxedParser&lt;'a, Output&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; ParseResult&lt;'a, Output&gt; {
        self.parser.parse(input)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>出于礼节，我们创建了一个新类型 <code>BoxedParser</code>来保存我们的 <code>box</code>。 要从任何其他类型的解析器（包括另一个<code>BoxedParser</code>，即使那毫无意义）创建一个新的<code>BoxedParser</code>，我们提供了一个函数<code>BoxedParser::new(parser)</code>，它只会将该解析器放入 我们的新类型中的一个 <code>Box</code>。 最后，我们为它实现了 <code>Parser</code>，这样它就可以作为解析器互换使用。</p>
<p>这使我们能够将解析器函数放入 <code>Box</code>，并且 <code>BoxedParser</code> 将与函数一样用作 <code>Parser</code>。 现在，正如前面提到的，这意味着将解析器移动到堆中，并且必须取消引用一个指针才能找到它，这可能会花费我们<em>几个宝贵的纳秒</em>，所以我们实际上可能想要推迟使用 <code>box</code>。 将一些更常用的组合子放到 <code>box</code> 就足够了。</p>
<h2><a class="header" href="#an-opportunity-presents-itself" id="an-opportunity-presents-itself"><strong>An Opportunity Presents Itself</strong></a></h2>
<p>但是，稍等片刻，这为我们提供了解决另一个变得麻烦的问题的机会。</p>
<p>还记得我们写的最后几个解析器吗？ 因为我们的组合子是独立的函数，当我们嵌套大量的组合子时，我们的代码开始变得有点不可读。 回想一下我们的 <code>quoted_string</code> 解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quoted_string&lt;'a&gt;() -&gt; impl Parser&lt;'a, String&gt; {
    map(
        right(
            match_literal(&quot;\&quot;&quot;),
            left(
                zero_or_more(pred(any_char, |c| *c != '&quot;')),
                match_literal(&quot;\&quot;&quot;),
            ),
        ),
        |chars| chars.into_iter().collect(),
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们可以在解析器上使用这些组合子方法而不是独立函数，它会有更好的可读性。 如果我们可以将组合子声明为 <code>Parser</code> trait 上的方法会怎样？</p>
<p>问题是，如果我们这样做，我们就失去了依赖 <code>impl Trait</code> 作为返回类型的能力，因为 <code>impl Trait</code> 不允许出现在 trait 声明中。</p>
<p>……但现在我们有了<code>BoxedParser</code>。 我们不能声明一个返回 <code>impl Parser&lt;'a, A&gt;</code> 的 trait ，但我们肯定<em>可以</em>声明一个返回 <code>BoxedParser&lt;'a, A&gt;</code> 的 trait 。</p>
<p>最好的部分是我们甚至可以使用默认实现声明这些，这样我们就不必为实现 <code>Parser</code> 的每个类型重新实现每个组合子。</p>
<p>让我们用 <code>map</code> 来试试，通过扩展我们的 <code>Parser</code> trait 如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser&lt;'a, Output&gt; {
    fn parse(&amp;self, input: &amp;'a str) -&gt; ParseResult&lt;'a, Output&gt;;

    fn map&lt;F, NewOutput&gt;(self, map_fn: F) -&gt; BoxedParser&lt;'a, NewOutput&gt;
    where
        Self: Sized + 'a,
        Output: 'a,
        NewOutput: 'a,
        F: Fn(Output) -&gt; NewOutput + 'a,
    {
        BoxedParser::new(map(self, map_fn))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>啊这，好多<code>'a'</code>，唉，它们都是必要的。 幸运的是，我们仍然可以不变地重用旧的组合子函数——而且，我们还得到一个额外的好处，不仅可以获得更好的语法来应用它们，我们还通过自动 <code>box</code> 来摆脱爆炸性的 <code>impl Trait</code> 类型。 现在我们可以稍微改进我们的 <code>quoted_string</code> 解析器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quoted_string&lt;'a&gt;() -&gt; impl Parser&lt;'a, String&gt; {
    right(
        match_literal(&quot;\&quot;&quot;),
        left(
            zero_or_more(pred(any_char, |c| *c != '&quot;')),
            match_literal(&quot;\&quot;&quot;),
        ),
    )
    .map(|chars| chars.into_iter().collect())
}
<span class="boring">}
</span></code></pre></pre>
<p>乍一看现在更明显，正在对 <code>right()</code> 的结果调用 <code>.map()</code>。</p>
<p>我们也可以给 <code>pair</code>、<code>left</code> 和 <code>right</code> 相同的处理，但是对于这三个，我认为当它们是函数时读起来更容易，因为它们反映了 <code>pair</code> 的输出结构 类型。 如果你不同意，完全可以像我们对 <code>map</code> 所做的那样将它们添加到 trait 中，并且非常欢迎你继续尝试将其作为练习。</p>
<p>不过，另一个主要候选人是 <code>pred</code>。 让我们将它的定义添加到 <code>Parser</code> trait 中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pred&lt;F&gt;(self, pred_fn: F) -&gt; BoxedParser&lt;'a, Output&gt;
where
    Self: Sized + 'a,
    Output: 'a,
    F: Fn(&amp;Output) -&gt; bool + 'a,
{
    BoxedParser::new(pred(self, pred_fn))
}
<span class="boring">}
</span></code></pre></pre>
<p>这下我们就可以用 <code>pred</code> 重写 <code>quoted_string</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>zero_or_more(any_char.pred(|c| *c != '&quot;')),
<span class="boring">}
</span></code></pre></pre>
<p>我认为这读起来更好一些，我认为我们也会保留 <code>zero_or_more</code> 原样 - 它读起来就像应用了以下谓词的零个或多个 <code>any_char</code>，这对我来说听起来很半。 当然，如果你愿意这么写，你也可以继续将 <code>zero_or_more</code> 和 <code>one_or_more</code> 移到 trait 中。</p>
<p>除了重写<code>quoted_string</code>，我们还要修正<code>single_element</code>中的<code>map</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn single_element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    left(element_start(), match_literal(&quot;/&gt;&quot;)).map(|(name, attributes)| Element {
        name,
        attributes,
        children: vec![],
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们试着取消对 <code>element_start</code> 和我们之前注释掉的测试的注释，看看情况是否变得更好。 开始编译并尝试运行测试......</p>
<p>……而且，是的，现在编译时间恢复正常了。 甚至可以继续删除文件顶部的字体大小设置。</p>
<p>这只是通过 <code>box</code> 两个 <code>map</code> 和一个 <code>pred</code> - <em>而且</em>我们从中得到了更好的语法！</p>
<h2><a class="header" href="#having-children" id="having-children">Having Children</a></h2>
<p>现在让我们为父元素的开始标记编写解析器。 它几乎与<code>single_element</code> 相同，只是它以<code>&gt;</code> 结尾而不是<code>/&gt;</code>。 后面还有零个或多个子元素和一个结束标记，但首先我们需要解析实际的开始标记，所以让我们完成这个函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    left(element_start(), match_literal(&quot;&gt;&quot;)).map(|(name, attributes)| Element {
        name,
        attributes,
        children: vec![],
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们如何得到这些子元素？ 它们将是单个元素或父元素本身，并且它们有零个或多个，所以我们有我们可信赖的 <code>zero_or_more</code> 组合子，但是我们提供什么？ 我们还没有编写过的一件事是多重解析器：解析<em>或者</em>单个元素<em>或</em>父元素的东西。</p>
<p>为了完成这个特性，我们需要一个组合子，它按顺序尝试两个解析器：如果第一个解析器成功，我们就完成了，我们返回它的结果，就是这样。 如果失败，我们不会返回错误，而是在<em>相同的输入</em>上尝试第二个解析器。 如果成功，很好，如果没有，我们也会返回错误，因为这意味着我们的两个解析器都失败了，这是一个整体性失败。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn either&lt;'a, P1, P2, A&gt;(parser1: P1, parser2: P2) -&gt; impl Parser&lt;'a, A&gt;
where
    P1: Parser&lt;'a, A&gt;,
    P2: Parser&lt;'a, A&gt;,
{
    move |input| match parser1.parse(input) {
        ok @ Ok(_) =&gt; ok,
        Err(_) =&gt; parser2.parse(input),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这使得我们可以声明一个解析器<code>element</code>，它匹配单个元素或父元素（现在，我们只使用<code>open_element</code> 来表示它，一旦我们有了<code>element</code>，我们将处理 <code>element</code>）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    either(single_element(), open_element())
}
<span class="boring">}
</span></code></pre></pre>
<p>现在让我们为结束标记添加一个解析器。 它具有必须匹配开始标签的特性，这意味着解析器必须知道开始标签的名称是什么。 但这就是函数参数的用途，对吧？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn close_element&lt;'a&gt;(expected_name: String) -&gt; impl Parser&lt;'a, String&gt; {
    right(match_literal(&quot;&lt;/&quot;), left(identifier, match_literal(&quot;&gt;&quot;)))
        .pred(move |name| name == &amp;expected_name)
}
<span class="boring">}
</span></code></pre></pre>
<p>事实证明，那个 <code>pred</code> 组合子真的很有用，不是吗？</p>
<p>现在，让我们为完整的父元素解析器、子元素和所有元素组合起来：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parent_element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    pair(
        open_element(),
        left(zero_or_more(element()), close_element(…oops)),
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>Oops。现在我们要怎么把参数传给<code>close_element</code>？我想我们还缺少最后一个组合子。</p>
<p>我们已经很接近了。一旦我们解决了最后这个问题以让<code>parent_element</code>工作，我们就能把<code>element</code>解析器的<code>open_element</code>替换成新的<code>parent_element</code>，这就意味着，我们就有一个完整可用的XML解析器。</p>
<p>还记得我前面说过我们后面会回到<code>and_then</code>吗？好的，后面就是这里了。我们所需要的组合子，实际上，就是<code>and_then</code>：我们需要一个东西能接收一个解析子，还要一个函数，这个函数能接收解析子的返回结果并返回一个<em>新</em>解析子，这个解析子我们后面再用。这有点像<code>pair</code>，但不是仅仅收集tuple里的两个结果，我们把结果传入一个函数。这也是<code>and_then</code>怎么作用在<code>Result</code>和<code>Options</code>的方式，除了这个更好理解，因为<code>Result</code>和<code>Options</code>基本上什么也不做，它们只是包含了一些数据而已(或者不包含，在某一些情况下)。</p>
<p>所以让我们试着实现一下它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn and_then&lt;'a, P, F, A, B, NextP&gt;(parser: P, f: F) -&gt; impl Parser&lt;'a, B&gt;
where
    P: Parser&lt;'a, A&gt;,
    NextP: Parser&lt;'a, B&gt;,
    F: Fn(A) -&gt; NextP,
{
    move |input| match parser.parse(input) {
        Ok((next_input, result)) =&gt; f(result).parse(next_input),
        Err(err) =&gt; Err(err),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>看看这些类型，这里有很多类型变量，但是我们认识<code>P</code>，我们的输入解析器，<code>P</code>有一个结果类型<code>A</code>。我们的函数<code>F</code>，本来是一个从<code>A</code>到<code>B</code>的<code>map</code>，然而，关键的不同在于<code>and_then</code>接收一个函数，这个函数把<code>A</code>转化为一个新的解析器<code>NextP</code>，<code>NextP</code>有一个返回类型<code>B</code>。最终的结果类型是<code>B</code>，因此我们可以假设不管从<code>NextP</code>返回的是什么，将是最后的结果。</p>
<p>这段代码没类型那么复杂：我们一开始运行输入解析器，如果失败，这段code也失败，但是如果输入解析器成功，接下来我们调用函数<code>f</code>作用于result(为类型<code>A</code>)，从<code>f(result)</code>返回的是个新的解析器， 类型是<code>B</code>。我们把返回的解析器作用在下一段输入，然后直接返回结果。如果失败，就挂在这里，如果成功，我们就得到类型为<code>B</code>的值。</p>
<p>再来一次：首先我们运行类型为<code>P</code>的解析器，如果成功，我们调用函数<code>F</code>作用在解析器<code>P</code>的结果上，得到下一个类型为<code>NextP</code>的解析器，然后我们运行，得到最终的结果。</p>
<p>让我们也把它直接加到<code>Parser</code>特质上，因为这个就像<code>map</code>，肯定这样读起来更好。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn and_then&lt;F, NextParser, NewOutput&gt;(self, f: F) -&gt; BoxedParser&lt;'a, NewOutput&gt;
where
    Self: Sized + 'a,
    Output: 'a,
    NewOutput: 'a,
    NextParser: Parser&lt;'a, NewOutput&gt; + 'a,
    F: Fn(Output) -&gt; NextParser + 'a,
{
    BoxedParser::new(and_then(self, f))
}

<span class="boring">}
</span></code></pre></pre>
<p>OK，现在，这样做有什么好处？</p>
<p>首先，我们几乎可以用这个实现<code>pair</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pair&lt;'a, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; impl Parser&lt;'a, (R1, R2)&gt;
where
    P1: Parser&lt;'a, R1&gt; + 'a,
    P2: Parser&lt;'a, R2&gt; + 'a,
    R1: 'a + Clone,
    R2: 'a,
{
    parser1.and_then(move |result1| parser2.map(move |result2| (result1.clone(), result2)))
}
<span class="boring">}
</span></code></pre></pre>
<p>看上去很整洁，但是这里有个问题：<code>parser2.map()</code>消耗了<code>parser2</code>来创建包装解析器，而且函数是<code>Fn</code>，不是<code>FnOnce</code>，因此不允许消费<code>parser2</code>，只能取它的引用。Rust的问题，换句话说。在一个这些不是问题的更高级的语言中，这可以是一个很整洁的定义<code>pair</code>的方法。</p>
<p>尽管如此，我们还是能在Rust用这个函数懒生成<code>close_element</code>解析器的正确版本，或者，换句话，我们可以把参数传入它。</p>
<p>回想一下我们失败的尝试：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parent_element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    pair(
        open_element(),
        left(zero_or_more(element()), close_element(…oops)),
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>通过使用 <code>and_then</code>，我们现在可以通过使用该函数构建正确版本的 <code>close_element</code> 来获得正确的结果。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parent_element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    open_element().and_then(|el| {
        left(zero_or_more(element()), close_element(el.name.clone())).map(move |children| {
            let mut el = el.clone();
            el.children = children;
            el
        })
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>现在看起来有点复杂，因为 <code>and_then</code> 必须在 <code>open_element()</code> 中进行，在那里我们找到进入 <code>close_element</code> 的地方。这意味着 <code>open_element</code> 之后的解析器的其余部分都必须在 <code>and_then</code> 闭包内构造。此外，因为该闭包现在是来自 <code>open_element</code> 的 <code>Element</code> 结果的唯一接收者，我们返回的解析器也必须向前传递该信息。</p>
<p>我们在生成的解析器上 <code>map</code>的内部闭包具有对外部闭包中的 <code>Element</code>（<code>el</code>）的引用。我们必须使用 <code>clone()</code> ，因为一个 <code>Fn</code> 中，只有对它的引用。我们获取内部解析器的结果（我们的 <code>Vec&lt;Element&gt;</code> 子元素）并将其添加到我们克隆的 <code>Element</code> 中，然后将其作为最终结果返回。</p>
<p>我们现在需要做的就是返回到我们的 <code>element</code> 解析器并确保我们将 <code>open_element</code> 更改为 <code>parent_element</code>，这样它就会解析整个元素结构，而不是只是它的开头，我相信我们已经完成了！</p>
<h2><a class="header" href="#word-or-do-i-have-to" id="word-or-do-i-have-to">Word Or Do I Have To?</a></h2>
<p>还记得我们讨论过 <code>map</code> 模式如何在 Planet Haskell 上被称为“函子”吗？</p>
<p><code>and_then</code> 模式是你在 Rust 中经常看到的另一种模式，通常与 <code>map</code> 位于相同的位置。它在 <code>Iterator</code> 上被称为 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map"><code>flat_map</code></a>，但它的模式与其他模式相同。</p>
<p>它的花名是<code>monad</code>。如果你有一个东西 <code>Thing&lt;A&gt;</code>，并且你有一个可用的 <code>and_then</code> 函数，它可以将一个函数从 <code>A</code> 传递给 <code>Thing&lt;B&gt;</code>，这样现在你就有了一个新的 <code>Thing&lt;B&gt;</code> 来替代原来的，这就是一个 monad。</p>
<p>该函数可能会立即被调用，比如当你有一个 <code>Option&lt;A&gt;</code> 时，我们已经知道它是一个 <code>Some(A)</code> 还是一个 <code>None</code>，我们直接应用该函数，如果它是一个 <code>Some(A)</code>，那么就会给我们一个<code>Some(B)</code>。</p>
<p>它也可能被称为 <code>惰性 (lazy)</code>。例如，如果有一个仍在等待解析的 <code>Future&lt;A&gt;</code>，它不会立即调用该函数来创建一个 <code>Future&lt;B&gt;</code>，而是创建一个新的 <code>Future&lt;B&gt;</code>它包含 <code>Future&lt;A&gt;</code> 和函数，然后等待 <code>Future&lt;A&gt;</code> 完成。当它这样做时，它会使用 <code>Future&lt;A&gt;</code> 的结果调用函数，这样就搞定了 <a href="https://bodil.lol/parser-combinators/#footnote_1">1</a>(He isn't really your uncle.)，得到你的 <code>Future&lt; B&gt;</code> 。换句话说，在<code>Future</code> 的情况下，可以将传递给<code>and_then</code> 的函数视为<em>回调函数</em>，因为它会在完成时使用原始 future 的结果进行调用。它还比这更有趣，因为它返回一个 <em>new</em> <code>Future</code>，它可能已经或可能没有被解决，所以它是一种将 future 连在一起的方法。</p>
<p>然而，与函子一样，Rust 的类型系统目前不能表达 <code>monad</code>，所以让我们只需注意这种模式被称为 <code>monad</code>，而且令人失望的是，这和网上的搜到的意思并不一样，它与墨西哥卷饼毫无关系。</p>
<h2><a class="header" href="#whitespace-redux" id="whitespace-redux">Whitespace, Redux</a></h2>
<p>只有最后一件事。</p>
<p>我们现在应该有一个能够解析一些 XML 的解析器，但是他并不能很好的接受空格。 标签之间应该允许任意空格，这样我们就可以自由地在标签之间插入换行符等（原则上，标识符和文字之间应该允许空格，比如<code>&lt; div /&gt;</code>，但这里跳过它）。 在这一点上，我们应该能够毫不费力地为此组合一个快速组合子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whitespace_wrap&lt;'a, P, A&gt;(parser: P) -&gt; impl Parser&lt;'a, A&gt;
where
    P: Parser&lt;'a, A&gt;,
{
    right(space0(), left(parser, space0()))
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们将 <code>element</code> 包裹在里面，它将忽略 <code>element</code> 周围的所有前面和后面空格，这意味着我们可以随意使用尽可能多的换行符和尽可能多的缩进。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn element&lt;'a&gt;() -&gt; impl Parser&lt;'a, Element&gt; {
    whitespace_wrap(either(single_element(), parent_element()))
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#were-finally-there" id="were-finally-there">We're Finally There!</a></h2>
<p>我想我们终于做到了！ 让我们写个测试庆祝一下！</p>
<pre><code class="language-RUST">#[test]
fn xml_parser() {
    let doc = r#&quot;
        &lt;top label=&quot;Top&quot;&gt;
            &lt;semi-bottom label=&quot;Bottom&quot;/&gt;
            &lt;middle&gt;
                &lt;bottom label=&quot;Another bottom&quot;/&gt;
            &lt;/middle&gt;
        &lt;/top&gt;&quot;#;
    let parsed_doc = Element {
        name: &quot;top&quot;.to_string(),
        attributes: vec![(&quot;label&quot;.to_string(), &quot;Top&quot;.to_string())],
        children: vec![
            Element {
                name: &quot;semi-bottom&quot;.to_string(),
                attributes: vec![(&quot;label&quot;.to_string(), &quot;Bottom&quot;.to_string())],
                children: vec![],
            },
            Element {
                name: &quot;middle&quot;.to_string(),
                attributes: vec![],
                children: vec![Element {
                    name: &quot;bottom&quot;.to_string(),
                    attributes: vec![(&quot;label&quot;.to_string(), &quot;Another bottom&quot;.to_string())],
                    children: vec![],
                }],
            },
        ],
    };
    assert_eq!(Ok((&quot;&quot;, parsed_doc)), element().parse(doc));
}

</code></pre>
<p>下面这个测试会因为有未闭合 tag 而解析失败：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn mismatched_closing_tag() {
    let doc = r#&quot;
        &lt;top&gt;
            &lt;bottom/&gt;
        &lt;/middle&gt;&quot;#;
    assert_eq!(Err(&quot;&lt;/middle&gt;&quot;), element().parse(doc));
}
<span class="boring">}
</span></code></pre></pre>
<p>好消息是它返回不匹配的结束标记作为错误。 坏消息是它实际上并没有<em>说</em>问题是不匹配的结束标签，只是<em>错误在哪里</em>。 总比没有好，但是，老实说，随着错误消息的出现，它仍然很糟糕。 但是想让它能成功的找到错至少得再写一篇同样长的文章。</p>
<p>让我们关注好消息：我们使用解析器组合子从头开始编写了一个解析器！ 我们知道解析器既构成函子又构成单子，因此你现在可以在令人生畏的范畴论知识聚会上给人们留下深刻印象了<a href="https://bodil.lol/parser-combinators/#footnote_2">2</a>。（Please don't be that person at parties. 别真的这么干）</p>
<p>最重要的是，我们现在知道解析器组合子是如何从头开始工作的。 现在没有人能阻止我们！</p>
<h2><a class="header" href="#victory-puppies" id="victory-puppies">Victory Puppies</a></h2>
<p><img src="https://bodil.lol/parser-combinators/many-puppies.gif" alt="img" /></p>
<h2><a class="header" href="#further-resources" id="further-resources">Further Resources</a></h2>
<p>首先，我对用严格的 <code>rust</code>术语 向你解释 monad 感到内疚，而且我知道如果我不向你指出 <a href="https://homepages.com">他的开创性论文</a>，Phil Wadler 会对我非常不满。 其中详细介绍了更多令人兴奋的细节——包括它们与解析器组合子的关系。</p>
<p>本文中的想法与 <a href="https://crates.io/crates/pom"><code>pom</code></a> 解析器组合子库背后的想法极为相似，如果这让你想在同一个解析器组合子中使用风格，我强烈推荐它。</p>
<p>Rust 解析器组合子的最新技术仍然是 <a href="https://crates.io/crates/nom"><code>nom</code></a>，以至于前面提到的 <code>pom</code> 显然是派生的名称（而且没有比这更好的称赞了），但它采用了与我们今天在这里构建的方法截然不同的方法。</p>
<p>另一个流行的 Rust 解析器组合库是 <a href="https://crates.io/crates/combine"><code>combine</code></a>，它可能也值得一看。</p>
<p>Haskell 的开创性解析器组合库是 <a href="http://hackage.haskell.org/package/parsec">Parsec</a>。</p>
<p>最后，我对解析器组合子的第一次认识归功于 Graham Hutton 所著的 <a href="http://www.cs.nott.ac.uk/%7Epszgmh/pih.html"><em>Programming in Haskell</em></a>，这是一本很棒的书，不仅容易读而且还会教给你 Haskell 的积极副作用。</p>
<h2><a class="header" href="#licence" id="licence">Licence</a></h2>
<p>This work by <a href="https://bodil.lol/">Bodil Stokke</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
<p>本文由 Bodil Stokke 撰写，基于署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)协议。</p>
<h1><a class="header" href="#对web30概念的梳理" id="对web30概念的梳理">对Web3.0概念的梳理</a></h1>
<p>作者： <a href="chapter_6/mike@oct.network">Mike Tang</a>, <a href="chapter_6/lester@oct.network">Lester Li</a></p>
<h2><a class="header" href="#前言-2" id="前言-2">前言</a></h2>
<p>随着Bitcoin的天启事件（参见：《比特币白皮书》），近年来技术领域涌现出一大批新名词。这些名词的意义以及它们之间的关联，别说普通人不容易理解，就连混迹业界多年的资深人士也很难分得清。因为这些概念已经不再局限在纯技术领域了，它们是多学科交叉的前沿领域。</p>
<p>这些概念包括，但不仅限于如下：</p>
<p><img src="chapter_6/./image/web3/1.png" alt="1" /></p>
<p>一个新手面对这么多的概念，会不知所措。这时，他们往往会选择某一个术语所代表的方向研究下去，这是完全没问题的。但对整体性的把握也非常重要，有关这些综述性的资料，在目前的互联网中，要么就是一些飘渺的宏大乌托邦叙述，要么就是一些概念的简单陈列讲解。对这些概念成系统的成逻辑的梳理，还非常缺乏。</p>
<p>限于篇幅，本文不可能对这些概念一一讲解。本文的主要目标是尝试在这成堆的概念中，寻找出有关Web3.0的主要脉络。</p>
<h2><a class="header" href="#对web30的畅想" id="对web30的畅想">对Web3.0的畅想</a></h2>
<p>许多人对Web3.0有各种畅想，这些畅想的内涵可谓是千差万别。《刘毅：Web3.0到底是醒世恒言还是危言耸听？》中对Web3.0思想史的一个简要摘述如下：</p>
<p>什么是Web3.0？互联网当前处于Web2.0阶段，Web3.0是对下一代互联网的设计和设想。15年前，Web的发明人Tim Bernard-Lee爵士认为，目前互联网的局限在于，HTML是给人看的，没有元数据，不能被机器所理解。因此应该把数据赋予含义，开发出更智能、自动化程度更高的互联网应用，从而实现Web3.0，即语义网（Semantic Web）。但是大约在5年前，Lee爵士对下一代互联网的看法发生了变化，他发起了互联网大宪章运动，呼吁用户和从业者对互联网的未来进行广泛地讨论。</p>
<p>以太坊联创和Polkadot创始人Gavin Wood博士在2014年提出了一种革命性的Web3.0设想，并随后发起成了Web3基金会。他的理念是：Web3是为让互联网更去中心化、可验证、安全而发起的一组广泛的运动和协议；Web3愿景是实现无服务器、去中心化的互联网，即用户掌握自己身份、数据和命运的互联网；Web3将启动新全球数字经济系统，创造新业务模式和新市场，打破平台垄断，推动广泛的、自下而上的创新。</p>
<p>两位大师在不同的方向上进行着尝试。</p>
<p>Tim Bernard-Lee亲自发起了Solid项目 ，旨在让用户能控制他们在 Web 上产生的数据和内容，能选择数据如何被使用。Solid 的核心是个人数据存储系统 Solid POD，你在网上产生的所有数据都储存在 Solid POD 中，如你的联系人，你的照片和评论， 用户可选择将 Solid POD 储存在自己家中的计算机上，或挑选的网上 Solid POD 供应商（比如 Berners-Lee 创办的 Inrupt），你的所有数据都控制在自己手中，可以自由的添加或删除数据，授予权限给他人或应用来读取或写入部分 Solid POD 数据，不需要同步，因为你的数据一直伴随着你。这个平台需要开发者支持才能真正产生效果，很难想象中心化的平台会支持这个无法控制数据的去中心化平台。</p>
<p>Gavin Wood创办了Polkadot项目，旨在通过提供开箱即用的共享安全性保证和可互操作的多链网络架构，为用于承载Web3.0使命的各种parachain项目创建一个创新的平台。Gavin博士把Polkadot定义成为一个layer0的项目，即平台的平台 (The platform of platforms)。以此平台为根，期待绽放新时代的无穷分支没有边界的应用网络，从而逐渐侵蚀和替代现有的Web2.0互联网。</p>
<p>当然，业界还存在更多其它的有价值的观点，并在不同的方向上进行着尝试。</p>
<p>面对这些看似都很有道理的前沿的庞杂的甚至是相互冲突的思想，我们如何进行有效地梳理呢？</p>
<h2><a class="header" href="#web10和web20" id="web10和web20">Web1.0和Web2.0</a></h2>
<p>让我们回到互联网1.0的时代去看看能否发现一些有价值的东西。（以下这部分翻译自 a16z 的文章《Web 3.0 and the Future of Trust》by Ali Yahya 中的互联网演化这部分，有删节修改）</p>
<p><img src="chapter_6/./image/web3/2.png" alt="2" /></p>
<p>互联网早期的那一批协议其实相当美妙，TCP, IP, SMTP 和 HTTP，我们叫它 Web1.0 协议，它们是在70年代到80年代设计的，秉承的是开放性和包容性的精神，它们是开放的标准。这意味着在世界上任何地方任何人，能够站在平等的位置，在它们之上构建系统，而不需要经过任何人的准许。比如，现在已经存在几百个这些协议的开源的实现了。目前，在你手机中的那些协议的代码，不管它是iPhone还是Android手机，都直接依赖于这些开源的代码。</p>
<p>不知你有没有感受到，互联网对人类来说其实是一件特别伟大的事情，一个奇迹。现在的全球互联网是一个大的整体，而不是大量的不相交的独立的网络。世界上二百多个国家，千万计的公司——它们甚至有利益冲突——竟然神奇般地聚集和运行在这些同样的协议上，并在此之上互相连接，没有任何例外。</p>
<p>在这样一个常年分化的世界中，这是不寻常的，我们如何来解释这种现象呢？它其实就是开源的结果。因为互联网的核心协议是开源的，没人能单方面地控制互联网。它们的出现和支持是至下而上的且基本中立的。正是由于这些底层协议的稳定，在其之上才构建了现今的互联网生态。</p>
<p><img src="chapter_6/./image/web3/3.png" alt="3" /></p>
<p>这些协议的出现引导了一个创新的黄金时代的来临。在其之上，企业主和它们的投资人相信游戏的规则是中立和公平的。但是，开源很难营利！所以这些创业公司的商业模式是在这些互联网的开放协议上构建带产权的闭源的协议。这些协议就是Web2.0协议。</p>
<p><img src="chapter_6/./image/web3/4.png" alt="4" /></p>
<p>这其中少数创业公司已经变成了人类历史上最有价值的公司，你肯定听过其中一些。然后，也因为这些公司，数十亿人几乎免费地用上了伟大的新科技。这是一个现象级的事情。直到最近，这些公司都没有为此获得足够的名声（针对让数十亿人几乎免费地用上了伟大的新科技这一件事情）。</p>
<p><img src="chapter_6/./image/web3/5.png" alt="5" /></p>
<p>但是，一个严重的警告也随之而来，Web2.0的这些科技巨头已经变成大中介和互联网的守门人了。今天我们在互联网上做的大部分的事情，比如搜索网络、与人们联系、分享内容，都被迫依赖由这些公司开发的带产权的不透明的服务代码，不然就无法去做那些事情。</p>
<p>于是，这些公司就对他们的用户和第三方开发者，掌握了巨大的权力。凭借他们对所有数据的控制，它们控制了：平台上用户间的每个交互，每个用户无缝退出和切换到其它平台的能力，内容创作者被发现和发布内容的潜力，所有资本的流动，及第三方开发者和他们的用户间的所有关系。</p>
<p>他们还控制了游戏规则。在任何时候，没有警告，几乎完全按照他们的条款，这些公司可以改变在他们平台上允许发生的任何事情——经常在运行过程中剥夺整个第三方公司或用户的所有权力。这些公司已经成长为巨型怪兽。</p>
<p>互联网的故事，就变成了：基于中立和开放，就有了价值创造的可能性。而当太多权力掌握在少数营利性人类机构手中时，就会抑制创新，进入一个令人警惕的状态。</p>
<p>试想一下，在Web1.0的协议之上，孕育了Google这样的巨头。而在Google这样的Web2.0协议之上，还能孕育出一个新的类似的巨头吗？这是不可想象的事情（想象不出来如何做到）。Google已经成为互联网的守门人，它是不会让你在它之上再去做守门人的事情的。也就是说，Web2.0已经是科技树的一片叶子，已经到头。</p>
<p>于是我们要回去最初的状态去思考，不基于这些守门人的服务去思考，而是基于开放的Web1.0去思考：我们如何从“Don’ be evil“（Google已经放弃）去到 “Can’t be evil”。从不去做恶，进化到无法做恶。</p>
<h2><a class="header" href="#对协议的进一步分析" id="对协议的进一步分析">对协议的进一步分析</a></h2>
<p>Web1.0的开放协议让今天的互联网变得可能。但是，对于真实世界的软件平台服务来说，它们并不是一套完整的乐高积木。还有很多部分的协议缺失了，比如数据的存储协议，基于数据的计算协议等。</p>
<p>而Web2.0的科技巨头更进一步，提供了这些缺失协议的闭源版本，从而建立起了强大的商业模式（这是它们出现的本质原因）。</p>
<p>Web2.0有如下一些特点</p>
<ul>
<li>平台经济。平台最终必然走向垄断</li>
<li>隐私换服务</li>
<li>数据归平台方所有。对数据的任何挖掘、加工等产生的利润，归平台方所有</li>
<li>依赖于平台而生存的某些职业，在平台的利益分配上，没有定价权</li>
</ul>
<p>简单地说，Web2.0让平台成为最有钱有势的一方，所有人都在给平台打工。这种平台模式，不大可能从内部突破。这里面更详细的分析，请见：《刘毅：Web3.0到底是醒世恒言还是危言耸听？》。</p>
<p>Web2.0，数据完全由企业掌控，会有如下问题</p>
<ul>
<li>数据易泄漏。外界的攻击，导致数据易被盗取。特别是很多企业内部数据用明文存储，一旦被盗，所有信息相当于完全公开</li>
<li>数据易丢失。企业运维的事故性丢失，或黑客的攻击性丢失，或企业倒闭服务关停导致的数据丢失等等</li>
<li>数据可被篡改。企业对其内部的数据库，有至高无上的权利，理论上来说，可修改任何数据（比如删除做恶的记录），即使是用的所谓纯增量数据库也是如此</li>
<li>数据会被审查。审查这个东西争议很大，虽然在某些方面有积极的意义，但是在另一方面负面作用非常大</li>
<li>数据会被打包售卖。这其实是一个灰色的商业模式，此不赘述</li>
<li>数据孤岛。同一行业下竞争企业数据孤岛现象特别严重，数据的相互交互特别困难</li>
</ul>
<p>数据有这么多潜在的问题，核心原因就是数据被视为企业最核心的资产，数据及数据的使用规则，完全由企业来掌控。普通用户完全没有权力参与其中。</p>
<p>从Web3.0的角度来看，如果数据依赖于人或机构，必定会出现上述现象。而如果数据本身依托于开放的协议以及数学算法，那么是有可能解决上述那些问题的。</p>
<p>业界一些大师最近几年提出了一些观点，比如</p>
<ul>
<li>A16z的Chris Dixon提出”重启互联网”（参见：《Rebooting the Internet》）</li>
<li>Gavin Wood说：“今天的互联网在设计上就是坏掉的。“ （参见：《Why We Need Web 3.0》）</li>
</ul>
<p>我们需要的是一套开放的协议——就像Web1.0那样。</p>
<h2><a class="header" href="#比特币的启发" id="比特币的启发">比特币的启发</a></h2>
<p>如何做？比特币给了我们一些启发。</p>
<p>比特币背后的思想很有意思，它用密码学的一些基础设施比如数字签名，Web1.0的开放协议（TCP，UDP等），和一个非常聪明的激励结构来构建了一个集体所有的中立的数据库，或者叫分布式账本，用于记录比特币的交易/支付数据。</p>
<p>这个数据库的创新点在于，它的安全性是由它的用户至下而上建立的，而这个用户可以是任何人，在任何地点，在没有任何人允许的情况下参与进来。换句话说，对数据库的控制本身是分布式的，没有守门人。当然，它的挑战在于，许多参与者是不诚实的，如果可能，他们会想在这个系统中钻空子以获利。比特币的天才之处在于它的激励结构，它让系统可以自我监管（self-policing）。它不把唯一的一份数据库放在一个“可信赖“的数据中心（这个数据中心可能是被Google这种大公司拥有），而是在网络上每个参与者都持有一份他们自己的拷贝。</p>
<p>这会产生了一个问题：我们如何确保数据库的所有拷贝是始终保持一致，以保证没人能插入一个做假的交易数据呢？</p>
<p>答案是网络中的每个参与者（被称为矿工）监视着网络，并且给他们认为有效的交易集合投票。关键之处在于他们用他们算力进行投票。比如Alice是一个矿工，她给网络贡献的算力越大，她就帮助网络有更多的安全性。作为结果，协议给她更多的投票权力和更大的奖励。</p>
<p>重要的是，付给Alice的奖励是新挖出的比特币。所以比特币一口气做了两件事情，做为一种货币而存在，同时又成为引导自身安全性的资金来源。</p>
<p>这种思想被称为工作量证明（PoW）。内在逻辑是你必须给这个数据库贡献安全性以获得投票和回报。结果是形成了一种优雅的激励结构，该结构鼓励网络中的参与者相互检查。因此，即使他们彼此不信任，他们也会信任他们一直共同保护的这个数据库（分布式账本）。</p>
<p>比特币是最简单的加密网络。它试图处理去信任货币的问题——货币的正统性和背书不依赖于人类机构，而是依赖于数学上的保证。</p>
<p>这就是比特币背后的思想，伟大！当然，从这种模式出发不能直接推出Web3.0的具体形式，但会给我们巨大的启发。比特币给我们展示了一个可靠的无许可分布式系统是能够在现实世界中稳定持久运行的。人们有理由相信沿着这个思路发展下去，一个新的世界正在等待着我们。现在全世界最聪明的头脑们正在沿着这个方向积极探索（同时也伴随着巨大的投资热潮和泡沫）。</p>
<h2><a class="header" href="#web30的特点" id="web30的特点">Web3.0的特点</a></h2>
<p>业界对Web3.0的定义花样百出，莫衷一是，几乎把所有对未来的美好理想都强加到Web3.0之上，这是不可取的。</p>
<p>我们对Web3.0的特点进行了一些归纳：</p>
<ul>
<li>Web3.0必须是开放的</li>
<li>Web3.0必须是安全的。因为开放，且安全，所以必须用到密码学技术</li>
<li>Web3.0必定是去中心化的或者叫分布式的。开放协议，必定造就去中心化</li>
<li>Web3.0的平台和应用必定具有原生通证，因为去中心化需要通过通证自动结算各方的利益分配</li>
</ul>
<p>Web3.0会在生产关系上产生巨大的突破。</p>
<p>对服务的提供方来说：</p>
<ul>
<li>平台的代码（协议）是开放的</li>
<li>不是一家企业独自掌控平台，而是一个社区拥有这个平台</li>
<li>平台的利润，不再是不透明的，不可预测的，优先流向大股东的（大股东可能为追求更高的巨额利润来对平台的策略进行修改）。而是按规则的，可计算的，可预测地分配给所有平台中价值的创造者</li>
<li>平台的商业模式仍然能容纳Web2.0的成熟的商业模式，比如广告、会员服务、游戏等</li>
<li>平台可能催生新的商业模式</li>
<li>平台不会像Web2.0一样，因为其主体公司的倒闭而关闭，一个参与节点的关闭不影响Web3.0平台整体的运行</li>
</ul>
<p>对用户来说：</p>
<ul>
<li>App的使用体验与Web2.0仍然类似或一致</li>
<li>用户对自己贡献的内容具有所有权，能够根据对平台的内容贡献获得一定的回报</li>
<li>对自己使用平台服务时产生的隐私数据，能够比较清楚的知晓这些数据的边界和用途，并对这些数据具有一定的决策权，可用其产生一定的经济收益</li>
<li>对平台承诺的对一些私密数据的存储有信心（因为是密码学保证且代码是开源的）</li>
<li>用户能跨平台地拥有一些东西的所有权（这个所有权是密码学保证的，不是某个机构认证的），这样在跨平台交互的时候，能认证且自由转移这些所有权资产</li>
</ul>
<p>我们整理Web1.0, Web2.0, Web3.0的历史关系，做图如下：</p>
<p><img src="chapter_6/./image/web3/6.png" alt="6" /></p>
<p>Web3.0不是Web2.0的直系后代，而更像是远房表亲。Web3.0的核心思想更多来自Web1.0的开放协议簇和密码学领域的混合。Web3.0平台的运营商业模式和用户使用体验与Web2.0没有太大区别。Web3.0是开放的协议簇，基于Web3.0将会产生更丰富多样的创新的商业模式。</p>
<p>Web3.0不一定能在所有领域对Web2.0产生全面的替代，但一定会在某些领域，特别是具有明显网络效应的领域产生突破。比如：社交媒体、UGC内容平台（博客，问答等）、原创内容（如音乐，艺术，书籍等）分发平台等领域。</p>
<h2><a class="header" href="#结语-2" id="结语-2">结语</a></h2>
<p>我们用一张图来总结Web3.0的核心要素：</p>
<p><img src="chapter_6/./image/web3/7.png" alt="7" /></p>
<p>图片来自《Web3.0应用的新机遇》</p>
<p>Web3.0是一个更加开放，公平和安全的网络，其网络形态不是当前Web2.0的简单升级，它要解决的核心问题，其实是平台利益的分配问题。Web3.0要在激励人的主观能动性和价值创造的基础上尝试解决利益分配问题。而利益的分配，又与组织形式密切相关。这正是区块链能发挥作用的地方，这些细节具体会在下一篇《为什么Web3.0需要区块链》中详细讲解。</p>
<p>Web3.0不是在一块空白之地上建立空中楼阁，它致力于解决人类社会发展中的深层次问题。</p>
<h2><a class="header" href="#引用" id="引用">引用</a></h2>
<ol>
<li>比特币白皮书  <a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a></li>
<li>Web 3.0 and the Future of Trust  <a href="https://a16z.com/2019/11/12/the-end-of-centralization-and-the-future-of-trust/">https://a16z.com/2019/11/12/the-end-of-centralization-and-the-future-of-trust/</a></li>
<li>Rebooting the Internet <a href="https://medium.com/dfinity/rebooting-the-internet-andreessen-horowitzs-chris-dixon-on-the-decentralized-web-e0b4b0245645">https://medium.com/dfinity/rebooting-the-internet-andreessen-horowitzs-chris-dixon-on-the-decentralized-web-e0b4b0245645</a></li>
<li>Why We Need Web 3.0  <a href="https://gavofyork.medium.com/why-we-need-web-3-0-5da4f2bf95ab">https://gavofyork.medium.com/why-we-need-web-3-0-5da4f2bf95ab</a></li>
<li>《刘毅：Web3.0到底是醒世恒言还是危言耸听？》 <a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1618666137&amp;ver=3014&amp;signature=gvJ5zET-uhEK6GCJGTPMG70iAollqC4oToIB1aXZrOq6drLiThxPVXc1feP84*J*pcNKnovNPIc2umIuPPHuwzef7mKrD*sUhGCcH89SG2aUT5-9lp4nNxJ86S9HxLUQ&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1618666137&amp;ver=3014&amp;signature=gvJ5zET-uhEK6GCJGTPMG70iAollqC4oToIB1aXZrOq6drLiThxPVXc1feP84<em>J</em>pcNKnovNPIc2umIuPPHuwzef7mKrD*sUhGCcH89SG2aUT5-9lp4nNxJ86S9HxLUQ&amp;new=1</a></li>
<li>《Web3.0应用的新机遇》 <a href="https://mp.weixin.qq.com/s/DxHSRASawmwU_snbsKXKdw">https://mp.weixin.qq.com/s/DxHSRASawmwU_snbsKXKdw</a></li>
</ol>
<h2><a class="header" href="#rbatis-orm-20--零开销编译时动态sql的探索" id="rbatis-orm-20--零开销编译时动态sql的探索">Rbatis ORM 2.0 | 零开销编译时动态SQL的探索</a></h2>
<p>作者：朱秀杰</p>
<hr />
<ul>
<li>什么是动态SQL？</li>
</ul>
<p>在某种高级语言中，如果嵌入了SQL语句，而这个SQL语句的主体结构已经明确，例如在Java的一段代码中有一个待执行的SQL“select * from t1 where c1&gt;5”，在Java编译阶段，就可以将这段SQL交给数据库管理系统去分析，数据库软件可以对这段SQL进行语法解析，生成数据库方面的可执行代码，这样的SQL称为静态SQL，即在编译阶段就可以确定数据库要做什么事情。
而如果嵌入的SQL没有明确给出，如在Java中定义了一个字符串类型的变量sql：String sql;，然后采用preparedStatement对象的execute方法去执行这个sql，该sql的值可能等于从文本框中读取的一个SQL或者从键盘输入的SQL，但具体是什么，在编译时无法确定，只有等到程序运行起来，在执行的过程中才能确定，这种SQL叫做动态SQL</p>
<h3><a class="header" href="#前言-3" id="前言-3">前言</a></h3>
<blockquote>
<p>笔者曾经在2020年发布基于rust的orm第一版，参见文章https://rustcc.cn/article?id=1f29044e-247b-441e-83f0-4eb86e88282c</p>
</blockquote>
<p>v1.8版本依靠rust提供的高性能，sql驱动依赖sqlx-core，未作特殊优化性能即超过了go、java之类的orm
v1.8版本一经发布，受到了许多网友的肯定和采纳，并应用于诸多生产系统之上。
v1.8版本借鉴了mybatis plus 同时具备的基本的crud功能并且推出py_sql简化组织编写sql的心理压力，同时增加一系列常用插件，极大的方便了广大网友。</p>
<blockquote>
<p>同时1.8版本也具备了某些网友提出的问题，例如：</p>
</blockquote>
<ul>
<li>by_id*()的方式，局限性很大，只能操作具有该id的表，能否更改为 by_column*(column:&amp;str,arg:xxx)；传入需要操作的column的形式？</li>
<li>CRUDTable trait 能否不要指定id主键（因为有的表有可能不止一个主键）？</li>
<li>当使用TxManager外加tx_id管理事务的方式，因为用到了锁，似乎影响性能</li>
<li>py_sql使用ast+解释执行的方式，不但存在 运行时，运行时解析阶段，运行时解释执行阶段，能否优化为完全0开销的方式？</li>
<li>能否加入xml格式的动态sql存储，实现sql和代码解耦分离，不要使用CDATA转义（太麻烦了），适当兼容从java迁移过来的系统并适当复用之前的mybais xml？</li>
</ul>
<p>经过一段时间的思考和整理，于是推出v2.0版本，实现完全0开销的动态sql，sql构建性能提高N倍（只生成sql），完整查询QPS（组织sql到得到结果）性能提高至少2倍以上，并解决以上问题</p>
<p>兼顾方便和性能，例如这里使用html_sql查询(v2.0版本)分页代码片段：</p>
<ul>
<li>html文件</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;https://github.com/rbatis/rbatis_sql/raw/main/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper&gt;
    &lt;select id=&quot;select_by_condition&quot;&gt;
        select * from biz_activity where
        &lt;if test=&quot;name != ''&quot;&gt;
            name like #{name}
        &lt;/if&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li>main.rs文件</li>
</ul>
<pre><pre class="playground"><code class="language-rust">    #[crud_table]
    #[derive(Clone, Debug)]
    pub struct BizActivity {
        pub id: Option&lt;String&gt;,
        pub name: Option&lt;String&gt;,
        pub pc_link: Option&lt;String&gt;,
        pub h5_link: Option&lt;String&gt;,
        pub pc_banner_img: Option&lt;String&gt;,
        pub h5_banner_img: Option&lt;String&gt;,
        pub sort: Option&lt;String&gt;,
        pub status: Option&lt;i32&gt;,
        pub remark: Option&lt;String&gt;,
        pub create_time: Option&lt;NaiveDateTime&gt;,
        pub version: Option&lt;i32&gt;,
        pub delete_flag: Option&lt;i32&gt;,
    }
    
    #[html_sql(rb, &quot;example/example.html&quot;)]
    async fn select_by_condition(rb: &amp;mut RbatisExecutor&lt;'_&gt;, page_req: &amp;PageRequest, name: &amp;str) -&gt; Page&lt;BizActivity&gt; { todo!() }
    
    #[async_std::main]
    pub async fn main() {
        fast_log::init_log(&quot;requests.log&quot;, 1000, log::Level::Info, None, true);
        //use static ref
        let rb = Rbatis::new();
        rb.link(&quot;mysql://root:123456@localhost:3306/test&quot;)
            .await
            .unwrap();
        let a = select_by_condition(&amp;mut (&amp;rb).into(), &amp;PageRequest::new(1, 10), &quot;test&quot;)
            .await
            .unwrap();
        println!(&quot;{:?}&quot;, a);
    }
</code></pre></pre>
<blockquote>
<p>介绍Java最普遍的ORM框架前世今生 - Mybatis、MybatisPlus，XML，OGNL表达式，dtd文件</p>
</blockquote>
<ul>
<li>
<p>MyBatis在java和sql之间提供更灵活的映射方案,MyBatis将sql语句和方法实现，直接写到xml文件中，实现和java程序解耦
为何这样说,MyBatis将接口和SQL映射文件进行分离,相互独立,但又通过反射机制将其进行动态绑定。
其实它底层就是Mapper代理工厂[MapperRegistry]和Mapper标签映射[MapperStatement],它们两个说穿了就是Map容器,就是我们常见的HashMap、ConcurrentHashMap。
所以说,MyBatis使用面向接口的方式这种思想很好的实现了解耦和的方式,同时易于开发者进行定制和扩展,比如我们熟悉的通用Mapper和分页插件pageHelper,方式也非常简单。</p>
</li>
<li>
<p>什么是DTD文件？</p>
</li>
</ul>
<p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。同样，它可以作用于xml文件也可以作用于html文件.
Intellij IDEA,CLion,VSCode等等ide均具备该文件合法模块，标签智能提示的能力
例如:</p>
<pre><code class="language-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!ELEMENT mapper (sql* | insert* | update* | delete* | select* )+&gt;
        &lt;!ATTLIST mapper
                &gt;
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;https://github.com/rbatis/rbatis_sql/raw/main/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li>什么是OGNL表达式？</li>
</ul>
<p>OGNL(Object-Graph Navigation Language)大概可以理解为:对象图形化导航语言。是一种可以方便地操作对象属性的开源表达式语言.
Rbatis在html，py_sql内部借鉴部分ognl表达式的设计，但是rbatis实际操作的是json对象。</p>
<p>例如(#{name},表示从参数中获取name参数，#符号表示放如预编译sql参数并替换为mysql的'?'或者pg的‘$1’，如果是$符号表示直接插入并替换sql):</p>
<pre><code class="language-html">&lt;select id=&quot;select_by_condition&quot;&gt;select * from table where name like #{name}&lt;/select&gt;
</code></pre>
<h3><a class="header" href="#探索实现架构走弯路-最初版本基于ast解释执行" id="探索实现架构走弯路-最初版本基于ast解释执行">探索实现架构走弯路-最初版本基于AST+解释执行</a></h3>
<p>AST抽象语法树，可以参考其他博客 <a href="https://blog.csdn.net/weixin_39408343/article/details/95984062">https://blog.csdn.net/weixin_39408343/article/details/95984062</a>
<img src="https://cdn.learnku.com/uploads/images/202006/21/65201/3S3U7Tdvx0.png!large" alt="" /></p>
<ul>
<li>AST结构体大概长这样</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Node {
    pub left: Option&lt;Box&lt;Node&gt;&gt;,
    pub value: Value,
    pub right: Option&lt;Box&lt;Node&gt;&gt;,
    pub node_type: NodeType,
}
impl Node{
    #[inline]
    pub fn eval(&amp;self, env: &amp;Value) -&gt; Result&lt;Value, crate::error::Error&gt; {
        if self.equal_node_type(&amp;NBinary) {
            let left_v = self.left.as_ref().unwrap().eval(env)?;
            let right_v = self.right.as_ref().unwrap().eval(env)?;
            let token = self.to_string();
            return eval(&amp;left_v, &amp;right_v, token);
        } else if self.equal_node_type(&amp;NArg) {
            return self.value.access_field(env);
        }
        return Result::Ok(self.value.clone());
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>表达式是如何运行的？</p>
</blockquote>
<ul>
<li>例如执行表达式‘1+1’，首先经过框架解析成3个Node节点的二叉树,‘+’符号节点左叶子节点为1，右叶子节点为1</li>
<li>执行时，执行‘+’节点的eval方法，这时它会执行叶子节点的eval（）方法得到2给值(这里eval方法实际执行了clone操作)，并根据符号‘+’对2给值累加，并返回。</li>
</ul>
<blockquote>
<p>结论： 这种架构下，其实存在一些弊端，例如存在很多不必要的clone操作，node需要在程序运行阶段 解析-&gt;生成AST-&gt;逐行解释执行AST。这些都是存在一些时间和cpu、内存开销的</p>
</blockquote>
<h3><a class="header" href="#探索实现架构走弯路-尝试基于wasm" id="探索实现架构走弯路-尝试基于wasm">探索实现架构走弯路-尝试基于wasm</a></h3>
<ul>
<li>什么是wasm？
WebAssembly/wasm WebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式。</li>
</ul>
<p>rust也有一些wasm运行时，这类框架可以进行某些JIT编译优化工作。例如 wasmtime/cranelift/
曾经发现调用cranelift 运行时调用开销 800ns/op，对于频繁进出宿主-wasm运行时调用的话，似乎并不是特别适合ORM。况且接近800ns的延迟，说实话挺难接受的。参见issues
https://github.com/bytecodealliance/wasmtime/issues/2644
经过一些时间等待，该问题被解决后，仍然需要耗费至少50ns的时间开销。对于sql中出现参数动则20次的调用，时间延迟依然会进一步拉大</p>
<h3><a class="header" href="#探索实现架构-真正的0开销抽象尝试过程宏是元编程也是高性能的关键" id="探索实现架构-真正的0开销抽象尝试过程宏是元编程也是高性能的关键">探索实现架构-真正的0开销抽象，尝试过程宏，是元编程也是高性能的关键</a></h3>
<p>我们一直在说0开销，C++的实现遵循“零开销原则”：如果你不使用某个抽象，就不用为它付出开销[Stroustrup，1994]。而如果你确实需要使用该抽象，可以保证这是开销最小的使用方式。
— Stroustrup</p>
<ul>
<li>如果我们使用过程宏直接把表达式编译为纯rust函数代码，那么就实现了真正意义上令人兴奋的0开销！不但降低cpu使用率，同时提升性能</li>
</ul>
<blockquote>
<p>过程宏框架，syn和quote（分别解析和生成词条流）</p>
</blockquote>
<p>我们知道syn和quote结合起来是实现过程宏的主要方式，但是syn和quote仅支持rust语法规范。
如何让它能变相解析我们自定义的语法糖呢？</p>
<ul>
<li>答案就是让我们的语法糖转换为符合rust规范的语法，让syn和quote能够正常解析和生成词条流</li>
</ul>
<blockquote>
<p>关于扩展性-包装serde_json还是拷贝serde_json源码？</p>
</blockquote>
<p>我们执行的表达式参数都是json参数，这里涉及使用到serde_json。但是serde_json其实不具备 类似 serde_json::Value + 1 的语法规则，你会得到编译错误！</p>
<ul>
<li>
<p>（语法不支持）解决方案： impl std::ops::Add for serde_json::Value{} 实现标准库的接口即可支持。</p>
</li>
<li>
<p>但是碍于 孤儿原则（当你为某类型实现某 trait 的时候，必须要求类型或者 trait 至少有一个是在当前 crate 中定义的。你不能为第三方的类型实现第三方的 trait ）你会得到编译错误！</p>
</li>
</ul>
<blockquote>
<p>语法糖语义和实现trait 支持扩展</p>
</blockquote>
<ul>
<li>（孤儿原则）解决方案: 实现自定义结构体，并依赖serde_json::Value对象，并实现该结构体的语法规则支持！</li>
</ul>
<p>自定义的结构体大概长这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq, Clone, Debug)]
pub struct Value&lt;'a&gt; {
    pub inner: Cow&lt;'a, serde_json::Value&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>性能优化1-写时复制Cow-避免不必要的克隆</p>
</blockquote>
<ul>
<li>科普：写时复制（Copy on Write）技术是一种程序中的优化策略，多应用于读多写少的场景。主要思想是创建对象的时候不立即进行复制，而是先引用（借用）原有对象进行大量的读操作，只有进行到少量的写操作的时候，才进行复制操作，将原有对象复制后再写入。这样的好处是在读多写少的场景下，减少了复制操作，提高了性能。</li>
</ul>
<p>实现表达式执行时，并不是所有操作都存在‘写’的，大部分场景是基于‘读’
例如表达式:</p>
<pre><code class="language-html"> &lt;if test=&quot;id &gt; 0 || id == 1&quot;&gt;
            id = ${id}
&lt;/if&gt;
</code></pre>
<ul>
<li>这里，读取id并判断是否大于0或等于1</li>
</ul>
<blockquote>
<p>性能优化2-重复变量利用优化</p>
</blockquote>
<ul>
<li>表达式定义了变量参数id，进行2次访问，那我们生成的fn函数中即要判断是否已存在变量id，第二次直接访问而不是重复生成
例如:</li>
</ul>
<pre><code class="language-html"> &lt;select id=&quot;select_by_condition&quot;&gt;
        select * from table where
        id != #{id}
        and 1 != #{id}
&lt;/select&gt;
</code></pre>
<blockquote>
<p>性能优化3-sql预编译参数替换算法优化</p>
</blockquote>
<p>预编译的sql需要把参数替换为例如 mysql:'?',postgres:'$1'等符号。</p>
<ul>
<li>字符串替换性能的关键-rust的string存储于堆内存</li>
</ul>
<p>rust的String对象是支持变长的字符串，我们知道Vec是存储于堆内存（因为计算机堆内存容量更大，而栈空间是有限的）大概长这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>性能优化-不使用format！宏等生成String结构体的函数，减少访问堆内存。</p>
</li>
<li>
<p>巧用char进行字符串替换，因为单个char存储于栈，栈的速度快于堆</p>
</li>
<li>
<p>替换算法优化内容长这样.(这里我们使用<code> new_sql.push(char)</code>,只访问栈内存空间)</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    macro_rules! push_index {
     ($n:expr,$new_sql:ident,$index:expr) =&gt; {
                  {
                     let mut num=$index/$n;
                     $new_sql.push((num+48) as u8 as char);
                     $index % $n
                  }
              };
    ($index:ident,$new_sql:ident) =&gt; {
                if  $index&gt;=0 &amp;&amp; $index&lt;10{
                    $new_sql.push(($index+48)as u8 as char);
                }else if $index&gt;=10 &amp;&amp; $index&lt;100 {
                    let $index = push_index!(10,$new_sql,$index);
                    let $index = push_index!(1,$new_sql,$index);
                }else if $index&gt;=100 &amp;&amp; $index&lt;1000{
                    let $index = push_index!(100,$new_sql,$index);
                    let $index = push_index!(10,$new_sql,$index);
                    let $index = push_index!(1,$new_sql,$index);
                }else if $index&gt;=1000 &amp;&amp; $index&lt;10000{
                    let $index = push_index!(1000,$new_sql,$index);
                    let $index = push_index!(100,$new_sql,$index);
                    let $index = push_index!(10,$new_sql,$index);
                    let $index = push_index!(1,$new_sql,$index);
                }else{
                     use std::fmt::Write;
                     $new_sql.write_fmt(format_args!(&quot;{}&quot;, $index))
                    .expect(&quot;a Display implementation returned an error unexpectedly&quot;);
               }
       };
    }
    
        for x in sql.chars() {
        if x == '\'' || x == '&quot;' {
            if string_start == true {
                string_start = false;
                new_sql.push(x);
                continue;
            }
            string_start = true;
            new_sql.push(x);
            continue;
        }
        if string_start {
            new_sql.push(x);
        } else {
            if x=='?' &amp;&amp; #format_char != '?' {
                index+=1;
                new_sql.push(#format_char);
                push_index!(index,new_sql);
            }else{
                new_sql.push(x);
            }
        }
    }

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#最后的验证阶段零开销编译时动态sql执行效率压测" id="最后的验证阶段零开销编译时动态sql执行效率压测">最后的验证阶段，（零开销、编译时动态SQL）执行效率压测</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>v2.0请求耗时
耗时:3923900800
耗时:3576816000
耗时:3248177800
耗时:3372922200


v1.8请求耗时
耗时:6372459300
耗时:7709288000
耗时:6739494900
耗时:6590053200
<span class="boring">}
</span></code></pre></pre>
<p>结论： v2.0相对于老版本，qps至少快一倍</p>
<h1><a class="header" href="#github-趋势榜-2" id="github-趋势榜-2">GitHub 趋势榜</a></h1>
<p>编辑：张汉东</p>
<blockquote>
<p>说明：记录一下本月在 GitHub 趋势榜单出现的 新的项目。</p>
<p>排名不分先后</p>
</blockquote>
<hr />
<h2><a class="header" href="#vaultwarden--非官方-bitwarden-兼容服务器的-rust-实现" id="vaultwarden--非官方-bitwarden-兼容服务器的-rust-实现">vaultwarden ： 非官方 Bitwarden 兼容服务器的 Rust 实现</a></h2>
<p>Bitwarden 是一个开源的密码管理服务，全平台支持，介面简洁，前后端均开源（Telegram 仅客户端开源）功能全面，支持两步验证（Lastpass 付费版都不支持的功能）、团队共享密码库，另外，支持将服务端部署在自己的服务器上。</p>
<p>以前称为 bitwarden_rs。</p>
<p><a href="https://github.com/dani-garcia/vaultwarden">https://github.com/dani-garcia/vaultwarden</a></p>
<h2><a class="header" href="#sysinfo--一个系统处理程序" id="sysinfo--一个系统处理程序">sysinfo : 一个系统处理程序</a></h2>
<p>以获取信息并与 Rust 实现的进程进行交互。</p>
<p><a href="https://github.com/GuillaumeGomez/sysinfo">https://github.com/GuillaumeGomez/sysinfo</a></p>
<h2><a class="header" href="#feroxbuster-一种快速简单递归的内容发现工具" id="feroxbuster-一种快速简单递归的内容发现工具">feroxbuster: 一种快速，简单，递归的内容发现工具</a></h2>
<p>feroxbuster是一个旨在执行强制浏览的工具。</p>
<p>强制浏览是一种攻击，其目的是列举和访问没有被网络应用程序引用的资源，但攻击者仍可访问。</p>
<p>feroxbuster使用穷举结合词表来搜索目标目录中未链接的内容。这些资源可能存储有关网络应用程序和操作系统的敏感信息，如源代码、证书、内部网络地址等。</p>
<p>这种攻击也被称为可预测资源位置、文件列举、目录列举和资源列举。</p>
<p><a href="https://github.com/epi052/feroxbuster">https://github.com/epi052/feroxbuster</a></p>
<h2><a class="header" href="#aya--rust-实现的-ebpf-库" id="aya--rust-实现的-ebpf-库">aya : Rust 实现的 eBPF 库</a></h2>
<p>aya 的特色是 仅仅依赖 libc 的 纯度 99.9% 的Rust 实现。</p>
<p><a href="https://github.com/alessandrod/aya">https://github.com/alessandrod/aya</a></p>
<h2><a class="header" href="#neovide-rust-实现的干净利落的-neovim-客户端" id="neovide-rust-实现的干净利落的-neovim-客户端">Neovide: Rust 实现的干净利落的 Neovim 客户端</a></h2>
<p><a href="https://github.com/Kethku/neovide">https://github.com/Kethku/neovide</a></p>
<h2><a class="header" href="#libreddit-用-rust-实现一个私人定制的-reddit-前端" id="libreddit-用-rust-实现一个私人定制的-reddit-前端">libreddit: 用 Rust 实现一个私人定制的 Reddit 前端</a></h2>
<p><a href="https://github.com/spikecodes/libreddit">https://github.com/spikecodes/libreddit</a></p>
<h2><a class="header" href="#paru-pacman-助手" id="paru-pacman-助手">paru: pacman 助手</a></h2>
<p>pacman 软件包管理器是Arch Linux 的一大亮点。</p>
<p><a href="https://github.com/Morganamilo/paru">https://github.com/Morganamilo/paru</a></p>
<h2><a class="header" href="#delta-git-和-git-diff-查看器" id="delta-git-和-git-diff-查看器">delta: git 和 git diff 查看器</a></h2>
<p>该项目 star 数目近万了</p>
<p><a href="https://github.com/dandavison/delta">https://github.com/dandavison/delta</a></p>
<h2><a class="header" href="#git-branchless--git-无分支工作流" id="git-branchless--git-无分支工作流">git-branchless:  Git 无分支工作流</a></h2>
<p>Git-Brantless 是一套帮助开发者可视化，导航，操作和修复提交历史记录的工具。 它基于谷歌和Facebook等大公司的无可分割的Mercurial工作流。</p>
<p><a href="https://github.com/arxanas/git-branchless">https://github.com/arxanas/git-branchless</a></p>
<h2><a class="header" href="#metaplex-metaplex-协议-rust-实现" id="metaplex-metaplex-协议-rust-实现">metaplex: Metaplex 协议 Rust 实现</a></h2>
<p>Metaplex 是一个无需许可的链上协议，支持Solana 区块链的原生购买、销售和拍卖NFT，可大大降低了铸造和交易费用。</p>
<p><a href="https://github.com/metaplex-foundation/metaplex">https://github.com/metaplex-foundation/metaplex</a></p>
<h2><a class="header" href="#zoxide-一个更智能的cd命令" id="zoxide-一个更智能的cd命令">zoxide: 一个更智能的CD命令。</a></h2>
<p>支持所有主流 shell。</p>
<p><a href="https://github.com/ajeetdsouza/zoxide">https://github.com/ajeetdsouza/zoxide</a></p>
<h2><a class="header" href="#eww-用-rust-实现-widgets" id="eww-用-rust-实现-widgets">eww: 用 Rust 实现 widgets</a></h2>
<p>Elkowar’s Wacky Widgets，是一个独立的小部件系统，它基于 Rust，允许开发者在任何窗口管理器中实现自己的自定义小部件。</p>
<p>基于 GTK，应该是跨平台的。</p>
<ul>
<li><a href="https://github.com/elkowar/eww">https://github.com/elkowar/eww</a></li>
<li><a href="https://elkowar.github.io/eww/">https://elkowar.github.io/eww/</a></li>
</ul>
<h1><a class="header" href="#推荐项目--基础工具库-2" id="推荐项目--基础工具库-2">推荐项目 ｜ 基础工具库</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#helix--rust--实现的新一代文本编辑器" id="helix--rust--实现的新一代文本编辑器">helix ： Rust  实现的新一代文本编辑器</a></h2>
<p>Helix 编辑器具备以下主要特性：</p>
<ul>
<li>多项选择（Multiple selections）</li>
<li>通过 tree-sitter 实现语法高亮和代码编辑</li>
<li>解析过程是渐进式的，并且速度足够快，足以运行每一次击键。并且它足够稳健，甚至能够输出带有语法错误的结果。</li>
<li>内置语言服务器支持</li>
<li>语境感知补全： 文档/诊断/Code actions</li>
<li>在终端中运行：其基础实现利用终端前端，且与 tmux 连接良好或使用 ssh。</li>
<li>使用 Rust 构建，未使用 Electron、VimScript 和 JavaScript，更少能耗。</li>
</ul>
<p><a href="https://github.com/helix-editor/helix">https://github.com/helix-editor/helix</a></p>
<h2><a class="header" href="#findomain--发布了新版本" id="findomain--发布了新版本">Findomain ： 发布了新版本</a></h2>
<p>功能介绍摘录：</p>
<p>Findomain提供了一个Subdomains监控服务，提供：目录模糊/端口扫描/漏洞发现 - 以及更多 </p>
<p>这允许您使用多个顶级工具（OWASP AMASS，SUBLIST3R，ASSETFINDER和SUBFINDER）监视您的目标域，并在新子域名时发送警报，以便发送到Discord，Slack，Telegram，电子邮件或推送通知（Android / IOS / Smart Watch /桌面） 。</p>
<p>唯一需要做的是使用电子邮件地址（如果适用）或/和Webhooks / Telegram聊天信息配置文件，并将您的域放在另一个文件中，一旦您完成了保持您的完整自动子域监控服务 最新使用已发现的新子域，htth网站，打开端口，子域CNAME等的HOST IP，HTTP状态，屏幕截图。 您的所有数据都会安全地保存在关系数据库中，您可以随时申请数据转储。</p>
<p><a href="https://github.com/Findomain/Findomain">https://github.com/Findomain/Findomain</a></p>
<h2><a class="header" href="#脑机接口-协议api-rust-实现" id="脑机接口-协议api-rust-实现">脑机接口 协议/API Rust 实现</a></h2>
<p>(满脑子都是 Rust.jpg )</p>
<p>针对 NeuroSky MindWave EEG headset 设备 </p>
<p>应该是这家公司 <a href="http://www.neurosky.com.cn/products-markets/mindwave-mobile-2/">http://www.neurosky.com.cn/products-markets/mindwave-mobile-2/ </a>的设备</p>
<p><a href="https://github.com/junjunjd/rustymind">https://github.com/junjunjd/rustymind</a></p>
<h2><a class="header" href="#rust-高性能计时库" id="rust-高性能计时库">Rust 高性能计时库</a></h2>
<blockquote>
<p>by lemonhx &amp; zhongzc @ PingCAP </p>
</blockquote>
<p>minstant 在 Linux x86 x86_64 下使用 TSC 和在其他平台上使用 MONOTONIC_COARSE 吊打 std , 精度突破 10ns !</p>
<p>大家快来试用吧!</p>
<p><a href="https://github.com/LemonHX/minstant">https://github.com/LemonHX/minstant</a></p>
<h2><a class="header" href="#tabled--用于表格化打印结构体或枚举类型" id="tabled--用于表格化打印结构体或枚举类型">tabled : 用于表格化打印结构体或枚举类型</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tabled::{Tabled, table};

#[derive(Tabled)]
struct Language {
    name: &amp;'static str,
    designed_by: &amp;'static str,
    invented_year: usize,
}

let languages = vec![
    Language{
        name: &quot;C&quot;,
        designed_by: &quot;Dennis Ritchie&quot;,
        invented_year: 1972
    },
    Language{
        name: &quot;Rust&quot;,
        designed_by: &quot;Graydon Hoare&quot;,
        invented_year: 2010
    },
    Language{
        name: &quot;Go&quot;,
        designed_by: &quot;Rob Pike&quot;,
        invented_year: 2009
    },
];

let table = table!(&amp;languages);
let expected = &quot;+------+----------------+---------------+\n\
                | name |  designed_by   | invented_year |\n\
                +------+----------------+---------------+\n\
                |  C   | Dennis Ritchie |     1972      |\n\
                +------+----------------+---------------+\n\
                | Rust | Graydon Hoare  |     2010      |\n\
                +------+----------------+---------------+\n\
                |  Go  |    Rob Pike    |     2009      |\n\
                +------+----------------+---------------+\n&quot;;

assert_eq!(expected, table);
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://github.com/zhiburt/tabled">https://github.com/zhiburt/tabled</a></p>
<h2><a class="header" href="#crusty" id="crusty">Crusty</a></h2>
<p>Crusty，一个快速，可扩展，礼貌性的通用网络爬虫（Broad Web Crawler）。Crusty 旨在：</p>
<p>提供一种研究 www 和通用网络爬虫领域的方法；</p>
<ul>
<li>为可扩展性、可配置性和自定义数据收集提供程序接口；</li>
<li>快速，在稳定、可预测的单节点性能、不错的硬件饱和度方面；</li>
<li>易于扩展；</li>
<li>礼貌性，可能是通用网络爬虫中最重要的部分；</li>
<li>可监控，日志、自定义指标、实时 Grafana 仪表板；</li>
<li>易于交互，仅使用一个命令构建和运行，可重现的 docker 构建；</li>
</ul>
<p><a href="https://github.com/let4be/crusty">https://github.com/let4be/crusty</a></p>
<h2><a class="header" href="#trilliumrs-rust-异步-web-组件" id="trilliumrs-rust-异步-web-组件">trillium.rs: Rust 异步 Web 组件</a></h2>
<p>trillium 是一个 toolkit,可以让你快速的创建 Rust 的异步 Web 应用. 可以运行在 tokio, async-std, 或者smol上. 用起来就像下面一样简单.</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    trillium_smol::run(|conn: trillium::Conn| async move {
        conn.ok(&quot;hello from trillium!&quot;)
    });
}
</code></pre></pre>
<ul>
<li><a href="https://trillium.rs/">book</a></li>
<li><a href="https://github.com/trillium-rs/trillium">https://github.com/trillium-rs/trillium</a></li>
</ul>
<h2><a class="header" href="#玄铁处理核-rust-语言支持库现已发布" id="玄铁处理核-rust-语言支持库现已发布">玄铁处理核 Rust 语言支持库现已发布</a></h2>
<p>这个支持库允许Rust语言访问玄铁处理器的专有功能，包括特殊的页表、寄存器和专有指令，调试模块的支持也在编写之中。支持库适用于玄铁9系列RISC-V处理核，它能很好地支持裸机引导程序、调试器软件和机器监视环境的开发工作，也可用于研发新型操作系统内核。</p>
<p>同时，Rust芯片支持库对裸机环境的开发有一定的帮助。例如，它可以用于开发适配RustSBI的引导程序环境，以制作基于玄铁C906处理核的全志D1芯片引导程序。</p>
<p>支持库已经发布到crates平台，它详细的文档托管在docs.rs网站上；使用木兰宽松许可协议第2版开源，允许商业使用。</p>
<p><a href="https://github.com/luojia65/xuantie">https://github.com/luojia65/xuantie</a></p>
<h2><a class="header" href="#ripgrep-发布-v1300" id="ripgrep-发布-v1300">ripgrep 发布 v13.0.0</a></h2>
<p>ripgrep 13 是一个新的主要版本，本次更新包含bug修复，性能优化，和几个小的突破性的改进，并且修复了windows平台下的一个安全漏洞。 详细的版本说明可以参见：<a href="https://github.com/BurntSushi/ripgrep/releases/tag/13.0.0">https://github.com/BurntSushi/ripgrep/releases/tag/13.0.0</a></p>
<p>ripgrep 是一个面向文本行的搜索工具，可以根据正则表达式递归搜索当前的目录。ripgrep在功能上类似其他流行的搜索工具，如 The Silver Searcher，ack 和 grep 等。ripgrep支持Windows，macOS，和Linux，并且对于每次发行版都提供构建好的二进制程序以供下载。</p>
<h2><a class="header" href="#cuda-oxide" id="cuda-oxide">cuda-oxide</a></h2>
<p>cuda-oxide 是 CUDA 的安全包装器，使用它可以执行和协调 CUDA 内核。</p>
<p>CUDA是Compute Unified Device Architecture的缩写，是Nvidia开发的一项技术，可加速GPU计算流程。</p>
<p><a href="https://github.com/Protryon/cuda-oxide">https://github.com/Protryon/cuda-oxide</a></p>
<h2><a class="header" href="#xh友好快速的-http-请求工具" id="xh友好快速的-http-请求工具">xh：友好快速的 HTTP 请求工具</a></h2>
<p>尽可能多地重新实现了 HTTPie 的优秀设计。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ xh get baidu.com

HTTP/1.1 200 OK
accept-ranges: bytes
cache-control: max-age=86400
connection: Keep-Alive
content-length: 81
content-type: text/html
date: Sun, 20 Jun 2021 05:13:12 GMT
etag: &quot;51-47cf7e6ee8400&quot;
expires: Mon, 21 Jun 2021 05:13:12 GMT
last-modified: Tue, 12 Jan 2010 13:48:00 GMT
server: Apache

&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://github.com/ducaale/xh">https://github.com/ducaale/xh</a></p>
<h2><a class="header" href="#elfcat-elf-visualizer" id="elfcat-elf-visualizer">elfcat: ELF visualizer</a></h2>
<p>elfcat 可以从 ELF binary 中生成 HTML, 从而可以让你以一种非常生动的形式查看 ELF. 可以点击示例地址进行查看.</p>
<ul>
<li><a href="http://ruslashev.github.io/elfcat/hello_world.html">演示</a></li>
<li><a href="https://github.com/ruslashev/elfcat">https://github.com/ruslashev/elfcat</a></li>
</ul>
<h2><a class="header" href="#gtk4-rs-发布-gtk4-的-rust-绑定" id="gtk4-rs-发布-gtk4-的-rust-绑定">gtk4-rs 发布: GTK4 的 rust 绑定</a></h2>
<p>GTK4 的 rust 绑定正式发布，新功能，新官网，新的教程。</p>
<ul>
<li>链接：<a href="https://gtk-rs.org/blog/2021/06/22/new-release.html">https://gtk-rs.org/blog/2021/06/22/new-release.html</a></li>
<li>教程：<a href="https://gtk-rs.org/gtk4-rs/stable/latest/book/introduction.html">https://gtk-rs.org/gtk4-rs/stable/latest/book/introduction.html</a></li>
</ul>
<h2><a class="header" href="#feoblog-v040-发布" id="feoblog-v040-发布">FeoBlog v0.4.0 发布</a></h2>
<p>FeoBlog 是对分布式社交网络（协议 + 实现）的探索。</p>
<p><a href="https://github.com/NfNitLoop/feoblog">https://github.com/NfNitLoop/feoblog</a></p>
<h2><a class="header" href="#smallnum-编译期间的-number-优化" id="smallnum-编译期间的-number-优化">smallnum: 编译期间的 number 优化</a></h2>
<p>smallnum 可以对 number 进行 编译时大小优化。 宏返回能够适合静态边界的最小数值类型。对于无符号整数，宏输入是一个最大值。对于有符号整数，宏输入可以是最大值或最小值。</p>
<p><a href="https://github.com/tnballo/smallnum">https://github.com/tnballo/smallnum</a></p>
<h2><a class="header" href="#fang-后台任务执行库" id="fang-后台任务执行库">fang: 后台任务执行库</a></h2>
<p>fang是一个后台任务执行库. 支持:</p>
<ul>
<li>
<p>任务存储数据库</p>
</li>
<li>
<p>并发任务数</p>
</li>
<li>
<p>重启任务等</p>
</li>
<li>
<p><a href="https://www.badykov.com/rust/2021/06/27/fang/">https://www.badykov.com/rust/2021/06/27/fang/</a></p>
</li>
<li>
<p><a href="https://github.com/ayrat555/fang">https://github.com/ayrat555/fang</a></p>
</li>
</ul>
<h1><a class="header" href="#推荐项目---框架引擎-2" id="推荐项目---框架引擎-2">推荐项目 |  框架引擎</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#hitbox异步分布式缓存框架" id="hitbox异步分布式缓存框架">Hitbox：异步分布式缓存框架</a></h2>
<p>Hitbox是一个异步缓存框架，支持多个后端，适用于分布式和单机应用程序。 目前 Actix 已经集成了该框架。</p>
<p>后端支持 Redis ，该框架还在逐步完善中。</p>
<p><a href="https://github.com/hit-box/hitbox">https://github.com/hit-box/hitbox</a></p>
<h2><a class="header" href="#neuronika-rust-新的机器学习框架" id="neuronika-rust-新的机器学习框架">Neuronika: Rust 新的机器学习框架</a></h2>
<p>随着 Rust 语言热度的强劲增长，也有许多研究者探索 Rust 在机器学习等方面的研究。近日，有研究者用 Rust 编写了一个机器学习框架 Neuronika。</p>
<p>Neuronika 是由 Francesco Iannelli 等人开发，他们现在是计算机科学的硕士生。该框架提供了自动微分和动态神经网络，非常像 Pytorch。</p>
<ul>
<li><a href="https://github.com/neuronika/neuronika">https://github.com/neuronika/neuronika</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/381854038">https://zhuanlan.zhihu.com/p/381854038</a></li>
</ul>
<h2><a class="header" href="#thruster发布v112" id="thruster发布v112">Thruster发布v1.1.2</a></h2>
<p>Thruster，一个旨在让开发者在项目和团队之间保持高效一致的快速、直观的 Rust Web 框架。</p>
<p>v1.1.2版本的一些亮点：</p>
<ul>
<li>完全重建的路由树和解析器；</li>
<li>完全重建的内部“中间件”系统，获取中间件功能列表并使用闭包将它们组合起来；</li>
<li>更容易使用的中间件宏；</li>
<li>升级依赖库；</li>
</ul>
<p>在生产中使用 Thruster 的一些有趣指标：</p>
<ul>
<li>在过去的四个月里，它处理了 240 万个请求；</li>
<li>实例中没有（0%） 与框架相关的致命错误；</li>
<li>实例中95%的平均响应时间远低于 25 毫秒；</li>
<li>每个实例的平均 RAM 为 14.75MB；</li>
</ul>
<p>版本详情参见Release，<a href="https://github.com/thruster-rs/Thruster/blob/master/RELEASE.md">https://github.com/thruster-rs/Thruster/blob/master/RELEASE.md</a></p>
<h2><a class="header" href="#tantivy-v015-发布了" id="tantivy-v015-发布了">tantivy: v0.15 发布了</a></h2>
<p>tantivy 是 Rust 写的全文搜索引擎库. 现在tantivy 由 quickwit-inc 开发托管.</p>
<p><a href="https://github.com/quickwit-inc/tantivy">https://github.com/quickwit-inc/tantivy</a></p>
<h2><a class="header" href="#messages-异步-actor-框架" id="messages-异步-actor-框架">messages: 异步 actor 框架</a></h2>
<p>messages 是一个异步的 actor 框架, 受 actix 启发.</p>
<p><a href="https://github.com/popzxc/messages-rs">https://github.com/popzxc/messages-rs</a></p>
<h2><a class="header" href="#发布rg3d-020一个功能丰富且易于使用的游戏引擎" id="发布rg3d-020一个功能丰富且易于使用的游戏引擎">发布rg3d 0.20，一个功能丰富且易于使用的游戏引擎</a></h2>
<p>rg3d 0.20 已经发布。此版本包含许多新功能和改进。最大功能的是 WebAssembly 支持、初始 2D 支持和多层地形。</p>
<ul>
<li>文章链接 <a href="https://rg3d.rs/general/2021/06/11/rg3d-0.20-progress.html">https://rg3d.rs/general/2021/06/11/rg3d-0.20-progress.html </a></li>
<li><a href="https://github.com/rg3dengine/rg3d">https://github.com/rg3dengine/rg3d</a></li>
</ul>
<h2><a class="header" href="#wasmer-20-发布" id="wasmer-20-发布">Wasmer 2.0 发布！</a></h2>
<p>WebAssembly运行时Wasmer 2.0发布了：运行时速度快了50+%，热启动速度快了70+%，还有诸如引用类型、SIMD等更多新功能发布！</p>
<p>wasmer-2.0 发布：<a href="https://wasmer.io/posts/wasmer-2.0">https://wasmer.io/posts/wasmer-2.0</a></p>
<h2><a class="header" href="#walleye国际象棋引擎" id="walleye国际象棋引擎">Walleye：国际象棋引擎</a></h2>
<p>Walleye 是一种使用经典 alpha-beta 风格 AI 编写的与 UCI 兼容的引擎。 支持从任意 FEN 字符串加载棋盘位置、Unicode 漂亮地打印到控制台和帮助调试的 UCI 通信日志。注意，这是引擎，如果要玩儿的话要加 GUI，比如已经做过测试的 [Cute Chess(https://cutechess.com/)]。</p>
<p><a href="https://github.com/MitchelPaulin/Walleye">https://github.com/MitchelPaulin/Walleye</a></p>
<p>注：FEN 是 Forsyth-Edwards Notation 的简称，用来描述棋盘位置，详见<a href="https://www.chessprogramming.org/Forsyth-Edwards_Notation">维基百科</a>。</p>
<h1><a class="header" href="#七月刊" id="七月刊">七月刊</a></h1>
<p><img src="chapter_7/../image/rust_magazine3.png" alt="logo" /></p>
<p>目录顺序排名不分先后！</p>
<h2><a class="header" href="#发刊通告-9" id="发刊通告-9">发刊通告</a></h2>
<ul>
<li><a href="chapter_7/./announce.html">发刊通告</a></li>
</ul>
<h2><a class="header" href="#rust-资讯-3" id="rust-资讯-3">Rust 资讯</a></h2>
<ul>
<li><a href="chapter_7/./lang.html">官方动态</a></li>
<li><a href="chapter_7/./hots.html">社区热点</a></li>
<li><a href="chapter_7/./events.html">活动回顾</a></li>
<li><a href="chapter_7/./jobs.html">本月招聘</a></li>
<li><a href="chapter_7/./rust_china_conf_2021.html">RustChinaConf 2021 议题征集开放申请</a></li>
</ul>
<h2><a class="header" href="#rust-与-学术-3" id="rust-与-学术-3">Rust 与 学术</a></h2>
<ul>
<li><a href="chapter_7/./paper-rust-vs-c.html">论文导读 | 性能与生产力 : Rust vs C </a></li>
</ul>
<h2><a class="header" href="#rust-生产实践" id="rust-生产实践">Rust 生产实践</a></h2>
<ul>
<li><a href="chapter_7/./hw-rust-name-mangling.html">华为 | Rust 调用约定和名称修饰规则介绍</a></li>
<li><a href="chapter_7/./ant-futures-compat.html">蚂蚁集团 | Futures 0.1 和 0.3 兼容层的分析与应用</a></li>
<li><a href="chapter_7/./lark-rust-wasm-sqlite.html">字节跳动 ｜ 飞书 Rust 实践 之 SQLite 适配 WASM </a></li>
<li><a href="chapter_7/./rust-epoll-rdma-part2.html">Datenlord | Rust实现RDMA异步编程（二）</a></li>
<li><a href="chapter_7/./how-we-improved-the-performance-of-our-rust-app.html">Zellij 的性能优化</a></li>
</ul>
<h2><a class="header" href="#学习园地-6" id="学习园地-6">学习园地</a></h2>
<h3><a class="header" href="#新手入门-3" id="新手入门-3">新手入门</a></h3>
<ul>
<li><a href="chapter_7/./learn.html">学习资源</a></li>
<li><a href="chapter_7/./rusts-standard-library-traits.html">【完整】Rust 标准库 Trait 指南</a></li>
</ul>
<h3><a class="header" href="#原理与工程实践" id="原理与工程实践">原理与工程实践</a></h3>
<ul>
<li><a href="chapter_7/./coercion_in_rust.html">Rust 中的隐式类型转换</a></li>
<li><a href="chapter_7/./tokio-task-scheduler.html">Tokio Internals 之 任务调度</a></li>
<li><a href="chapter_7/./about-rust-features.html">为什么你不应该沉迷于 Rust 的“特性”</a></li>
<li><a href="chapter_7/./rust-no-std.html">Rust <code>no-std</code> 工程实践</a></li>
<li><a href="chapter_7/./dynamic_analyzing_tools.html">Rust 内存错误调试和动态分析工具分享</a></li>
</ul>
<h2><a class="header" href="#游戏-1" id="游戏-1">游戏</a></h2>
<ul>
<li><a href="chapter_7/./macroquad_game.html">使用Macroquad在Android设备上发布游戏</a></li>
</ul>
<h2><a class="header" href="#rust-与-操作系统-1" id="rust-与-操作系统-1">Rust 与 操作系统</a></h2>
<ul>
<li><a href="chapter_7/./trampoline-kernel.html">跨空间跳板内核</a></li>
</ul>
<h2><a class="header" href="#为-rust-语言做贡献" id="为-rust-语言做贡献">为 Rust 语言做贡献</a></h2>
<ul>
<li><a href="chapter_7/./trait-upcasting-part1.html">Trait Upcasting 系列 ｜ Part I</a></li>
</ul>
<h2><a class="header" href="#开源项目巡礼-3" id="开源项目巡礼-3">开源项目巡礼</a></h2>
<ul>
<li><a href="chapter_7/./github_trending.html">GitHub 趋势榜</a></li>
<li><a href="chapter_7/./tool_libs.html">推荐项目 ｜ 基础工具库</a></li>
<li><a href="chapter_7/./frameworks.html">推荐项目 |  框架引擎</a></li>
</ul>
<h1><a class="header" href="#发刊通告-10" id="发刊通告-10">发刊通告</a></h1>
<p>编辑：张汉东</p>
<h3><a class="header" href="#七月发刊通告" id="七月发刊通告">七月发刊通告</a></h3>
<p>《 RustMagazine 中文精选 》2021 年第七期发布了! </p>
<p>今年的七月，很不平凡。夏日最盛的时期，疫情却反反复复；河南遭遇千年一遇洪涝灾害。不过，无论如何，七月已过，愿所有美好如期而至，所有不好随风飘散。 </p>
<h3><a class="header" href="#本刊动态-3" id="本刊动态-3">本刊动态</a></h3>
<p>2021年（上半年）RustMagazine 中文精选 PDF 下载 : <a href="https://github.com/RustMagazine/rust_magazine_2021/releases/tag/0.5">https://github.com/RustMagazine/rust_magazine_2021/releases/tag/0.5</a></p>
<p><strong>（GitHub Page）从六月起已经停止 Rss 订阅</strong></p>
<p>因为当前 mdbook 的 rss 插件不是很方便，等以后再加 rss 支持吧。</p>
<p>可以到语雀平台自动支持邮件订阅。</p>
<h3><a class="header" href="#上期六月刊访问数据统计小结" id="上期六月刊访问数据统计小结">上期（六月刊）访问数据统计小结</a></h3>
<p><strong>用户数</strong></p>
<ul>
<li>新用户新增 2,124</li>
</ul>
<p><strong>浏览量：</strong></p>
<ul>
<li>网页浏览量 ： 15,115</li>
</ul>
<p><strong>五月份比较受欢迎的原创文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_6/ant-rust-data-layout.html">蚂蚁集团 ｜ Rust 数据内存布局</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_6/rabits.html">Rbatis ORM 2.0 | 零开销编译时动态SQL的探索</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_6/web3-part1.html">Web 3.0 概念的梳理</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_6/webassmebly-security.html">华为 | WebAssembly 安全性调研</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_6/rust-report.html">三万言｜2021 年 Rust 行业调研报告</a></li>
</ul>
<p><strong>四月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/improve-std-slice-binary-search.html">《优化 Rust 标准库的 binary_search》</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_async_os_opt.html">蚂蚁集团 | 异步化OS：利用 async/await 带来 10 倍性能提升</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/ant_trait.html">蚂蚁集团 | Trait 使用及实现分析</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/hw_bin_opt.html">华为 | Rust 编译后二进制大小和常用优化方式</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/tensorbase.html">开源产品 | TensorBase，基于Rust的现代化开源数据仓库</a></li>
</ul>
<p><strong>三月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<ul>
<li>《华为 | 基于 Rust 的下一代虚拟化平台 StratoVirt》</li>
<li>《华为 ｜ 基于 TVM Rust Runtime 和 WASM 沙箱运行 AI 模型》</li>
<li>《透过 Rust 探索系统本原 : 并发篇》</li>
<li>《蚂蚁集团 | Rust CPU Affinity 初探》</li>
<li>《Rust 中使用 MySql》</li>
</ul>
<p><strong>二月份比较受欢迎的文章 Top 5（按访问量依次排名）：</strong></p>
<p>注： 一月刊的 《图解 Rust 所有权》文章依旧最受欢迎，作者：肖猛 </p>
<ul>
<li>《 前端入门 ｜ Rust 和 WebAssembly》，作者: 陈鑫(lencx)</li>
<li>《 实践案例 | 使用 Bevy 游戏引擎制作炸弹人》，作者：Cupnfish</li>
<li>《 蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考 》， 作者：evenyag</li>
<li>《 华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景》，作者：俞一峻等三位</li>
<li>《 DatenLord ｜ Linux 全新异步接口 io_uring 的 Rust 生态盘点》，作者：施继成</li>
</ul>
<p>后续也期待大家投稿。欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！</p>
<h1><a class="header" href="#官方动态-1" id="官方动态-1">官方动态</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#rust-154-稳定版发布" id="rust-154-稳定版发布">Rust 1.54 稳定版发布</a></h2>
<p>Rust 1.54 更新的特性并不是很多，值得注意的是:</p>
<ol>
<li>增量编译功能又重新默认开启了。</li>
<li>在 ErrorKind 中 多了一个 OutOfMemory 类型。 </li>
</ol>
<p><a href="https://blog.rust-lang.org/2021/07/29/Rust-1.54.0.html">https://blog.rust-lang.org/2021/07/29/Rust-1.54.0.html</a></p>
<h2><a class="header" href="#taskready-宏将在-156-稳定" id="taskready-宏将在-156-稳定">task::ready! 宏将在 1.56 稳定</a></h2>
<p>futures-core 的 ready!() 宏存在好几年了，这个宏可以在处理 Future 的时候减少很多模板代码。</p>
<p>ready!() 宏稳定之后将会在 std::task 模块。</p>
<p><a href="https://github.com/rust-lang/rust/pull/81050">https://github.com/rust-lang/rust/pull/81050</a></p>
<h2><a class="header" href="#rust-2021-进入公开测试期" id="rust-2021-进入公开测试期">Rust 2021 进入公开测试期</a></h2>
<p>Rust 2021 版进入 公开测试期 。该版本的所有计划功能现在都可以在 nightly 版本中率先体验。同时还提供了方便的迁移办法，以便将代码从 Rust 2018 快速迁移到 Rust 2021 。</p>
<ul>
<li>安装最近的 nightly 工具链：<code>rustup update nightly</code> 。</li>
<li>运行 <code>cargo +nightly fix --edition</code> 。</li>
<li>编辑 <code>Cargo.toml</code> ，将 <code>cargo-features = [&quot;edition2021&quot;]</code> 置于顶部（位于 <code>[package]</code> 上方），并将 <code>edition</code> 改为 <code>edition = &quot;2021&quot; </code>。</li>
<li>运行 <code>cargo +nightly check</code> 以确认能否在新版本上正常工作。</li>
</ul>
<p>Datafuse 团队目前正在进行 Rust 2021 迁移的尝鲜体验，相关工作可以关注：<a href="https://github.com/datafuselabs/datafuse/pull/1159">https://github.com/datafuselabs/datafuse/pull/1159</a></p>
<p>Rust 2021 public testing period: <a href="https://blog.rust-lang.org/2021/07/21/Rust-2021-public-testing.html">https://blog.rust-lang.org/2021/07/21/Rust-2021-public-testing.html</a></p>
<p>the nightly version of Rust edition guide: <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2021/index.html">https://doc.rust-lang.org/nightly/edition-guide/rust-2021/index.html</a></p>
<h2><a class="header" href="#rustc_codegen_gcc-的-mcp-已经被接受" id="rustc_codegen_gcc-的-mcp-已经被接受">rustc_codegen_gcc 的 MCP 已经被接受</a></h2>
<p>在不久的将来，Rust 就会多一个 GCC 的后端。</p>
<p>同类项目还有 <a href="https://github.com/Rust-GCC/gccrs">GCC-rs </a>,GCC-rs  是 用 Cpp 重新实现 Rustc 的一个 GCC 前端。</p>
<p>为什么有 GCC-rs 这个项目？</p>
<ol>
<li>想要支持更多的 CPU 架构</li>
<li>跨语言 LTO。GCC-RS FAQ将Linux列为激励示例。 具有讽刺意味的是，Linux支持ltvm但不是gcc！</li>
<li>Rust 自举（Bootstrap）链很长，因为需要从C到OCAML，然后编译预发布 Rust 以编译 Rust 1.0编译 Rust 1.1 、1.2等，直到捕获最多1.53（或者最新版本）。 因此，如果您可以用C++中编写的 Rust 编译器直接编译1.53，则可以节省一些时间。</li>
<li>复用 GCC 插件</li>
</ol>
<p>但 <a href="https://github.com/antoyo/rustc_codegen_gcc">rustc_codegen_gcc</a>  作者认为 GCC-rs 其实没有很好的解决这些问题。</p>
<p>rustc_codegen_gcc 项目只需将GCC插入现有的Rust编译器作为代码生成后端，就可以简单的达成这些目标。</p>
<p>该项目的主要目标是能够在LLVM不支持的平台上编译 Rust 代码。 次要目标是检查使用GCC后端是否提供任何编译速度改进。</p>
<p>现在 rustc_codegen_gcc 已经被接受，gcc-rs 该何去何从？</p>
<p>相关阅读：<a href="https://zhuanlan.zhihu.com/p/387946955">Rust 与 开源 | GPL 许可证引发的问题</a></p>
<h2><a class="header" href="#gat-generic-associated-types-今年能否稳定-我看行" id="gat-generic-associated-types-今年能否稳定-我看行">GAT （generic associated types ）今年能否稳定？ 我看行。</a></h2>
<p>四天前，在 GAT tracking issues 下有人回复：</p>
<p>摘录</p>
<blockquote>
<p>我预计我们可能在10月份左右就能实现稳定化；但这确实取决于1-3个月的测试期。如果测试结束后相对来说没有错误，那么应该会很顺利。如果发现一些严重的错误、设计缺陷等，可能会推迟几个月，但这仍然为年底提供一些余地。</p>
</blockquote>
<p>鼓励大家来测试相关功能。</p>
<p>详细：<a href="https://github.com/rust-lang/rust/issues/44265#issuecomment-869888398">https://github.com/rust-lang/rust/issues/44265#issuecomment-869888398</a></p>
<h2><a class="header" href="#错误处理工作组工作进展报告" id="错误处理工作组工作进展报告">错误处理工作组工作进展报告</a></h2>
<p>官方错误处理工作组发布了一篇新文章，描述了当前错误处理需要解决的主要挑战：容易丢失上下文。</p>
<p>以下是一些摘要：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

// 需要加载一个配置文件，并且期望配置加载总是成功的。
fn main() {
    let _config = load_config()
        .expect(&quot;config is always valid and exists&quot;);
}

// 这里实现一个加载配置文件总是错误的样例，因为要展示错误诊断信息
fn load_config() -&gt; Result&lt;(), Error&gt; {
    Err(Error(SourceError))
}

// 我们有一个错误类型，只需打印“invalid config“
// 并且具有仅打印的源错误 &quot;config file does not exist&quot;
#[derive(Debug)]
struct Error(SourceError);

impl fmt::Display for Error {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.write_str(&quot;invalid config&quot;)
    }
}

impl std::error::Error for Error {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        Some(&amp;self.0)
    }
}

#[derive(Debug)]
struct SourceError;

impl fmt::Display for SourceError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.write_str(&quot;config file does not exist&quot;)
    }
}

impl std::error::Error for SourceError {}
</code></pre></pre>
<p>我们想要得到的错误信息如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo run
thread 'main' panicked at 'config is always valid and exists', src/main.rs:4:33

Error:
    0: invalid config
    1: config file does not exist

note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

<span class="boring">}
</span></code></pre></pre>
<p>通过这样的信息，我们可以看出程序退出是因为 panic 发生了。我们可以看出违反了 0 和 1 两种原因而导致了恐慌，并且能定位到恐慌发生的位置。</p>
<p>但是当前实际的输出是：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo run
thread 'main' panicked at 'config is always valid and exists: Error(SourceError)', main.rs:4:33
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
<span class="boring">}
</span></code></pre></pre>
<p>Rust的panic基础设施没有提供将Error类型转换为panic的方法，它只支持将Debug类型转换为panic，我们觉得这是一个大问题。同样的，语言也没有提供方便的工具来打印一个错误和它的所有源的错误信息。</p>
<p>当我们处理 Result 的时候：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let result = load_config();
    let _config = match result {
        Ok(config) =&gt; config,
        Err(error) =&gt; {
            println!(&quot;Error: {}&quot;, error);
            return;
        }
    };
}
</code></pre></pre>
<p>我们希望得到：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo run
Error: invalid config: config file does not exist
<span class="boring">}
</span></code></pre></pre>
<p>但实际输出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo run
Error: invalid config
<span class="boring">}
</span></code></pre></pre>
<p>默认情况下，源的所有错误信息都会丢失。这是因为我们用Display作为单个错误信息的接口。如果我们能回到过去，我们目前会建议在<code>Error trait</code>中加入<code>fn message(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result</code>，但现在这艘船已经起航了。</p>
<p>今天，库中解决这个问题的方法是滥用<code>Debug trait</code>。像<code>eyre</code>、<code>anyhow</code>这样的类型，甚至有时自定义的错误枚举也使用它们的<code>Debug</code>输出来打印人类可读报告中的全部错误链。</p>
<p>这样做的好处是使打印完整的错误报告变得容易，并且使<code>unwrap</code>、<code>expect</code>和从<code>main</code>返回都打印完整的错误报告。但这样做使我们无法访问错误的 Derive Debug格式，有可能隐藏了调试可能需要的内部细节，但这些细节并不是供用户阅读的错误信息的一部分。</p>
<p>错误处理的未来</p>
<p>最终，我们希望在Rust中进行错误处理时，你所使用的默认工具都能做正确的事情，并充分利用<code>Error trait</code>的设计。Unwrap 一个实现了<code>Error trait</code>的类型将保留原始的错误，作为一个动态的<code>Error</code>，然后可以在panic hook 中使用。打印一个完整的错误报告将是很容易做到的，而且很明显。有了这些变化，希望在报告错误时很难意外地丢弃信息。</p>
<p>要达成这个目标，需要有两步计划：</p>
<ol>
<li>
<p>集成 <code>Error Trait</code> 和 <code>Panic Runtime</code>。</p>
<p>a. 先将<code>Error trait</code>移至 <code>core</code>
b. 添加一个接口，用于从Error类型中创建一个panic，比如 <code>panic_error</code> 函数。类似于std中已经有的<code>panic_any</code>函数。这个函数将让panic处理程序通过<code>dyn Error</code>来访问错误。
c. 更新std提供的默认panic hook，通过Error trait 实际报告恐慌。它应该遍历来源并打印由错误本身捕获的回溯，如果有的话，或者可能自己捕获一个。
d. 最后，我们需要对<code>expect</code>和<code>unwrap</code>进行特殊处理，以便对实现了<code>Error trait</code>的类型 unwrap 时使用这些新的Error感知恐慌的接口。要做到这一点，我们首先需要解决一个健全性问题，即对基于寿命的条件的trait impls进行专业化处理，不过幸好我们已经有了一个<a href="https://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls">很好的解决方法</a>。</p>
</li>
<li>
<p>实现一个基础的错误报告工具。</p>
<p>我们不能完全达到这个目标，因为我们使用<code>Display</code>来处理单个错误信息，而且我们不能以向后兼容的方式来改变这一点，但我们希望增加一个方便的方法来打印完整的错误链和一些巧妙的行文，以减轻大部分的压力。</p>
<p>我们计划通过在标准库中添加一个<code>Report</code>类型来解决这个问题，该类型包装了一个<code>&amp;dyn Error</code>，并实现了<code>Display</code>，这样它就可以按要求打印每个源。我们希望<code>Report</code>的 <code>display </code>方法的输出能够支持Rust生态系统中最常见的错误串联的风格。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Error: {}&quot;, Report::from(error));

// Outputs:
// Error: outermost error: second error: root error

println!(&quot;Error: {:#}&quot;, Report::from(error))

// Outputs:
// Error: outermost error
//
// Caused by:
//    0: second error
//    1: root error

// report 方法大概像这样
fn report(&amp;self) -&gt; impl Display + '_
where
    Self: Sized,
{
    Report::from(self)
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>错误处理工作组最近创建了一个关于<a href="https://github.com/rust-lang/project-error-handling/issues/27#issuecomment-763950178">如何实现<code>Display::fmt</code>和<code>Error::source</code>的指导原则</a>。
这个建议只适用于作为库的API的一部分被暴露的错误类型。库或应用程序中的内部错误可以做任何他们想做的事情，但一旦他们需要被第三方用户集成到其他板块，重要的是错误要遵循一致的风格。。如果你对我们的理由感兴趣或有任何意见，请查看我们关于这个主题的github问题：<a href="https://github.com/rust-lang/project-error-handling/issues/27">Rust-lang/project-error-handling#27</a> 。</p>
</li>
</ol>
<p>这就是目前的计划，它不是我们想做的所有变化的完整计划，但我们认为这是最好的第一步。</p>
<blockquote>
<p>免责声明：这篇文章是计划和愿望的结合。这里有一些技术上的挑战需要解决，所以最终的结果可能与我们最初的设想有很大的不同，所以请不要认为这些都是最终结果。</p>
</blockquote>
<p><a href="https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html">https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html</a></p>
<h2><a class="header" href="#cargo-supply-chain-官方安全代码工作组发布的新工具" id="cargo-supply-chain-官方安全代码工作组发布的新工具">cargo-supply-chain: 官方安全代码工作组发布的新工具</a></h2>
<p>作用：</p>
<p>在依赖包关系图中收集作者、贡献者和发布者的crate数据。</p>
<p>使用场景：</p>
<ul>
<li>寻找值得支持的人和团体。</li>
<li>识别依赖关系图中的风险。</li>
<li>对所有你通过构建他们的软件而隐含信任的贡献者进行分析。这可能有清醒和谦卑的效果。</li>
</ul>
<p>cargo-supply-chain 自身也提供了一个输出样本： <a href="https://gist.github.com/Shnatsel/3b7f7d331d944bb75b2f363d4b5fb43d">publishers</a>, <a href="https://gist.github.com/Shnatsel/dc0ec81f6ad392b8967e8d3f2b1f5f80">crates</a>, <a href="https://gist.github.com/Shnatsel/511ad1f87528c450157ef9ad09984745">json</a>。</p>
<p>用法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo install cargo-supply-chain
<span class="boring">}
</span></code></pre></pre>
<p>该组织内还有另外一个工具：cargo-geiger。 可以检测crate 及其依赖关系中unsafe rust的用法。也可以 Rust 项目的安全检查比率。</p>
<p>相关链接：</p>
<ul>
<li><a href="https://www.rust-lang.org/governance/wgs/wg-secure-code">安全代码工作组官网</a></li>
<li><a href="https://github.com/rust-secure-code">安全代码工作组 GitHub 组织</a></li>
<li><a href="https://github.com/rust-secure-code/cargo-supply-chain">cargo-supply-chain</a></li>
<li><a href="https://github.com/rust-secure-code/cargo-geiger">cargo-geiger</a></li>
</ul>
<h2><a class="header" href="#让-rust-更快的解析-float类型-已被合并到-rust-core-库" id="让-rust-更快的解析-float类型-已被合并到-rust-core-库">让 Rust 更快的解析 float类型 已被合并到 Rust core 库</a></h2>
<p>作者两年前就提出了如何让 Rust 解析 float 更快更安全, 不过最近, 这些改变才合并到libcore.</p>
<p>这意味着, 当你解析大量的 float 类型时, 性能会得到非常夸张的提升.</p>
<p>例如:</p>
<ul>
<li>
<p>0.06,0.13,0.25,0.38,0.44,0.44,0.38,0.44,0.5,0.56 这样的数据大概会提升 2 倍.</p>
</li>
<li>
<p>-65.613616999999977,43.420273000000009,-65.619720000000029,43.418052999999986,-65.625,43.421379000000059 这样的数据大约会提升 10倍 性能.</p>
</li>
<li>
<p>8.988465674311580536566680e307 这种数据大概会提升1600~10,000倍的提升.</p>
</li>
<li>
<p><a href="https://github.com/rust-lang/rust/pull/86761">https://github.com/rust-lang/rust/pull/86761</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/2101.11408">相关算法论文</a></p>
</li>
</ul>
<h2><a class="header" href="#rfc-3128-io-safety" id="rfc-3128-io-safety">RFC 3128: I/O Safety</a></h2>
<p>Rust 现在已经有一个被采纳的 I/O 安全的 RFC. 该 RFC 用于处理 文件操作符和 sockets 等的生命周期. 这让编写底层安全的系统对象有了可能.</p>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md">https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md</a></p>
<h2><a class="header" href="#rustc_codegen_gcc-进展报告2" id="rustc_codegen_gcc-进展报告2">rustc_codegen_gcc 进展报告#2</a></h2>
<p>rustc_codegen_gcc 是 rustc 的 GCC 代码，这意味着它可以被现有的 rustc 前端加载，通过支持更多的架构和 GCC 的优化而受益于 GCC。</p>
<p>当前状态：Antoyo 手动实现了 popcount（因为 gcc 会产生一个对某些函数的调用，这在 no-std 中是行不通的）。除此之外，修复了一些东西，使之更容易在 godbolt 中添加这个 gcc 代码，并使 Antoyo 的这个PR合并到 rustc 中。</p>
<p>报告#2的详情参见 Antoyo 的博客链接，<a href="https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-2">https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-2</a></p>
<h1><a class="header" href="#社区热点-4" id="社区热点-4">社区热点</a></h1>
<p>编辑：张汉东 </p>
<hr />
<h2><a class="header" href="#rustchinaconf-2021-议题征集开放申请" id="rustchinaconf-2021-议题征集开放申请">RustChinaConf 2021 议题征集开放申请</a></h2>
<p><a href="chapter_7/./rust_china_conf_2021.html">申请通道详情</a></p>
<h2><a class="header" href="#为linux内核添加rust支持的最新补丁已经出现" id="为linux内核添加rust支持的最新补丁已经出现">为Linux内核添加Rust支持的最新补丁已经出现</a></h2>
<p>Miguel Ojeda一直在领导 &quot;Rust for Linux&quot;的工作--现在这个项目得到了Google的资助以使这种编程语言能够在内核中使用。虽然5.14内核合并窗口目前正在进行，但这并没有被标记为拉动请求阶段，估计要到下一个或者更晚的周期才会登陆。这是继4月份发出的 &quot;征求意见&quot;补丁之后的又一进展。</p>
<p>Rust for Linux的启用现在已经达到了33000多行代码，部分原因是他们目前在树中包括了Rust的 &quot;alloc&quot;标准库的一个子集，为内核目的进行了修改。最终，开发者们将尝试把变化放到上游的alloc crate中，但现在是在内核树中进行，其他需要的库也是在内核树中进行的。</p>
<p>这些新补丁的另一个变化是，之前的版本需要使用Rust编译器的每夜版本，而现在内核可以用beta和稳定版的Rustc编译。然而，内核支持确实需要一些Rust编译器的功能，目前被上游视为不稳定的来源。</p>
<p>除了AArch64、PowerPC和x86_64之外，ARM 32位和RISC-V体系现在也被Rust for Linux所支持。</p>
<p>除了Linux内核中的Rust管道外，Rust支持的最初用户是Rust中的Android Binder IPC实现，这仍被认为是一项正在进行的工作。</p>
<p>这些最新的Rust for Linux内核补丁可以在内核邮件列表中找到：</p>
<p><a href="https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/">https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/</a></p>
<p>此消息来自: <a href="https://www.cnbeta.com/articles/tech/1148741.htm">https://www.cnbeta.com/articles/tech/1148741.htm</a></p>
<h2><a class="header" href="#facebook-从-java-到-rust--buck-的未来" id="facebook-从-java-到-rust--buck-的未来">Facebook 从 Java 到 Rust | Buck 的未来</a></h2>
<p>Buck 是 Facebook 在 2013 年的Facebook Mobile DevCon上亮相的一个快速的 Android 构建系统。从那时起，它已经扩展到支持用15种以上的语言编写的应用程序，目标平台包括手机、服务器、智能设备和VR头盔等等。</p>
<p>不过，随着时间的推移，Buck并没有跟上这种功能和灵活性的增长，没有进行必要的架构改变和改进来管理这种复杂性。随着Facebook内部和外部开发新的功能，发现这导致了巨大的实施复杂性，对核心和语言规则进行修改的挑战越来越大。虽然该团队在近4年前就开始了一项举措，逐步对 Buck 进行一些这样的跨领域的架构改进，但这些改变是非常困难的。</p>
<p>所以，从2020年开始，该团队开始构思，如果从零开始构建 Buck 会怎么样？怎样才能写出一个可以在未来 10 年或 20 年中继续扩展的构建系统？</p>
<p>在考虑这次重写的同时，我们利用这个机会实验并验证了Rust作为构建系统的技术栈。Facebook对Rust编程语言的投资越来越大，许多项目都在使用它，并取得了巨大的成功。我们发现这种语言非常合适，原因有很多：</p>
<ol>
<li>Rust的<code>async/await</code>语法使得编写异步代码非常顺畅，而且Rust有助于正确处理复杂的并发性细节。Buck的Java计算向并发计算的每一次迁移都是一个长达数月的艰难过渡，而且那里仍然存在着明显的单线程瓶颈。</li>
<li>Rust有很多高级语言特性，使开发更容易，更愉快。这些都是像枚举、模式匹配、特质（trait）、过程宏和所有其他的功能，这些功能都受到 Rust开发者的广泛喜欢。</li>
<li>Rust对内存分配提供了更大的控制。GC语言（即便是分代收集）在处理像Buck这样的增量计算时也有挑战。</li>
<li>Rust是高性能的。我们已经看到了将一些程序用Rust重写后的显著加速。</li>
</ol>
<p>在接下来的几个月里，你可能会看到Buck的进展较少，但请放心，我们将继续努力为社区提供最好的构建系统。我们认识到，分享过程的一个重要部分是为Buck的用户定义一个平稳的过渡，并确保社区可以和我们一起前进。我们计划在2022年1月前公开这个方案，届时会有更多关于当前Buck用户过渡的细节。</p>
<p><a href="https://developers.facebook.com/blog/post/2021/07/01/future-of-buck">https://developers.facebook.com/blog/post/2021/07/01/future-of-buck</a></p>
<h2><a class="header" href="#知乎近期-rust-相关问题摘录" id="知乎近期-rust-相关问题摘录">知乎近期 Rust 相关问题摘录</a></h2>
<ul>
<li><a href="https://www.zhihu.com/question/451687128">2021年了，Rust在偏底层的某些领域是替代C++的一个好的选择吗？</a></li>
<li><a href="https://www.zhihu.com/question/447731745">相比Rust，现代C++有什么难度吗?</a></li>
<li><a href="https://www.zhihu.com/question/30407715">如何看待 Rust 的应用前景？</a></li>
<li><a href="https://www.zhihu.com/question/437987252">在2021 年，Rust 将会比 C++ 强在哪里？</a></li>
<li><a href="https://www.zhihu.com/question/463506409">Rust 的优点是什么？</a></li>
<li><a href="https://www.zhihu.com/question/390738348">就高频量化交易系统而言，据说rust作为主要面向安全的高性能计算编程语言，比c++要强，这个是真的吗？</a></li>
</ul>
<h2><a class="header" href="#rust--copilot-什么效果" id="rust--copilot-什么效果">Rust + Copilot 什么效果？</a></h2>
<p>近日 Discord 工程师尝试用 copilot 来辅助开发 Rust 项目。效果不是很好。</p>
<p>视频观看：<a href="https://t.me/rust_daily_news/4914">https://t.me/rust_daily_news/4914</a></p>
<h2><a class="header" href="#rust-gamedev-23" id="rust-gamedev-23">Rust GameDev #23</a></h2>
<p>这一期游戏开发报告中包含了一些很有创意的游戏。写 Rust 累了，可以玩一玩，都是开源的。</p>
<ol>
<li>吃尾蛇。支持wasm，可以网页玩耍。关卡设计的很有心。基于 bevy 0.5 实现。</li>
</ol>
<ul>
<li><a href="https://github.com/szunami/taileater/">https://github.com/szunami/taileater/</a></li>
<li><a href="https://szunami.itch.io/taileater">https://szunami.itch.io/taileater</a></li>
</ul>
<ol start="2">
<li>Egregoria，模拟城市建设者，试图复制现代社会以及尽可能复制。基于  Legion ecs 实现。</li>
</ol>
<p><a href="https://github.com/Uriopass/Egregoria">https://github.com/Uriopass/Egregoria</a></p>
<ol start="3">
<li>Blightmud ，是一款 命令行终端的 mud 客户端，可以支持很多 mud server，比如 bat.org 等。</li>
</ol>
<p><a href="https://github.com/Blightmud/Blightmud">https://github.com/Blightmud/Blightmud</a></p>
<ol start="4">
<li>Dango， 多人物理沙盒游戏。基于 bevy , Nphysics 物理引擎， CrystalObs 网络库等。Dango 目前在浏览器中基于wasm 运行 server，其他玩家通过 webrtc 加入。</li>
</ol>
<p><a href="https://github.com/ErnWong/dango-tribute">https://github.com/ErnWong/dango-tribute</a></p>
<ol start="5">
<li>hyper-farmer ： 基于bevy实现，游戏虽然简单但是挺有创意，锻炼双手协调</li>
</ol>
<ul>
<li><a href="https://wilsk.itch.io/hyper-farmer">https://wilsk.itch.io/hyper-farmer</a> 在线玩</li>
<li><a href="https://github.com/will-hart/cloud-surfer">https://github.com/will-hart/cloud-surfer </a></li>
</ul>
<ol start="6">
<li>fish-game，基于 macroquad 游戏引擎实现，支持wasm</li>
</ol>
<ul>
<li><a href="https://fedorgames.itch.io/fish-game">https://fedorgames.itch.io/fish-game</a> 在线玩</li>
<li><a href="https://github.com/heroiclabs/fishgame-macroquad">https://github.com/heroiclabs/fishgame-macroquad</a> 源码</li>
<li><a href="https://github.com/not-fl3/macroquad">https://github.com/not-fl3/macroquad</a> 游戏引擎</li>
</ul>
<p><a href="https://gamedev.rs/news/023/">https://gamedev.rs/news/023/</a></p>
<h2><a class="header" href="#cncf-又多了俩-rust-项目" id="cncf-又多了俩-rust-项目">CNCF 又多了俩 Rust 项目</a></h2>
<p>Good to see both wasmCloud and Krustlet submitted to the CNCF Sandbox at the same time:</p>
<ul>
<li>wasmCloud: <a href="https://github.com/cncf/toc/issues/693">https://github.com/cncf/toc/issues/693</a></li>
<li>Krustlet: <a href="https://github.com/cncf/toc/issues/690">https://github.com/cncf/toc/issues/690</a></li>
</ul>
<h2><a class="header" href="#zenoh-性能提升的故事-漫游在-rust-异步仙境" id="zenoh-性能提升的故事-漫游在-rust-异步仙境">Zenoh 性能提升的故事｜ 漫游在 Rust 异步仙境</a></h2>
<p>在 Rust Maginze 月刊第四期中介绍过 Zenoh :  <a href="chapter_7/%5Bhttps://rustmagazine.github.io/rust_magazine_2021/chapter_4/zenoh.html%5D(https://rustmagazine.github.io/rust_magazine_2021/chapter_4/zenoh.html)">开源产品 | eclipse zenoh 助力雾计算和边缘计算</a> </p>
<p>eclipse zenoh （读： /zeno/ ） ，提供了零开销的Pub/Sub、Store/Query 和 计算。</p>
<p>zenoh 统一了 动态/静止/使用中的数据并提供计算结果。它颇有分寸地将传统的Pub/Sub与地理分布的存储、查询和计算融合在一起，同时保留了远远超出任何主流协议栈的时间和空间效率水平。</p>
<p>官网是 zenoh.io 。</p>
<p>GitHub代码仓库 <code>eclipse-zenoh/zenoh</code> 。</p>
<p>2020 年 12 月 Eclipse Edge Native 工作组启动，并将 Zenoh 引入 Eclipse 。并用 Rust 对 zenoh 进行重写。</p>
<p>在本文中，Zenoh 团队剖析了他们如何改进让异步性能提升一倍。</p>
<ul>
<li>8字节payload 时超过3.5M msg/s</li>
<li>1Mb payload 时超过 45Gb/s</li>
<li>在 backlogged 场景下，延迟低至 35 微秒</li>
</ul>
<p>该团队如何做到的呢？</p>
<p>一：准备工作</p>
<ol>
<li>准备测试环境，以便获得可复现的结果。因为很多外部因素可能会影响代码性能，这是为了排除这些干扰。这有个非常棒的指南：https://easyperf.net/blog/2019/08/02/Perf-measurement-environment-on-Linux</li>
<li>彻底阅读 <a href="https://nnethercote.github.io/perf-book/title-page.html">《Rust 性能手册》</a>。我们发现它对Rust的性能技巧和诀窍以及剖析技术都很有见地。另外，还有一篇关于<a href="http://likebike.com/posts/How_To_Write_Fast_Rust_Code.html">如何在Rust中编写高性能代码</a>的博客也是不错的参考。</li>
</ol>
<p>二：寻找性能热点（hotspots）</p>
<ol>
<li>我们先使用 <a href="https://github.com/flamegraph-rs/flamegraph">flamegraph</a> 来生成火焰图，打算寻找 zenoh 中的异步性能热点。然而，异步使得火焰图相当难以阅读，因为异步调度器和future执行器基本上出现在火焰图中每一个地方。所以改变了性能剖析工具，开始使用 <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> ，可以提供更清晰的热点图，尤其是序列化和反序列化方面。</li>
<li>改进了序列化/反序列化相关实现，性能直接提升 100% 。但是这种改进在吞吐量测试中没有反映出来。</li>
</ol>
<p>三： 堆分配还是栈分配？</p>
<p>zenoh 团队 一直避免在关键环节进行堆分配。用 valgrind 仔细检查后发现，并没有不必要的堆分配，缓存未命中率也不高。因此该团队开始检查 栈分配的问题，利用 Rust 编译器的一个 flag （仅在 Rust Nightly 可用）来验证一个数据结构多大以及它的内存对齐方式。</p>
<p>rust
$ RUSTFLAGS=-Zprint-type-sizes cargo build --release
用这种方式来编译 zenoh 即可。输出：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print-type-size type: `net::protocol::proto::msg::Data`: 304 bytes, alignment: 8 bytes
print-type-size     field `.key`: 40 bytes
print-type-size     field `.data_info`: 168 bytes
print-type-size     field `.payload`: 96 bytes
<span class="boring">}
</span></code></pre></pre>
<p>异步数据结构也会这样打印出来。然后该团队发现了一个痛苦的事实：</p>
<ol>
<li>异步 future，一旦被编译，就会在栈中占用几十 KB 的空间。每次有消息需要通过网络发送，就会调用这些 futures。</li>
<li>因为zenoh广泛使用异步，所以现在导致 栈太深太大，给内存带来很大压力。</li>
<li>经过思考，该团队将 异步代码隔离在特定的部分，尤其是网络交互部分，而其他部分则转为使用同步。由此来平衡 同步和异步，汲取了两个世界的优点。大幅减少了栈内存的压力，带了巨大的性能提升。</li>
</ol>
<p>四： 性能测试结果</p>
<p>该团队性能测试环境为：AMD Ryzen 5800x，32GB内存，通过100Gb以太网连接，根据前面所说的性能测试环境配置指南配置好。</p>
<p>具体的性能测试图表，可以进一步查看文章。也可以关注 zenoh 团队的博客，因为他们性能优化还会继续。</p>
<p><a href="https://zenoh.io/blog/2021-07-13-zenoh-performance-async/">https://zenoh.io/blog/2021-07-13-zenoh-performance-async/</a></p>
<h2><a class="header" href="#清华90后校友mit助理教授范楚楚获acm博士论文奖rust社区ralf-jung荣誉提名" id="清华90后校友mit助理教授范楚楚获acm博士论文奖rust社区ralf-jung荣誉提名">清华90后校友、MIT助理教授范楚楚获ACM博士论文奖，Rust社区Ralf Jung荣誉提名</a></h2>
<p>Ralf Jung 的博士论文为《Understanding and Evolving the Rust Programming Language (https://people.mpi-sws.org/~jung/phd/thesis-screen.pdf)》</p>
<p>RalfJung 研究的这个，是对  Safe Rust 安全模型做了形式化验证，也为 Unsafe Rust UB 检查建立了模型。实至名归。</p>
<p><a href="https://mp.weixin.qq.com/s/wkjexOyXXpEC-nYEWxpkWQ">https://mp.weixin.qq.com/s/wkjexOyXXpEC-nYEWxpkWQ</a></p>
<h2><a class="header" href="#tokio-支持-io-uring" id="tokio-支持-io-uring">Tokio 支持 io-uring</a></h2>
<p>Tokio 为 Linux 上的 io-uring 系统 API 提供支持。此版本提供异步文件操作，将在后续版本中添加对更多操作的支持。</p>
<p>tokio-uring API可能构成Tokio 2.0版本的基础，2024 年 可能会发布 tokio 2.0 ，然后集成这个库。</p>
<p><a href="https://tokio.rs/blog/2021-07-tokio-uring">https://tokio.rs/blog/2021-07-tokio-uring</a></p>
<h2><a class="header" href="#同一功能实现下-rust-vs-elixir-代码量比较-案例--ockam" id="同一功能实现下-rust-vs-elixir-代码量比较-案例--ockam">同一功能实现下 Rust vs Elixir 代码量比较 案例 : Ockam</a></h2>
<p>Ockam 是一套 用于相互身份验证和分布式应用程序之间的端到端加密消息的工具。 目前提供 Rust 和 Elixir 两种实现。</p>
<p>从 Rust  和 Elixir 的比例来看:</p>
<ul>
<li>Rust 69.3%</li>
<li>Elixir 30.7%</li>
</ul>
<p>因为是同一种功能特性实现（Rust 比 Elixir 多两个特性实现），但是否可以从 代码量得出开发效率 elixir 是 Rust  的两倍呢？ </p>
<p>我认为不尽然。也需要看场景。 这个项目设计到分布式消息通信，这方面因为elixir 的默认支持 的生产力可能更高。 而 Rust 可能还需要多做一些基础工作。 </p>
<p>这就好比，很多人说 rust 编译helloworld比 c 的大，但其实 c 的一些基础库操作系统都是默认支持的，不需要另外携带，rust 则需要。</p>
<p><a href="https://github.com/ockam-network/ockam">https://github.com/ockam-network/ockam</a></p>
<h2><a class="header" href="#cncf宣布linkerd毕业" id="cncf宣布linkerd毕业">CNCF宣布Linkerd毕业</a></h2>
<p>Linkerd 是第一个加入 CNCF 沙箱的项目，沙箱当时被称为 inception，现在是第一个获得毕业地位的服务网格项目。</p>
<p>Linkerd 创始人、Buoyant 首席技术官 Oliver Gould 说。“我们的使命是为服务网格领域带来简单性和用户同理心，我们不得不孜孜不倦地努力消除普遍认为服务网格复杂而笨重的说法。虽然我们做出了有争议的技术决策——采用 Rust 而不是 C++，构建特定于服务网格的'微代理'而不是使用通用代理，专注于 Kubernetes 而不是构建抽象层——这些决策已经得到验证，而我们的全球运营者社区再次对这一愿景下注。”</p>
<ul>
<li><a href="https://linkerd.io/2021/07/28/announcing-cncf-graduation/">https://linkerd.io/2021/07/28/announcing-cncf-graduation/</a></li>
<li>中文 <a href="https://mp.weixin.qq.com/s/P5dQjVe0jidguNhZ0KzGTg">https://mp.weixin.qq.com/s/P5dQjVe0jidguNhZ0KzGTg</a></li>
<li><a href="https://linkerd.io/">https://linkerd.io/</a></li>
</ul>
<h2><a class="header" href="#rust-search-extension-130-rc-版发布" id="rust-search-extension-130-rc-版发布">Rust Search Extension 1.3.0-rc 版发布！</a></h2>
<p>想提前体验的朋友欢迎在这个页面下载并帮忙测测，如果没啥 bug 了周末就正式发布！</p>
<ul>
<li><a href="https://github.com/huhu/rust-search-extension/wiki/V1.3.0-Release-Candidate-(zh_CN)">https://github.com/huhu/rust-search-extension/wiki/V1.3.0-Release-Candidate-(zh_CN) </a></li>
<li><a href="https://rust.extension.sh/changelog/">https://rust.extension.sh/changelog/</a></li>
</ul>
<h2><a class="header" href="#arti-一个纯rust实现的tor" id="arti-一个纯rust实现的tor">Arti: 一个纯Rust实现的Tor</a></h2>
<p>今天，我很高兴地宣布 Tor 的新时代实现。</p>
<p>在过去一年左右的时间里，我们一直致力于“Arti”，这是一个用 Rust 重写 Tor 的项目。感谢 Zcash Open Major Grants (ZOMG) 的资助，我们终于可以将 Arti 项目列入我们的优先事项列表，并投入更多时间。</p>
<p>下面我将谈谈我们为什么要做这个项目，它对 Tor 用户和运营商意味着什么，它的未来发展方向，以及人们可以如何提供帮助。</p>
<ul>
<li><a href="https://blog.torproject.org/announcing-arti">https://blog.torproject.org/announcing-arti</a> </li>
<li><a href="https://gitlab.torproject.org/tpo/core/arti/">https://gitlab.torproject.org/tpo/core/arti/</a></li>
</ul>
<h2><a class="header" href="#scott-mabin-全职加入-乐鑫科技" id="scott-mabin-全职加入-乐鑫科技">Scott Mabin 全职加入 乐鑫科技</a></h2>
<p>Scott Mabin 全职加入 Espressif，将为其所有芯片提供 Rust 支持，改善其芯片的 Rust 生态系统。</p>
<p>乐鑫科技（股票代码：688018）是一家全球化的无晶圆厂半导体公司，成立于2008 年，在中国、捷克、印度、新加坡和巴西均设有办公地，团队来自20 多个国家和地区。</p>
<p>组织</p>
<p>支持esp的分叉编译器已经被移到 esp-rs组织中，同时还有一些idf支持板块--很快就会有更多的内容。在esp-rs/rust资源库中的讨论已经开始，在过去的一个月中，Espressif每周都会举办社区会议，重点是推动Rust支持的发展。</p>
<p>Espressif芯片上的Rust标准库</p>
<p>@ivmarkov 一直在努力将Rust STD库移植到esp-idf上，esp-idf是Espressif芯片的基于C的开发环境，esp-idf有一个newlib环境，可以用来构建Rust库。@ivmarkov把rust-esp32-std-hello演示版本放在一起，以展示其功能，其中包括WiFi、线程和使用esp-idf的驱动来驱动显示器。非常酷的东西! 有一些初期的问题，你可以在这里追踪，但希望我们很快就能开始向上游提供这些补丁。</p>
<p>为了补充Espressif芯片的标准库，esp-idf-hal已经被更新并移到esp-rs组织中。这个 crate 有API来使用标准库中没有抽象的外围设备和硬件，例如SPI外围设备。与HAL一起，esp-idf-svc也被加入，它是Espressif芯片的嵌入式svc特性的实现。embedded-svc背后的目标是提供围绕更高级别的嵌入式服务的抽象，WiFi、Ping、HTTPD、NVS等。</p>
<p><a href="https://mabez.dev/blog/posts/esp-rust-espressif/">https://mabez.dev/blog/posts/esp-rust-espressif/</a></p>
<h2><a class="header" href="#lemmy-发布-v0113" id="lemmy-发布-v0113">Lemmy 发布 v0.11.3</a></h2>
<p>Lemmy 类似于Reddit、Hacker News等网站。你订阅你感兴趣的论坛，发布链接和讨论，然后投票，并对其进行评论。在背后它却是非常不同的；任何人都可以很容易地运行一个服务器，所有这些服务器是联合的（类似电子邮件），并连接到同一个宇宙，称为Fediverse。对于一个链接聚合器来说，这意味着在一个服务器上注册的用户可以订阅任何其他服务器上的论坛，并可以与其他地方注册的用户进行讨论。</p>
<p>总体目标是创建一个容易自主托管的、分散的替代Reddit和其他链接聚合器的网站，不受公司控制和干涉。</p>
<ul>
<li><a href="https://github.com/LemmyNet/lemmy">https://github.com/LemmyNet/lemmy</a></li>
<li><a href="https://lemmy.ml/post/75818">https://lemmy.ml/post/75818</a></li>
</ul>
<h1><a class="header" href="#活动回顾-3" id="活动回顾-3">活动回顾</a></h1>
<p>后期编辑：张汉东</p>
<blockquote>
<p>编者按：</p>
<p>总结了本月的活动，包括线上和线下。</p>
<p>线上： 《Rust 唠嗑室》和 《RustFriday 飞书群线上沙龙》</p>
</blockquote>
<hr />
<h1><a class="header" href="#活动预告" id="活动预告">活动预告：</a></h1>
<h2><a class="header" href="#20210808-杭州线下-meetup" id="20210808-杭州线下-meetup">2021.08.08 杭州线下 Meetup</a></h2>
<p><img src="chapter_7/./image/event/hz_rustmeetup.jpg" alt="" /></p>
<h2><a class="header" href="#公开课认识面向基础架构语言rust" id="公开课认识面向基础架构语言rust">公开课：认识面向基础架构语言Rust</a></h2>
<p>Rust究竟是一门怎样的语言? 为什么连续五年夺得”最受程序员喜爱的编程语言”称号。我们有幸邀请到Rust中文社区的苏林老师分享一下:</p>
<p>课程主题：《认识面向基础架构语言Rust》</p>
<p>课程时间： 2021年8月1日 20:30-21:30</p>
<p>课程内容：</p>
<ul>
<li>Rust语言设计思想</li>
<li>Rust语言现状和未来</li>
<li>通过一个hello word理解Rust语言如何执行</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/z-L33EyR7qac8KUlSxUFlA">https://mp.weixin.qq.com/s/z-L33EyR7qac8KUlSxUFlA</a></p>
<hr />
<h1><a class="header" href="#线上rust-唠嗑室本月汇总-3" id="线上rust-唠嗑室本月汇总-3">【线上】Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598/video">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
<li>后期编辑：高宪凤</li>
</ul>
<h3><a class="header" href="#rust-唠嗑室第28期---对rust标准库的扩展实现技术分享" id="rust-唠嗑室第28期---对rust标准库的扩展实现技术分享">《Rust 唠嗑室》第28期 - 对Rust标准库的扩展实现技术分享</a></h3>
<p><strong>时间</strong>: 2021/07/06 20:30-21:30</p>
<p><strong>主讲人</strong>：Arch</p>
<p><strong>题目</strong>：hzqd 的小工具箱</p>
<p><strong>内容</strong>： Kotlin 标准库的 Rust 实现，和其他一些小玩意儿。对Rust标准库的扩展实现技术分享。</p>
<p>参考资料：</p>
<ol>
<li>https://crates.io/crates/tap</li>
<li>https://github.com/hzqd/aoko</li>
<li>https://github.com/tokio-rs/bytes</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1Sw411R7s6">查看回放</a></p>
<hr />
<h3><a class="header" href="#rust-唠嗑室第29期---rust-no_std的库开发经验分享" id="rust-唠嗑室第29期---rust-no_std的库开发经验分享">《Rust 唠嗑室》第29期 - rust no_std的库开发经验分享</a></h3>
<p><strong>时间</strong>: 2021/07/20 20:30-21:30</p>
<p><strong>主讲人</strong>：DaviRain</p>
<p><strong>题目</strong>：rust no_std的库开发经验分享</p>
<p><strong>内容</strong>：</p>
<ul>
<li>
<p>首先简单介绍std和no_std的区别</p>
</li>
<li>
<p>然后介绍使用no_std库方式， 由于支持no_std的特性有两种不同的方式，因此使用no_std库也有两种方式。</p>
<ul>
<li>如何验证一个库是否支持no_std特性的验证方式</li>
<li>如何改写一个std库为支持std和no_std的特性的方法。</li>
</ul>
</li>
<li>
<p>其它：</p>
<ul>
<li>具体的如何写一个支持std和no_std的库。</li>
<li>一些在std和no_std下都可以使用的primitive的仓库和相关的资源和文章。</li>
</ul>
</li>
</ul>
<p>参考资料：</p>
<ol>
<li>https://github.com/DaviRain-Su/rust-no-std-source</li>
<li>https://github.com/confio/ics23</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV11o4y1D7RZ">查看回放</a></p>
<hr />
<center> 🔥🔥🔥🔥 <strong>RustFriday 飞书群线上沙龙</strong> 🔥🔥🔥🔥 </center>
<h1><a class="header" href="#线上rustfriday-飞书群线上沙龙-3" id="线上rustfriday-飞书群线上沙龙-3">【线上】RustFriday 飞书群线上沙龙</a></h1>
<p>每周五晚八点，限定两个主题：语言特性和开源项目，在线讨论。</p>
<p>Rust 中文社群 飞书群 邀请你加入：</p>
<p>对话群： <a href="https://applink.feishu.cn/TeLAcbDR">https://applink.feishu.cn/TeLAcbDR</a></p>
<p>话题群：<a href="https://applink.feishu.cn/TeLD868w">https://applink.feishu.cn/TeLD868w</a></p>
<p>视频来源：<a href="https://space.bilibili.com/24917186">https://space.bilibili.com/24917186</a></p>
<h2><a class="header" href="#第十三期-讨论主题如何在面试中考察一个人-rust-水平" id="第十三期-讨论主题如何在面试中考察一个人-rust-水平">第十三期 讨论主题：如何在面试中考察一个人 Rust 水平？</a></h2>
<ol>
<li>如何面试/或准备应聘一场 Rust 面试。</li>
<li>实际面试经验分享 （@ huangjj ）</li>
<li>vscode + ra 使用小技巧分享 。</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1ZV411p7Y3">查看回放</a></p>
<h2><a class="header" href="#第十四期" id="第十四期">第十四期：</a></h2>
<p>分享者：吴翱翔</p>
<p>【讨论主题】</p>
<ol>
<li>Rust 消息队列实现多房间号的聊天室应用(视频长度 26 分钟)</li>
<li>Rust 运行时动态加载配置文件和软中断(视频长度 17 分钟)</li>
</ol>
<p>【回放】</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1w64y1t7PQ/">视频一</a></li>
<li><a href="https://www.bilibili.com/video/BV1Jw41197Rd/">视频二</a></li>
</ul>
<h2><a class="header" href="#第十五期-讨论主题了解-rust-analyzer-原理-part-1" id="第十五期-讨论主题了解-rust-analyzer-原理-part-1">第十五期 讨论主题：了解 rust-analyzer 原理 Part 1</a></h2>
<ol>
<li>这系列视频是 ra 作者为贡献者或潜在贡献者录制的</li>
<li>第一集展示了 ra 源码仓库的代码组织结构，从项目文档开始，逐步介绍了 cargo xtask 的使用，虽然采用扁平的 crate 结构，但也分主要的几个入口库 （ide/ hir 等），还看到了处理过程宏和声明宏相关的crate，还有 vfs（虚拟文件系统）等。</li>
<li>还展示了一些可能的贡献点：</li>
</ol>
<ul>
<li>bench 测试目录下有一个很大的 8500 行 代码的文件，需要分隔成多个小文件</li>
<li>指定了 code style，然后接下来会根据code style 进行代码重构</li>
<li>对标准库扩展的库中，可能需要添加一些文档</li>
<li>帮忙增加 fuzz 测试等等。</li>
</ul>
<p>参考资料：</p>
<ol>
<li>https://github.com/rust-analyzer/rust-analyzer</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1wg411772D">查看回放</a></p>
<h2><a class="header" href="#第十六期-讨论主题了解-rust-analyzer-原理-part-2" id="第十六期-讨论主题了解-rust-analyzer-原理-part-2">第十六期 讨论主题：了解 rust-analyzer 原理 Part 2</a></h2>
<p>【主题】 </p>
<ol>
<li>Rust 1.54 特性 </li>
<li>学习 LSP-language-server-protocol规范 ，然后跟随 rust-analyzer 作者学习 rust-analyzer 原理 （part 2）</li>
</ol>
<p>【总结】</p>
<ol>
<li>Rust 1.54 更新的特性并不是很多，值得注意的是，增量编译功能又重新默认开启了。并且在 ErrorKind 中 多了一个 OutOfMemory 类型。 </li>
<li>RustAnalyzer 学习心得：</li>
</ol>
<ul>
<li>ra 为什么需要虚拟文件系统？ 主要有三点原因：
<ul>
<li>为了重复使用文件，以及优化内存。所以不可能使用  std::fs::read_to_string 这样的方式去读取文件。有虚拟文件系统就方便多了。</li>
<li>需要兼容多平台文件系统和路径。比如 windows 路径和linux路径有很大差异，需要统一抽象。</li>
<li>需要平台无关的 绝对路径和相对路径的 控制转换。 </li>
</ul>
</li>
<li>ra 的虚拟文件系统（vfs）只是一种快照系统，它只需要获取文件什么时候修改，哪里修改即可，不需要知道具体修改什么内容。类似于 git。</li>
<li>代码架构比较常规，比如通过对象安全的 Hander trait  来提供统一接口，用于监控文件。也针对 每个 crate 提供一个对应的 FileSet 来管理文件，就好像是 文件系统分区的概念。</li>
<li>vfs 是 ra 数据流动的基础。 如果你对 实现一个简易且健壮的文件系统比较感兴趣，可以看看 vfs 的实现。</li>
<li>ra 作者强烈推荐了这个库 ： https://crates.io/crates/fst 。</li>
</ul>
<p>【回放】</p>
<p><a href="https://www.bilibili.com/video/BV1jL411n7e3/">https://www.bilibili.com/video/BV1jL411n7e3/</a></p>
<hr />
<center> 🔥🔥🔥🔥 <strong>北京-Rust区块链开发者活动现场实录-20210619</strong> 🔥🔥🔥🔥 </center>
<p>视频集地址：<a href="https://www.bilibili.com/video/BV1Jh411h7pp">https://www.bilibili.com/video/BV1Jh411h7pp</a></p>
<h1><a class="header" href="#rust异步编程原理及其在starcoin中实践" id="rust异步编程原理及其在starcoin中实践">Rust异步编程原理及其在Starcoin中实践</a></h1>
<p><strong>演讲者</strong>：方圆</p>
<p>参考资料：</p>
<ol>
<li>https://starcoin.org</li>
<li>https://github.com/starcoinorg</li>
</ol>
<h1><a class="header" href="#web30时代背景下rust的机遇" id="web30时代背景下rust的机遇">Web3.0时代背景下Rust的机遇</a></h1>
<p><strong>演讲者</strong>：Mike</p>
<p>Web3.0时代背景下，Rust的机遇</p>
<p>WebAssembly</p>
<ul>
<li>Serverless 边缘计算</li>
<li>链上代码</li>
<li>浏览器中运行UI</li>
</ul>
<p>Web3.0 框架</p>
<p>参考资料：</p>
<ol>
<li>https://rustcc.cn/article?id=289da7be-19ce-49fe-af6d-3a7946404ca6</li>
<li>https://www.chainnews.com/articles/601126700329.htm</li>
</ol>
<h1><a class="header" href="#谈谈ckb的同步优化" id="谈谈ckb的同步优化">谈谈CKB的同步优化</a></h1>
<p><strong>演讲者</strong>：罗超</p>
<p>CKB上线前4个月遇到重大问题优化思路和优化方案。</p>
<h1><a class="header" href="#用-rust-语言开发可扩展和隐私保护服务" id="用-rust-语言开发可扩展和隐私保护服务">用 Rust 语言开发可扩展和隐私保护服务</a></h1>
<p><strong>演讲者</strong>：Jamie</p>
<h1><a class="header" href="#用rust写evmewasm合约" id="用rust写evmewasm合约">用Rust写EVM.Ewasm合约</a></h1>
<p><strong>演讲者</strong>：Antonio</p>
<p>参考资料：</p>
<ol>
<li>https://github.com/WasmEdge/WasmEdge</li>
</ol>
<h1><a class="header" href="#rust-与零知识证明" id="rust-与零知识证明">Rust 与零知识证明</a></h1>
<p><strong>演讲者</strong>：张烨</p>
<p>参考资料：</p>
<ol>
<li>https://github.com/veorq/cryptocoding</li>
</ol>
<h1><a class="header" href="#rust-在substrate开发框架中的使用" id="rust-在substrate开发框架中的使用">Rust 在Substrate开发框架中的使用</a></h1>
<p><strong>演讲者</strong>：王大锤</p>
<h1><a class="header" href="#圆桌1-rust编程语言应用前景" id="圆桌1-rust编程语言应用前景">圆桌1-Rust编程语言应用前景</a></h1>
<p>Rust 独特的地方：</p>
<ol>
<li>内存管理机制，在编译进做代码检查；</li>
<li>所有权和生命周期机制，保证内存安全；</li>
<li>后云计算时代会使用WebAssembly，WebAssembly与Rust紧密相关；</li>
<li>Rust是最适合区块链开发的语言；
......</li>
</ol>
<h1><a class="header" href="#圆桌2-rust区块链开发实践漫谈" id="圆桌2-rust区块链开发实践漫谈">圆桌2-Rust区块链开发实践漫谈</a></h1>
<p>问题1：如何与Rust结缘？</p>
<ul>
<li>因工作结缘</li>
<li>因解决实际问题结缘</li>
</ul>
<p>问题2：开发者放弃Rust语言的原因是什么？新手如何克服困难？</p>
<ul>
<li>计算机基础知识欠缺</li>
<li>习惯于高级语言，不习惯底层算法与逻辑，不愿意改变</li>
</ul>
<p>问题3：Rust安全性是如何实现的？</p>
<ul>
<li>所有权机制，没有空指针</li>
</ul>
<p>问题4：项目由C++转向Rust，项目在迁移过程中有什么需要注意的？</p>
<ul>
<li>Rust 基于社区语言，参与度很强，通过交流不断学习</li>
<li>对Rust有全局认识，减少学习成本</li>
</ul>
<h1><a class="header" href="#本月招聘-3" id="本月招聘-3">本月招聘</a></h1>
<h2><a class="header" href="#招聘second-state--rust-webassembly-工程师开发者布道师" id="招聘second-state--rust-webassembly-工程师开发者布道师">【招聘】Second State ｜ Rust-WebAssembly 工程师/开发者布道师</a></h2>
<p>Second State 于2019年成立，专注云计算与边缘计算的开源软件。我们的开源产品 WasmEdge， 目前已被 Linux 基金会旗下的 CNCF 接受为沙箱项目。</p>
<ul>
<li>WasmEdge 源代码：<a href="https://github.com/WasmEdge/WasmEdge">https://github.com/WasmEdge/WasmEdge</a></li>
<li>其他项目代码：<a href="https://github.com/second-state">https://github.com/second-state</a></li>
</ul>
<p>Second State 目前已经获得 SIG(海纳亚洲) 、奇绩创坛（YC中国）的投资。Marc Fleury 博士与陆奇博士是我们的顾问。我们目前已经与头部云厂商、头部区块链项目建立了密切的合作关系，现金流为正。</p>
<p>我们希望能够打造一支国际化团队，目前团队分布在台北、北京、美国、与澳洲。这其中工程师占比90%，绝大多数是名校硕士以上学历。我们在北京与台北有研发中心。</p>
<p>20年前，我们经历了 Java 从浏览器端到服务端的转变。10年前，我们经历了 JavaScript 从浏览器到服务端的转变。现在，我们想邀请您一起见证 WebAssembly 从浏览器到服务端的过程，共同构建下一代的开源基础设施软件。</p>
<p>我们正在期待一位 Rust-WebAssembly 工程师/开发者布道师加入：</p>
<ol>
<li>熟悉 Rust/C++ 与 WebAssembly，或者愿意学习 Rust</li>
<li>热爱分享，技术输出是一大乐趣</li>
<li>具有探索和创新精神，WasmEdge 根据实际场景的需求，希望能够尽快推动落地 WebAssembly</li>
<li>能够自觉主动地完成工作</li>
<li>英文水平过关</li>
</ol>
<p>以下是加分项</p>
<ol>
<li>有自己的技术输出平台，比如 blog、微信公众号、B站</li>
<li>有开源项目工作经验或是开源贡献经历</li>
</ol>
<p>工作职责：</p>
<ol>
<li>编写 Rust SDK 与 WasmEdge （此部分可根据个人经历自由选择）</li>
<li>WasmEdge 社区增长与活跃</li>
<li>撰写 WasmEdge 文档及使用案例</li>
<li>积极参与线上/线下社区活动，布道 Rust、 WebAssembly/WasmEdge</li>
<li>探索新技术与 WasmEdge 的合作场景及案例</li>
</ol>
<p>我们可以提供：</p>
<ol>
<li>具有竞争力的薪酬+期权，六险一金</li>
<li>自由灵活的办公时间，可以选择远程办公</li>
<li>国际化团队氛围</li>
<li>顶级开源基金会平台</li>
</ol>
<p>工作氛围轻松，结果导向，只要你有意愿与能力，可以独立掌控项目
全职、实习均可。</p>
<p>联系方式：vivian@secondstate.io 或添加微信 h0923xw</p>
<p>加入 Second State，一起建立下一代开源基础设施吧。</p>
<h2><a class="header" href="#北京中关村远程tensorbase开源数据仓库等一群人做一件事-1" id="北京中关村远程tensorbase开源数据仓库等一群人做一件事-1">[北京中关村/远程][TensorBase][开源数据仓库]等一群人，做一件事</a></h2>
<p><a href="https://github.com/tensorbase/tensorbase">TensorBase</a>，基于Rust的现代化开源实时数据仓库。它专注于开源大数据存储和分析的基础设施，让大数据背后的价值可以惠及这个时代中每个个体和企业。</p>
<p>团队介绍：我本人的<a href="https://jinmingjian.xyz/resume/">简介在这里</a>。TensorBase已获陆奇博士旗下奇绩创坛（原YC中国）的种子轮投资，陆奇博士就是我们的合伙人！</p>
<p>开源，惠人达己。创新，守正出奇。基础设施的未来，必定是开源和创新的。目前TensorBase有很好的社区和成果，ClickHouse的核心领导人Alexey Milovidov给TensorBase提交了PR，中国的开源数据基础设施项目首次赢得了国外开源数仓领袖的敬意，我们可以骄傲！</p>
<p>我有一个梦想：和一群中国工程师一起相互帮助、探索和努力，做一件可以走在这个时代的最前沿，还可以让自己成长、开心和骄傲的事情。我等这样一群人：</p>
<ol>
<li>愿意使用Rust语言，并贡献到Rust开源社区（希望你不要把语言当作一个工具，虽然客观上它确是一个工具）。</li>
<li>有创新和探索精神，愿意在无人区工作。</li>
</ol>
<ul>
<li>内核向：对数据工程、高性能系统、高性能计算、编译器、Linux内核、分布式、并发、网络协议等一个或者多个领域有实践或有兴趣。</li>
<li>社区向：对Rust/数据有兴趣的前端或Technical writer。</li>
</ul>
<ol start="3">
<li>爱做TensorBase这样一件事情，爱和TensorBase这样一群人一起工作。</li>
</ol>
<p>全职、实习均可，但实习生需要onsite。</p>
<p>对比大厂，提供有竞争力的薪酬 + 期权。</p>
<p>联系方式：</p>
<p>邮箱： <strong>hr@tensorbase.io</strong></p>
<p>工作地点：</p>
<p>海淀区中关村。这里离好几个新近的开源创业团队都很近，比如太极图形。这里是中国开源创业的新硅谷。不加班，希望大家早睡早起，我邀请大家一起去边上的海淀公园晨跑，为家国健康工作50年。同时，对于合适的同学，可以远程工作。</p>
<p>加入我们，一起创造TensorBase的下一个五年！ </p>
<h2><a class="header" href="#datafuse--数据库rust讲师-1" id="datafuse--数据库rust讲师-1">Datafuse | 数据库Rust讲师</a></h2>
<blockquote>
<p>Datafuse是使用Rust构建的完全面向云架构的新一代开源数仓，目的为用户提供更高性能，更低成本、更加易用的数据分析服务。</p>
<p>Datafuse项目地址： <a href="https://github.com/datafuselabs/datafuse">https://github.com/datafuselabs/datafuse</a></p>
</blockquote>
<p>简历发送： <strong>hr @ datafuselabs.com</strong></p>
<p><strong>职位诱惑：</strong></p>
<ul>
<li>Remote办公，六险一金，弹性工作，大牛带队，扁平管理。</li>
<li>待遇：面谈</li>
</ul>
<p><strong>职位职责：</strong></p>
<ol>
<li>负责Rust相关课程开发及授课工作</li>
<li>了解Datafuse项目，从项目中抽取模块编排教学工作</li>
<li>从事Datafuse部分文档输出</li>
<li>针对Datafuse输出用户解决方案</li>
</ol>
<p><strong>职位要求：</strong></p>
<ol>
<li>良好的系统编程能力，喜爱或是有Rust经验及扎实的C/C++功底更佳</li>
<li>熟悉数据库运行原理或是大数据应用场景更佳</li>
<li>喜欢关注新技术，愿意做技术推广</li>
<li>了解课程设计及开发</li>
<li>热忠自动完成事情</li>
</ol>
<h2><a class="header" href="#百度招聘rust研发工程师-1" id="百度招聘rust研发工程师-1">百度招聘Rust研发工程师</a></h2>
<p><strong>1. 职位概况</strong></p>
<ul>
<li>岗位名称：资深Rust研发工程师</li>
<li>所属部门：百度安全部</li>
<li>岗位职级：技术T5-T7</li>
<li>工作地点：北京市</li>
</ul>
<p><strong>2. 工作职责</strong></p>
<ul>
<li>负责数据安全计算相关产品核心组件研发以及开源社区建设</li>
<li>参与数据安全与隐私计算产品研发</li>
<li>负责基于Intel SGX、ARM TrustZone等硬件技术的调研、分析与应用转化</li>
<li>负责机器学习与深度学习算法在TEE技术上的移植与优化</li>
</ul>
<p><strong>3.职位要求</strong></p>
<ul>
<li>计算机软件、信息安全等相关专业，统招本科及以上学历</li>
<li>有良好的系统编程能力，喜爱或有Rust开发经验以及扎实的C/C++功底</li>
<li>熟悉常用数据结构和算法，熟悉Linux系统</li>
<li>关注代码设计和新技术，有持续学习的习惯</li>
<li>有TEE可信执行环境、Intel SGX、机器学习、区块链相关技术经验者优先</li>
<li>熟悉Github开源社区，长期贡献者优先</li>
</ul>
<p>有意者请投简历至邮箱：luoyanhua@baidu.com</p>
<h2><a class="header" href="#phala招聘-rust区块链研发工程师-1" id="phala招聘-rust区块链研发工程师-1">Phala招聘 Rust区块链研发工程师</a></h2>
<p><strong>1. 关于Phala Network</strong></p>
<p>波卡系保密智能合约平台，可以实现保密前提下的数据交易协议，致力于成为 Web3.0 数据隐私计算的基础设施。基于 Substrate 开发的 Phala 未来将会成为 Polkadot 平行链，通过跨链协议为任何区块链的提供机密智能合约能力。Phala 是波卡生态的重要成员：2019 年 8 月获得 Web3 基金会 Grant，2020 年 3 月成为首批加入 Parity Substrate Builders 计划的项目之一。在 Phala Network，我们相信下一代区块链需要安全高效的处理机密数据，因此我们开发了基于 TEE 的保密合约，致力于为区块链实现保密能力。</p>
<p><strong>2. 职位描述</strong> </p>
<ul>
<li>有 Rust 开发经验，或拥有快速上手 Rust 的能力</li>
<li>区块链相关数据结构与算法</li>
<li>扎实的计算机科学基础知识</li>
<li>熟悉 Git 版本管理、单元测试，熟悉开源协作</li>
<li>认同技术文档、开源教程、参与技术分享的重要性并积极参与</li>
</ul>
<p><strong>3. 职位方向</strong></p>
<p><strong>核心协议</strong></p>
<ul>
<li>
<p>Intel SGX SDK 开发与整合</p>
</li>
<li>
<p>P2P网络通信与密钥管理</p>
</li>
<li>
<p>XCM 跨链协议整合</p>
</li>
<li>
<p>对接 Filecoin 等分布式存储协议</p>
</li>
</ul>
<p><strong>保密合约基础设施</strong></p>
<ul>
<li>WASM、Ink! 执行环境的整合、优化、Chain Extension 开发</li>
<li>调研和改进合约编程模型</li>
<li>WASM 工具链的整合</li>
</ul>
<p><strong>区块链开发</strong></p>
<ul>
<li>设计与实现 Substrate Pallet</li>
<li>Ink! 合约研发、测试与部署</li>
<li>不同场景下的 XCM API 设计与实现</li>
</ul>
<p><strong>计算平台</strong></p>
<ul>
<li>构建兼容工业标准的 Serverless、FaaS 基础平台在 Phala 上开发与移植应用，并测试平台的可用性</li>
</ul>
<p><strong>4. 加分项</strong> </p>
<ul>
<li>有可信执行环境应用开发经验：Intel SGX、AMD SEV、Arm TrustZone</li>
<li>Substrate或其他区块链节点开发经验</li>
<li>扎实的应用密码学知识：非对称加密、零知识证明、多方安全计算</li>
<li>跨链桥（比特币SPV节点）、Layer 2 开发经验（核心协议方向）</li>
<li>Solidity、Ink等智能合约开发经验（区块链开发方向）</li>
<li>FaaS、Serverless、Event Sourcing实施经验（计算平台方向）</li>
<li>分布式系统任务调度、分布式事务、分布式存储等基础设施的开发经验（计算平台方向）</li>
</ul>
<p>有意者请联系邮箱：hire@phala.network或微信：h4xbigcat</p>
<h2><a class="header" href="#automata-network-招聘区块链研发工程师-1" id="automata-network-招聘区块链研发工程师-1">Automata Network 招聘区块链研发工程师</a></h2>
<p><strong>1. 关于Automata Network</strong></p>
<p>Automata Network 是一个全新的隐私中间件网络，致力于通过为 dApp 提供无缝衔接的隐私保护和高可用性解决方案，来促进 Web3.0 社区的发展。我们正在寻找对此领域感兴趣，有热情，同时具有强大自力驱 的小伙伴。希望你能加入我们，作为团队核心的研发成员，进行技术的探索和应用的研发。公司总部位于新加坡，你也可以选择在家远程办公，请速将简历砸向我们吧!</p>
<p><strong>2. 职位描述</strong></p>
<ul>
<li>基于 Substrate (https://substrate.dev) 进行区块链相关应用的研发</li>
<li>基于 Intel SGX 进行支持可信执行环境(TEE)相关研发</li>
<li>探索前沿的技术解决方案，设计技术架构</li>
<li>编写单元测试，编写技术文档，审核其他成员的代码</li>
</ul>
<p><strong>3. 职位要求</strong></p>
<ul>
<li>两年以上的软件开发经验</li>
<li>熟练掌握 Rust 或者 Modern C++ 其中一门语言，熟悉常见脚本语言如 Shell 和 Python的使用</li>
<li>具有很强的解决问题能力和沟通能力，能够快速学习并掌握新的技术</li>
<li>熟悉开源社区的开发和协作方式</li>
<li>加分项: 熟悉 TEE 相关技术，如 Intel SGX 开发，了解区块链相关协议和常见共识算法</li>
</ul>
<p><strong>4. 加分福利</strong></p>
<ul>
<li>具有市场竞争力的薪资待遇，优秀的小伙伴更可获得 token 配额</li>
<li>灵活安排的工作时间，积极开放的工作氛围以及行业大牛的手把手指导</li>
<li>在最前沿的技术领域进行探索，填补技术空白，能让你快速成长，成为领域内的专家</li>
</ul>
<p>有意者请投简历至邮箱: hiring@ata.network</p>
<p>如果对Rust与区块链有兴趣，请关注OneBlock+微信公众号，还有多家区块链项目在招募Rust工程师。</p>
<h1><a class="header" href="#rustchinaconf-2021-议题征集开放申请-1" id="rustchinaconf-2021-议题征集开放申请-1">RustChinaConf 2021 议题征集开放申请</a></h1>
<h2><a class="header" href="#大会介绍" id="大会介绍">大会介绍</a></h2>
<p>Rust China Conf 2021 由 Rust 中文社区发起主办、知名企业和开源组织联合协办，是年度国内规模最大并唯一的 Rust 线下大型会议，深受 Rust 中文社区开发者与相关企业的喜爱与推崇。</p>
<p>本次大会为线下会议，将于9月19日-20日在上海举办，预计到场人数 300 左右，包含个人开发者和企业用户。到场人员主要为一线程序员，已在个人或公司项目中实践 Rust。</p>
<p>本次大会将同步开启线上直播、以及结束后上传相关录像。线上线下联动，将覆盖 30,000+ Rust 开发者群体。</p>
<p>本次大会也获得了国内知名开发者社区、媒体与出版社的支持。依托 Rust 中文社区本身的影响力，加上多个社区联合宣传，将进一步扩大本次 Rust China Conf 的传播范围。</p>
<h2><a class="header" href="#大会目标" id="大会目标">大会目标</a></h2>
<p>本次大会为中国本土范围的第一次 Rust 大会，致力于成为中国 Rustaceans 面对面交流的盛宴，为国内的 Rust 开发者和企业提供一次充分的成果展示、技术分享、能力提升、行业资讯交流、企业人才储备建设的机会。</p>
<h2><a class="header" href="#大会议题范围" id="大会议题范围">大会议题范围</a></h2>
<p>Rust 语言独有的特性，使得其适应面非常广泛，通过广泛搜集整个社区和企业中的议题，分类参考如下：</p>
<ul>
<li>库或框架</li>
<li>Rust 语言贡献</li>
<li>Rust 学术/ 教育/ 教程 / 书籍</li>
<li>Rust 社区</li>
<li>Rust 生产环境使用经验</li>
<li>最佳实践</li>
<li>系统编程</li>
<li>WebAssembly</li>
<li>数据库</li>
<li>游戏开发</li>
<li>区块链</li>
<li>嵌入式开发</li>
<li>安全（Security）领域</li>
<li>其他领域</li>
<li>workshop</li>
</ul>
<h2><a class="header" href="#议题提交截止时间" id="议题提交截止时间">议题提交截止时间</a></h2>
<p>8月20日 23:59</p>
<h2><a class="header" href="#议题审核流程" id="议题审核流程">议题审核流程</a></h2>
<p>议题由 Rust China Conf 2021 组委会审核， 已确认通过的议题会第一时间更新在大会官网：<a href="https://rustcc.cn/2021rustchinaconf">https://rustcc.cn/2021rustchinaconf</a>  。</p>
<p>所有议题审核最后截止时间：<strong>2021年9月10日</strong></p>
<h2><a class="header" href="#组委会联系邮箱" id="组委会联系邮箱">组委会联系邮箱</a></h2>
<p><strong>624910278@qq.com</strong></p>
<p>期待与大家相见。</p>
<h2><a class="header" href="#议题申请通道" id="议题申请通道">议题申请通道</a></h2>
<p>议题申请通道：<a href="https://shimo.im/forms/xqpwpdXw6YxrJTj9/fill">https://shimo.im/forms/xqpwpdXw6YxrJTj9/fill</a></p>
<h1><a class="header" href="#论文导读--性能与生产力--rust-vs-c" id="论文导读--性能与生产力--rust-vs-c">论文导读 | 性能与生产力 : Rust vs C</a></h1>
<p>作者： 张汉东</p>
<hr />
<blockquote>
<ul>
<li>原标题：Performance vs Programming Effort betweenRust and C on Multicore Architectures:  CaseStudy in N-Body</li>
<li>论文地址：<a href="https://arxiv.org/abs/2107.11912">https://arxiv.org/abs/2107.11912</a></li>
<li>发表时间：2021年7月26</li>
<li>关键字：Rust,  C,  N-Body,  Parallel  Computing,  Performance  comparsion, Programming Cost</li>
</ul>
</blockquote>
<hr />
<h2><a class="header" href="#前言-4" id="前言-4">前言</a></h2>
<p>曾经 Fortran和C一直是高性能计算（HPC）的默认编程语言。这两种语言都提供了可以和操作系统内存以及硬件进行交互的基础类型和函数，从而在响应时间和资源使用方面产生高效的代码。然而，对这两种语言而言，如何生成可维护和可扩展的代码是一个真正的挑战。</p>
<p>Rust 语言诞生之后，它天生为并发和安全而设计，并且借鉴了面向过程/面向对象/函数式等语言的特点。Rust 的目标在性能方面对标 C 语言，但在安全和生产力方面则比 C 更胜一筹。</p>
<p>这篇论文就是比较研究 Rust 和 C 语言在 性能和 编程效能（Programming effort）两方面，看能否确定 Rust 是一种保持一定性能水平的同时拥有更少工作量（更高的编程效能和生产力）的语言。如果是这样，那么 Rust 则是 HPC 领域的绝佳替代品。</p>
<p>之前 Rust 社区也探讨过如何确定 Rust 生产力的问题，那么这篇文章就是一个启示。本文并非论文完整翻译，只是一些重点摘要。</p>
<h2><a class="header" href="#什么是-n-body-" id="什么是-n-body-">什么是 N-Body ?</a></h2>
<h3><a class="header" href="#背景-5" id="背景-5">背景</a></h3>
<p>N-Body ，即 N 体问题。</p>
<p>在二十世纪的第一次数学家大会(1900年)上，二十世纪伟大的数学家希尔伯特(David Hilbert)在他著名的演讲中提出了23个困难的数学问题。其中 N 体问题的 特例 三体问题就被提了出来。</p>
<p>先从 三体 问题说起。三体问题是天体力学中的基本力学模型。它是指三个质量、初始位置和初始速度都是任意的可视为质点的天体，在相互之间万有引力的作用下的运动规律问题。三体问题（three-body problem）最简单的一个例子就是太阳系中太阳、地球和月球的运动。</p>
<p>N 体问题就是 三体问题更一般化的多体问题。多体问题是一个十分复杂的理论问题，也是天体力学各个分支学科的共同基础课题。当<code>N=2</code>时，即为二体问题，已完全解决（回想一下牛顿万有引力定律）。<code>N=3</code>即成为著名的三体问题，除一些特殊的限制性三体问题可以得出特解外 ，一般三体问题仍是悬而未决的难题。对于<code>N&gt;3</code>的N体问题，根本无法求出分析解。现在主要是采用数值方法和定性方法来进行研究。特别是随着电子计算机的广泛使用，数值方法更成为研究N体问题的主要手段。</p>
<p>八卦：</p>
<ol>
<li>科幻作家刘慈欣的《地球往事》三部曲之一《三体》即是以此问题为基础而创作的。</li>
<li>多体问题也在电视连续剧《犯罪心理》中&quot;Compulsion&quot;这段被显著提到。</li>
<li>多体问题也出现在1951年科幻电影《地球停转之日》，其中Klaatu为了吸引一位科学家的注意而解决了这个问题。</li>
</ol>
<p>以上参考维基百科。</p>
<h3><a class="header" href="#计算" id="计算">计算</a></h3>
<p>对于 N body 有很多的稍微近似的算法，多是基于实际的物理场景的，比如大部分天体是属于一个星系的，每个星系之间都非常远，所以可以将一些星系作为整体计算，构建一颗树，树中的某些节点是其所有叶子的质心，这样就可以减少计算量，但是放到 GPU 的场景下一个 <code>O(N^2)</code> 的暴力算法利用 GPU 的并行能力可以非常快的算出来。</p>
<p>在网上也有针对 <code>n-body</code>的 各个语言性能比较：https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/nbody.html</p>
<h2><a class="header" href="#高性能计算特点" id="高性能计算特点">高性能计算特点</a></h2>
<p>高性能计算（HPC）是指使用非凡的计算能力系统和并行处理技术来解决具有高计算需求的复杂问题。实现这一目的不仅需要有提供必要处理能力的架构，还需要有允许问题被有效计算的软件。这就是为什么不能简单地选择一门编程语言，它的选择会对应用性能和所需的编程效能产生影响。</p>
<p>HPC系统必须有效地计算问题，以提高程序的响应时间。能做到这一点的语言，必须是拥有和底层硬件打交道的能力。目前在这个领域最流行的语言是 Fortran 和 C 。尽管被广泛使用，但用这些语言生成可维护和可扩展的代码是一个真正的挑战。Java 和 Python 这两种语言还试图进入这个领域，可想而知，它们失败了。</p>
<p>在这个意义上，语言应该至少提供以下功能： </p>
<ul>
<li>允许直接操作内存内容的指针。 </li>
<li>一套位操作符，如果使用得当，可以大大改善程序时间。 </li>
<li>支持不同的标志或编译选项，根据支持的架构优化代码。</li>
<li>使用/嵌入本地底层架构指令的能力，以利用其硬件特性的优势。</li>
</ul>
<p>此外，为了提高响应时间，语言应该提供工具或库，允许扩展基础语言功能，为多处理器架构提供并发和并行处理能力，包括共享（如OpenMP）和分布式内存（如OpenMPI或MPICH）。</p>
<p>该论文的重点是评估 Rust 能否在 HPC 领域成为 C 语言的替代品，所以使用 HPC 领域最常见的 N体问题 作为案例，并且做了如下工作：</p>
<ol>
<li>在多核架构上，使用 Rust 语言对 N 体问题进行多次优化实现。</li>
<li>严格对比 多核架构下 N 体问题的 C 和 Rust 实现，来确定 Rust 在 HPC 领域中的优势与劣势。</li>
</ol>
<h2><a class="header" href="#rust-实现" id="rust-实现">Rust 实现</a></h2>
<p>N 体问题用于模拟一个由 N 个个体组成的系统在时间推移过程中的演变。每个个体都有一个初始状态，由其速度和位置给出。系统的运动是通过离散的时间瞬间来模拟的。 在每一个瞬间，个体都经历了一个加速度，这个加速度来自于其余个体的引力，这影响了它的状态。牛顿力学是模拟的基础。</p>
<p>这项模拟是在 3 个空间维度上进行的，两个物体<code>Ci</code>和<code>Cj</code>之间的引力是用牛顿的万有引力定律计算出来的。</p>
<p><img src="chapter_7/./image/rust-vs-c/n-body.png" alt="1" /></p>
<p>其中，<code>F</code>是指物体之间的引力大小，<code>G</code>是指引力常数（<code>6.674×(10^11)</code>），<code>mi</code> 对应 Ci 的质量，<code>mj</code> 对应 Cj 的质量，<code>r</code> 对应 Ci和Cj之间的欧氏距离（euclidean distance）。</p>
<p>当 N 大于 2 时，一个物体上的引力相当于其余 <code>N-1</code> 个物体施加的所有引力总和。根据牛顿第二定律，牵引力导致每个物体加速和移动： <code>F = m·a</code> （这是一个矢量表达式，加速度和合力的方向始终保持一致）</p>
<p>牛顿第二定律独立性告诉我们：物体受几个外力作用，在一个外力作用下产生的加速度只与此外力有关，与其他力无关，各个力产生的加速度的矢量和等于合外力产生的加速度，合加速度和合外力有关。</p>
<p>在一个小的时间间隔<code>dt</code> 内，<code>Ci</code>的加速度大约是恒定的，所以速度的变化大约是: <code>d·vi = ai·dt</code>。</p>
<p><code>Ci</code>位置的变化是其速度和加速度在<code>dt</code>时间间隔内的积分：</p>
<p><img src="chapter_7/./image/rust-vs-c/n-body2.png" alt="2" /></p>
<p>在这个公式中，很明显，一半的位置变化是由于旧的速度，而另一半是由于新的速度。 这种整合方案被称为 Leapfrog 。解法伪代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FOR every-body-i = 1 to N
		FOR every-body-j = 1 to N
    		Calculate the force exerted by j on i // 计算 j 对 i 所施加的力
        Sum of the forces affecting i         // 影响 i 的力之和
    Calculate the displacement of the body i  // 计算 i 的位移
    Moving the body i                         // 移动 i
<span class="boring">}
</span></code></pre></pre>
<p>上面伪代码中有两个数据依赖：</p>
<ol>
<li>首先，一个个体不能移动，直到其他个体完成计算它们的相互作用。</li>
<li>第二，在其他个体完成当前步骤之前，他们也不能前进到下一个步骤。</li>
</ol>
<h2><a class="header" href="#rust-vs--c-实现" id="rust-vs--c-实现">Rust vs  C 实现</a></h2>
<h3><a class="header" href="#性能-5" id="性能-5">性能</a></h3>
<p>论文中给出了一些性能测试图表。看得出来，整体性能 Rust 和 C 相差无几。</p>
<p>在单精度方面，C语言版本在所有问题规模上都优于Rust，实现了高达1.18倍的改进，而在双精度方面，两种实现的性能几乎相同。</p>
<p>当分析两种实现产生的汇编代码时，可以看到当使用数学优化（precision relaxation）时，C语言对主代码进行了更有效的转译。 这种行为在双精度中没有被复制，在双精度中两种代码是非常相似的。</p>
<p>这些优化还没有包含在 Rust 的稳定版本中，所以这一点有望在未来得到改善。</p>
<h3><a class="header" href="#编程效能" id="编程效能">编程效能</a></h3>
<p>有很多方法来衡量编程的成本，包括计算代码行数。尽管它们很简单，但这些参数并不能反映算法的复杂性。</p>
<p>还可以测量开发时间，但这取决于程序员的经验。这些指标都极具主观性，导致很难去评估编程的成本。</p>
<p>但是 代码行数 和 开发时间 算是互补的方法，一定程度上在广义上来评估编程的效能是可以的。</p>
<p><strong>先来看看代码行数：</strong></p>
<table><thead><tr><th></th><th>C</th><th>Rust</th></tr></thead><tbody>
<tr><td>Main</td><td>66</td><td>40</td></tr>
<tr><td>Total</td><td>219</td><td>195</td></tr>
</tbody></table>
<p>Rust的优势在于，作为一种具有高级语言的一些特征的语言，它既是函数式的，也是面向对象的，它可以开发出比C语言更紧凑、更容易解释的代码。代码量少的情况下，还有更强的可维护性。</p>
<p>在优化过程中：</p>
<ul>
<li>C 语言需要不断改变解决方案的逻辑才能更好地利用数据位置的优势，而 Rust 则更有效地管理了内存，优化过程中不需要对解决方案进行修改。</li>
<li>Rust 的迭代器可以通过更简单的方式生成并行代码，而 C 则需要对不同的 OpenMP 选项来实现适当并行化。</li>
<li>Rust 中添加外部库非常方便，比如数学优化库或 rayon库。C 则比较麻烦。</li>
</ul>
<h2><a class="header" href="#实验结论" id="实验结论">实验结论</a></h2>
<p>先来看一下论文结论。</p>
<p>Rust 创建的 N-Body 优化算法是从一个基础版本开始，然后不断迭代优化出来的。优化措施如下：</p>
<ol>
<li>多线程。将单线程的基础版本修改为多线程，增加并发计算。</li>
<li>用 <code>for_each</code> 代替 <code>fold</code>，性能没有变化，但是增加了可读性。</li>
<li>在数学层面上进行优化，虽然损失了计算精度，但是提升了算法性能。</li>
<li>开启自动向量化，进行并行计算。Rust 支持自动向量化（SIMD）。</li>
<li>使用 Jemalloc 内存分配器替换默认分配器，性能有所提高，但不是很明显。</li>
<li>其他。</li>
</ol>
<p>对 Rust 算法优化完之后，和 C 语言对应的算法进行了比较。在双精度方面，性能结果很接近，但在单精度方面，C版本的性能要好一些。 这是因为Rust对这种数据类型的数学运算的优化不如C语言好。</p>
<p>在编程效能（生产力）方面，Rust与C不同，它有一些高级语言的特性，这有利于生成易于维护的代码。  此外，由于它具有函数式语言和面向对象语言的特点，它允许生成更紧凑的代码，导致程序的代码行数更少。 此外，Rust试图有效地管理内存，在某些情况下，不需要对计算逻辑进行修改就可以利用数据位置的优势。</p>
<p>基于所获得的结果和所进行的分析，论文作者们认为在与本研究类似场景的情况下，<strong>Rust可以被定位为HPC的C语言的替代品</strong>。 由于该语言仍在不断发展中，社区支持将成为其最终可行性的决定因素。</p>
<h2><a class="header" href="#相关资料" id="相关资料">相关资料</a></h2>
<p><a href="https://github.com/ManuelCostanzo/Gravitational_N_Bodies_Rust">https://github.com/ManuelCostanzo/Gravitational_N_Bodies_Rust</a></p>
<h1><a class="header" href="#华为--rust-调用约定和名称修饰规则介绍" id="华为--rust-调用约定和名称修饰规则介绍">华为 | Rust 调用约定和名称修饰规则介绍</a></h1>
<p>作者：周紫鹏 / 后期编辑：张汉东</p>
<hr />
<h2><a class="header" href="#背景介绍-3" id="背景介绍-3">背景介绍</a></h2>
<p>一般来说调用的约定和名称修饰（<a href="https://en.wikipedia.org/wiki/Name_mangling">Name mangling</a>）对于程序员来说是不需要感知到的，它们一般都是通过编译器来完成，但是如果涉及到汇编代码的函数调用，就需要了解所编写代码最终编译生成的符号信息。调用约定和名称修饰都是属于ABI（<a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application Binary Interface</a>）范畴内容，当前Rust还没有一个<a href="https://people.gnome.org/%7Efederico/blog/rust-stable-abi.html">稳定的ABI</a>，所以编译的时候需要将所有依赖的crates一起编译。名称修饰最主要解决的一个问题是，保证代码链接时名称的唯一性。因为在一些编程语言中，支持命名空间、泛型、重载等特性，支持在同一个命名空间中存在相同的函数名称或者标识符，为了做区分就需要在编译时做相应的修饰，比如加入crate信息、命名空间信息等。</p>
<p>在进行<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/hw_bin_opt.html">Rust二进制大小分析</a>和Rust热补丁分析时，对Rust符号组名规则的分析同样也是必要的，这有助于我们了解Rust代码生成的符号信息，所以本文将对Rust名称修饰规则做一个简单的介绍。</p>
<h2><a class="header" href="#legacy-规则" id="legacy-规则">legacy 规则</a></h2>
<p>Rust从 1.9版本开始使用legacy规则，Rust的legacy规则是基于<a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling">Itanium IA-64 C++ ABI</a>进行了部分的修改，最主要的是在符号最后加了哈希值用来解决部分场景下的符号唯一性的问题。</p>
<h3><a class="header" href="#普通函数" id="普通函数">普通函数</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crate 名称:legacy_mangling
fn foo() {
    println!(&quot;foo&quot;);
}

fn foo_arg(x: i32) {
    println!(&quot;x = {}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>foo</code>组名后：<code>_ZN15legacy_mangling3foo17h7bf46936ec8fddf1E</code></p>
<p>其中<code>_ZN</code>为legacy规则的组名符号开头，和Itanium IA-64 C++ ABI规则一致，后面紧跟的15是crate的<code>legacy_mangling</code>的字符个数，包括了中间的下划线。3表示函数<code>foo</code>，最后面紧跟着17是hash值<code>h7bf46936ec8fddf1</code>，并以<code>E</code>表示结束。</p>
<p><code>foo_arg</code>组名后：<code>_ZN15legacy_mangling7foo_arg17h9d3deebd56cd9668E</code></p>
<p>可以发现参数并不会体现在前面的组名中，而是通过hash值来做区分。</p>
<h3><a class="header" href="#带泛型参数的函数" id="带泛型参数的函数">带泛型参数的函数</a></h3>
<pre><pre class="playground"><code class="language-rust">// crate 名称:legacy_mangling
fn main() {
    foo_generic(1);
    foo_generic(1.0);
    foo_generic(&quot;Hello&quot;);
}
fn foo_generic&lt;T: std::fmt::Display&gt;(x: T) {
    println!(&quot;x = {:#}&quot;, x);
}
</code></pre></pre>
<p><code>foo_generic</code>组名后：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_ZN15legacy_mangling11foo_generic17hf6d667a670f9aa59E
_ZN15legacy_mangling11foo_generic17ha0a4115d4cba4650E
_ZN15legacy_mangling11foo_generic17he59e5604e24e62a6E
<span class="boring">}
</span></code></pre></pre>
<p>泛型参数实例化后符号差异也是在hash值上，不会将泛型参数信息体现在组名中。由于参数不会体现在，这也使得在函数热补丁场景下，很难确定具体的补丁函数是哪个。</p>
<h3><a class="header" href="#结构体方法" id="结构体方法">结构体方法</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let point = Point{
        x: 1,
        y: 2,
    };
    println!(&quot;{}&quot;, point.add());
    println!(&quot;{}&quot;, point.sub())
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn add(&amp;self) -&gt; i32 {
        self.x + self.y
    }

    fn sub(&amp;self) -&gt; i32 {
        self.x - self.y
    }
}
</code></pre></pre>
<p>Point结构体方法<code>add</code>和<code>sub</code>组名后:</p>
<pre><code>_ZN15legacy_mangling5Point3add17h9b332fc1bb45a67eE
_ZN15legacy_mangling5Point3sub17hf189faef70b4895dE
</code></pre>
<p>组名后是crate + Struct + func + hash的组成方式，同样是不会携带参数信息。由于Struct名称也会当成组名的一部分，所以此时不允许定义mod和Struct同名的子模块。编译器在编译的时候，也会判断函数是否被使用，如果没有被使用的函数，不会进行编译，比如main函数中只调用了<code>point.add()</code>，那不会将sub函数编译到二进制中，这也是编译器对可执行二进制大小的优化。</p>
<h3><a class="header" href="#trait方法" id="trait方法">trait方法</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let point = Point{
        x: 1,
        y: 2,
    };
    println!(&quot;{}&quot;, point.add());
}

pub trait Compute {
    fn add(&amp;self) -&gt; i32;
}

struct Point {
    x: i32,
    y: i32,
}

impl Compute for Point{
    fn add(&amp;self) -&gt; i32 {
        self.x + self.y
    }
}
</code></pre></pre>
<p>组名后：<code>_ZN67_$LT$legacy_mangling..Point$u20$as$u20$legacy_mangling..Compute$GT$3add17h9b332fc1bb45a67eE</code></p>
<p>可以看到组名之后变得相对比较复杂，因为我们在不违反孤儿原则的情况下，可以实现另外crate中的trait，或者Struct在另外的crate中，所以在组名中的trait和Struct包含了crate名称。<code>$</code>和<code>.</code>两个符号是保留的特殊符号，这两个符号在编码中用来命名会报错。</p>
<h3><a class="header" href="#闭包" id="闭包">闭包</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let add_one = |x: u32| -&gt; u32 { x + 1 };
    println!(&quot;{}&quot;, add_one(1));

}
</code></pre></pre>
<p>组名后：<code>_ZN15legacy_mangling4main28_$u7b$$u7b$closure$u7d$$u7d$17h5e4f3fa236bcd1c3E</code></p>
<p>闭包组名会包含crate名称和闭包所在函数名称，并且会携带<code>closure</code>关键字，但是不会体现具体的捕获参数等信息。</p>
<p>关于legacy规则的其他语法特性的组名方式此处不再进行更多的介绍，并且官方对于legacy的组名规则说明也比较少，后面介绍正在标准化过程中的V0规则。</p>
<h2><a class="header" href="#v0规则" id="v0规则">V0规则</a></h2>
<p>V0规则的<a href="https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html">RFC</a>当前正在实现过程中，对应的<a href="https://github.com/rust-lang/rust/issues/60705">ISSUE</a>和<a href="https://github.com/rust-lang/rfcs/pull/2603">PR</a>，从Rust1.39版本之后的Nightly版本中可以通过rustflags设置使用V0规则。使用方式：可以通过设置<code>RUSTFLAGS=-Zsymbol-mangling-version=v0</code>或者在.cargo/config中添加rustflags</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[build]
rustflags = [&quot;-Z&quot;, &quot;symbol-mangling-version=v0&quot;]
<span class="boring">}
</span></code></pre></pre>
<p>当前V0规则标准化过程涉及的GDB工具、GCC、Perf、valgrind等适配已经完成，按照<a href="https://github.com/rust-lang/rust/issues/60705">进展ISSUE</a>描述的情况看，只剩下Doc相关的适配，相信在不久将来会合入到stable版本中。</p>
<p>RFC中总结了当前legacy规则存在如下一些问题：</p>
<ul>
<li>通用的参数和一些其他的信息在重组名过程中会丢失，并且不能从符号中获取到单态函数的参数类型。如同我们前面做的测试，泛型函数和带参数的函数并不能通过重组名的符号反推出来，因为都是以Hash值作为结尾。</li>
<li>方案存在不一致情况，大部分使用 <a href="http://refspecs.linuxbase.org/cxxabi-1.86.html#mangling">Itanium ABI</a>样式进行编码，但有些却没有使用</li>
<li>生成的符号中包含<code>.</code>，但是该符号在部分平台上不支持</li>
<li>它取决于编译器内部结构，其结果无法被其他编译器实现或外部工具复制</li>
</ul>
<p>V0规则主要解决如下问题：</p>
<ul>
<li>它以可逆的方式编码有关泛型参数的信息。也就是可以通过符号反推出泛型的参数信息。</li>
<li>它有一个一致的定义，不依赖于漂亮地打印某些语言结构。</li>
<li>字符由<code>A-Z</code>，<code>a-z</code>， <code>0-9</code>，和<code>_</code>组成</li>
</ul>
<p>V0规则很重要的一个点是取消了Hash值，可以通过重组后的符号信息解码出源码的信息，这也是后续如果Rust的ABI稳定的一部分，可以预测给定的代码生成的符号信息。</p>
<p>下面以几个简单的例子介绍V0规则函数名称重组之后的情况</p>
<h3><a class="header" href="#普通函数-1" id="普通函数-1">普通函数</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crate 名称:v0_mangling
fn foo() {
    println!(&quot;foo&quot;);
}

fn foo_arg(x: i32) {
    println!(&quot;x = {}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>foo</code>组名后：<code>_RNvCs1L72TZisdJI_11v0_mangling3foo</code></p>
<p><code>foo_arg</code>组名后：<code>_RNvCs1L72TZisdJI_11v0_mangling7foo_arg</code></p>
<p>V0 组名规则以_R作为开头，去掉了后面的Hash值，普通函数中也去掉了E函数作为结尾。</p>
<h3><a class="header" href="#mod中函数" id="mod中函数">mod中函数</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    fn bar() {}
}

mod foo {
    fn bar() {}
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>_RNvNtCs1234_7mycrate3foo3bar
&lt;&gt;^^^^^&lt;----&gt;&lt;------&gt;&lt;--&gt;&lt;--&gt;
 ||||||   |      |     |   |
 ||||||   |      |     |   +--- &quot;bar&quot; identifier
 ||||||   |      |     +------- &quot;foo&quot; identifier
 ||||||   |      +------------- &quot;mycrate&quot; identifier
 ||||||   +-------------------- disambiguator for &quot;mycrate&quot;
 |||||+------------------------ start-tag for &quot;mycrate&quot;
 ||||+------------------------- namespace tag for &quot;foo&quot;
 |||+-------------------------- start-tag for &quot;foo&quot;
 ||+--------------------------- namespace tag for &quot;bar&quot;
 |+---------------------------- start-tag for &quot;bar&quot;
 +----------------------------- common Rust symbol prefix
</code></pre>
<p>上图从RFC中复制的内容，对每个字段进行了详细的说明，当然具体的编码方式可以参见RFC。</p>
<h3><a class="header" href="#带泛型参数的函数-1" id="带泛型参数的函数-1">带泛型参数的函数</a></h3>
<pre><pre class="playground"><code class="language-rust">// crate 名称:legacy_mangling
fn main() {
    foo_generic(1);
    foo_generic(1.0);
    foo_generic(&quot;Hello&quot;);
}
fn foo_generic&lt;T: std::fmt::Display&gt;(x: T) {
    println!(&quot;x = {:#}&quot;, x);
}
</code></pre></pre>
<p><code>foo_generic</code>组名后：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_RINvCs1L72TZisdJI_11v0_mangling11foo_genericReEB2_        --&gt;  foo_generic(&quot;Hello&quot;);
_RINvCs1L72TZisdJI_11v0_mangling11foo_genericdEB2_         --&gt;  foo_generic(1.0);
_RINvCs1L72TZisdJI_11v0_mangling11foo_genericlEB2_         --&gt;  foo_generic(1);
<span class="boring">}
</span></code></pre></pre>
<p>泛型参数实例化之后会再最后的参数中体现，其中参数对照如下，比如<code>foo_generic(&quot;Hello&quot;)</code>传入的是<code>&amp;str</code>所以符号名称为<code>ReE</code>，<code>R</code>代表<code>&amp;</code>，<code>e</code>表示的是str类型，E表示参数结束。同理传入为float的实例化是<code>dE</code>，传入i32的实例化是<code>lE</code>。</p>
<pre><code>&lt;type&gt; = &lt;basic-type&gt;
       | &lt;path&gt;                      // named type
       | &quot;A&quot; &lt;type&gt; &lt;const&gt;          // [T; N]
       | &quot;S&quot; &lt;type&gt;                  // [T]
       | &quot;T&quot; {&lt;type&gt;} &quot;E&quot;            // (T1, T2, T3, ...)
       | &quot;R&quot; [&lt;lifetime&gt;] &lt;type&gt;     // &amp;T
       | &quot;Q&quot; [&lt;lifetime&gt;] &lt;type&gt;     // &amp;mut T
       | &quot;P&quot; &lt;type&gt;                  // *const T
       | &quot;O&quot; &lt;type&gt;                  // *mut T
       | &quot;F&quot; &lt;fn-sig&gt;                // fn(...) -&gt; ...
       | &quot;D&quot; &lt;dyn-bounds&gt; &lt;lifetime&gt; // dyn Trait&lt;Assoc = X&gt; + Send + 'a
       | &lt;backref&gt;

&lt;basic-type&gt; = &quot;a&quot;      // i8
             | &quot;b&quot;      // bool
             | &quot;c&quot;      // char
             | &quot;d&quot;      // f64
             | &quot;e&quot;      // str
             | &quot;f&quot;      // f32
             | &quot;h&quot;      // u8
             | &quot;i&quot;      // isize
             | &quot;j&quot;      // usize
             | &quot;l&quot;      // i32
             | &quot;m&quot;      // u32
             | &quot;n&quot;      // i128
             | &quot;o&quot;      // u128
             | &quot;s&quot;      // i16
             | &quot;t&quot;      // u16
             | &quot;u&quot;      // ()
             | &quot;v&quot;      // ...
             | &quot;x&quot;      // i64
             | &quot;y&quot;      // u64
             | &quot;z&quot;      // !
             | &quot;p&quot;      // placeholder (e.g. for generic params), shown as _
</code></pre>
<p>其他语法特性的组名规则不再一一进行列举，V0相对legacy规则有一些的改进，可以方便的从组名后的符号方便的推测出组名之后的代码。组名规则的变更会涉及到大量的工具需要适配，V0的RFC从18年就开始提出，当前大部分的适配已经完成，V0规则对需要精确知道组名之后的源代码是很有帮助的，比如在我们实际业务中会涉及到Rust函数级别的热补丁实现，就需要知道我们所要打补丁的代码最终会生成的符号组成，legacy规则就很难解决这个问题。</p>
<h2><a class="header" href="#参考-7" id="参考-7">参考：</a></h2>
<p>https://doc.rust-lang.org/reference/abi.html</p>
<p>https://people.gnome.org/~federico/blog/rust-stable-abi.html</p>
<p>https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html#unresolved-questions</p>
<h1><a class="header" href="#蚂蚁集团--futures-01-和-03-兼容层的分析与应用" id="蚂蚁集团--futures-01-和-03-兼容层的分析与应用">蚂蚁集团 ｜ Futures 0.1 和 0.3 兼容层的分析与应用</a></h1>
<p>作者： Rachelint</p>
<h2><a class="header" href="#背景-6" id="背景-6">背景</a></h2>
<p>我们团队在 futures 0.1 版本时便在项目中对其进行了广泛使用，但 futures 发展到 0.3 加上 rust 引入了async/await 关键字后，明显具有了更高的可读性和可维护性，将 futures crate 进行版本升级是迟早要做的事情。但是如果一次性将项目中所有相关代码进行升级，工作量之大明显是难以接受的，稳定性方面也难以确保。因此我们决定利用 futures 0.3 提供的兼容层，对 futures 相关代码进行逐步升级。
在本文中，我想分享一下对兼容层实现的一些理解，还有在实践中得到的一些经验。文章大致分为三部分：</p>
<ul>
<li>兼容层的大致使用方法</li>
<li>兼容层原理分析</li>
<li>实践经验</li>
</ul>
<p>部分观点可能存在过于主观，或者存在错误等情况，欢迎指正。</p>
<h2><a class="header" href="#1-future01-和-future03-的区别" id="1-future01-和-future03-的区别">1. Future01 和 Future03 的区别</a></h2>
<p>首先看看两个版本中trait的声明 (在文中，futures 0.1 的 Future trait 称为 Future01，而 futures 0.3 的称为 Future03，下同)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 0.1
pub trait Future {
    type Item;
    type Error;
    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;
}

// 0.3
pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看出，主要有三处不同：</p>
<ol>
<li>Future01 有两个关联类型 Item 和 Error，因为其中的 Poll 其实就是一个特殊的 Result 类型；
而 Future03 则只有一个关联类型 Output，而其中的 Poll 变为一个枚举类型；</li>
<li>Future03 poll 中的参数之一从 Future01 中的 &amp;mut self 变为了Pin&lt;&amp;mut Self&gt;；</li>
<li>Future03 poll 中多了一个参数cx: &amp;mut Context；
这里主要简单介绍一下第2和第3点区别：</li>
</ol>
<ul>
<li>Future03 为什么需要 Pin&lt;&amp;mut Self&gt;？首先 Pin 只会限制实现了 !Unpin 的类型的移动，而 rust 只为一些如下特例实现了 !Unpin：
<ul>
<li>PhantomPinned；</li>
<li>编译器为 async/await desugar 之后生成的 impl Future结构体；</li>
</ul>
</li>
</ul>
<p>很明显，Pin 主要是为了解决 async/await 自动生成 Future 的问题，那问题就是自引用，移动自引用结构体会造成指针失效。限于篇幅问题，这里先不再展开了，想更详细地了解关于 Pin 的知识，推荐阅读以下文章：</p>
<ol>
<li><a href="https://folyd.com/blog/rust-pin-unpin/">Rust的Pin与Unpin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/67803708">Rust Async: Pin概念解析</a></li>
</ol>
<ul>
<li>
<p>Future03 为什么需要 cx: &amp;mut Context？现在 Context 当中还是只有一个 waker: &amp;Waker 成员，新加入这个参数，按个人理解主要是用于改变按个人理解主要是用于改变 Waker（在01中起相同作用的是Notify) 设置和在 poll(..) 中对其进行获取的方式。</p>
<p>Future01 中 notify 的传入与获取大致流程：</p>
<p><img src="chapter_7/./image/ant/1.png" alt="wait_future1.png" /></p>
<p>Future 0.3 中 notify 的传入与获取大致流程：</p>
<p><img src="chapter_7/./image/ant/2.png" alt="future03_wake.png" /></p>
</li>
</ul>
<p>很明显，实现 Future01 和 03 相互间的转换只要解决以后区别即可，而实际的实现大致上也是这么一个思路。</p>
<h2><a class="header" href="#2-使用方法" id="2-使用方法">2. 使用方法</a></h2>
<p>我们的目的是在项目中让 futures 0.1 和 0.3 相关内容并存，并根据需要实现它们之间的相互转换。</p>
<h3><a class="header" href="#cargotoml-配置" id="cargotoml-配置">Cargo.toml 配置</a></h3>
<ul>
<li>首先要解决 futures 0.1 和 futures 0.3 两个 crate 都叫 futures 的问题。利用 cargo 提供的重命名功能即可，由于项目中暂时还是以 futures 0.1为主，因此把 futures 0.3 重命名为了 future03。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
futures = &quot;0.1&quot;
futures03 = { package = &quot;futures&quot;, version = &quot;0.3&quot; }
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>然后需要解决它们之间的相互转换的问题。这里可以启用 futures 0.3 提供的 compat feature，可以使用组合子的方式很方便解决相互转换的问题，在 Cargo.toml 中进行简单设置即可启用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
futures = &quot;0.1&quot;
futures03 = { package = &quot;futures&quot;, version = &quot;0.3&quot;, features = [&quot;compat&quot;] }
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#转换方法" id="转换方法">转换方法</a></h3>
<p>那么具体要如何相互转换呢？
这比较简单，利用compat组合子就可以直接实现了。</p>
<pre><pre class="playground"><code class="language-rust">use futures::future::Ok;
use futures03::compat::Future01CompatExt;
use futures03::executor::block_on;

fn main() {
    let fut01 = futures::future::ok::&lt;i32, ()&gt;(42);
    let fut03 = fut01.compat();
    let res = block_on(fut03);
    println!(&quot;the fut03 res:{}&quot;, res.unwrap());
}
</code></pre></pre>
<p>Future03 转 Future01。这就没那么简单了，能转 Future01 的 Future03 需要满足以下两个限制（文章后面会解析为什么）：</p>
<ul>
<li>这个 Future03 需要是一个TryFuture。怎样的 Future03 才会是 TryFuture 呢？其实很简单，关联类型 Output 为 Result 就行了，看相关源码就很容易知道，会自动为这类 Future 实现 TryFuture：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F, T, E&gt; TryFuture for F
where
    F: ?Sized + Future&lt;Output = Result&lt;T, E&gt;&gt;,
{
	...
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>这个 Future03 需要是 Unpin 的。Pin 解析起来比较复杂，这里就先不进行解析了，留到后面。
所以如果当前的 Future03 既不是 TryFuture，也不是 Unpin 的。那要怎么转 Future01 呢？还是利用组合子就可以解决了。</li>
</ul>
<p>unit_error 组合子可以通过将 Future03&lt;Ouput=T&gt; 转换为Future03&lt;Output=Result&lt;T, ()&gt;&gt; 解决问题1；<br />
而 boxed 组合子则可以通过将其放到堆区的方法使之满足 Unpin，从而解决问题2。</p>
<pre><pre class="playground"><code class="language-rust">use futures03::future::{FutureExt, TryFutureExt};
use futures::Future;

async fn make_fut03() -&gt; i32 {
    42
}

fn main() {
    // 这是一个既不是TryFuture也不满足Unpin的Future
    let fut03 = make_fut03();
    // let fut01 = fut03.compat(); 错误做法，编译时会报不满足trait限制的错
    let fut01 = fut03.unit_error().boxed().compat();
    let res = fut01.wait();
    println!(&quot;the fut01 res:{}&quot;, res.unwrap());
}
</code></pre></pre>
<h2><a class="header" href="#3-原理分析" id="3-原理分析">3. 原理分析</a></h2>
<h3><a class="header" href="#compat01as03-分析" id="compat01as03-分析">Compat01As03 分析</a></h3>
<p>接下来，按照以上思路简单分析一下在 futures03::compat 的具体实现，先介绍 Future01 到 Future03 的转换，主要逻辑为位于 compat/compat01as03.rs 中。</p>
<ul>
<li>关于关联类型和 Poll 的转换：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
#[must_use = &quot;futures do nothing unless you `.await` or poll them&quot;]
pub struct Compat01As03&lt;T&gt; {
    pub(crate) inner: Spawn01&lt;T&gt;,
}

impl&lt;Fut: Future01&gt; Future03 for Compat01As03&lt;Fut&gt; {
    type Output = Result&lt;Fut::Item, Fut::Error&gt;;

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; task03::Poll&lt;Self::Output&gt; {
        poll_01_to_03(self.in_notify(cx, Future01::poll))
    }
}

fn poll_01_to_03&lt;T, E&gt;(x: Result&lt;Async01&lt;T&gt;, E&gt;) -&gt; task03::Poll&lt;Result&lt;T, E&gt;&gt; {
    match x? {
        Async01::Ready(t) =&gt; task03::Poll::Ready(Ok(t)),
        Async01::NotReady =&gt; task03::Poll::Pending,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看到，Compat01As03<Fut> 被实现为 Future03&lt;Output = Result&lt;Fut::Item, Fut::Error&gt;&gt;，poll 返回值的转换逻辑也很比较简单；</p>
<ul>
<li>关于 Pin，直接为 Compat01As03 实现了 Unpin。个人看法，在这个源文件中没发现对 T 为 Unpin 的限制，或许是因为是当前如果要自行实现自引用结构，只能使用 unsafe 的缘故？</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Unpin for Compat01As03&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>将 Waker 转换为 NotifyHandle：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NotifyWaker(task03::Waker);

#[allow(missing_debug_implementations)]
#[derive(Clone)]
struct WakerToHandle&lt;'a&gt;(&amp;'a task03::Waker);

impl From&lt;WakerToHandle&lt;'_&gt;&gt; for NotifyHandle01 {
    fn from(handle: WakerToHandle&lt;'_&gt;) -&gt; Self {
		// 将waker放到堆区
        let ptr = Box::new(NotifyWaker(handle.0.clone()));
		
        // 获取指针放到NotifyHandle中
        unsafe { Self::new(Box::into_raw(ptr)) }
    }
}

// 将waker封装一层后为其实现Notify，
// notify方法的实现其实就是直接调用waker.wake_by_ref()
impl Notify01 for NotifyWaker {
    fn notify(&amp;self, _: usize) {
        self.0.wake_by_ref();
    }
}


// 在上一节所列的源码中，可以看到in_notify的身影，在这里看到：
// in_notify的作用就是将Waker转化而成的NotifyHanle传入到Spawn::poll_fn_notify中，
// 之后的过程就可以参考之前的流程图了
fn in_notify&lt;R&gt;(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;, f: impl FnOnce(&amp;mut T) -&gt; R) -&gt; R {
    let notify = &amp;WakerToHandle(cx.waker());
    self.inner.poll_fn_notify(notify, 0, f)
}
<span class="boring">}
</span></code></pre></pre>
<p>如上所述，主要实现思路还是比较简单的，将 Waker 放到堆区，然后获取其指针放到 NotifyHanle，然后将构建出的 NotifyHanle 传到 Spawn::poll_fn_notify 中。这样在调用 task.notify() 对内层 Futures01 进行唤醒时，就能转而调用外层 Compat01As03 的 waker.wake_by_ref()，对其进行唤醒，其他相关函数同理。</p>
<h3><a class="header" href="#compat-分析" id="compat-分析">Compat 分析</a></h3>
<p>Future03 到 01 的思路也是比较类似的，主要逻辑位于 compat/compat03as01.rs。</p>
<ul>
<li>关于关联类型和Poll的转换：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]
#[must_use = &quot;futures do nothing unless you `.await` or poll them&quot;]
pub struct Compat&lt;T&gt; {
    pub(crate) inner: T,
}

fn poll_03_to_01&lt;T, E&gt;(x: task03::Poll&lt;Result&lt;T, E&gt;&gt;) -&gt; Result&lt;Async01&lt;T&gt;, E&gt; {
    match x? {
        task03::Poll::Ready(t) =&gt; Ok(Async01::Ready(t)),
        task03::Poll::Pending =&gt; Ok(Async01::NotReady),
    }
}

impl&lt;Fut&gt; Future01 for Compat&lt;Fut&gt;
where
	// 注意这里，对Fut进行了限制，需要实现TryFuture03和Unpin
    Fut: TryFuture03 + Unpin,
{
    type Item = Fut::Ok;
    type Error = Fut::Error;

    fn poll(&amp;mut self) -&gt; Poll01&lt;Self::Item, Self::Error&gt; {
        with_context(self, |inner, cx| poll_03_to_01(inner.try_poll(cx)))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看到，Compat<T> 被实现为 Future01&lt;Item = Fut::Ok, Error = Fut::Error&gt;，poll 返回值的转换逻辑同样比较简单。从源码中可以看出 Fut 需要实现 TryFuture03 和 Unpin，这就能解析为什么 Future03 转 01 需要用到unit_error 和 boxed 组合子(详细可看第一章)。</p>
<ul>
<li>关于 Pin，Future03 一般是由 async/await 自动生成而来的，而入本章第一节所示，该自动生成的 Future 是少数由rust 自动实现 !Unpin 的类型之一，所以这里进行了限制，只会有关联类型 T 满足 Unpin的Compat<T> 实现Future01。</li>
</ul>
<p>当想要将 async/await 自动生成的 Future03(大多数情况下) 转化为 Future01 时，必须先调用boxed 组合子
重建构建一个满足 Unpin的 新 Future03。</p>
<ul>
<li>将 NotifyHandle 转换为 Waker：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Current(task01::Task);

impl Current {
    fn new() -&gt; Self {
       	// 注意了, 这里是不是很眼熟, task::current()可以获取当前的Task结构，
        // 然后利用其构建Current结构，并转换为空指针在构建RawWaker时候传入，
        // 最后再经由vtable调用并传参到wake中，最终进行熟悉的task.notify()调用。
        Self(task01::current())
    }

    fn as_waker(&amp;self) -&gt; WakerRef&lt;'_&gt; {
        // 对指针解引用后获取再借用
        unsafe fn ptr_to_current&lt;'a&gt;(ptr: *const ()) -&gt; &amp;'a Current {
            &amp;*(ptr as *const Current)
        }

        // 将self转为void*
        fn current_to_ptr(current: &amp;Current) -&gt; *const () {
            current as *const Current as *const ()
        }
		
        // vtable中需要实现的方法 ////////////////////////////////
        unsafe fn clone(ptr: *const ()) -&gt; RawWaker {
   			...
        }

        unsafe fn drop(_: *const ()) {}

        unsafe fn wake(ptr: *const ()) {
            ptr_to_current(ptr).0.notify()
        }
		////////////////////////////////////////////////////////
       	
        // 将self转化为空指针，主要为了之后构建RawWaker时传入
        let ptr = current_to_ptr(self);

        // 构建vtable
        let vtable = &amp;RawWakerVTable::new(clone, wake, wake, drop);
        
        // 构建RawWaker，构建Waker
        WakerRef::new_unowned(std::mem::ManuallyDrop::new(unsafe {
            task03::Waker::from_raw(RawWaker::new(ptr, vtable))
        }))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在注释中已经说的较为详细了，具体的思路和 Compat01As03 是类似的，为了能在调用内层 Future03 waker.wake()/waker.wake_by_ref() 时，能转而调用到外层 Compat 的 task.notify()，从而对其进行唤醒，其他相关函数亦同理。</p>
<h2><a class="header" href="#4-一些实践经验" id="4-一些实践经验">4. 一些实践经验</a></h2>
<h3><a class="header" href="#如何较好地进行局部升级" id="如何较好地进行局部升级">如何较好地进行局部升级</a></h3>
<p>在这次的任务中，我需要对特定路径进行 futures 0.1 到 0.3 的升级，以适配想要加入到项目中的 crate。我想趁机在相关路径上引入 async/await，以提高代码可读性和可维护性。在实现的过程中，主要遇到了两个问题：</p>
<ul>
<li>当前 Trait 不支持 async fn；</li>
<li>还需要保持旧的 runtime，因为如果升级 runtime 的话，影响太大(几乎要对整个项目所有相关的地方进行升级)；</li>
</ul>
<p>对于 Trait 不支持 async fn 的问题，暂时可以通过使用第三方库 async-trait 来解决，使用方法很简单。其大致原理是，async_trait 宏将代码转换为一个返回 Pin&lt;Box&lt;dyn Future + Send + 'async&gt;&gt; 的同步方法。</p>
<pre><pre class="playground"><code class="language-rust">use futures03::executor::block_on;
use async_trait::async_trait;

#[async_trait]
trait TestTrait {
    async fn method1(&amp;self);
    async fn method2(&amp;self);
}

struct TestStruct;

#[async_trait]
impl TestTrait for TestStruct {
    async fn method1(&amp;self) {
        println!(&quot;I am async method1&quot;);
    }

    async fn method2(&amp;self) {
        println!(&quot;I am async method2&quot;);
    }
}

fn main() {
    let ts = TestStruct;
    block_on(ts.method1());
    block_on(ts.method2());
}
</code></pre></pre>
<p>那么如何有效地在保持旧版本 runtime 的情况下，将调用路径升级到 async/await 方式呢？个人比较推荐将最底层返回的 Future01 使用 compat 组合子转为 03，然后中间路径一直使用 async/await，再在最上层再次使用 compat 等组合子再次转为 Future01，放入到旧版 runtime 执行，示例如下：</p>
<pre><pre class="playground"><code class="language-rust">use futures::Future;
use futures03::compat::Future01CompatExt;
use futures03::{FutureExt, TryFutureExt};
use futures_cpupool::CpuPool;

type BoxedFuture&lt;T&gt; = Box&lt;dyn Future&lt;Item = T, Error = ()&gt; + Send&gt;;

fn func1() -&gt; BoxedFuture&lt;i32&gt; {
    Box::new(futures::future::ok(42))
}

async fn func2() -&gt; Result&lt;i32, ()&gt; {
    // convert to Future 0.3
    let res1_compat_03 = func1().compat().await?;
    Ok(res1_compat_03 + 42)
}

async fn func3() -&gt; Result&lt;i32, ()&gt; {
    let res2_03 = func2().await?;
    Ok(res2_03 + 42)
}

fn main() {
    let pool = CpuPool::new(4);

    let fut03 = func3();
    // convert back to Future 0.1
    let fut01 = fut03.boxed().compat();

    // spawn to the old runtime
    let res = pool.spawn(fut01).wait();
    
    println!(&quot;res:{}&quot;, res.unwrap());
}
</code></pre></pre>
<h3><a class="header" href="#返回-future-的函数和-async-fn-的区别" id="返回-future-的函数和-async-fn-的区别">返回 Future 的函数和 async fn 的区别</a></h3>
<p>在 futures 0.1 中，由于没有 async fn 所以返回 Future 的函数是一种比较普遍的写法，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type BoxedFuture&lt;T&gt; = Box&lt;dyn Future&lt;Item = T, Error = ()&gt; + Send&gt;;

fn func1() -&gt; BoxedFuture&lt;i32&gt; {
    Box::new(futures::future::ok(42))
}
<span class="boring">}
</span></code></pre></pre>
<p>但这和 async fn 其实是有着微妙的区别，借用 minitrace-rust crate 来进行示例（这里返回的是 Future03，因为这是 01 和 03 共有的区别，用 01 来写这例子的话要多次来回 compat，代码非常绕）</p>
<pre><pre class="playground"><code class="language-rust">use futures03::{Future as Future03, FutureExt};
use minitrace::{CollectArgs, FutureExt as MiniFutureExt, Span};
use std::pin::Pin;

type BoxedFuture&lt;T&gt; = Pin&lt;Box&lt;dyn Future03&lt;Output=T&gt; + Send&gt;&gt;;

async fn func1() -&gt; i32 {
    42
}

// async fn func2() -&gt; i32 {
//     func1().in_span(Span::from_local_parent(&quot;func1&quot;)).await
// }

fn func2() -&gt; BoxedFuture&lt;i32&gt; {
    func1().in_span(Span::from_local_parent(&quot;func1&quot;)).boxed()
}

#[tokio::main]
async fn main() {
    let (span, collector) = Span::root(&quot;func2&quot;);
    let f = func2().in_span(span);

    tokio::spawn(f).await.unwrap();

    let spans = collector.collect_with_args(CollectArgs::default().sync(true));

    for span in spans {
        println!(&quot;span: event:{}, id:{}, pid:{}&quot;, span.event, span.id, span.parent_id);
    }
}


#当前结果：
span: event:func2, id:1, pid:0

#注释掉func2，而去除async func2注释后结果：
span: event:func1, id:65537, pid:1
span: event:func2, id:1, pid:0

</code></pre></pre>
<p>可以看出，当把 async fn func2() -&gt; i32 改成 func2() -&gt; BoxedFuture<i32> 后，func1 相关的 span 生成失败了 (Span::from_local_parent(&quot;func1&quot;))，这是为什么呢？</p>
<p>我刚开始遇到这个问题时也被搞晕了，后来用调试器进行跟踪，发现问题主要在于各层次 Future 生成和 poll() 执行顺序方面。</p>
<ul>
<li>async fn 情况下的大致执行顺序，GenFutureFuncx 表示 funcx 所生成或返回的 Future：</li>
</ul>
<p><img src="chapter_7/./image/ant/3.png" alt="afunc2.png" /></p>
<ul>
<li>返回 Future 的 fn 情况下的可能执行顺序：</li>
</ul>
<p><img src="chapter_7/./image/ant/4.png" alt="sfunc2.png" /></p>
<p>正如流程图中所示，导致最终结果差别的，正是 Span::from_local_parent() 和 最外层 InSpan::poll() 执行的先后顺序不同（在上述流程图中对这两个步骤进行了相关标注）。</p>
<p>因为经过在 InSpan::poll() 中会将进行一些操作，产生一个与当前线程绑定的 span_id 作为所谓的local_parent，而在返回 Future 的情况下，Span::from_local_parent() 先于 最外层 InSpan::poll() 执行从而导致了前者的执行失败，因为 local_parent 在其执行时根本还没被构建。</p>
<p>这个差别比较隐蔽，一般也不会造成影响，毕竟 Future::poll() 的执行顺序还是正确的，但在以上例子中还是使执行结果产生了差异，还是值得稍微知道一下的。</p>
<h2><a class="header" href="#5-总结" id="5-总结">5. 总结</a></h2>
<p>以上为本人对 futures 兼容层的一些理解和经验，之前由于要进行这方面的工作，看了比较多的相关资料，但一直没空进行梳理。这次重新看了一下并进行总结，感觉还是收获颇大的。</p>
<h2><a class="header" href="#参考-8" id="参考-8">参考</a></h2>
<ol>
<li><a href="https://segmentfault.com/a/1190000025153586">异步代码的几种写法 Rust学习笔记</a></li>
<li><a href="https://rust-lang.github.io/futures-rs/blog/2019/04/18/compatibility-layer.html">Compatibility Layer</a></li>
<li><a href="https://snowstar.org/2019/11/30/rust-future-async-and-await/">Rust - Future与异步</a></li>
<li><a href="https://copyfuture.com/blogs-details/20190927110724330tylc3e6v1u655pl">TiKV Rust Client 迁移记 - Futures 0.1 至 0.3</a></li>
<li><a href="https://folyd.com/blog/rust-pin-unpin/">Rust的Pin与Unpin</a></li>
<li><a href="https://os.phil-opp.com/async-await/#executor-with-waker-support">Async/Await</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/67803708">Rust Async: Pin概念解析</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">rfcs - 2349</a></li>
</ol>
<h1><a class="header" href="#字节跳动--飞书-rust-实践-之-sqlite-适配-wasm" id="字节跳动--飞书-rust-实践-之-sqlite-适配-wasm">字节跳动 ｜ 飞书 Rust 实践 之 SQLite 适配 WASM</a></h1>
<p>作者：木色 / 后期编辑：张汉东</p>
<hr />
<blockquote>
<p>飞书在做WASM的适配，分享下关系型数据库SQLite适配WASM的历程。</p>
</blockquote>
<p>SQLite是一个跨平台的关系型数据库，广泛使用于客户端开发，飞书也使用SQLite作为数据持久化存储；同时为了方便上层使用，采用了diesel作为orm与SQLite进行交互，整体使用方式为：</p>
<pre><code class="language-js">rust code -&gt; diesel orm -&gt; sqlite ffi
</code></pre>
<p>调用情况如图：</p>
<p><img src="chapter_7/./image/lark/1.png" alt="1.png" /></p>
<p>为了将SQLite移植到WEB上，我们需要做两部分内容：</p>
<ol>
<li>将sqlite编译到wasm平台</li>
<li>封装wasm平台的跨模块调用接口给diesel使用</li>
</ol>
<p>考虑到WEB上持久化存储机制的脆弱，以及业务形态考量，在WEB上并不需要做持久化，暂时只做一个<strong>内存中的关系型数据库</strong>；确定好这几个特点要求，我们SQLite的WASM移植之路开始了，Let's Go!</p>
<h1><a class="header" href="#wasm的工作模式" id="wasm的工作模式">WASM的工作模式</a></h1>
<p>目前WASM实际有三种工作模式：Emscripten模式、WASI模式和无任何依赖的纯粹模式，在Rust语言中，分别对应<code>wasm32-unknown-emscripten</code>、<code>wasm32-wasi</code>、<code>wasm32-unknown-unknown</code>三种编译目标；前两种模式的wasm产物分别需要宿主提供posix接口和wasi接口功能，最后一种模式完全没有外部依赖</p>
<p>对于这三种模式，对C/C++代码的友好度：<code>Emscripten&gt;Wasi&gt;&gt;Unknown</code></p>
<p>rust社区的生态基本是围绕着<code>wasm32-unknown-unknown</code>和<code>wasm32-wasi</code>构建的，如wasm-bindgen工具等；不过考虑到unknown环境对外部依赖少，所以sdk中的rust代码我们就先确定了，优先使用<code>wasm32-unknown-unknown</code>模式，<code>wasm32-wasi</code>模式次之。而对于sqlite部分，我们则将三种wasm工作模式都尝试了：</p>
<h1><a class="header" href="#emscripten模式适配" id="emscripten模式适配">Emscripten模式适配</a></h1>
<p>Emscripten是用于帮助将C/C++代码编译到WASM目标格式的工具链，并且提供posix相关调用的模拟功能。</p>
<h2><a class="header" href="#编译出emscripten产物" id="编译出emscripten产物">编译出emscripten产物</a></h2>
<p>SQLite是一个C库，用emscripten很方便地就可以将SQLite编译为wasm，这个过程很简单，使用emcc就可以直接编译（可以参考：https://github.com/sql-js/sql.js/blob/master/Makefile）</p>
<p>第一步编译sqlite到wasm轻松搞定：我们将sqlite编译为一个emscripten target的wasm实例，由前端负责加载；然后在sdk侧，通过wasm的abi接口调用sqlite wasm实例提供的接口。</p>
<h2><a class="header" href="#sqlite接口调用" id="sqlite接口调用">SQLite接口调用</a></h2>
<p>但是到第二步，提供wasm的ffi给diesel时，我们遇到了麻烦：默认diesel使用的libsqlite-sys提供的是C abi的ffi，在native环境，SQLite库和ffi的使用者共享同一个内存空间，所以很多事情都比较容易处理，比如内存分配或者指针的直接操作等；但是如果sqlite编译成一个单独的wasm实例，ffi部分作为一个独立的wasm实例调用sqlite时，两个wasm实例在不同的内存空间，不能直接使用指针等依赖相同内存空间的操作，这就导致emscripten target下的ffi调用流程都需要全新实现。</p>
<h3><a class="header" href="#使用类似动态库方式调用" id="使用类似动态库方式调用">使用类似动态库方式调用</a></h3>
<p>具体表现为：先异步启动sqlite wasm实例，并将实例导出的接口挂在js全局对象window上，然后在rust中通过wasm-bindgen来绑定这些js接口。比如sqlite连接db创建db连接时传入db路径的操作，wasm环境需要调用wasm的内存分配函数分配内存，并写入数据：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// native版操作

pub fn establish(raw_database_url: &amp;str) -&gt; ConnectionResult&lt;Self&gt; {

    let mut conn_pointer = ptr::null_mut();

    let database_url = CString::new(raw_database_url.trim_start_matches(&quot;sqlite://&quot;))?;

    let connection_status = unsafe { ffi::sqlite3_open(database_url.as_ptr(), &amp;mut conn_pointer) };

    ...

}

// wasm版操作

#[wasm_bindgen]

extern &quot;C&quot; {

    // sqliteBindings是挂在window上的全局对象

    // allocateUTF8、stackAlloc是emscripten wasm导出的字符串、栈内存分配接口

    #[wasm_bindgen(js_namespace = sqliteBindings, js_name = allocateUTF8)]

    pub fn allocate_utf8(s: &amp;str) -&gt; *const i8;

    #[wasm_bindgen(js_namespace = sqliteBindings, js_name = stackAlloc)]

    pub fn stack_alloc_sqlite3(size: usize) -&gt; *mut *mut ffi::sqlite3;

}

pub fn establish(raw_database_url: &amp;str) -&gt; ConnectionResult&lt;Self&gt; {

    let conn_pointer = stack_alloc_sqlite3(0);

    let database_url_ptr = allocate_utf8(raw_database_url.trim_start_matches(&quot;sqlite://&quot;));

    let connection_status = unsafe { ffi::sqlite3_open(database_url_ptr, conn_pointer) };

    ...

}
<span class="boring">}
</span></code></pre></pre>
<p>对于diesel中用到sqlite的地方都类似添加wasm支持，我们实现了在emscripten模式下工作的diesel+sqlite，其数据流动方式为：</p>
<p><img src="chapter_7/./image/lark/2.png" alt="2.png" /></p>
<p>这种工作模式下，sqlite是一个独立的wasm实例，其他的lark sdk代码是一个实例，实际运行时，先由js代码加载sqlite的wasm实例，再加载sdk的wasm实例，之后sdk中的diesel代码通过封装好的交互接口调用sqlite实例的功能。</p>
<p>这个工作模式下，每次sqlite的调用都涉及到两个wasm实例间数据的拷贝（不同wasm实例的内存空间是独立的），对于db这种高频率数据调用场景来说开销过大。</p>
<p>因此我们考虑：能否能将sqlite实例和其他sdk实例代码合并生成一个wasm实例？如果sqlite是一个emscripten模式的wasm，sdk其他代码就也必须打成emscripten模式，但是如前面所述，rust的wasm生态的核心是<code>wasm32-unknown-unknown</code>和<code>wasm32-wasi</code>，所以如果想做到一个实例包含sdk代码和sqlite，就不能使用<code>wasm32-unknown-emscripten</code>模式。另外，在<code>wasm32-wasi</code>和<code>wasm32-unknown-unknown</code>模式下，我们可以使用C的abi，也就是不需要如emscripten模式的wasm接口封装，可以类似native平台下的方式从rust调用sqlite。</p>
<h1><a class="header" href="#wasi模式适配" id="wasi模式适配">WASI模式适配</a></h1>
<p>在优化sdk和sqlite为一个实例的实践中，我们排除了Emscripten模式的使用；而在wasi和unknown模式中，wasi是一个对C/C++代码更加友好的平台，wasi标准中的接口和posix比较接近。</p>
<p>但是wasi目前一般是在非WEB平台执行的，想要在web上跑就需要提供wasi需要的对应功能的模拟，幸运的是，社区已经有了对应功能：https://github.com/wasmerio/wasmer-js/tree/master/packages/wasi</p>
<p>运行的宿主环境搞定了，我们来看sqlite本身；目前sqlite是没有提供wasi的官方支持的，但是sqlite有一个非常灵活的架构：</p>
<p><img src="chapter_7/./image/lark/3.png" alt="3.png" /></p>
<p>SQLite将所有平台相关的操作都封装在了OS对应模块中，并且通过VFS的方式抽象了平台功能使用，那么只要我们实现一个在WASI模式下工作的vfs即可</p>
<p>直接参考官方的实现https://www.sqlite.org/src/doc/trunk/src/test_demovfs.c， 编译时打开SQLITE_OS_OTHER选项，并链接到我们对应的C语言实现的vfs，配合wasmer-js的wasi模拟，终于，我们将sqlite和sdk其他代码都打成一个wasm32-wasi模式的wasm实例。</p>
<p>但是。。。</p>
<p>一次升级rust版本后，发现wasm-bindgen不再工作了。。。详情见：https://github.com/rustwasm/wasm-bindgen/issues/2471， 问题原因是2021年1月13日，rust合并了一个更改wasi模式下abi格式的提交，在这个之前rust下wasi模式和unknown模式的abi是一致的，但是这个提交之后，两者分叉了，而且wasm-bindgen官方也没有适配wasi的计划。。。</p>
<p>所以现在留给我们的只剩下一条路了：wasm32-unknown-unknown</p>
<h1><a class="header" href="#unknown模式适配" id="unknown模式适配">Unknown模式适配</a></h1>
<p>unknown模式是对C/C++最不友好的模式：没有头文件声明、没有字符串操作方法、没有fd相关方法甚至连malloc都没有。。。不过只有这一条路了，见山开山，遇海填海</p>
<p>有三个功能需要提供在Unknown模式下工作的实现：内存分配器、用到的C函数、VFS实现</p>
<h2><a class="header" href="#内存分配器适配" id="内存分配器适配">内存分配器适配</a></h2>
<p>C语言在wasm32-unknown-unknown模式下是没有提供malloc的封装的，但是rust里面有内存相关的封装，那么我们可以在rust中实现malloc方法供sqlite链接后调用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 为了最小影响，更改了malloc的调用名

#[cfg(all(target_arch = &quot;wasm32&quot;, target_os = &quot;unknown&quot;))]

mod allocator {

    use std::alloc::{alloc, dealloc, realloc as rs_realloc, Layout};

    #[no_mangle]

    pub unsafe fn sqlite_malloc(len: usize) -&gt; *mut u8 {

        let align = std::mem::align_of::&lt;usize&gt;();

        let layout = Layout::from_size_align_unchecked(len, align);

        let ptr = alloc(layout);

        ptr

    }

    const SQLITE_PTR_SIZE: usize = 8;

    #[no_mangle]

    pub unsafe fn sqlite_free(ptr: *mut u8) -&gt; i32 {

        let mut size_a = [0; SQLITE_PTR_SIZE];

        size_a.as_mut_ptr().copy_from(ptr, SQLITE_PTR_SIZE);

        let ptr_size: u64 = u64::from_le_bytes(size_a);

        let align = std::mem::align_of::&lt;usize&gt;();

        let layout = Layout::from_size_align_unchecked(ptr_size as usize, align);

        dealloc(ptr, layout);

        0

    }

    #[no_mangle]

    pub unsafe fn sqlite_realloc(ptr: *mut u8, size: usize) -&gt; *mut u8 {

        let align = std::mem::align_of::&lt;usize&gt;();

        let layout = Layout::from_size_align_unchecked(size, align);

        rs_realloc(ptr, layout, size)

    }

}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#libc功能提供" id="libc功能提供">libc功能提供</a></h2>
<p>打开SQLITE_OS_OTHER开关后，因为不再使用系统的接口，对libc的依赖已经少了很多，但是还有几个基础非系统函数依赖：</p>
<pre><code class="language-C">strcspn
strcmp/strncmp
strlen
strchr/strrchr
qsort
</code></pre>
<p>字符串的几个函数非常简单，直接自己实现就行；而对最后一个qsort函数，拷贝许可证宽松的三方实现就行</p>
<h2><a class="header" href="#vfs实现" id="vfs实现">VFS实现</a></h2>
<p>emscripten和wasi都是利用宿主提供的虚拟文件系统进行操作，在unknown模式下为了不增加外部依赖，我们可以直接在sdk代码内部提供一个memory vfs供sqlite使用。</p>
<p>实现vfs的核心是提供两个结构体实现：</p>
<pre><code class="language-C">typedef struct sqlite3_vfs sqlite3_vfs;

typedef void (*sqlite3_syscall_ptr)(void);

struct sqlite3_vfs {

    int iVersion; /* Structure version number (currently 3) */

    int szOsFile; /* Size of subclassed sqlite3_file */

    int mxPathname; /* Maximum file pathname length */

    sqlite3_vfs *pNext; /* Next registered VFS */

    const char *zName; /* Name of this virtual file system */

    void *pAppData; /* Pointer to application-specific data */

    int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,

    int flags, int *pOutFlags);

    int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);

    int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);

    int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);

    void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);

    void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);

    void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);

    void (*xDlClose)(sqlite3_vfs*, void*);

    int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);

    int (*xSleep)(sqlite3_vfs*, int microseconds);

    int (*xCurrentTime)(sqlite3_vfs*, double*);

    int (*xGetLastError)(sqlite3_vfs*, int, char *);

    /*

    ** The methods above are in version 1 of the sqlite_vfs object

    ** definition. Those that follow are added in version 2 or later

    */

    int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);

    /*

    ** The methods above are in versions 1 and 2 of the sqlite_vfs object.

    ** Those below are for version 3 and greater.

    */

    int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);

    sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);

    const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);

    /*

    ** The methods above are in versions 1 through 3 of the sqlite_vfs object.

    ** New fields may be appended in future versions. The iVersion

    ** value will increment whenever this happens.

    */

};

typedef struct sqlite3_io_methods sqlite3_io_methods;

struct sqlite3_io_methods {

    int iVersion;

    int (*xClose)(sqlite3_file*);

    int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);

    int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);

    int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);

    int (*xSync)(sqlite3_file*, int flags);

    int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);

    int (*xLock)(sqlite3_file*, int);

    int (*xUnlock)(sqlite3_file*, int);

    int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);

    int (*xFileControl)(sqlite3_file*, int op, void *pArg);

    int (*xSectorSize)(sqlite3_file*);

    int (*xDeviceCharacteristics)(sqlite3_file*);

    /* Methods above are valid for version 1 */

    int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);

    int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);

    void (*xShmBarrier)(sqlite3_file*);

    int (*xShmUnmap)(sqlite3_file*, int deleteFlag);

    /* Methods above are valid for version 2 */

    int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);

    int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);

    /* Methods above are valid for version 3 */

    /* Additional methods may be added in future releases */

};
</code></pre>
<h3><a class="header" href="#使用rust实现vfs" id="使用rust实现vfs">使用rust实现vfs</a></h3>
<p>实现一个memvfs，至少需要一个可动态调整的容器；而C语言官方没有这种容器，如果要使用C语言实现memvfs，那只能自己实现一个类似的HashMap或者LinkedList，稍显麻烦；所以这块逻辑也用rust实现了。</p>
<h4><a class="header" href="#vfs绑定" id="vfs绑定">VFS绑定</a></h4>
<p>在rust代码中，提供一个sqlite3_os_init的方法出来，在和sqlite链接时，会自动链接到这个函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]

pub unsafe fn sqlite3_os_init() -&gt; std::os::raw::c_int {
    let mut mem_vfs = Box::new(super::memvfs::get_mem_vfs());

    let mem_vfs_ptr: *mut crate::sqlite3_vfs = mem_vfs.as_mut();

    let rc = crate::sqlite3_vfs_register(mem_vfs_ptr, 1);

    debug!(&quot;sqlite3 vfs register result: {}&quot;, rc);

    std::mem::forget(mem_vfs);

    rc
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#内存数据存储容器" id="内存数据存储容器">内存数据存储容器</a></h4>
<p>因为要支持多个路径，所以最简单的实现就是提供一个HashMap，使用路径作为key：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node {
    size: usize,
    data: Vec&lt;u8&gt;,
}

lazy_static! {
    static ref FS: RwLock&lt;HashMap&lt;String, Arc&lt;RwLock&lt;Node&gt;&gt;&gt;&gt; = RwLock::new(HashMap::new());
}
<span class="boring">}
</span></code></pre></pre>
<p>数据读写接口：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn copy_out(&amp;self, dst: *mut raw::c_void, offset: isize, count: usize) -&gt; Option&lt;()&gt; {
        if self.size &lt; offset as usize + count {
            log::trace!(&quot;handle invalid input offset&quot;);
            return None;
        }

        let ptr = self.data.as_ptr();

        let dst = dst as *mut u8;

        unsafe {
            let ptr = ptr.offset(offset);
            ptr.copy_to(dst, count);
        }

        Some(())
 }

 fn write_in(&amp;mut self, src: *const raw::c_void, offset: isize, count: usize) {
        let new_end = offset as usize + count;
        
        // 这里注意要根据传入的offset做扩容
        let count_extend: isize = new_end as isize - self.data.len() as isize;
        if count_extend &gt; 0 {
            self.data.extend(vec![0; count_extend as usize]);
        }

        if new_end &gt; self.size {
            self.size = new_end;
        }

        let ptr = self.data.as_mut_ptr();

        unsafe {
            let ptr = ptr.offset(offset);
            ptr.copy_from(src as *const u8, count);
        }
 }
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#vfs实现-1" id="vfs实现-1">VFS实现</a></h4>
<p>在<code>sqlite3_vfs</code>的<code>xOpen</code>方法实现中注册对应自定义的<code>sqlite3_io_methods</code></p>
<p>借助上述的工作，我们最终将sqlite编译为wasm32-unknown-unknown模式下的wasm文件，同时上层使用可以直接复用diesel，做到业务代码不用改动。</p>
<p>至此，lark sdk在web上的工作模式为：</p>
<p><img src="chapter_7/./image/lark/4.png" alt="4.png" /></p>
<p>整体工作模式再次和native平台对齐了，无外部依赖，查询时也不需要wasm实例之间的数据拷贝。</p>
<h1><a class="header" href="#datenlord--rust实现rdma异步编程二async-rust-封装-ucx-通信库" id="datenlord--rust实现rdma异步编程二async-rust-封装-ucx-通信库">Datenlord | Rust实现RDMA异步编程（二）：async Rust 封装 UCX 通信库</a></h1>
<p>作者：王润基</p>
<hr />
<p>UCX 是一个高性能网络通信库，它作为 MPI 所依赖的通信模块之一在高性能计算领域得到广泛的使用。UCX 使用 C 语言编写，为了在 Rust 项目中使用它，我们需要将它的 C 接口包装成 Rust 库。在这个过程中我们充分利用了 Rust 的杀手级特性—— async-await 协程来包装异步 IO 接口，从而极大降低了应用的编程复杂度。</p>
<p>去年我们用 Rust 实现的高性能分布式文件系统 MadFS，底层就使用了我们自己包装过的 UCX 作为通信模块，它在大规模 RDMA 网络上展现出了良好的性能。UCX 官方在得知这一消息后也很开心地宣传了我们这个项目 :)</p>
<p><img src="chapter_7/./image/rdma/ucx-twitter.png" alt="1" /></p>
<p>本文首先会介绍一下 UCX 通信库的功能和编程模型，然后介绍我们用 async Rust 封装 UCX 的过程，具体代码可以参考 GitHub 仓库：<a href="https://github.com/madsys-dev/async-ucx">async-ucx</a>。值得注意的是，这里介绍的 IO 模型和封装异步 IO 的方法是通用的，可以适用到其它 IO 库当中。</p>
<h2><a class="header" href="#ucx-通信接口简介" id="ucx-通信接口简介">UCX 通信接口简介</a></h2>
<p>UCX 的全称是 Unified Communication X。正如它名字所展示的，UCX 旨在提供一个统一的抽象通信接口，能够适配任何通信设备，并支持各种应用的需求。</p>
<p>下图是 UCX 官方提供的架构图：</p>
<p><img src="chapter_7/./image/rdma/Architecture.png" alt="2" /></p>
<p>可以看到，UCX 整体分为两层：上层的 UCP 接口和底层的 UCT 接口。</p>
<p>底层的 UCT 适配了各种通信设备：从单机的共享内存，到常用的 TCP Socket，以及数据中心常用的 RDMA 协议，甚至新兴的 GPU 上的通信，都有很好的支持。</p>
<p>上层的 UCP 则是在 UCT 不同设备的基础上，封装了更抽象的通信接口，以方便应用使用。具体来说有以下几类：</p>
<ul>
<li>Active Message：最底层的接口，提供类似 RPC 的语义。每条 Active Message 会触发接收端进行一些操作。</li>
<li>RMA / Atomic：是对远程直接内存访问（RDMA）的抽象。通信双方可以直接读写远端的内存，但是需要有额外的内存注册过程。</li>
<li>Tag Matching：常用于高性能计算 MPI 程序中。每条消息都会附带一个 64 位整数作为 tag，接收方每次可以指定接收哪种 tag 的消息。</li>
<li>Stream：对字节流（TCP）的抽象。</li>
</ul>
<p>一般来说，和底层通信设备模型最匹配的接口具有最高的性能，其它不匹配的接口都会有一次软件转换过程。另一方面，同一种 UCP 接口发送不同大小的消息可能也会使用不同的 UCT 方法。例如在 RDMA 网络中，由于内存注册也有不小的开销，因此对于小消息来说，拷贝到预注册好的缓冲区再发送的性能更高。这些策略默认是由 UCX 自己决定的，用户也可以通过设置环境变量的方式手动修改。</p>
<blockquote>
<p>在我们的系统中，使用了 UCP Tag 接口并基于此实现了轻量级的 RPC。在 RPC 场景下，Tag 可以用于区分不同上下文的消息：每个链接双方首先随机生成一个 tag 作为请求的标识，对于每次请求再随机生成一个 tag 作为回复的标识。此外 Tag 接口还支持 IO Vector，即将不连续的多个内存段合并成一个消息发送。这个特性可以用来将用户提供的数据缓冲区和 RPC 请求打包在一起，一定程度上避免数据拷贝。</p>
</blockquote>
<h2><a class="header" href="#ucx-编程模型简介" id="ucx-编程模型简介">UCX 编程模型简介</a></h2>
<p>UCX 采用了以异步 IO 为核心的编程模型。其中 UCP 层定义的核心对象有以下四种：</p>
<ul>
<li>Context：全局资源的上下文，管理所有通信设备。一般每个进程创建一个即可。</li>
<li>Worker：任务的管理调度中心，以轮询方式执行任务。一般每个线程创建一个，会映射为网卡上的一个队列。</li>
<li>Listener：类似 TCP Listener，用来在 worker 之间创建连接。</li>
<li>Endpoint：表示一个已经建立的连接。在此之上提供了各种类型的通信接口。</li>
</ul>
<p>它们之间的所属关系如下图所示：</p>
<p><img src="chapter_7/./image/rdma/ucp.png" alt="3" /></p>
<h3><a class="header" href="#建立连接" id="建立连接">建立连接</a></h3>
<p>UCX 中双方首先要建立连接，拿到一个 Endpoint 之后才能进行通信。建立连接一般要通过 Listener，过程和 TCP 比较类似：</p>
<p>通信双方 A/B 首先建立各自的 Context 和 Worker，其中一方 A 在 Worker 上创建 Listener 监听连接请求，Listener 的地址会绑定到本机的一个端口上。用户需要通过某种方法将这个地址传递给另一方 B。B 拿到地址后在 Worker 上发起 connect 操作，此时 A 会收到新连接请求，它可以选择接受或拒绝。如果接受则需要在 Worker 上 accept 这个请求，将其转换为 Endpoint。之后 B 会收到 A 的回复，connect 操作完成，返回一个 Endpoint。此后双方就可以通过这对 Endpoint 进行通信了。</p>
<h3><a class="header" href="#内存注册" id="内存注册">内存注册</a></h3>
<p>对于常规的通信接口，用户可以直接在 Endpoint 上发起请求。但对于 RMA（远程内存访问）操作，需要被访问的一方首先在自己的 Context 上注册内存，同时指定访问权限，获得一个 Mem handle。然后将这个本地 handle 转化为其他节点可以访问的一串 token，称为 remote key（rkey）。最后想办法把 rkey 传给远端。远端拿着这个 rkey 进行远程内存访问操作。</p>
<h3><a class="header" href="#异步任务处理重点" id="异步任务处理重点">异步任务处理（重点）</a></h3>
<p>为了发挥最高的性能，整个 UCX 通信接口是全异步的。所谓异步指的是 <strong>IO 操作的执行不会阻塞当前线程</strong>，一次操作的发起和完成是独立的两个步骤。如此一来 CPU 就可以同时发起很多 IO 请求，并且在它们执行的过程中可以做别的事情。</p>
<p>不过接下来问题来了：程序如何知道一个异步任务是否完成了？常见的有两种做法：主动轮询，被动通知。前者还是需要占用 CPU 资源，所以一般都采用通知机制。在 C 这种传统过程式语言中，异步完成的通知一般通过 **回调函数（callback）**实现：每次发起异步操作时，用户都需要传入一个函数指针作为参数。当任务完成时，后台的运行时框架会调用这个函数来通知用户。下面是 UCX 中一个异步接收接口的定义：</p>
<pre><code class="language-c">ucs_status_ptr_t ucp_tag_recv_nb (
  ucp_worker_h worker,
  void ∗ buffer,
  size_t count,
  ucp_datatype_t datatype,
  ucp_tag_t tag,
  ucp_tag_t tag_mask,
  ucp_tag_recv_callback_t cb  // &lt;-- 回调函数
);

// 回调函数接口的定义
typedef void(∗ ucp_tag_recv_callback_t) (
  void ∗request, 
  ucs_status_t status,        // 执行结果，错误码
  ucp_tag_recv_info_t ∗info   // 更多信息，如收到的消息长度等
);
</code></pre>
<p>这个接口的语义是：发起一个异步 Tag-Matching 接收操作，并立即返回。当真的收到 tag 匹配的消息时，UCX 后台会处理这个消息，将其放到用户提供的 buffer 中，最后调用用户传入的 callback，通知用户任务的执行结果。</p>
<p>这里有一个很重要的问题是：上面提到的“后台处理”到底是什么时候执行的？答案是 UCX 并不会自己创建后台线程去执行它们，<strong>所有异步任务的后续处理和回调都是在 <code>worker.progress()</code> 函数中，也就是用户主动向 worker 轮询的过程中完成的</strong>。这个函数的语义是：“看看你手头要处理的事情，有哪些是能做的？尽力去推动一下，做完的通知我。” 换句话说，Worker 正在处理的所有任务组成了一个状态机，progress 函数的作用就是用新事件推动整个状态机的演进。后面我们会看到，对应到 async Rust 世界中，所有异步 IO 任务组成了最基础的 Future，worker 对应 Runtime，而 progress 及其中的回调函数则充当了 Reactor 的角色。</p>
<p>回到传统的 C 语言，在这里异步 IO 的最大难点是编程复杂性：多个并发任务在同一个线程上交替执行，只能通过回调函数来描述下一步做什么，会使得<strong>原本连续的执行逻辑被打散到多个回调函数中</strong>。本来局部变量就可以维护的状态，到这里就需要额外的结构体来在多个回调函数之间传递。随着异步操作数量的增加，代码的维护难度将会迅速上升。下面的伪代码展示了在 UCX 中如何通过异步回调函数来实现最简单的 echo 服务：</p>
<pre><code class="language-c">// 由于 C 语言语法的限制，这段代码需要从下往上读

// 这里存放所有需要跨越函数的状态变量
struct CallbackContext {
  ucp_endpoint_h ep;
  void *buf;
} ctx;

void send_cb(void ∗request, ucs_status_t status) {
  //【4】发送完毕
  ucp_request_free(request);
  exit(0);
}

void recv_cb(void ∗request, ucs_status_t status, ucp_tag_recv_info_t ∗info) {
  //【3】收到消息，发起发送请求
  ucp_tag_send_nb(ctx-&gt;ep, ctx-&gt;buf, info-&gt;length, ..., send_cb);
  ucp_request_free(request);
}

int main() {
  // 省略 UCX 初始化部分
  //【0】初始化任务状态
  ctx-&gt;ep = ep;
  ctx-&gt;buf = malloc(0x1000);
  //【1】发起异步接收请求
  ucp_tag_recv_nb(worker, ctx-&gt;buf, 0x1000, ..., recv_cb);
  //【2】不断轮询，驱动后续任务完成
	while(true) {
    ucp_worker_progress(worker);
  }
}
</code></pre>
<p>作为对比，假如 UCX 提供的是同步接口，那么同样的逻辑只需要以下几行就够了：</p>
<pre><code class="language-c">int main() {
  // 省略 UCX 初始化部分
  void *buf = malloc(0x1000);
  int len;
  ucp_tag_recv(worker, buf, 0x1000, &amp;len, ...);
  ucp_tag_send(ep, buf, len, ...);
  return 0;
}
</code></pre>
<p>面对传统异步编程带来的“回调地狱”，主流编程语言经过了十几年的持续探索，终于殊途同归，纷纷引入了控制异步的终极解决方案—— async-await 协程。它的杀手锏就是能让开发者<strong>用同步的风格编写异步的逻辑</strong>。经过我们的封装过后，在 Rust 中用 async 协程编写同样的逻辑是长这样的：</p>
<pre><pre class="playground"><code class="language-rust">async fn main() {
  // 省略 UCX 初始化部分
  let mut buf = vec![0u8; 0x1000];
  let len = worker.tag_recv(&amp;mut buf, ...).await.unwrap();
  ep.tag_send(&amp;buf[..len], ...).await.unwrap();
}
</code></pre></pre>
<p>下面我们就来介绍如何用 Rust 的协程机制包装 UCX 异步接口。</p>
<h2><a class="header" href="#rust-封装-ucx" id="rust-封装-ucx">Rust 封装 UCX</a></h2>
<h3><a class="header" href="#生成-rust-接口" id="生成-rust-接口">生成 Rust 接口</a></h3>
<p>用 Rust 包装 C 语言库的第一步是用社区提供的 <a href="https://github.com/rust-lang/rust-bindgen/">bindgen</a> 工具，从 C 头文件自动生成 Rust 绑定代码。生成的代码一般直接作为 <code>*-sys</code> 库发布，具体实现可以参考我们封装的 <a href="https://github.com/madsys-dev/async-ucx/tree/master/ucx-sys">ucx-sys</a>。接下来我们要在它的基础上继续封装出高层接口，也就是 async-ucx。</p>
<h3><a class="header" href="#封装-ucx-对象" id="封装-ucx-对象">封装 UCX 对象</a></h3>
<p>async-ucx 做的第一件事就是封装 UCX 对象。在 C 语言中对象创建出来后用户会拿到一个 handle，也就是一个指针。用户之后需要自己管理对象的生命周期，在用完后手动释放掉资源。</p>
<p>在 Rust 中我们需要将 C 的 handle 包装成一个 struct，通过引用计数来自动管理对象的生命周期，在对象的 Drop 函数中释放其资源。下面的代码展示了对 Worker 对象的封装过程：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 创建 Worker 需要依赖 Context，具体实现代码略过
pub struct Context {
  handle: ucp_context_h,
}

pub struct Worker {
  handle: ucp_worker_h,		// 包装 C handle
  context: Arc&lt;Context&gt;,	// 引用上级对象
}
impl Worker {
  // 从 Context 创建 Worker
  pub fn new(context: &amp;Arc&lt;Context&gt;) -&gt; Rc&lt;Self&gt; {
    // 准备参数和返回值
    let mut params = MaybeUninit::&lt;ucp_worker_params_t&gt;::uninit();
    unsafe { (*params.as_mut_ptr()).field_mask = 0 };
    let mut handle = MaybeUninit::uninit();
    // 调用 C 函数创建对象，获得 handle
    let status =
    unsafe { ucp_worker_create(context.handle, params.as_ptr(), handle.as_mut_ptr()) };
    assert_eq!(status, ucs_status_t::UCS_OK);
    // 包装为 Rust 对象
    Rc::new(Worker {
      handle: unsafe { handle.assume_init() },
      context: context.clone(),
    })
  }
}
// 析构时释放资源
impl Drop for Worker {
  fn drop(&amp;mut self) {
    unsafe { ucp_worker_destroy(self.handle) }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>对象其它接口的包装也是类似的：首先将用户传入的参数转化成 C 接口的形式，然后 unsafe 调用 C 接口，最后将返回结果转化成 Rust 的形态返回给用户。</p>
<h3><a class="header" href="#封装异步操作重点" id="封装异步操作重点">封装异步操作（重点）</a></h3>
<p>接下来到了最重要的一步：用 Future 封装基于回调函数的异步接口。</p>
<p>首先我们来回顾一下 Future 的工作原理：它本质是一个状态机，只提供一个 poll 函数来驱动内部状态的演进。poll 函数的本质是事件轮询，它会检查自己关心的事件是否已经完成，如果完成就继续推进执行，否则就挂起等待。在挂起之前 Future 需要将自己的 waker 注册到后台的事件响应器（Reactor）中，以便在事件发生时能够被唤醒。当事件发生后，Reactor 通过 waker 唤醒 Future，Future 再次执行上述 poll 的过程，这一次它会看到事件已经发生，于是状态机得以继续推进。</p>
<p>基于 Future 的整个异步运行时的工作原理如下图所示：</p>
<p><img src="chapter_7/./image/rdma/async.png" alt="4" /></p>
<p>其中 Future 接口的具体定义如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
  type Output;
  // 尝试推进状态机：
  //   如果事件就绪就返回 Poll::Ready(T)
  //   否则从 cx 中拿一个 waker 注册给 reactor，然后返回 Poll::Pending
  fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>下面我们要做的就是：利用回调函数来实现上面的 poll 函数。主要解决两个问题：查询事件状态，注册 waker。</p>
<ul>
<li>
<p>查询事件状态：这个比较好办。因为 UCX 的异步函数都会返回一个 request 对象，并且提供了接口来查询 request 的状态。所以我们只需要将 request 对象加入 Future 的状态中即可。</p>
<pre><code class="language-c">// 异步函数的返回值就是 request
ucs_status_ptr_t ucp_tag_recv_nb (...);
// 查询 request 状态的接口
ucs_status_t ucp_tag_recv_request_test (
  void ∗request,
	ucp_tag_recv_info_t ∗info
);
</code></pre>
</li>
<li>
<p>注册 waker：这件事需要一些技巧。之前我们提到 callback 实际上充当了 Reactor 的角色，所以这里我们需要将 waker 从 Future 传递给 callback。</p>
<p>观察 UCX callback 函数的定义，可以发现其中一个参数就是 request：</p>
<pre><code class="language-c">typedef void(∗ ucp_tag_recv_callback_t) (
  void ∗request,  // 可以通过这里，在 Future 和 callback 之间传递信息
  ucs_status_t status,
  ucp_tag_recv_info_t ∗info
);
</code></pre>
<p>并且 UCX 允许我们塞一些自己的私货到 request 对象中，正好就解决了传递 waker 的问题。</p>
</li>
</ul>
<p>接下来正式开始实现！首先定义我们要向 request 中夹带的私货：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Request {
  // 只有一个 waker，使用了 futures 库中的 AtomicWaker 来保证原子性
  waker: futures::task::AtomicWaker,
}
// NOTE：这里无需 #[repr(C)]，因为操作内部变量都是在 Rust 中实现的
<span class="boring">}
</span></code></pre></pre>
<p>然后向 UCX Context 注册这个私货：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Context {
  pub fn new() -&gt; Arc&lt;Self&gt; {
    // 创建 Context 的时候注册私货信息
    let params = ucp_params_t {
      request_size: std::mem::size_of::&lt;Request&gt;() as u64,
      request_init: Some(Request::init),
      request_cleanup: Some(Request::cleanup),
			...
    };
    // 构造 Context 略
  }
}
impl Request {
	// 初始化私货（原地构造）
  unsafe extern &quot;C&quot; fn init(request: *mut c_void) {
    (request as *mut Self).write(Request::default());
    // 注意：不能使用 *request = xxx; 的写法
    // 因为 request 指向的内存是未初始化状态，会导致在未定义内存上触发析构函数！
  }
	// 清理私货（原地析构）
  unsafe extern &quot;C&quot; fn cleanup(request: *mut c_void) {
    std::ptr::drop_in_place(request as *mut Self)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来将整个 request 包装成一个 Future：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 由于不同的操作会有不同的返回值，这里就用泛型参数 T 表示返回值类型
struct RequestHandle&lt;T&gt; {
  // UCX 返回的 request 对象，它的头部就是我们的私货
  ptr: ucs_status_ptr_t,
	// 查询 request 状态的函数
  poll_fn: unsafe fn(ucs_status_ptr_t) -&gt; Poll&lt;T&gt;,
}
//////////////////////// 核心代码 /////////////////////////
impl&lt;T&gt; Future for RequestHandle&lt;T&gt; {
  type Output = T;
  fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut std::task::Context) -&gt; Poll&lt;Self::Output&gt; {
    // 查询状态，如果就绪直接返回
    if let ret @ Poll::Ready(_) = unsafe { (self.poll_fn)(self.ptr) } {
      return ret;
    }
    // 注册 waker（通过私货）
    let request = unsafe { &amp;mut *(self.ptr as *mut Request) };
    request.waker.register(cx.waker());
    // 返回等待，挂起任务
    Poll::Pending
  }
}
//////////////////////////////////////////////////////////
impl&lt;T&gt; Drop for RequestHandle&lt;T&gt; {
  fn drop(&amp;mut self) {
    // request 要求手动释放
    unsafe { ucp_request_free(self.ptr as _) };
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，用这个 Future 实现一个完整的 recv 过程：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Endpoint {
	pub async fn tag_recv(&amp;self, tag: u64, buf: &amp;mut [u8]) -&gt; usize {
    // 首先实现 callback
    unsafe extern &quot;C&quot; fn callback(request: *mut c_void, ...) {
      // 只需简单地从 request 中取出 waker 唤醒即可
      let request = &amp;mut *(request as *mut Request);
      request.waker.wake();
    }
    // 发起异步操作，调用 C 函数，传入 callback
    let status = unsafe {
      ucp_tag_recv_nb(self.handle, ..., Some(callback))
    };
    if UCS_PTR_IS_PTR(status) {
      panic!(&quot;failed to recv tag: {:?}&quot;, UCS_PTR_RAW_STATUS(status));
    }
    // 将返回的 request 包装成 Future 并 await 结果！
    RequestHandle {
      ptr: status,
      poll_fn: poll_tag,	// 查询状态的具体实现略
    }.await
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>经过这样一番包装，我们就可以简单地使用一行命令，以同步风格完成 IO 操作了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = worker.tag_recv(tag, &amp;mut buf, ...).await;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#封装-worker-progress" id="封装-worker-progress">封装 worker progress</a></h3>
<p>终于结束了吗？别忘了所有的回调函数都是由 <code>worker.progress()</code> 驱动的。用户必须定期调用这个函数，不然所有任务都会卡住不动了。</p>
<p>那么解决方法也非常简单：我们在异步运行时中首先创建一个协程，不停地调用 <code>worker.progress()</code> ，然后 yield 让出。为了做到与具体的异步运行时库无关，我们这里只实现了这个协程本身，用户需要手动 spawn 它：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Worker {
	pub async fn polling(self: Rc&lt;Self&gt;) {
    // 不停循环直到 worker 的其它引用都释放了为止
    while Rc::strong_count(&amp;self) &gt; 1 {
      // 不停地调用 progress，直到没有新事件产生
      while self.progress() != 0 {}
      // 暂时让出 CPU，等待下次调度
      futures_lite::future::yield_now().await;
    }
  }
}
// 用法示例：tokio::task::spawn_local(worker.clone().polling());
<span class="boring">}
</span></code></pre></pre>
<p>当所有其它协程任务都挂起时，运行时就会调度运行 polling 协程，用新事件触发若干回调函数，从而唤醒对应的协程。</p>
<h2><a class="header" href="#在-rust-异步运行时中使用-ucx" id="在-rust-异步运行时中使用-ucx">在 Rust 异步运行时中使用 UCX</a></h2>
<p>到此为止我们就完成了对 UCX 异步封装的主要工作。值得注意的是，上面过程只用到了 Rust 语言内建的 async-await 语法，以及标准库中定义的最核心接口（Future 等），完全不依赖于任何一种特定的运行时环境（Tokio，async-std，smol 等）。</p>
<p>接下来我们以 Tokio 为例，介绍在 Rust 异步运行时中使用 async-ucx 构建一个完整可用程序的过程。这里我们实现一个最简单的 echo 程序：客户端向服务端发送一条消息，服务端收到后打印出来。完整代码在 <a href="https://github.com/madsys-dev/async-ucx/blob/master/examples/tag.rs">examples/tag.rs</a>。</p>
<p>首先写主函数：</p>
<pre><pre class="playground"><code class="language-rust">use async_ucx::ucp::*;
use std::io::Result;

// 使用 Tokio 默认的单线程运行时
#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn main() -&gt; Result&lt;()&gt; {
  env_logger::init();
  // 这里需要创建一个 LocalSet，才能 spawn !Send 的单线程 Future
  let local = tokio::task::LocalSet::new();
  // 根据命令行参数决定是服务端还是客户端
  if let Some(server_addr) = std::env::args().nth(1) {
    local.run_until(client(server_addr)).await?;
  } else {
    local.run_until(server()).await?;
  }
  Ok(())
}
</code></pre></pre>
<p>接下来实现服务端：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn server() -&gt; Result&lt;()&gt; {
  println!(&quot;server&quot;);
  // 创建 worker 和后台 progress 协程
  let context = Context::new();
  let worker = context.create_worker();
  tokio::task::spawn_local(worker.clone().polling());

  // 创建 listener 并等待连接
  let mut listener = worker.create_listener(&quot;0.0.0.0:0&quot;.parse().unwrap());
  println!(&quot;listening on {}&quot;, listener.socket_addr());
  let connection = listener.next().await;
  let _endpoint = worker.accept(connection);
  println!(&quot;accept&quot;);

  // 接收消息并打印出来
  let mut buf = [0u8; 0x100];
  let len = worker.tag_recv(100, &amp;mut buf).await;
  let msg = std::str::from_utf8(unsafe { transmute(&amp;buf[..len]) }).unwrap();
  println!(&quot;recv: {:?}&quot;, msg);
  Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>客户端更加简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn client(server_addr: String) -&gt; Result&lt;()&gt; {
  println!(&quot;client&quot;);
  // 创建 worker 和后台 progress 协程
  let context = Context::new();
  let worker = context.create_worker();
  tokio::task::spawn_local(worker.clone().polling());

  // 建立连接
  let endpoint = worker.connect(server_addr.parse().unwrap());
  println!(&quot;connect to {:?}&quot;, server_addr);
  
  // 发送消息
  let msg = b&quot;hello&quot;;
  endpoint.tag_send(100, msg).await;
  println!(&quot;send: {:?}&quot;, msg);
  Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>就这么简单，不到 50 行代码就可以实现一个完整的客户端和服务端。相比之下，UCX 官方提供的 <a href="https://github.com/openucx/ucx/blob/50ad33918b242d35d5c7ef1ba032dbc6a636ca2f/examples/ucp_hello_world.c">ucp_hello_world</a> 程序足足用了好几百行 C 代码才实现了同样的功能。这说明我们的封装更加简单易用，同时 async Rust 能够极大的提高异步编程开发效率。</p>
<h2><a class="header" href="#总结与展望" id="总结与展望">总结与展望</a></h2>
<p>本文介绍了用 async Rust 封装 UCX 异步接口的主要过程。其中涉及的核心知识技巧包括：</p>
<ul>
<li>C 语言中用回调函数处理异步逻辑的方法</li>
<li>Rust 语言中 Future 的角色和功能，异步运行时的基本原理</li>
<li>如何用 Future 包装回调函数，如何在二者之间传递信息</li>
<li>如何实现 Reactor，用事件驱动整个异步框架的运行</li>
</ul>
<p>目前 async-ucx 已经基本完成了对 UCP 接口的封装，还剩下另一半 UCT 接口没有实现。</p>
<p>此外，目前 async-ucx 还只支持以 busy-polling 轮询模式处理事件，这会使得运行它的 CPU 核一直处于 100% 满载状态。这样做当然性能是最高的，但是不太节能。UCX 自身支持休眠-唤醒机制，可以在没有事件发生的时候休眠当前线程、让出 CPU、等事件发生时再唤醒。其内部实现是为每个 worker 都创建了一个 event_fd，用户可以拿它去做 epoll，从而阻塞线程等待事件发生。</p>
<p>但是，要用好这一机制需要与 Rust 异步执行器进行深度整合。据我了解，至少 Tokio 1.0 是没有暴露相关接口的。而且这部分的实现一旦有任何闪失，都会导致唤醒遗失、程序卡住的问题出现。未来如何科学地实现休眠机制也是一个不小的挑战。</p>
<p>总的来说，异步 IO 在支持极高性能的同时也带来了极大的编程复杂性，而 Rust 的 async 协程机制很好的压制了这种复杂性。在我看来，Rust 是这个时代最适合编写复杂 IO 系统的语言。欢迎感兴趣的读者继续关注，<del>一同加入到我们推翻 C/C++ 旧世界的行列中来！</del></p>
<h1><a class="header" href="#zellij-的性能优化" id="zellij-的性能优化">Zellij 的性能优化</a></h1>
<ul>
<li>作者： <a href="https://www.poor.dev/blog/performance">Aram Drevekenin</a></li>
<li>译者： <a href="https://github.com/yct21">yct21</a></li>
</ul>
<p><img src="chapter_7/./image/zellij/zellij-performance-improve-1.png" alt="Zellij impovement post cover" /></p>
<p>过去的几个月里，我们一直工作在 <a href="https://github.com/zellij-org/zellij">Zellij</a> 的故障修复和性能调优上。在这个过程中，我们发现了不少问题和瓶颈，并采取了一些创造性的手段解决或者绕过它们。</p>
<p>本文我会用图文描述我们遇到的 2 个问题。在处理完这 2 个问题后，我们的应用已经能在性能上和同类产品打成平手，甚至超越它们。</p>
<p>这是 Zellij 的社区维护人员和贡献者共同创造的成果，详情请见后文的致谢部分。</p>
<p><em>关于本文的代码示例</em></p>
<p>本文中的代码示例围绕想表达的论点做了酌情简化。由于 Zellij 是一个已用于实际使用的应用，其内部代码可能会涉及和包含无关的细节。如果读者想深入研究的话，在每个代码示例后，有实际代码的链接，包括相关 PR 的链接。</p>
<h2><a class="header" href="#应用的功能与遇到的问题" id="应用的功能与遇到的问题">应用的功能与遇到的问题</a></h2>
<p><img src="chapter_7/./image/zellij/zellij-performance-improve-2.png" alt="Zellij Application" /></p>
<p>Zellij 是一个终端复用软件，简单来说，这是一个运行于虚拟终端（如 Alacritty, iterm2, Konsole 等）和 shell 之间的应用。</p>
<p>Zellij 中可以创造标签页和窗格，另外由于一直在后台运行，也可以脱离和重连某个会话。Zellij 保存了每个窗格的状态，让用户在重连或者切换标签页的之后还能回到原有的会话中。这个状态包含了窗格中的文本和样式，以及光标的位置等信息。 </p>
<p>当某个窗格包含有大量的数据时，应用会遇到严重的性能问题。例如，<code>cat</code> 一个非常大的文件，Zellij 不仅比一个裸的虚拟终端要慢，比其他终端复用软件也要慢上许多。</p>
<p>这里我们深入挖掘这个问题，看看问题的根源是什么，并探索相应的解决方案。</p>
<h2><a class="header" href="#问题流程" id="问题流程">问题流程</a></h2>
<p>我们采用了多线程的架构，每个线程完成某些特定的任务，并通过 <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">MPSC 通道</a>相互通信。数据的解析与渲染分别由 pty 线程和 screen 线程完成。 </p>
<p>pty 线程 会查询 <a href="https://man7.org/linux/man-pages/man7/pty.7.html">pty</a>，这是我们与 shell（或者其他在终端中运行的程序）的接口。该线程会向 screen 线程发送原始数据，并由其解析数据，构造出这个窗格的内部状态。</p>
<p>另外，每隔一小段时间，pty 线程会给 screen 线程发送 <em>render</em> 消息，让其根据窗格的状态渲染用户的 UI。 </p>
<p><img src="chapter_7/./image/zellij/zellij-performance-improve-3.gif" alt="Zellij work flow" /></p>
<p>pty 线程会启动一个异步任务，采用一个非阻塞的循环去轮询 pty，检查是否有新的数据。如果没有数据，pty 线程会休眠一段固定的时间。pty 线程在拿到数据后会向 screen 线程发送 <em>data</em> 指令，让其解析数据。此外，在以下情况下，pty 线程会去发 render 指令：</p>
<ol>
<li>pty 缓存中没有数据</li>
<li>从上次 render 指令发送已经过了 30ms 以上</li>
</ol>
<p>其中第二种情况是为了用户体验，这样当有大量数据从 pty 传来时，用户可以实时地在屏幕中看到更新。</p>
<p>让我们看一下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>task::spawn({
    async move {
        // TerminalBytes is an asynchronous stream that polls the pty
        // and terminates when the pty is closed
        let mut terminal_bytes = TerminalBytes::new(pid);
        let mut last_render = Instant::now();
        let mut pending_render = false;
        let max_render_pause = Duration::from_millis(30);
        while let Some(bytes) = terminal_bytes.next().await {
            let receiving_data = !bytes.is_empty();
            if receiving_data {
                send_data_to_screen(bytes);
                pending_render = true;
            }
            if pending_render &amp;&amp; last_render.elapsed() &gt; max_render_pause {
                send_render_to_screen();
                last_render = Instant::now();
                pending_render = false;
            }
            if !receiving_data {
                // wait a fixed amount of time before polling for more data
                task::sleep(max_render_pause).await;
            }
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>实际的代码可以参考<a href="https://github.com/zellij-org/zellij/blob/b20ac47d689a13cc894c3a10838cb8c2247a6e42/zellij-server/src/pty.rs#L170">该链接</a>。</p>
<h2><a class="header" href="#代码排障" id="代码排障">代码排障</a></h2>
<p>为了测试这段流程的性能，我们会 <code>cat</code> 一个 2,000,000 行的文件，并使用 <em>hyperfine</em>，并打开 <code>--show-output</code> 选项，使其不会忽略 <em>stdout</em> 的时间。我们采用 <em>tmux</em> 作为对照组。</p>
<p><code>hyperfine --show-output &quot;cat /tmp/bigfile&quot;</code> 在 tmux 的运行结果如下（窗格大小： 59 行，104 列）：</p>
<blockquote>
<p>Time (mean ± σ):      5.593 s ±  0.055 s    [User: 1.3 ms, System: 2260.6 ms]
Range (min … max):    5.526 s …  5.678 s    10 runs</p>
</blockquote>
<p>同样的指令在 Zellij 的运行结果如下（窗格大小：59 行，104 列）：</p>
<blockquote>
<p>Time (mean ± σ):     19.175 s ±  0.347 s    [User: 4.5 ms, System: 2754.7 ms]
Range (min … max):   18.647 s … 19.803 s    10 runs</p>
</blockquote>
<p>结果并不理想，对此我们要采取一些措施。</p>
<h3><a class="header" href="#难点-1-mpsc-消息通道溢出" id="难点-1-mpsc-消息通道溢出">难点 1: MPSC 消息通道溢出</a></h3>
<p>我们遇到的第一个性能瓶颈是 MPSC 消息通道的溢出。为了形象描述这个问题，我们给前面的流程图加个速： </p>
<p><img src="chapter_7/./image/zellij/zellij-performance-improve-4.gif" alt="Zellij Application" /></p>
<p>pty 线程和 screen 线程的数据处理速率并不同步，前者向消息通道中发送数据的速度远快于后者消耗的速度。这在以下方面影响了性能：</p>
<ol>
<li>消息通道持续地扩张，不停地占用更多的内存</li>
<li>由于 screen 线程随着数据的增加，占用了越来越多的 CPU 时间，原有的 30ms 间隔也变的相对不重要，线程在渲染上会花费比未溢出情况下更多的时间。</li>
</ol>
<h3><a class="header" href="#解决方案限制的消息通道的大小背压机制" id="解决方案限制的消息通道的大小背压机制">解决方案：限制的消息通道的大小（背压机制）</a></h3>
<p>问题的直接解决方法，是对消息通道的缓存大小进行限制，以此给 2 个线程带来了同步。我们将消息通道的大小限制到了很小的一个值（50 条消息），并切换到了 <a href="https://docs.rs/crossbeam/0.7.3/crossbeam/channel/index.html">crossbeam</a>，采用了其提供的 <code>select!</code> 宏。</p>
<p>除此之外，我们移除了自己实现的异步流，而是采用 <em>async_std</em> 的 <a href="https://docs.rs/async-std/1.4.0/async_std/fs/struct.File.html">File</a>, 这样就无需在后台进行轮训。</p>
<p>我们来看下相关的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>task::spawn({
    async move {
        let render_pause = Duration::from_millis(30);
        let mut render_deadline = None;
        let mut buf = [0u8; 65536];
        // AsyncFileReader is implemented using async_std's File
        let mut async_reader = AsyncFileReader::new(pid);

        // &quot;async_send_render_to_screen&quot; and &quot;async_send_data_to_screen&quot;
        // send to a crossbeam bounded channel
        // resolving once the send is successful, meaning there is room
        // for the message in the channel's buffer

        loop {
            // deadline_read attempts to read from async_reader or times out
            // after the render_deadline has passed
            match deadline_read(&amp;mut async_reader, render_deadline, &amp;mut buf).await {
                ReadResult::Ok(0) | ReadResult::Err(_) =&gt; break, // EOF or error
                ReadResult::Timeout =&gt; {
                    async_send_render_to_screen(bytes).await;
                    render_deadline = None;
                }
                ReadResult::Ok(n_bytes) =&gt; {
                    let bytes = &amp;buf[..n_bytes];
                    async_send_data_to_screen(bytes).await;
                    render_deadline.get_or_insert(Instant::now() + render_pause);
                }
            }
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>完整的代码可以参考这个<a href="https://github.com/zellij-org/zellij/blob/8ccf3d61a02e8df8c45e70b230d4cf3266195f0b/zellij-server/src/pty.rs#L164">链接</a>。</p>
<p>现在的运行流程可以参照下图：</p>
<p><img src="chapter_7/./image/zellij/zellij-performance-improve-5.gif" alt="Zellij Application" /></p>
<h3><a class="header" href="#性能提升的度量" id="性能提升的度量">性能提升的度量</a></h3>
<p>让我们回到之前的性能测试，以下是使用 <code>hyperfine --show-output &quot;cat /tmp/bigfile&quot;</code> 的结果（窗格大小：59 行，104 列）：</p>
<pre><code># Zellij before this fix
Time (mean ± σ):     19.175 s ±  0.347 s    [User: 4.5 ms, System: 2754.7 ms]
Range (min … max):   18.647 s … 19.803 s    10 runs

# Zellij after this fix
Time (mean ± σ):      9.658 s ±  0.095 s    [User: 2.2 ms, System: 2426.2 ms]
Range (min … max):    9.433 s …  9.761 s    10 runs
 
# Tmux
Time (mean ± σ):      5.593 s ±  0.055 s    [User: 1.3 ms, System: 2260.6 ms]
Range (min … max):    5.526 s …  5.678 s    10 runs
</code></pre>
<p>可以看到已经有了很大的改进，不过和 tmux 比起来，还不够好。</p>
<h3><a class="header" href="#难题-2-提升渲染和数据处理的性能" id="难题-2-提升渲染和数据处理的性能">难题 2: 提升渲染和数据处理的性能</a></h3>
<p>现在我们将有背压的流水线和 screen 线程连接在了一起，如果我们能提升 sceen 线程的工作，也就是数据的处理与渲染，那么应用的性能将得到进一步的提升。</p>
<h3><a class="header" href="#数据解析" id="数据解析">数据解析</a></h3>
<p>数据解析部分会将 ANSI/VT 指令（例如 <code>\033[10;2H\033[36mHi there!</code>），并将其转换成 Zellij 所定义的数据结构。</p>
<p>相关的代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Grid {
    viewport: Vec&lt;Row&gt;,
    cursor: Cursor,
    width: usize,
    height: usize,
}

struct Row {
    columns: Vec&lt;TerminalCharacter&gt;,
}

struct Cursor {
    x: usize,
    y: usize
}

#[derive(Clone, Copy)]
struct TerminalCharacter {
    character: char,
    styles: CharacterStyles
}
<span class="boring">}
</span></code></pre></pre>
<p>实际的代码可以参考<a href="https://github.com/zellij-org/zellij/blob/50d049a0edd2b342b4c6e9e279d0be77c2c5398d/zellij-server/src/panes/grid.rs">链接 1 </a>和<a href="https://github.com/zellij-org/zellij/blob/50d049a0edd2b342b4c6e9e279d0be77c2c5398d/zellij-server/src/panes/terminal_character.rs">链接 2 </a></p>
<h3><a class="header" href="#row-的预分配" id="row-的预分配"><code>Row</code> 的预分配</a></h3>
<p>数据解析器的是应用中被优化最频繁的部分，其中很多改动超出了本文的范畴。在此我们列举提升最大的几个优化。</p>
<p>以下是 <code>Row</code> 的定义，其中添加字符的方法是解析器中最常使用的方法。特别是向行尾添加字符，这个过程中会将 <code>TerminalCharacter</code> 添加到 <code>Row</code> 的 <code>columns</code> 字段。每次 <code>push</code> 都会改变这个 <code>vector</code> 的大小，并可能造成内存的再分配。这对性能造成了一定的影响。为此我们在新建或者调整窗体大小的时候，对 <code>Row</code> 进行了预分配。</p>
<p>代码修改前：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Row {
    pub fn new() -&gt; Self {
        Row {
            columns: Vec::new(),
        }
    }}
}
<span class="boring">}
</span></code></pre></pre>
<p>修改后：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Row {
    pub fn new(width: usize) -&gt; Self {
        Row {
            columns: Vec::with_capacity(width),
        }
    }}
}
<span class="boring">}
</span></code></pre></pre>
<p>具体代码可以参考<a href="https://github.com/zellij-org/zellij/blob/50d049a0edd2b342b4c6e9e279d0be77c2c5398d/zellij-server/src/panes/grid.rs#L1861">该链接</a>。</p>
<h3><a class="header" href="#缓存字符长度" id="缓存字符长度">缓存字符长度</a></h3>
<p>有些字符比另一些更长，例如东亚的字符，或者 emoji。 Zellij 使用了 <a href="https://crates.io/crates/unicode-width">unicode-width</a> 这个优秀的 crate，去查询字符的长度。</p>
<p>在将字符加入行中后，虚拟终端需要知道当前行的长度，去决定是否要自动换行。因此我们需要不停地查询字符的长度。</p>
<p>既然我们要多次查询字符的长度，我们可以缓存 <code>c.width()</code> 的结果，将其存入 <code>TerminalCharacter</code> 结构体中。</p>
<p>于是如下程序：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TerminalCharacter {
    character: char,
    styles: CharacterStyles
}

impl Row {
    pub fn width(&amp;self) -&gt; usize {
        let mut width = 0;
        for terminal_character in self.columns.iter() {
            width += terminal_character.character.width();
        }
        width
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在做了如下更改后，性能得到了提升：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TerminalCharacter {
    character: char,
    styles: CharacterStyles,
    width: usize,
}

impl Row {
    pub fn width(&amp;self) -&gt; usize {
        let mut width = 0;
        for terminal_character in self.columns.iter() {
            width += terminal_character.width;
        }
        width
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>实际代码可以参考<a href="https://github.com/zellij-org/zellij/blob/50d049a0edd2b342b4c6e9e279d0be77c2c5398d/zellij-server/src/panes/grid.rs#L1892">该链接</a>。</p>
<h3><a class="header" href="#加速渲染" id="加速渲染">加速渲染</a></h3>
<p>Screen 线程的渲染部分将每个窗格的状态，按照前文提到的数据结构进行组织，并将其转换成 ANSI/VT 指令，发送到用户的虚拟终端上。</p>
<p><code>Grid</code> 中的 <code>render</code> 方法将各个字符以及它的样式和位置转换成 ANSI/VT 指令并发给终端，覆盖前一次渲染的结果。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render(&amp;mut self) -&gt; String {
    let mut vte_output = String::new();
    let mut character_styles = CharacterStyles::new();
    let x = self.get_x();
    let y = self.get_y();
    for (line_index, line) in grid.viewport.iter().enumerate() {
        vte_output.push_str(
            // goto row/col and reset styles
            &amp;format!(&quot;\u{1b}[{};{}H\u{1b}[m&quot;, y + line_index + 1, x + 1)
        );
        for (col, t_character) in line.iter().enumerate() {
            let styles_diff = character_styles
                .update_and_return_diff(&amp;t_character.styles);
            if let Some(new_styles) = styles_diff {
                // if this character's styles are different
                // from the previous, we update the diff here
                vte_output.push_str(&amp;new_styles);
            }
            vte_output.push(t_character.character);
        }
        // we clear the character styles after each line
        // in order not to leak styles from the pane to our left
        character_styles.clear();
    }
    vte_output
}
<span class="boring">}
</span></code></pre></pre>
<p>具体代码可以参考<a href="https://github.com/zellij-org/zellij/blob/4b7fe3ca7b095968bd34b24949de790a4d8af28e/zellij-server/src/panes/terminal_pane.rs#L153">该链接</a>。</p>
<p>写入 <code>STDOUT</code> 是一个很耗时的操作，我们可以通过限制发往终端的指令数量，从而提升应用的性能。为了达成这个目的，我们要采用一个输出缓冲区，用于追踪渲染时改变的视图区域。在渲染时，就可以构造这部分区域的指令。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct CharacterChunk {
    pub terminal_characters: Vec&lt;TerminalCharacter&gt;,
    pub x: usize,
    pub y: usize,
}

#[derive(Clone, Debug)]
pub struct OutputBuffer {
    changed_lines: Vec&lt;usize&gt;, // line index
    should_update_all_lines: bool,
}

impl OutputBuffer {
    pub fn update_line(&amp;mut self, line_index: usize) {
        self.changed_lines.push(line_index);
    }
    pub fn clear(&amp;mut self) {
        self.changed_lines.clear();
    }
    pub fn changed_chunks_in_viewport(
        &amp;self,
        viewport: &amp;[Row],
    ) -&gt; Vec&lt;CharacterChunk&gt; {
        let mut line_changes = self.changed_lines.to_vec();
        line_changes.sort_unstable();
        line_changes.dedup();
        let mut changed_chunks = Vec::with_capacity(line_changes.len());
        for line_index in line_changes {
            let mut terminal_characters: Vec&lt;TerminalCharacter&gt; = viewport
                .get(line_index).unwrap().columns
                .iter()
                .copied()
                .collect();
            changed_chunks.push(CharacterChunk {
                x: 0,
                y: line_index,
                terminal_characters,
            });
        }
        changed_chunks
    }
}}
<span class="boring">}
</span></code></pre></pre>
<p>实际代码可以参考<a href="https://github.com/zellij-org/zellij/blob/50d049a0edd2b342b4c6e9e279d0be77c2c5398d/zellij-server/src/panes/grid.rs#L204">该链接</a>。</p>
<p>当前的实现仅仅跟踪了改动行，也尝试过对列做进一步的优化，但我发现这样会极大增加代码的复杂度，但对性能的提升十分有限。</p>
<p>最后，我们来看看所有这些优化的成效。以下是使用 <code>hyperfine --show-output &quot;cat /tmp/bigfile&quot;</code> 的结果，窗体大小还是 59 行，104 列）：</p>
<pre><code class="language-text"># Zellij before all fixes
Time (mean ± σ):     19.175 s ±  0.347 s    [User: 4.5 ms, System: 2754.7 ms]
Range (min … max):   18.647 s … 19.803 s    10 runs

# Zellij after the first fix
Time (mean ± σ):      9.658 s ±  0.095 s    [User: 2.2 ms, System: 2426.2 ms]
Range (min … max):    9.433 s …  9.761 s    10 runs

# Zellij after the second fix (includes both fixes)
Time (mean ± σ):      5.270 s ±  0.027 s    [User: 2.6 ms, System: 2388.7 ms]
Range (min … max):    5.220 s …  5.299 s    10 runs

# Tmux
Time (mean ± σ):      5.593 s ±  0.055 s    [User: 1.3 ms, System: 2260.6 ms]
Range (min … max):    5.526 s …  5.678 s    10 runs
</code></pre>
<p>至此，我们的应用已经能在性能上与其他成熟的终端复用软件一较高下。改进的空间依然还有，但现在也能为用户带来优秀的体验了。</p>
<h2><a class="header" href="#结论-9" id="结论-9">结论</a></h2>
<p>我们通过 <code>cat</code> 大文件来度量性能，能覆盖的情景其实比较有限。在其他情境下，Zellij 有可能表现地更好或者更糟。性能测试是一个很复杂的领域，本文的数据只能作为一个模糊的指标。</p>
<p>Zellij 从未宣称比同类应用更快，只是将性能作为一个尽力提高的目标。</p>
<p>如果你发现了本文中的错误，可以联系 <a href="chapter_7/aram@poor.dev">aram@poor.dev</a>，我们欢迎任何任何改动、想法、反馈。</p>
<p>如果你觉得本文不错，想在未来看到更多这样的内容，可以考虑在 <a href="https://www.twitter.com/im_snif">twitter</a> 上关注我。</p>
<h2><a class="header" href="#链接" id="链接">链接</a></h2>
<ul>
<li><a href="https://github.com/zellij-org/zellij/pull/523">第一个背压 PR</a></li>
<li><a href="https://github.com/zellij-org/zellij/pull/536">第二个背压 PR</a></li>
<li><a href="https://github.com/zellij-org/zellij/pull/567">数据处理和渲染相关的 PR</a></li>
</ul>
<h2><a class="header" href="#致谢-1" id="致谢-1">致谢</a></h2>
<ul>
<li><a href="https://github.com/kxt">Tamás Kovács</a>: MPSC 通道和背压等改动的作者，审阅了本文</li>
<li><a href="https://github.com/kunalmohan">Kunal Mohan</a>: 校验并帮助完成了背压相关改动，审阅了本文</li>
<li><a href="https://github.com/imsnif">Aram Drevekenin</a>: 参与了数据解析与渲染的改动</li>
</ul>
<h1><a class="header" href="#学习资源-3" id="学习资源-3">学习资源</a></h1>
<p>编辑：张汉东</p>
<hr />
<h2><a class="header" href="#rand-之书" id="rand-之书">Rand 之书</a></h2>
<ul>
<li><a href="https://github.com/rust-random/book/">英文：The Rust Rand Book</a></li>
<li><a href="https://github.com/zjp-CN/Rust-Rand-Book-zh">中文：Rand 之书</a></li>
</ul>
<h2><a class="header" href="#rust-新书--hands-on-rust-" id="rust-新书--hands-on-rust-">Rust 新书 ：《 Hands-on Rust 》</a></h2>
<p>PragProg 出版社出的一本新书 《Hands-on Rust》，以游戏开发为主题学习 Rust 。 </p>
<p><a href="https://pragprog.com/titles/hwrust/hands-on-rust/">https://pragprog.com/titles/hwrust/hands-on-rust/</a></p>
<p>视频介绍：<a href="https://www.youtube.com/watch?v=DvcWrd5VJ2I">https://www.youtube.com/watch?v=DvcWrd5VJ2I</a></p>
<h2><a class="header" href="#rust-for-rustaceans-样章试译--第二章-rust-基础" id="rust-for-rustaceans-样章试译--第二章-rust-基础">《Rust for Rustaceans》 样章试译 | 第二章 Rust 基础</a></h2>
<p>本文是对 Jon Gjengset 写的新书 《Rust for Rustaceans》样章第二章的中文试译初稿。出于对 Jon 的尊敬，以及想了解 Jon 眼中的 Rust ，我打算翻译一下这本书。发出来让大家看看翻译效果，欢迎指正。</p>
<p><a href="https://mp.weixin.qq.com/s/PW7UQ1QpolXeXQTgJGblog">https://mp.weixin.qq.com/s/PW7UQ1QpolXeXQTgJGblog</a></p>
<h2><a class="header" href="#曼宁新书推荐--refactoring-to-rust" id="曼宁新书推荐--refactoring-to-rust">曼宁新书推荐：  《Refactoring to Rust》</a></h2>
<p>这本书试图教会你，如何把现有项目用 Rust 语言重构。 比较适合想在公司里推广 Rust 的朋友。</p>
<p><a href="https://www.manning.com/books/refactoring-to-rust">https://www.manning.com/books/refactoring-to-rust</a></p>
<h2><a class="header" href="#在-r-语言中调用-rust" id="在-r-语言中调用-rust">在 R 语言中调用 Rust</a></h2>
<p><a href="https://extendr.github.io/rextendr/">https://extendr.github.io/rextendr/</a></p>
<h2><a class="header" href="#tezedge-使用-nom-加速二进制解析" id="tezedge-使用-nom-加速二进制解析">TezEdge: 使用 nom 加速二进制解析</a></h2>
<p>Tezos 是一个开源去中心化区块链网络，为智能合约和数字资产提供平台。 之前 Tezos 节点使用 serde 来序列化/反序列化二进制，但是这样始终维护着一个中间结构，占用了 CPU 和 内存。所以他们使用 nom 直接对二进制流进行解析，就消除来这个中间结构，提升了性能。</p>
<ul>
<li><a href="https://medium.com/tezedge/speeding-up-incoming-message-parsing-by-3-to-10-times-by-switching-from-serde-to-the-nom-library-a74b04391bb4">https://medium.com/tezedge/speeding-up-incoming-message-parsing-by-3-to-10-times-by-switching-from-serde-to-the-nom-library-a74b04391bb4</a></li>
<li><a href="https://github.com/tezedge/tezedge">https://github.com/tezedge/tezedge</a></li>
</ul>
<h2><a class="header" href="#rust-概念解惑--deref-vs-asref-vs-borrow-vs-cow" id="rust-概念解惑--deref-vs-asref-vs-borrow-vs-cow">Rust 概念解惑 | Deref vs AsRef vs Borrow vs Cow</a></h2>
<ul>
<li>英文：<a href="https://dev.to/zhanghandong/rust-concept-clarification-deref-vs-asref-vs-borrow-vs-cow-13g6">https://dev.to/zhanghandong/rust-concept-clarification-deref-vs-asref-vs-borrow-vs-cow-13g6</a></li>
<li>中文：<a href="https://mp.weixin.qq.com/s/OdcLb5U8QCeYH08feThN7w">Rust 概念解惑 | Deref vs AsRef vs Borrow vs Cow </a></li>
</ul>
<h2><a class="header" href="#arithmetic-parser-一个多功能的算术表达式解析器" id="arithmetic-parser-一个多功能的算术表达式解析器">arithmetic-parser: 一个多功能的算术表达式解析器</a></h2>
<p>此项目可以作为 Rust 学习案例</p>
<p><a href="https://github.com/slowli/arithmetic-parser">https://github.com/slowli/arithmetic-parser</a></p>
<h2><a class="header" href="#bevy-引擎游戏开发指南系列视频" id="bevy-引擎游戏开发指南系列视频">Bevy 引擎游戏开发指南系列视频</a></h2>
<p>该指南是利用 Bevy 引擎开发一个好玩的类似小蜜蜂的游戏。</p>
<p><a href="https://www.youtube.com/channel/UCiT_r1GD7JSftnbViKHcOtQ">https://www.youtube.com/channel/UCiT_r1GD7JSftnbViKHcOtQ</a></p>
<h2><a class="header" href="#rust-如何和-ffi-的数据打交道" id="rust-如何和-ffi-的数据打交道">Rust 如何和 FFI 的数据打交道</a></h2>
<p>该博客主要是简单展示如何通过 FFi 进行数据交互</p>
<p><a href="https://blog.guillaume-gomez.fr/articles/2021-07-29+Interacting+with+data+from+FFI">https://blog.guillaume-gomez.fr/articles/2021-07-29+Interacting+with+data+from+FFI</a></p>
<h2><a class="header" href="#与c相比如何改善rust巨大的二进制大小" id="与c相比如何改善rust巨大的二进制大小">与c相比，如何改善Rust巨大的二进制大小？</a></h2>
<p>如果你想尽可能的减少Rust生成的二进制文件大小，请看这里：</p>
<ul>
<li><a href="https://github.com/johnthagen/min-sized-rust">https://github.com/johnthagen/min-sized-rust</a></li>
<li><a href="https://blog.mgattozzi.dev/rusts-runtime/">https://blog.mgattozzi.dev/rusts-runtime/</a></li>
</ul>
<h2><a class="header" href="#讨论为什么说-openssl-是-rust-开发的痛点" id="讨论为什么说-openssl-是-rust-开发的痛点">【讨论】为什么说 OpenSSL 是 Rust 开发的痛点？</a></h2>
<p>来自 reddit 的讨论，摘录一段评论：</p>
<p>在Node.JS和Python中，TLS的实现是来自运行时的。有人已经为你处理了这个令人头痛的问题。缺点是，当你写一个NodeJS或Python程序时，你需要确保你的用户也安装了该运行时。</p>
<p>Rust没有这样的运行时。当你运行你的Rust程序时，该程序必须知道如何以某种方式处理TLS。</p>
<p>那么<code>openssl-sys</code>与其他 crate，如<code>serde</code>、<code>clap</code>等有什么不同？</p>
<p>你从 crates.io 上找到的大多数crates都是纯粹的Rust crates，它们是用Rust工具链编译的，（通常）静态链接到你的可执行文件中。这是一个相对简单的过程，只依赖于Rust编译工具，反正你已经设置好了。</p>
<p><code>openssl-sys</code>（像大多数其他的-sys板块）不是一个纯粹的Rust crate。它依赖于实际的OpenSSL库，它是一个C/C++库。这意味着还有许多其他方面需要考虑。</p>
<p>OpenSSL是静态链接还是动态链接到最终可执行文件？</p>
<p>在哪里找到/如何为链接器编译必要的文件？</p>
<p>这里没有适用于所有用户的开箱即用的解决方案。通常你需要下载带有必要文件的OpenSSL二进制分布，并以某种方式通知<code>openssl-sys</code>在哪里提取这些文件，或者你需要设置OpenSSL构建工具链（C/C++编译器等），然后让<code>openssl-sys</code>为你从头编译 OpenSSL。</p>
<p><a href="https://www.reddit.com/r/rust/comments/oto406/why_is_ssl_such_a_pain/">https://www.reddit.com/r/rust/comments/oto406/why_is_ssl_such_a_pain/</a></p>
<h2><a class="header" href="#local-native系列教程完结了" id="local-native系列教程完结了">Local Native系列教程完结了</a></h2>
<p>Local Native是一个跨平台的Rust写的桌面应用程序，使用的UI框架是iced，教程记录了如何搭建整个程序的过程，因为本人水平有待提高，因此教程肯定会有不少问题，希望对此感兴趣的朋友可以提出问题，我会尽可能解决。这个项目会长期维护，知道iced等重要依赖达到1.0稳定版本。</p>
<p>上次收到的反馈有注释过长之类的，在新版本中有了改正，非常感谢大家的反馈。</p>
<ul>
<li>项目总结：<a href="https://localnative.app/blog/2021/07/28/localnative-2021-soc-retrospective-blog">https://localnative.app/blog/2021/07/28/localnative-2021-soc-retrospective-blog</a></li>
<li>0-9章：<a href="https://localnative.app/docs/tutorial0">https://localnative.app/docs/tutorial0</a></li>
</ul>
<h2><a class="header" href="#prechelt-论文--比较rustjavalispcc-和脚本语言" id="prechelt-论文--比较rustjavalispcc-和脚本语言">Prechelt 论文 | 比较Rust、Java、Lisp、C/C++ 和脚本语言</a></h2>
<p>文章主要介绍了关于编程语言对生产力和程序效率的影响的讨论。</p>
<p><a href="https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html">https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html</a></p>
<h2><a class="header" href="#rust-实现-esp8266-驱动程序" id="rust-实现-esp8266-驱动程序">Rust 实现 esp8266 驱动程序</a></h2>
<p>通过串口与esp8266 模块通信。通过这个模块，可以加入现有的接入点或创建自己的接入点。创建网络后，该模块既可以侦听传入的 TCP 连接，也可以连接到其他套接字。</p>
<p><a href="https://github.com/alekseysidorov/esp8266-wifi-serial">https://github.com/alekseysidorov/esp8266-wifi-serial</a></p>
<h2><a class="header" href="#rust-中那些超棒的-unstable-特性" id="rust-中那些超棒的-unstable-特性">Rust 中那些超棒的 Unstable 特性</a></h2>
<p>本文讲解了Rust编译器的一些超棒的未稳定特性，并且通过例子来使读者了解这些未稳定特性的基本用法和情况。</p>
<p><a href="https://lazy.codes/posts/awesome-unstable-rust-features/">https://lazy.codes/posts/awesome-unstable-rust-features/</a></p>
<h2><a class="header" href="#深入理解-rust-的-features" id="深入理解-rust-的-features">深入理解 Rust 的 Features</a></h2>
<p><a href="https://fasterthanli.me/articles/understanding-rust-futures-by-going-way-too-deep">https://fasterthanli.me/articles/understanding-rust-futures-by-going-way-too-deep</a></p>
<h2><a class="header" href="#如何在-rust-中实现工作池" id="如何在-rust-中实现工作池">如何在 Rust 中实现工作池</a></h2>
<p>单纯看到 Rust 所有权模型，工作池模式会不太适合 Rust。但是相反，拥抱函数式编程和不可变数据使 Rust 拥有了更简单易用和更优雅的工具：并行迭代器和流。作者提供了 #计算密集型# 和 #I/O 密集型# 两种作业的工作池使用方式。</p>
<p><a href="https://kerkour.com/blog/rust-worker-pool/">https://kerkour.com/blog/rust-worker-pool/</a></p>
<h2><a class="header" href="#rust-和-jvm" id="rust-和-jvm">Rust 和 JVM</a></h2>
<p>通过 jni 让 rust 和 Java 结合起来，可以在 Java 中使用 rust function</p>
<p><a href="https://blog.frankel.ch/start-rust/7">https://blog.frankel.ch/start-rust/7</a></p>
<h2><a class="header" href="#如何-在-yew-框架-和-trunk-中使用-tailwind-css" id="如何-在-yew-框架-和-trunk-中使用-tailwind-css">如何 在 yew 框架 和 Trunk 中使用 Tailwind CSS</a></h2>
<ul>
<li><a href="https://dev.to/arctic_hen7/how-to-set-up-tailwind-css-with-yew-and-trunk-il9">https://dev.to/arctic_hen7/how-to-set-up-tailwind-css-with-yew-and-trunk-il9</a></li>
<li><a href="https://github.com/thedodd/trunk">https://github.com/thedodd/trunk</a></li>
<li><a href="https://github.com/yewstack/yew">https://github.com/yewstack/yew</a></li>
<li><a href="https://tailwindcss.com/">https://tailwindcss.com/</a></li>
</ul>
<h2><a class="header" href="#rust--tauri--svelte-指南" id="rust--tauri--svelte-指南">Rust + Tauri + Svelte 指南</a></h2>
<p><a href="https://jbarszczewski.com/rust-tauri-svelte-tutorial">https://jbarszczewski.com/rust-tauri-svelte-tutorial</a></p>
<h2><a class="header" href="#系列-在树莓派上跑-wasm-模块" id="系列-在树莓派上跑-wasm-模块">系列： 在树莓派上跑 wasm 模块</a></h2>
<p><a href="https://blog.knoldus.com/host-a-wasm-module-on-raspberry-pi-easily-part-1/">https://blog.knoldus.com/host-a-wasm-module-on-raspberry-pi-easily-part-1/</a></p>
<h2><a class="header" href="#fluvio-smartstreams-为应用程序日志编写-wasm-过滤器" id="fluvio-smartstreams-为应用程序日志编写-wasm-过滤器">Fluvio SmartStreams:： 为应用程序日志编写 wasm 过滤器</a></h2>
<p><a href="https://www.infinyon.com/blog/2021/06/smartstream-filters/">https://www.infinyon.com/blog/2021/06/smartstream-filters/</a></p>
<h2><a class="header" href="#用-rust-重写-go-项目最开始慢-45-倍然后经过rust-社区网友支招优化以后反过来比-go-项目快且稳定" id="用-rust-重写-go-项目最开始慢-45-倍然后经过rust-社区网友支招优化以后反过来比-go-项目快且稳定">用 Rust 重写 go 项目，最开始慢 4～5 倍，然后经过Rust 社区网友支招优化以后，反过来比 go 项目快且稳定</a></h2>
<p>这个帖子下涉及一些异步优化技巧可以看看</p>
<p><a href="https://www.reddit.com/r/rust/comments/oje3w7/rewrote_golang_project_in_rust_its_4x_times/">https://www.reddit.com/r/rust/comments/oje3w7/rewrote_golang_project_in_rust_its_4x_times/</a></p>
<h2><a class="header" href="#discourse-论坛--使用-rust-webassembly-和--mozjpeg-加速上传" id="discourse-论坛--使用-rust-webassembly-和--mozjpeg-加速上传">Discourse 论坛 ： 使用 Rust 、WebAssembly 和  MozJPEG 加速上传</a></h2>
<p><a href="https://blog.discourse.org/2021/07/faster-user-uploads-on-discourse-with-rust-webassembly-and-mozjpeg">https://blog.discourse.org/2021/07/faster-user-uploads-on-discourse-with-rust-webassembly-and-mozjpeg</a></p>
<h2><a class="header" href="#rust-实现的轻量级浏览器用于教学目标" id="rust-实现的轻量级浏览器用于教学目标">Rust 实现的轻量级浏览器，用于教学目标</a></h2>
<p><a href="https://github.com/lmt-swallow/puppy-browser/">https://github.com/lmt-swallow/puppy-browser/</a></p>
<h2><a class="header" href="#如何在-windows-上进行-rust-开发" id="如何在-windows-上进行-rust-开发">如何在 Windows 上进行 Rust 开发</a></h2>
<p>微软官方指南，在 Windows 上使用 Rust 进行开发，包括开发环境的设置、Windows 的 Rust 和代码示例。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/dev-environment/rust/">https://docs.microsoft.com/en-us/windows/dev-environment/rust/</a></p>
<h2><a class="header" href="#hyperfunctions-postgresql-中的函数用于简化时序数据的工作" id="hyperfunctions-postgresql-中的函数用于简化时序数据的工作">hyperfunctions: PostgreSQL 中的函数，用于简化时序数据的工作</a></h2>
<p>Rust 实现的 postgresql 扩展。能简化开发工作。</p>
<p>其中提到一个理念：创建新的 SQL 函数，而不是重新发明语法。值得品味。</p>
<p><a href="https://blog.timescale.com/blog/introducing-hyperfunctions-new-sql-functions-to-simplify-working-with-time-series-data-in-postgresql/">https://blog.timescale.com/blog/introducing-hyperfunctions-new-sql-functions-to-simplify-working-with-time-series-data-in-postgresql/</a></p>
<h2><a class="header" href="#并不总是icache的原因" id="并不总是icache的原因">并不总是iCache的原因</a></h2>
<p>摘要： </p>
<p>众所周知，内联是一项很有用的代码优化技术。但有时候我们也常听到类似下面这样的观点：</p>
<p>内联也会使代码变慢，因为内联会增加代码的大小，使指令缓存变大并导致缓存未命中。</p>
<p>对于内联导致代码运行速度变慢的原因，不少人归结为内联使得iCache命中率降低，造成指令流水线在取指的过程中耗费更多的时间。</p>
<p>本文作者通过使用若干有效的工具(perf/valgrind)对比了是否启用内联特性的代码性能和汇编指令，提出了内联可能造成代码变慢的另一种解释：</p>
<p>试考虑内联技术将函数S内联展开于函数C中：</p>
<ol>
<li>内联使得C占用了更多的寄存器。由于函数S的代码直接在函数C的函数体中展开，造成函数C在程序上下文切换过程中加入了更多的push/pop指令，并且函数C的运行时栈的空间进一步膨胀。与内联版本中每次调用函数C都意味着这些新增的push/pop指令都会运行不同，未内联版本的push/pop指令只存在于函数S的上下文中，并且只有当函数C确实调用函数S时，这些指令才会被运行；</li>
<li>基于第一点的基本认识，现在设想函数S在流程控制语句中被调用（循环或条件分支等），编译器可能会提升函数S中的某些指令到条件分支之外，造成这些指令从冷路径变为热路径（冷热路径：因为条件分支可能不会执行，但是位于条件分支之外的代码总会执行，是为热路径）；</li>
<li>在上述场景中，随着外层函数C的栈中局部变量和流程控制语句增多，编译器的优化反而使得热路径执行效率降低。</li>
</ol>
<ul>
<li>[https://matklad.github.io/2021/07/10/its-not-always-icache.html]</li>
<li><a href="https://matklad.github.io/2021/07/09/inline-in-rust.html">https://matklad.github.io/2021/07/09/inline-in-rust.html</a></li>
<li><a href="https://www.scylladb.com/2017/07/06/scyllas-approach-improve-performance-cpu-bound-workloads/">https://www.scylladb.com/2017/07/06/scyllas-approach-improve-performance-cpu-bound-workloads/</a></li>
</ul>
<h2><a class="header" href="#一个-rust-编写的-k8s-controller" id="一个-rust-编写的-k8s-controller">一个 Rust 编写的 k8s controller</a></h2>
<p>作者为了学习 k8s 的 controller 以及 Rust, 用 Rust 编写了一个 controller.</p>
<p><a href="https://blog.frankel.ch/start-rust/6/">https://blog.frankel.ch/start-rust/6/</a></p>
<h2><a class="header" href="#rust-在前端中的使用" id="rust-在前端中的使用">Rust 在前端中的使用</a></h2>
<p>这其实是一个手把手教你如何使用 WebAssembly 的教程.</p>
<p><a href="https://blog.frankel.ch/start-rust/5/">https://blog.frankel.ch/start-rust/5/</a></p>
<h1><a class="header" href="#完整rust-标准库-trait-指南" id="完整rust-标准库-trait-指南">【完整】Rust 标准库 Trait 指南</a></h1>
<p>译者： Praying</p>
<blockquote>
<ul>
<li>原文标题：Tour of Rust's Standard Library Traits</li>
<li>原文链接：<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md">https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md </a></li>
<li>说明： 可能网络中也存在其他翻译，但本篇是由 Praying 独立翻译完成的。</li>
</ul>
</blockquote>
<h2><a class="header" href="#内容目录" id="内容目录">内容目录</a></h2>
<ul>
<li>引言 </li>
<li>Trait 基础 </li>
<li>自动 Trait</li>
<li>泛型 Trait</li>
<li>格式化 Trait</li>
<li>操作符 Trait</li>
<li>转换 Trait</li>
<li>错误处理 </li>
<li>迭代器 Trait</li>
<li>I/O Trait</li>
<li>总结 </li>
</ul>
<h2><a class="header" href="#引言-1" id="引言-1">引言</a></h2>
<p>你是否曾想过下面这些 trait 有什么不同？</p>
<ul>
<li><code>Deref&lt;Traget=T&gt;</code>，<code>AsRef&lt;T&gt;</code>，以及<code>Borrow&lt;T&gt;</code>？</li>
<li><code>Clone</code>，<code>Copy</code>，和<code>ToOwned</code>？</li>
<li><code>From&lt;T&gt;</code> 和<code>Into&lt;T&gt;</code>?</li>
<li><code>TryFrom&lt;&amp;str&gt;</code> 和<code>FromStr</code>？</li>
<li><code>FnOnce</code>，<code>FnMut</code>，<code>Fn</code>和<code>fn</code>?</li>
</ul>
<p>或者你曾问过自己下面这些问题：</p>
<ul>
<li>
<p>“我在 trait 中，什么时候使用关联类型（associated type），什么时候使用泛型（generic types）？”</p>
</li>
<li>
<p>“什么是泛型覆盖实现（generic <a href="https://doc.rust-lang.org/book/ch10-02-traits.html?highlight=blanket#using-trait-bounds-to-conditionally-implement-methods" title="blanket impls">blanket impls</a>）”?</p>
</li>
<li>
<p>“subtrait 和 supertrait 是如何工作的？”</p>
</li>
<li>
<p>“为什么这个 trait 没有任何方法？”</p>
</li>
</ul>
<p>那么这篇文章就是为你而写的！它回答了包括但不限于上述所有的问题。我们将一起对 Rust 标准库中所有最流行和最常用的 trait 进行快速的浏览。<br/></p>
<p>你可以按章节顺序阅读本文，也可以跳到你最感兴趣的 trait，因为每个 trait 章节的开头都有一个指向前置章节的链接列表，你应该阅读这些链接，以便有足够的背景知识来理解当前章节的解释（译注：很抱歉，译文中暂时无法提供链接跳转）。</p>
<h2><a class="header" href="#triat-基础" id="triat-基础">Triat 基础</a></h2>
<p>我们将会覆盖足够多的基础知识，这样文章的其余部分就可以精简，而不必因为它们在不同的 trait 中反复出现而重复解释相同的概念。</p>
<h3><a class="header" href="#trait-项item" id="trait-项item">Trait 项（Item）</a></h3>
<p>Trait 项是指包含于 trait 声明中的任意项。</p>
<h4><a class="header" href="#self" id="self">Self</a></h4>
<p><code>Self</code>总是指代实现类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    // always returns i32
    fn returns_num() -&gt; i32;

    // returns implementing type
    fn returns_self() -&gt; Self;
}

struct SomeType;
struct OtherType;

impl Trait for SomeType {
    fn returns_num() -&gt; i32 {
        5
    }

    // Self == SomeType
    fn returns_self() -&gt; Self {
        SomeType
    }
}

impl Trait for OtherType {
    fn returns_num() -&gt; i32 {
        6
    }

    // Self == OtherType
    fn returns_self() -&gt; Self {
        OtherType
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#函数function" id="函数function">函数（Function）</a></h4>
<p>Trait 函数是指第一个参数不是<code>self</code>关键字的任意函数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Default {
    // function
    fn default() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 函数可以通过 trait 或者实现类型的命名空间来调用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let zero: i32 = Default::default();
    let zero = i32::default();
}
</code></pre></pre>
<h4><a class="header" href="#方法method" id="方法method">方法（Method）</a></h4>
<p>Trait 方法是指，第一个参数使用了<code>self</code>关键字并且<code>self</code>的类型是<code>Self</code>,<code>&amp;Self</code>，<code>&amp;mut Self</code>之一。<code>self</code>的类型也可以被<code>Box</code>，<code>Rc</code>，<code>Arc</code>或<code>Pin</code>来包装。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    // methods
    fn takes_self(self);
    fn takes_immut_self(&amp;self);
    fn takes_mut_self(&amp;mut self);

    // above methods desugared
    fn takes_self(self: Self);
    fn takes_immut_self(self: &amp;Self);
    fn takes_mut_self(self: &amp;mut Self);
}

// example from standard library
trait ToString {
    fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 方法可以通过在实现类型上使用点（.）操作符来调用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let five = 5.to_string();
}
</code></pre></pre>
<p>此外，trait 方法还可以像函数那样由 trait 或者实现类型通过命名空间来调用。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let five = ToString::to_string(&amp;5);
    let five = i32::to_string(&amp;5);
}
</code></pre></pre>
<h4><a class="header" href="#关联类型associated-types" id="关联类型associated-types">关联类型（Associated Types）</a></h4>
<p>Trait 可以有关联类型。当我们需要在函数签名中使用<code>Self</code>以外的某个类型，但是希望这个类型可以由实现者来选择而不是硬编码到 trait 声明中，这时关联类型就可以发挥作用了。</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    type AssociatedType;
    fn func(arg: Self::AssociatedType);
}

struct SomeType;
struct OtherType;

// any type implementing Trait can
// choose the type of AssociatedType

impl Trait for SomeType {
    type AssociatedType = i8; // chooses i8
    fn func(arg: Self::AssociatedType) {}
}

impl Trait for OtherType {
    type AssociatedType = u8; // chooses u8
    fn func(arg: Self::AssociatedType) {}
}

fn main() {
    SomeType::func(-1_i8); // can only call func with i8 on SomeType
    OtherType::func(1_u8); // can only call func with u8 on OtherType
}
</code></pre></pre>
<h4><a class="header" href="#泛型参数generic-parameters" id="泛型参数generic-parameters">泛型参数（Generic Parameters）</a></h4>
<p>“泛型参数”泛指泛型类型参数（generic type parameters）、泛型生命周期参数（generic lifetime parameters）、以及泛型常量参数（generic const parameters）。因为这些说起来比较拗口，所以人们通常把它们简称为 “泛型类型（generic type）”、“生命周期（lifetime）”和 “泛型常量（generic const）”。由于我们将要讨论的所有标准库 trait 中都没有使用泛型常量，所以它们不在本文的讨论范围之内。</p>
<p>我们可以使用参数来对一个 trait 声明进行泛化（generalize ）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// trait declaration generalized with lifetime &amp; type parameters
trait Trait&lt;'a, T&gt; {
    // signature uses generic type
    fn func1(arg: T);

    // signature uses lifetime
    fn func2(arg: &amp;'a i32);

    // signature uses generic type &amp; lifetime
    fn func3(arg: &amp;'a T);
}

struct SomeType;

impl&lt;'a&gt; Trait&lt;'a, i8&gt; for SomeType {
    fn func1(arg: i8) {}
    fn func2(arg: &amp;'a i32) {}
    fn func3(arg: &amp;'a i8) {}
}

impl&lt;'b&gt; Trait&lt;'b, u8&gt; for SomeType {
    fn func1(arg: u8) {}
    fn func2(arg: &amp;'b i32) {}
    fn func3(arg: &amp;'b u8) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>泛型可以具有默认值，最常用的默认值是<code>Self</code>，但是任何类型都可以作为默认值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// make T = Self by default
trait Trait&lt;T = Self&gt; {
    fn func(t: T) {}
}

// any type can be used as the default
trait Trait2&lt;T = i32&gt; {
    fn func2(t: T) {}
}

struct SomeType;

// omitting the generic type will
// cause the impl to use the default
// value, which is Self here
impl Trait for SomeType {
    fn func(t: SomeType) {}
}

// default value here is i32
impl Trait2 for SomeType {
    fn func2(t: i32) {}
}

// the default is overridable as we'd expect
impl Trait&lt;String&gt; for SomeType {
    fn func(t: String) {}
}

// overridable here too
impl Trait2&lt;String&gt; for SomeType {
    fn func2(t: String) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>除了可以对 trait 进行参数化之外，我们还可以对单个函数和方法进行参数化。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn func&lt;'a, T&gt;(t: &amp;'a T);
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#泛型类型-vs-关联类型" id="泛型类型-vs-关联类型">泛型类型 vs 关联类型</a></h4>
<p>泛型类型和关联类型都把在 trait 的函数和方法中使用哪种具体类型的决定权交给了实现者，因此这部分内容要去解释什么时候使用泛型类型，什么时候使用关联类型。</p>
<p>通常的经验法则是：</p>
<ul>
<li>
<p>当每个类型只应该有 trait 的一个实现时，使用关联类型。</p>
</li>
<li>
<p>当每个类型可能会有 trait 的多个实现时，使用泛型类型。</p>
</li>
</ul>
<p>比如说我们想要定义一个名为<code>Add</code>的 trait，该 trait 允许我们对值进行相加。下面是一个最初的设计和实现，里面只使用了关联类型。</p>
<pre><pre class="playground"><code class="language-rust">trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>假设现在我们想要添加这样一种功能：把<code>i32</code>加到<code>Point</code>上，其中<code>Point</code>里面的成员<code>x</code>和<code>y</code>都会加上<code>i32</code>。</p>
<pre><pre class="playground"><code class="language-rust">trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add for Point { // ❌
    type Rhs = i32;
    type Output = Point;
    fn add(self, rhs: i32) -&gt; Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2); // ❌
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>上面的代码会抛出错误：</p>
<pre><code>error[E0119]: conflicting implementations of trait `Add` for type `Point`:
  --&gt; src/main.rs:23:1
   |
12 | impl Add for Point {
   | ------------------ first implementation here
...
23 | impl Add for Point {
   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point`
</code></pre>
<p>因为<code>Add</code> trait 没有被任何的泛型类型参数化，我们只能在每个类型上实现这个 trait 一次，这意味着，我们只能一次把<code>Rhs</code>和<code>Output</code>类型都选取好！为了能够使<code>Point</code>和<code>i32</code>类型都能和<code>Point</code>相加，我们必须把<code>Rhs</code>从一个关联类型重构为泛型类型，这样就能够让我们根据<code>Rhs</code>不同的类型参数来为<code>Point</code>实现 trait 多次。</p>
<pre><pre class="playground"><code class="language-rust">trait Add&lt;Rhs&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add&lt;Point&gt; for Point {
    type Output = Self;
    fn add(self, rhs: Point) -&gt; Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add&lt;i32&gt; for Point { // ✅
    type Output = Self;
    fn add(self, rhs: i32) -&gt; Self::Output {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2); // ✅
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
</code></pre></pre>
<p>假如说我们增加了一个名为<code>Line</code>的新类型，它包含两个<code>Point</code>，现在，在我们的程序中存在这样一种上下文环境，即将两个<code>Point</code>相加之后应该产生一个<code>Line</code>而不是另一个<code>Point</code>。这在当我们当前的<code>Add</code> trait 设计中是不可行的，因为<code>Output</code>是一个关联类型，但是我们通过把<code>Output</code>从关联类型重构为泛型类型来实现这个新需求。</p>
<pre><pre class="playground"><code class="language-rust">trait Add&lt;Rhs, Output&gt; {
    fn add(self, rhs: Rhs) -&gt; Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add&lt;Point, Point&gt; for Point {
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add&lt;i32, Point&gt; for Point {
    fn add(self, rhs: i32) -&gt; Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

struct Line {
    start: Point,
    end: Point,
}

impl Add&lt;Point, Line&gt; for Point { // ✅
    fn add(self, rhs: Point) -&gt; Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3: Point = p1.add(p2);
    assert!(p3.x == 3 &amp;&amp; p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2);
    assert!(p3.x == 3 &amp;&amp; p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let l: Line = p1.add(p2); // ✅
    assert!(l.start.x == 1 &amp;&amp; l.start.y == 1 &amp;&amp; l.end.x == 2 &amp;&amp; l.end.y == 2)
}
</code></pre></pre>
<p>所以，哪个<code>Add</code> trait 是最好的呢？这取决于你程序中的需求！放在合适的场景中，它们都很好。</p>
<h3><a class="header" href="#作用域scope" id="作用域scope">作用域（Scope）</a></h3>
<p>只有当 trait 在作用域之中时，trait 项才能被使用。大多数 Rustaceans 在第一次尝试写一个 I/O 相关的程序时，都会在吃过一番苦头之后了解到这一点，因为<code>Read</code>和<code>Write</code>的 trait 并不在标准库的预置（prelude）中。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = File::open(&quot;Cargo.toml&quot;)?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer)?; // ❌ read_to_string not found in File
    Ok(())
}
</code></pre></pre>
<p><code>read_to_string(buf: &amp;mut String)</code>声明于<code>std::io::Read</code>中并且被<code>std::fs::File</code>结构体实现，但是要想调用它，<code>std::io::Read</code>必须在当前作用域中。</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;
use std::io::Read; // ✅

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = File::open(&quot;Cargo.toml&quot;)?;
    let mut buffer = String::new();
    file.read_to_string(&amp;mut buffer)?; // ✅
    Ok(())
}
</code></pre></pre>
<p>标准库预置（The standard library prelude）是标准库中的一个模块，也就是说，<code>std::prelude::v1</code>，它在每个其他模块的顶部被自动导入，即<code>use std::prelude::v1::*</code>。这样的话，下面这些 trait 就总会在作用域中，我们不需要自己显式地导入它们，因为它们是预置的一部分。</p>
<ul>
<li>AsMut</li>
<li>AsRef</li>
<li>Clone</li>
<li>Copy</li>
<li>Default</li>
<li>Drop</li>
<li>Eq</li>
<li>Fn</li>
<li>FnMut</li>
<li>FnOnce</li>
<li>From</li>
<li>Into</li>
<li>ToOwned</li>
<li>IntoIterator</li>
<li>Iterator</li>
<li>PartialEq</li>
<li>PartialOrd</li>
<li>Send</li>
<li>Sized</li>
<li>Sync</li>
<li>ToString</li>
<li>Ord</li>
</ul>
<h3><a class="header" href="#派生宏derive-macros" id="派生宏derive-macros">派生宏（Derive Macros）</a></h3>
<p>标准库导出了一小部分派生宏，这么派生宏可以让我们可以便捷地在一个类型上实现 trait，前提是该类型的所有成员都实现了这个 trait。派生宏以它们所实现的 trait 来命名。</p>
<ul>
<li>Clone</li>
<li>Copy</li>
<li>Debug</li>
<li>Default</li>
<li>Eq</li>
<li>Hash</li>
<li>Ord</li>
<li>PartialEq</li>
<li>PartialOrd</li>
</ul>
<p>使用示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// macro derives Copy &amp; Clone impl for SomeType
#[derive(Copy, Clone)]
struct SomeType;
<span class="boring">}
</span></code></pre></pre>
<p>注意：派生宏也是过程宏（procedural macros），它们可以被用来做任何事情，没有强制规定它们必须要实现一个 trait，或者它们只能在所有成员都实现 trait 的情况下才能工作，这些只是标准库中派生宏所遵循的惯例。</p>
<h3><a class="header" href="#默认实现default-impls" id="默认实现default-impls">默认实现（Default Impls）</a></h3>
<p>Trait 可以为它们的函数和方法提供默认实现。</p>
<pre><pre class="playground"><code class="language-rust">trait Trait {
    fn method(&amp;self) {
        println!(&quot;default impl&quot;);
    }
}

struct SomeType;
struct OtherType;

// use default impl for Trait::method
impl Trait for SomeType {}

impl Trait for OtherType {
    // use our own impl for Trait::method
    fn method(&amp;self) {
        println!(&quot;OtherType impl&quot;);
    }
}

fn main() {
    SomeType.method(); // prints &quot;default impl&quot;
    OtherType.method(); // prints &quot;OtherType impl&quot;
}
</code></pre></pre>
<p>如果 trait 中的某些方法是完全通过 trait 的另一些方法来实现的，这就非常方便了。</p>
<pre><pre class="playground"><code class="language-rust">trait Greet {
    fn greet(&amp;self, name: &amp;str) -&gt; String;
    fn greet_loudly(&amp;self, name: &amp;str) -&gt; String {
        self.greet(name) + &quot;!&quot;
    }
}

struct Hello;
struct Hola;

impl Greet for Hello {
    fn greet(&amp;self, name: &amp;str) -&gt; String {
        format!(&quot;Hello {}&quot;, name)
    }
    // use default impl for greet_loudly
}

impl Greet for Hola {
    fn greet(&amp;self, name: &amp;str) -&gt; String {
        format!(&quot;Hola {}&quot;, name)
    }
    // override default impl
    fn greet_loudly(&amp;self, name: &amp;str) -&gt; String {
        let mut greeting = self.greet(name);
        greeting.insert_str(0, &quot;¡&quot;);
        greeting + &quot;!&quot;
    }
}

fn main() {
    println!(&quot;{}&quot;, Hello.greet(&quot;John&quot;)); // prints &quot;Hello John&quot;
    println!(&quot;{}&quot;, Hello.greet_loudly(&quot;John&quot;)); // prints &quot;Hello John!&quot;
    println!(&quot;{}&quot;, Hola.greet(&quot;John&quot;)); // prints &quot;Hola John&quot;
    println!(&quot;{}&quot;, Hola.greet_loudly(&quot;John&quot;)); // prints &quot;¡Hola John!&quot;
}
</code></pre></pre>
<p>标准库中的很多 trait 为很多它们的方法提供了默认实现。</p>
<h3><a class="header" href="#泛型覆盖实现generic-blanket-impls" id="泛型覆盖实现generic-blanket-impls">泛型覆盖实现（Generic Blanket Impls）</a></h3>
<p>泛型覆盖实现是一种在泛型类型而不是具体类型上的实现，为了解释为什么以及如何使用它，让我们从为整数类型实现一个<code>is_even</code>方法开始。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Even {
    fn is_even(self) -&gt; bool;
}

impl Even for i8 {
    fn is_even(self) -&gt; bool {
        self % 2_i8 == 0_i8
    }
}

impl Even for u8 {
    fn is_even(self) -&gt; bool {
        self % 2_u8 == 0_u8
    }
}

impl Even for i16 {
    fn is_even(self) -&gt; bool {
        self % 2_i16 == 0_i16
    }
}

// etc

#[test] // ✅
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
<span class="boring">}
</span></code></pre></pre>
<p>很明显，上面的实现十分啰嗦。而且，所有我们的实现几乎都是一样的。此外，如果 Rust 决定在未来增加更多的整数类型，我们必须回到这段代码中，用新的整数类型来更新它。我们可以通过使用泛型覆盖实现来解决所有的问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -&gt; bool;
}

// generic blanket impl
impl&lt;T&gt; Even for T
where
    T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
    u8: TryInto&lt;T&gt;,
    &lt;u8 as TryInto&lt;T&gt;&gt;::Error: Debug,
{
    fn is_even(self) -&gt; bool {
        // these unwraps will never panic
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

#[test] // ✅
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
<span class="boring">}
</span></code></pre></pre>
<p>不同于默认实现，泛型覆盖实现提供了方法的实现，所以它们不能被重写。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -&gt; bool;
}

impl&lt;T&gt; Even for T
where
    T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
    u8: TryInto&lt;T&gt;,
    &lt;u8 as TryInto&lt;T&gt;&gt;::Error: Debug,
{
    fn is_even(self) -&gt; bool {
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

impl Even for u8 { // ❌
    fn is_even(self) -&gt; bool {
        self % 2_u8 == 0_u8
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码会抛出下面的错误：</p>
<pre><code>error[E0119]: conflicting implementations of trait `Even` for type `u8`:
  --&gt; src/lib.rs:22:1
   |
10 | / impl&lt;T&gt; Even for T
11 | | where
12 | |     T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
13 | |     u8: TryInto&lt;T&gt;,
...  |
19 | |     }
20 | | }
   | |_- first implementation here
21 |
22 |   impl Even for u8 {
   |   ^^^^^^^^^^^^^^^^ conflicting implementation for `u8`
</code></pre>
<p>这些实现有重叠，因此它们是冲突的，所以 Rust 拒绝编译这段代码以确保 trait 的一致性。trait 一致性是指，对于任意给定的类型，最多存在某一 trait 的一个实现。Rust 用来强制执行特质一致性的规则，这些规则的含义，以及针对这些含义的变通方案都不在本文的讨论范围之内。</p>
<h3><a class="header" href="#subtraits--supertraits" id="subtraits--supertraits">Subtraits &amp; Supertraits</a></h3>
<p><code>subtrait</code>中的<code>sub</code>指的是子集（subset)，<code>supertrait</code>中的<code>super</code>指的是超集（superset）。如果我们有下面这个 trait 声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Subtrait: Supertrait {}
<span class="boring">}
</span></code></pre></pre>
<p>所有实现了<code>Subtrait</code>的类型是所有实现了<code>Supertrait</code>的类型的子集，或者反过来讲：所有实现了<code>Supertrait</code>的类型是所有实现了<code>Subtrait</code>类型的子集。而且，上面的代码是一种语法糖，展开来应该是：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Subtrait where Self: Supertrait {}
<span class="boring">}
</span></code></pre></pre>
<p>这是一个微妙而重要的区别，要明白约束在<code>Self</code>上，也就是实现<code>Subtrait</code>的类型而非<code>Subtrait</code>自身。后者也没有意义，因为 trait 约束只能作用于能够实现 trait 的具体类型，trait 本身不能实现其他的 trait：</p>
<pre><pre class="playground"><code class="language-rust">trait Supertrait {
    fn method(&amp;self) {
        println!(&quot;in supertrait&quot;);
    }
}

trait Subtrait: Supertrait {
    // this looks like it might impl or
    // override Supertrait::method but it
    // does not
    fn method(&amp;self) {
        println!(&quot;in subtrait&quot;)
    }
}

struct SomeType;

// adds Supertrait::method to SomeType
impl Supertrait for SomeType {}

// adds Subtrait::method to SomeType
impl Subtrait for SomeType {}

// both methods exist on SomeType simultaneously
// neither overriding or shadowing the other

fn main() {
    SomeType.method(); // ❌ ambiguous method call
    // must disambiguate using fully-qualified syntax
    &lt;SomeType as Supertrait&gt;::method(&amp;st); // ✅ prints &quot;in supertrait&quot;
    &lt;SomeType as Subtrait&gt;::method(&amp;st); // ✅ prints &quot;in subtrait&quot;
}
</code></pre></pre>
<p>此外，对于一个类型如何同时实现一个 subtrait 和一个 supertrait，也没有明确的规则。它可以在另一个类型的实现中实现其他的方法。</p>
<pre><pre class="playground"><code class="language-rust">trait Supertrait {
    fn super_method(&amp;mut self);
}

trait Subtrait: Supertrait {
    fn sub_method(&amp;mut self);
}

struct CallSuperFromSub;

impl Supertrait for CallSuperFromSub {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
    }
}

impl Subtrait for CallSuperFromSub {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
        self.super_method();
    }
}

struct CallSubFromSuper;

impl Supertrait for CallSubFromSuper {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
        self.sub_method();
    }
}

impl Subtrait for CallSubFromSuper {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
    }
}

struct CallEachOther(bool);

impl Supertrait for CallEachOther {
    fn super_method(&amp;mut self) {
        println!(&quot;in super&quot;);
        if self.0 {
            self.0 = false;
            self.sub_method();
        }
    }
}

impl Subtrait for CallEachOther {
    fn sub_method(&amp;mut self) {
        println!(&quot;in sub&quot;);
        if self.0 {
            self.0 = false;
            self.super_method();
        }
    }
}

fn main() {
    CallSuperFromSub.super_method(); // prints &quot;in super&quot;
    CallSuperFromSub.sub_method(); // prints &quot;in sub&quot;, &quot;in super&quot;

    CallSubFromSuper.super_method(); // prints &quot;in super&quot;, &quot;in sub&quot;
    CallSubFromSuper.sub_method(); // prints &quot;in sub&quot;

    CallEachOther(true).super_method(); // prints &quot;in super&quot;, &quot;in sub&quot;
    CallEachOther(true).sub_method(); // prints &quot;in sub&quot;, &quot;in super&quot;
}
</code></pre></pre>
<p>希望上面的例子能够表达出，subtrait 和 supertrait 之间可以是很复杂的关系。在介绍能够将这些复杂性进行整洁封装的心智模型之前，让我们快速回顾并建立我们用来理解泛型类型上的 trait 约束的心智模型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T: Clone&gt;(t: T) {
    // impl
}
<span class="boring">}
</span></code></pre></pre>
<p>在不知道这个函数的实现的情况下，我们可以合理地猜测，<code>t.clone()</code>会在某个时候被调用，因为当一个泛型类型被一个 trait 所约束时，意味着它对 trait 有依赖性。泛型与 trait 约束之间关系的心智模型是一个简单而直观的模型：泛型依赖于 trait 约束。</p>
<p>现在让我们看看<code>Copy</code>的 trait 声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy: Clone {}
<span class="boring">}
</span></code></pre></pre>
<p>上面的语法看起来与在一个泛型类型上应用 trait 约束很相似，但是<code>Copy</code>完全不依赖于<code>Clone</code>。之前的模型在这里没有帮助。个人认为，理解 subtrait 和 supertrait 最为简洁优雅的心智模型是：subtrait 细化（refine）了它们的 supertrait。</p>
<p>“细化（Refinement）”刻意保持一定的模糊性，因为它们在不同的上下文环境中会有不同的含义：</p>
<ul>
<li>
<p>subtrait 可能会使得 supertrait 的方法实现更为具体，快速，占用更少的内存，例如，<code>Copy:Clone</code>；</p>
</li>
<li>
<p>subtrait 可能会对 supertrait 的方法实现增加额外的保证，例如：<code>Eq: PartialEq</code>,<code>Ord: PartialOrd</code>,<code>ExactSizeIterator: Iterator</code>;</p>
</li>
<li>
<p>subtrait 可能会使得 supertrait 的方法更为灵活和易于调用，例如：<code>FnMut: FnOnce</code>,<code>Fn: FnMut</code>;</p>
</li>
<li>
<p>subtrait 可能会扩展 supertrait 并添加新的方法，例如：<code>DoubleEndedIterator: Iterator</code>,<code>ExactSizeIterator: Iterator</code>。</p>
</li>
</ul>
<h3><a class="header" href="#trait-对象" id="trait-对象">Trait 对象</a></h3>
<p>泛型给我们提供了编译期多态，而 trait 对象给我们提供了运行时多态。我们可以使用 trait 对象来让函数在运行时动态地返回不同的类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(condition: bool, vec: Vec&lt;i32&gt;) -&gt; Box&lt;dyn Iterator&lt;Item = i32&gt;&gt; {
    let iter = vec.into_iter();
    if condition {
        // Has type:
        // Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;
        // But is cast to:
        // Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
        Box::new(iter.map(|n| n * 2))
    } else {
        // Has type:
        // Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;
        // But is cast to:
        // Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
        Box::new(iter.filter(|&amp;n| n &gt;= 2))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 对象还允许我们在集合中存储多种类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::f64::consts::PI;

struct Circle {
    radius: f64,
}

struct Square {
    side: f64
}

trait Shape {
    fn area(&amp;self) -&gt; f64;
}

impl Shape for Circle {
    fn area(&amp;self) -&gt; f64 {
        PI * self.radius * self.radius
    }
}

impl Shape for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn get_total_area(shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt;) -&gt; f64 {
    shapes.into_iter().map(|s| s.area()).sum()
}

fn example() {
    let shapes: Vec&lt;Box&lt;dyn Shape&gt;&gt; = vec![
        Box::new(Circle { radius: 1.0 }), // Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;
        Box::new(Square { side: 1.0 }), // Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;
    ];
    assert_eq!(PI + 1.0, get_total_area(shapes)); // ✅
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait 对象是没有大小的，所以它们必须总是在一个指针后面。我们可以根据类型中<code>dyn</code>关键字的存在来区分具体类型和 trait 对象在类型级别上的区别。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;
trait Trait {}

// regular struct
&amp;Struct
Box&lt;Struct&gt;
Rc&lt;Struct&gt;
Arc&lt;Struct&gt;

// trait objects
&amp;dyn Trait
Box&lt;dyn Trait&gt;
Rc&lt;dyn Trait&gt;
Arc&lt;dyn Trait&gt;
<span class="boring">}
</span></code></pre></pre>
<p>不是所有的 trait 都可以被转成 trait 对象。当且仅当一个 trait 满足下面这些要求时，它才是对象安全的（object-safe）：</p>
<ul>
<li>trait 不要求<code>Self:Sized</code></li>
<li>trait 的所有方法都是对象安全的</li>
</ul>
<p>当一个 trait 方法满足下面的要求时，该方法是对象安全的：</p>
<ul>
<li>方法要求<code>Self:Sized</code> 或者</li>
<li>方法在其接收者位置仅使用一个<code>Self</code>类型</li>
</ul>
<p>理解为什么要求是这样的，与本文的其余部分无关，但如果你仍然好奇，可以阅读<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md" title="Sizeness in Rust">Sizeness in Rust</a>（译注：Sizedness in Rust 这篇文章已翻译，可在公众号翻阅往期文章）。</p>
<h3><a class="header" href="#标记-traitmarker-traits" id="标记-traitmarker-traits">标记 Trait（Marker Traits）</a></h3>
<p>标记 trait 是不含 trait 项的 trait。它们的工作把实现类型“标记（mark）”为具有某种属性，否则就没有办法在类型系统中去表示。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impling PartialEq for a type promises
// that equality for the type has these properties:
// - symmetry: a == b implies b == a, and
// - transitivity: a == b &amp;&amp; b == c implies a == c
// But DOES NOT promise this property:
// - reflexivity: a == a
trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;
}

// Eq has no trait items! The eq method is already
// declared by PartialEq, but &quot;impling&quot; Eq
// for a type promises this additional equality property:
// - reflexivity: a == a
trait Eq: PartialEq {}

// f64 impls PartialEq but not Eq because NaN != NaN
// i32 impls PartialEq &amp; Eq because there's no NaNs :)
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#自动-traitauto-trait" id="自动-traitauto-trait">自动 Trait（Auto Trait）</a></h3>
<p>自动 Trait 是指如果一个类型的所有成员都实现了该 trait，该类型就会自动实现该 trait。“成员（member）”的含义取决于类型，例如：结构体的字段、枚举的变量、数组的元素、元组的项，等等。</p>
<p>所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait。自动 trait 必须是标记 trait，所以编译器可以为它们提供一个自动的默认实现，如果它们有任何 trait 项，这就不可能实现了。</p>
<p>自动 trait 的例子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// implemented for types which are safe to send between threads
unsafe auto trait Send {}

// implemented for types whose references are safe to send between threads
unsafe auto trait Sync {}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#不安全-traitunsafe-trait" id="不安全-traitunsafe-trait">不安全 Trait（Unsafe Trait）</a></h3>
<p>Trait 可以被标记为 unsafe，以表明实现该 trait 可能需要 unsafe 代码。<code>Send</code>和<code>Sync</code>都被标记为 unsafe，因为如果它们不是自动实现的类型，就意味着它必须包含一些非<code>Send</code>或非<code>Sync</code>的成员，如果我们想手动标记类型为<code>Send</code>和<code>Sync</code>，作为实现者我们必须格外小心，确保没有数据竞争。</p>
<h2><a class="header" href="#自动-trait" id="自动-trait">自动 Trait</a></h2>
<h3><a class="header" href="#send--sync" id="send--sync">Send &amp; Sync</a></h3>
<p>所需预备知识</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe auto trait Send {}
unsafe auto trait Sync {}
<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型是<code>Send</code>，这就意味着它可以在线程之间被安全地发送（send）。如果一个类型是<code>Sync</code>，这就意味着它可以在线程间安全地共享引用。说得更准确点就是，当且仅当<code>&amp;T</code>是<code>Send</code>时，类型<code>T</code>是<code>Sync</code>。</p>
<p>几乎所有的类型都是<code>Send</code>和<code>Sync</code>。唯一值得注意的<code>Send</code>例外是<code>Rc</code>，<code>Sync</code>例外中需要注意的是<code>Rc</code>，<code>Cell</code>，<code>RefCell</code>。如果我们需要一个满足<code>Send</code>的<code>Rc</code>，我们可以使用<code>Arc</code>。如果我们需要一个<code>Cell</code>或<code>RefCell</code>的<code>Sync</code>版本，我们可以使用<code>Mutex</code>或<code>RwLock</code>。尽管我们使用<code>Mutex</code>和<code>RwLock</code>来包装一个原始类型，但通常来讲，使用标准库提供的原子类型会更好一些，比如<code>AtomicBool</code>，<code>AtomicI32</code>，<code>AtomicUsize</code>等等。</p>
<p>几乎所有的类型都是<code>Sync</code>这件事，可能会让一些人感到惊讶，但它是真的，即使是对于没有任何内部同步的类型来讲，也是如此。这能够得以实现要归功于 Rust 严格的借用规则。</p>
<p>我们可以传递同一份数据的若干个不可变引用到多个线程中，由于只要有不可变引用存在，Rust 就会静态地保证底层数据不被修改，所以我们可以保证不会发生数据竞争。</p>
<pre><pre class="playground"><code class="language-rust">use crossbeam::thread;

fn main() {
    let mut greeting = String::from(&quot;Hello&quot;);
    let greeting_ref = &amp;greeting;

    thread::scope(|scoped_thread| {
        // spawn 3 threads
        for n in 1..=3 {
            // greeting_ref copied into every thread
            scoped_thread.spawn(move |_| {
                println!(&quot;{} {}&quot;, greeting_ref, n); // prints &quot;Hello {n}&quot;
            });
        }

        // line below could cause UB or data races but compiler rejects it
        greeting += &quot; world&quot;; // ❌ cannot mutate greeting while immutable refs exist
    });

    // can mutate greeting after every thread has joined
    greeting += &quot; world&quot;; // ✅
    println!(&quot;{}&quot;, greeting); // prints &quot;Hello world&quot;
}
</code></pre></pre>
<p>同样地，我们可以把数据的一个可变引用传递给一个单独的线程，由于 Rust 静态地保证不存在可变引用的别名，所以底层数据不会通过另一个可变引用被修改，因此我们也可以保证不会发生数据竞争。</p>
<pre><pre class="playground"><code class="language-rust">use crossbeam::thread;

fn main() {
    let mut greeting = String::from(&quot;Hello&quot;);
    let greeting_ref = &amp;mut greeting;

    thread::scope(|scoped_thread| {
        // greeting_ref moved into thread
        scoped_thread.spawn(move |_| {
            *greeting_ref += &quot; world&quot;;
            println!(&quot;{}&quot;, greeting_ref); // prints &quot;Hello world&quot;
        });

        // line below could cause UB or data races but compiler rejects it
        greeting += &quot;!!!&quot;; // ❌ cannot mutate greeting while mutable refs exist
    });

    // can mutate greeting after the thread has joined
    greeting += &quot;!!!&quot;; // ✅
    println!(&quot;{}&quot;, greeting); // prints &quot;Hello world!!!&quot;
}
</code></pre></pre>
<p>这就是为什么大多数类型在不需要任何显式同步的情况下，都满足<code>Sync</code>的原因。当我们需要在多线程中同时修改某个数据<code>T</code>时，除非我们用<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>或者<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>来包装这个数据，否则编译器是不会允许我们进行这种操作，所以编译器会在需要时强制要求进行显式地同步。</p>
<h3><a class="header" href="#sized" id="sized">Sized</a></h3>
<p>如果一个类型是<code>Sized</code>，这意味着它的类型大小在编译期是可知的，并且可以在栈上创建一个该类型的实例。</p>
<p>类型的大小及其含义是一个微妙而巨大的话题，影响到编程语言的许多方面。因为它十分重要，所以我单独写了一篇文章<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md" title="Sizedness in Rust">Sizedness in Rust</a>，如果有人想要更深入地了解 sizedness，我强烈推荐阅读这篇文章。我会把这篇文章的关键内容总结在下面。</p>
<ol>
<li>所有的泛型类型都有一个隐含的<code>Sized</code>约束。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn func&lt;T&gt;(t: &amp;T) {}

// example above desugared
fn func&lt;T: Sized&gt;(t: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>因为所有的泛型类型上都有一个隐含的<code>Sized</code>约束，如果我们想要选择退出这个约束，我们需要使用特定的“宽松约束（relaxed bound）”语法——<code>?Sized</code>，该语法目前只为<code>Sized</code> trait 存在。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// now T can be unsized
fn func&lt;T: ?Sized&gt;(t: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>所有的 trait 都有一个隐含的<code>?Sized</code>约束。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

// example above desugared
trait Trait: ?Sized {}
<span class="boring">}
</span></code></pre></pre>
<p>这是为了让 trait 对象能够实现 trait，重申一下，所有的细枝末节都在<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md">Sizedness in Rust</a>中。</p>
<h2><a class="header" href="#泛型-traits" id="泛型-traits">泛型 traits</a></h2>
<h3><a class="header" href="#default" id="default">Default</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>可以为实现了<code>Default</code>的类型构造默认值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color {
    r: u8,
    g: u8,
    b: u8,
}

impl Default for Color {
    // default color is black
    fn default() -&gt; Self {
        Color {
            r: 0,
            g: 0,
            b: 0,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这在快速构建原型的时候十分有用，尤其是在我们没有过多要求而只需要一个类型实例的情况下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // just give me some color!
    let color = Color::default();
}
</code></pre></pre>
<p>当我们想要显式地把函数暴露给用户时，也可以选择这样做：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Canvas;
enum Shape {
    Circle,
    Rectangle,
}

impl Canvas {
    // let user optionally pass a color
    fn paint(&amp;mut self, shape: Shape, color: Option&lt;Color&gt;) {
        // if no color is passed use the default color
        let color = color.unwrap_or_default();
        // etc
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当我们需要构造泛型类型时，<code>Default</code>在泛型上下文中也是有用的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn guarantee_length&lt;T: Default&gt;(mut vec: Vec&lt;T&gt;, min_len: usize) -&gt; Vec&lt;T&gt; {
    for _ in 0..min_len.saturating_sub(vec.len()) {
        vec.push(T::default());
    }
    vec
}
<span class="boring">}
</span></code></pre></pre>
<p>我们还可以利用<code>Default</code>类型结合 Rust 的结构体更新语法（struct update syntax）来对结构体部分初始化。现在，我们有一个<code>Color</code>结构体构造函数<code>new</code>，该函数接收结构体的所有成员作为参数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Color {
    fn new(r: u8, g: u8, b: u8) -&gt; Self {
        Color {
            r,
            g,
            b,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>但是，我们可以有更为便利的构造函数，这些构造函数分别只接收结构体的一部分成员，结构体剩下的其他成员使用默认值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Color {
    fn red(r: u8) -&gt; Self {
        Color {
            r,
            ..Color::default()
        }
    }
    fn green(g: u8) -&gt; Self {
        Color {
            g,
            ..Color::default()
        }
    }
    fn blue(b: u8) -&gt; Self {
        Color {
            b,
            ..Color::default()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>还有一个<code>Default</code>派生宏，通过使用它我们可以像下面这样来写<code>Color</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// default color is still black
// because u8::default() == 0
#[derive(Default)]
struct Color {
    r: u8,
    g: u8,
    b: u8
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#clone" id="clone">Clone</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Clone {
    fn clone(&amp;self) -&gt; Self;

    // provided default impls
    fn clone_from(&amp;mut self, source: &amp;Self);
}
<span class="boring">}
</span></code></pre></pre>
<p>我们能够把<code>Clone</code>类型的不可变引用转换为所拥有的值，即<code>&amp;T</code>-&gt;<code>T</code>。<code>Clone</code>不保证这种转换的效率，所以它会很慢并且成本较高。我们可以使用派生宏在一个类型上快速实现<code>Clone</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct SomeType {
    cloneable_member1: CloneableType1,
    cloneable_member2: CloneableType2,
    // etc
}

// macro generates impl below
impl Clone for SomeType {
    fn clone(&amp;self) -&gt; Self {
        SomeType {
            cloneable_member1: self.cloneable_member1.clone(),
            cloneable_member2: self.cloneable_member2.clone(),
            // etc
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Clone</code>可以用于在泛型上下文中构造一个类型实例。下面是从前面章节拿过来的一个例子，其中的<code>Default</code>被替换为了<code>Clone</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn guarantee_length&lt;T: Clone&gt;(mut vec: Vec&lt;T&gt;, min_len: usize, fill_with: &amp;T) -&gt; Vec&lt;T&gt; {
    for _ in 0..min_len.saturating_sub(vec.len()) {
        vec.push(fill_with.clone());
    }
    vec
}
<span class="boring">}
</span></code></pre></pre>
<p>人们通常把克隆（clone）作为一种避免和借用检查器打交道的逃生出口（escape hatch）。管理带有引用的结构体很具有挑战性，但是我们可以通过克隆把引用变为所拥有的值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// oof, we gotta worry about lifetimes 😟
struct SomeStruct&lt;'a&gt; {
    data: &amp;'a Vec&lt;u8&gt;,
}

// now we're on easy street 😎
struct SomeStruct {
    data: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们正在编写的程序对性能不敏感，那么我们就不需要担心克隆数据的问题。Rust 是一门暴露了很多底层细节的语言，所以开发者很容易陷入过早的优化而非真正解决眼前的问题。对于很多程序来讲，最好的优先级顺序通常是，首先构建正确性，其次是优雅性，第三是性能，仅当在对性能进行剖析并确定性能瓶颈之后再去关注性能。通常而言，这是一个值得采纳的好建议，但是你需要清楚，它未必适用于你的程序。</p>
<h3><a class="header" href="#copy" id="copy">Copy</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Copy:Clone{}
<span class="boring">}
</span></code></pre></pre>
<p>我们拷贝<code>Copy</code>类型，例如：<code>T</code>-&gt;<code>T</code>.<code>Copy</code>承诺拷贝操作是简单的按位拷贝，所以它是快速高效的。我们不能自己实现<code>Copy</code>，只有编译器可以提供实现，但是我们可以通过使用<code>Copy</code>派生宏让编译器这么做，就像使用<code>Clone</code>派生宏一样，因为<code>Copy</code>是<code>Clone</code>的一个 subtrait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct SomeType;
<span class="boring">}
</span></code></pre></pre>
<p><code>Copy</code>对<code>Clone</code>进行了细化。一个克隆（clone）操作可能很慢并且开销很大，但是拷贝（copy）操作保证是快速且开销较小的，所以拷贝是一种更快的克隆操作。如果一个类型实现了<code>Copy</code>，<code>Clone</code>实现就无关紧要了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this is what the derive macro generates
impl&lt;T: Copy&gt; Clone for T {
    // the clone method becomes just a copy
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当一个类型实现了<code>Copy</code>之后，它在被移动（move）时的行为就发生了改变。默认情况下，所有的类型都有<em>移动（move）语义</em> ，但是一旦某个类型实现了<code>Copy</code>，它就有了<em>拷贝（copy）语义</em> 。为了解释二者的不同，让我们看一下这些简单的场景：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a &quot;move&quot;, src: !Copy
let dest = src;

// a &quot;copy&quot;, src: Copy
let dest = src;
<span class="boring">}
</span></code></pre></pre>
<p>在上面两种情况下，<code>dest = src</code>对<code>src</code>的内容进行按位拷贝并把结果移动到<code>dest</code>，唯一的不同是，在第一种情况（&quot;a move&quot;）中，借用检查器使得<code>src</code>变量失效并确保它后面不会在任何其他地方被使用;在第二种情况下（&quot;a copy&quot;）中，<code>src</code>仍然是有效且可用的。</p>
<p>简而言之：拷贝就是移动，移动就是拷贝。它们之间唯一的区别就是其对待借用检查器的方式。</p>
<p>来看一个关于移动（move）的更具体的例子，假定<code>sec</code>是一个<code>Vec&lt;i32&gt;</code>类型，并且它的内容看起来像下面这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{ data: *mut [i32], length: usize, capacity: usize }
<span class="boring">}
</span></code></pre></pre>
<p>当我们执行了<code>dest = src</code>，我们会得到：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src = { data: *mut [i32], length: usize, capacity: usize }
dest = { data: *mut [i32], length: usize, capacity: usize }
<span class="boring">}
</span></code></pre></pre>
<p>在这个未知，<code>src</code>和<code>dest</code>对同一份数据各有一个可变引用别名，这是一个大忌，因此，借用检查器让<code>src</code>变量失效，在编译器不报错的情况下。使得它不能再被使用。</p>
<p>再来看一个关于拷贝（copy）的更具体的例子，假定<code>src</code>是一个<code>Option&lt;i32&gt;</code>，且它的内容看起来如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{ is_valid: bool, data: i32 }
<span class="boring">}
</span></code></pre></pre>
<p>现在，当我们执行<code>dest = src</code>时，我们会得到：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src = { is_valid: bool, data: i32 }
dest = { is_valid: bool, data: i32 }
<span class="boring">}
</span></code></pre></pre>
<p>它们俩同时都是可用的！因此，<code>Option&lt;i32&gt;</code>是<code>Copy</code>。</p>
<p>尽管<code>Copy</code>是一个自动 trait，但是 Rust 语言设计者决定，让类型显式地选择拷贝语义，而不是在类型符合条件时默默地继承拷贝语义，因为后者可能会引起经常导致 bug 的混乱行为。</p>
<h3><a class="header" href="#any" id="any">Any</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Any: 'static {
    fn type_id(&amp;self) -&gt; TypeId;
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 的多态风格是参数化的，但是如果我们正在尝试使用一种类似于动态类型语言的更为特别（ad-hoc）的多态风格，那么我们可以通过使用<code>Any</code> trait 来进行模拟。我们不必手动为我们的类型实现<code>Any</code> trait，因为这已经被 generic blanket impl 所涵盖：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: 'static + ?Sized&gt; Any for T {
    fn type_id(&amp;self) -&gt; TypeId {
        TypeId::of::&lt;T&gt;()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>我们通过使用<code>downcast_ref::&lt;T&gt;()</code>和<code>downcast_mut::&lt;T&gt;()</code>方法从一个<code>dyn Any</code>中拿出一个<code>T</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::any::Any;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&amp;mut self) {
        self.x += 1;
        self.y += 1;
    }
}

fn map_any(mut any: Box&lt;dyn Any&gt;) -&gt; Box&lt;dyn Any&gt; {
    if let Some(num) = any.downcast_mut::&lt;i32&gt;() {
        *num += 1;
    } else if let Some(string) = any.downcast_mut::&lt;String&gt;() {
        *string += &quot;!&quot;;
    } else if let Some(point) = any.downcast_mut::&lt;Point&gt;() {
        point.inc();
    }
    any
}

fn main() {
    let mut vec: Vec&lt;Box&lt;dyn Any&gt;&gt; = vec![
        Box::new(0),
        Box::new(String::from(&quot;a&quot;)),
        Box::new(Point::default()),
    ];
    // vec = [0, &quot;a&quot;, Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_any).collect();
    // vec = [1, &quot;a!&quot;, Point { x: 1, y: 1 }]
}
</code></pre></pre>
<p>这个 trait 很少需要用到，因为在大多数情况下，参数化多态要优于临时多态性，后者也可以用枚举（enum）来模拟，枚举具有更好的类型安全，需要的间接（抽象）也更少。例如，我们可以用下面的方式实现上面的例子：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&amp;mut self) {
        self.x += 1;
        self.y += 1;
    }
}

enum Stuff {
    Integer(i32),
    String(String),
    Point(Point),
}

fn map_stuff(mut stuff: Stuff) -&gt; Stuff {
    match &amp;mut stuff {
        Stuff::Integer(num) =&gt; *num += 1,
        Stuff::String(string) =&gt; *string += &quot;!&quot;,
        Stuff::Point(point) =&gt; point.inc(),
    }
    stuff
}

fn main() {
    let mut vec = vec![
        Stuff::Integer(0),
        Stuff::String(String::from(&quot;a&quot;)),
        Stuff::Point(Point::default()),
    ];
    // vec = [0, &quot;a&quot;, Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_stuff).collect();
    // vec = [1, &quot;a!&quot;, Point { x: 1, y: 1 }]
}

</code></pre></pre>
<p>尽管<code>Any</code>很少被需要用到，但是在某些时候它也会十分地便利，正如我们在后面错误处理（Error Handling）部分所看到的那样。</p>
<h2><a class="header" href="#格式化-traits-formatting-traits" id="格式化-traits-formatting-traits">格式化 Traits (Formatting Traits)</a></h2>
<p>我们可以使用<code>std::fmt</code>中的格式化宏来把类型序列化(serialize)为字符串，其中最为我们熟知的就是<code>println!</code>。我们可以把格式化参数传递给<code>{}</code>占位符，这些占位符用于选择使用哪个 trait 来序列化占位符参数。</p>
<table><thead><tr><th>Trait</th><th>Placeholder</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Display</code></td><td><code>{}</code></td><td>显示表示</td></tr>
<tr><td><code>Debug</code></td><td><code>{:?}</code></td><td>调试表示</td></tr>
<tr><td><code>Octal</code></td><td><code>{:o}</code></td><td>八进制表示</td></tr>
<tr><td><code>LowerHex</code></td><td><code>{:x}</code></td><td>小写十六进制表示</td></tr>
<tr><td><code>UpperHex</code></td><td><code>{:X}</code></td><td>大写十六进制表示</td></tr>
<tr><td><code>Pointer</code></td><td><code>{:p}</code></td><td>内存地址</td></tr>
<tr><td><code>Binary</code></td><td><code>{:b}</code></td><td>二进制表示</td></tr>
<tr><td><code>LowerExp</code></td><td><code>{:e}</code></td><td>小写指数表示</td></tr>
<tr><td><code>UpperExp</code></td><td><code>{:E}</code></td><td>大写指数表示</td></tr>
</tbody></table>
<h3><a class="header" href="#display--tostring" id="display--tostring">Display &amp; ToString</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Display</code>类型可以被序列化为对用户更为友好的<code>String</code>类型。以<code>Point</code>类型为列：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}

fn main() {
    println!(&quot;origin: {}&quot;, Point::default());
    // prints &quot;origin: (0, 0)&quot;

    // get Point's Display representation as a String
    let stringified_point = format!(&quot;{}&quot;, Point::default());
    assert_eq!(&quot;(0, 0)&quot;, stringified_point); // ✅
}
</code></pre></pre>
<p>除了使用<code>format!</code>宏让一个类型以<code>String</code>类型显示，我们还可以使用<code>ToString</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ToString {
    fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>这个 trait 不需要我们实现，事实上，由于 generic blanket impl，我们也不能去实现它，因为所有实现了<code>Display</code>的类型都会自动实现<code>ToString</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Display + ?Sized&gt; ToString for T;
<span class="boring">}
</span></code></pre></pre>
<p>在<code>Point</code>上使用<code>ToString</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test] // ✅
fn display_point() {
    let origin = Point::default();
    assert_eq!(format!(&quot;{}&quot;, origin), &quot;(0, 0)&quot;);
}

#[test] // ✅
fn point_to_string() {
    let origin = Point::default();
    assert_eq!(origin.to_string(), &quot;(0, 0)&quot;);
}

#[test] // ✅
fn display_equals_to_string() {
    let origin = Point::default();
    assert_eq!(format!(&quot;{}&quot;, origin), origin.to_string());
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#debug" id="debug">Debug</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Debug</code>和<code>Display</code>有着相同的签名。唯一的不同在于，只有当我门指定了<code>{:?}</code>才会调用<code>Debug</code>实现。<code>Debug</code>可以被派生：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// derive macro generates impl below
impl fmt::Debug for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_struct(&quot;Point&quot;)
            .field(&quot;x&quot;, &amp;self.x)
            .field(&quot;y&quot;, &amp;self.y)
            .finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>为一个类型实现<code>Debug</code>能够使得这个类型在<code>dbg!</code>中使用，<code>dbg!</code>宏在快速打印日志方面比<code>println!</code>更合适，它的一些优势如下：</p>
<ol>
<li><code>dbg!</code>打印到 stderr 而不是 stdout，因此在我们的程序中，能够很容易地和标准输出的输出结果区分。</li>
<li><code>dbg!</code>会连同传入的表达式和表达式的计算结果一起打印出来。</li>
<li><code>dbg!</code>会获取传入参数的所有权并将其返回，因此你可以在表达式中使用它：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_condition() -&gt; bool {
    true
}

// no logging
fn example() {
    if some_condition() {
        // some code
    }
}

// println! logging
fn example_println() {
    // 🤦
    let result = some_condition();
    println!(&quot;{}&quot;, result); // just prints &quot;true&quot;
    if result {
        // some code
    }
}

// dbg! logging
fn example_dbg() {
    // 😍
    if dbg!(some_condition()) { // prints &quot;[src/main.rs:22] some_condition() = true&quot;
        // some code
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><code>dbg!</code>的唯一缺点就是它不会在 release 构建中自动裁剪，所以如果我们不想在最后生成的二进制包含这些内容，就必须手动移除它。</p>
<h2><a class="header" href="#操作符-traitoperator-traits" id="操作符-traitoperator-traits">操作符 Trait（Operator Traits）</a></h2>
<p>Rust 中所有的操作符都和 trait 关联，如果我们想要为我们的类型实现一些操作符，我们就必须实现与之关联的 trait。
| Trait(s) | 分类（Category） | 操作符（Operator(s)） | 描述（Description） |
|----------|----------|-------------|-------------|
| <code>Eq</code>, <code>PartialEq</code> | 比较 | <code>==</code> | 相等 |
| <code>Ord</code>, <code>PartialOrd</code> | 比较 | <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> | 比较 |
| <code>Add</code> | 算术 | <code>+</code> | 相加 |
| <code>AddAssign</code> | 算术 | <code>+=</code> | 相加并赋值 |
| <code>BitAnd</code> | 算术 | <code>&amp;</code> | 按位与 |
| <code>BitAndAssign</code> | 算术 | <code>&amp;=</code> | 按位与并赋值 |
| <code>BitXor</code> | 算术 | <code>^</code> | 按位异或 |
| <code>BitXorAssign</code> | 算术 | <code>^=</code> | 按位异或并赋值 |
| <code>Div</code> | 算术 | <code>/</code> | 除 |
| <code>DivAssign</code> | 算术 | <code>/=</code> | 除并赋值 |
| <code>Mul</code> | 算术 | <code>*</code> | 乘 |
| <code>MulAssign</code> | 算术 | <code>*=</code> | 乘并赋值 |
| <code>Neg</code> | 算术 | <code>-</code> | 一元求反 |
| <code>Not</code> | 算术 | <code>!</code> | 一元逻辑求反 |
| <code>Rem</code> | 算术 | <code>%</code> | 求余 |
| <code>RemAssign</code> | 算术 | <code>%=</code> | 求余并赋值|
| <code>Shl</code> | 算术 | <code>&lt;&lt;</code> | 左移 |
| <code>ShlAssign</code> | 算术 | <code>&lt;&lt;=</code> | 左移并赋值 |
| <code>Shr</code> | 算术 | <code>&gt;&gt;</code> | 右移 |
| <code>ShrAssign</code> | 算术 | <code>&gt;&gt;=</code> | 右移并赋值 |
| <code>Sub</code> | 算术 | <code>-</code> | 减 |
| <code>SubAssign</code> | 算术 | <code>-=</code> | 减并赋值 |
| <code>Fn</code> | 闭包 | <code>(...args)</code> | 不可变闭包调用 |
| <code>FnMut</code> | 闭包 | <code>(...args)</code> | 可变闭包调用 |
| <code>FnOnce</code> | 闭包 | <code>(...args)</code> | 一次性闭包调用 |
| <code>Deref</code> | 其他 | <code>*</code> | 不可变解引用 |
| <code>DerefMut</code> | 其他 | <code>*</code> | 可变解引用 |
| <code>Drop</code> | 其他 | - | 类型析构 |
| <code>Index</code> | 其他 | <code>[]</code> | 不可变索引 |
| <code>IndexMut</code> | 其他 | <code>[]</code> |可变索引|
| <code>RangeBounds</code> | 其他 | <code>..</code> | 区间 |</p>
<h3><a class="header" href="#比较-trait-comparison-traits" id="比较-trait-comparison-traits">比较 Trait （Comparison Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Eq</code>, <code>PartialEq</code></td><td>比较</td><td><code>==</code></td><td>相等</td></tr>
<tr><td><code>Ord</code>, <code>PartialOrd</code></td><td>比较</td><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>比较</td></tr>
</tbody></table>
<h4><a class="header" href="#partialeq--eq" id="partialeq--eq">PartialEq &amp; Eq</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait PartialEq&lt;Rhs = Self&gt;
where
    Rhs: ?Sized,
{
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;

    // provided default impls
    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>PartialEq&lt;Rhs&gt;</code>类型可以通过<code>==</code>操作符检查是否和<code>Rhs</code>类型相等。</p>
<p>所有的<code>PartialEq&lt;Rhs&gt;</code>实现必须确保相等性是对称的和可传递的。这意味着，对于任意的<code>a</code>、<code>b</code>、<code>c</code>:</p>
<ul>
<li><code>a == b</code>也意味着<code>b == a</code>（对称性）</li>
<li><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code> （传递性）</li>
</ul>
<p>默认情况下，<code>Rhs = Self</code>，因为我们几乎总是想要比较同一类型的不同实例，而不是不同类型的不同实例。这也保证了我们的实现是对称的和可传递的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32
}

// Rhs == Self == Point
impl PartialEq for Point {
    // impl automatically symmetric &amp; transitive
    fn eq(&amp;self, other: &amp;Point) -&gt; bool {
        self.x == other.x &amp;&amp; self.y == other.y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型的所有成员都实现了<code>PartialEq</code>，则它会派生实现<code>PartialEq</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Point {
    x: i32,
    y: i32
}

#[derive(PartialEq)]
enum Suit {
    Spade,
    Heart,
    Club,
    Diamond,
}

<span class="boring">}
</span></code></pre></pre>
<p>一旦我们为自己的类型实现了<code>PartialEq</code>，我们就能够轻松地在类型的引用之间进行相等性比较，这要归功于 generic blanket impls：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this impl only gives us: Point == Point
#[derive(PartialEq)]
struct Point {
    x: i32,
    y: i32
}

// all of the generic blanket impls below
// are provided by the standard library

// this impl gives us: &amp;Point == &amp;Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ B&gt; for &amp;'_ A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;mut Point == &amp;Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ B&gt; for &amp;'_ mut A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;Point == &amp;mut Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ mut B&gt; for &amp;'_ A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

// this impl gives us: &amp;mut Point == &amp;mut Point
impl&lt;A, B&gt; PartialEq&lt;&amp;'_ mut B&gt; for &amp;'_ mut A
where A: PartialEq&lt;B&gt; + ?Sized, B: ?Sized;

<span class="boring">}
</span></code></pre></pre>
<p>因为这个 trait 是泛型的，所以我们可以在不同的类型之间定义相等性（比较）。标准库利用这一点实现了类字符串类型之间的相互比较，比如<code>String</code>、<code>&amp;str</code>、<code>PathBuf</code>、<code>&amp;Path</code>、<code>OsString</code>、<code>&amp;OsStr</code>等等。</p>
<p>通常，我们应该仅为特定的不同类型之间实现相等性，这些不同类型包含了相同类型的数据，并且它们之间唯一的区别是表现数据的方式和与数据交互的方式。</p>
<p>下面是一个反面实例，关于某人试图在没有满足上述规则的不同类型之间实现<code>PartialEq</code>用以检查完整性的例子：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq)]
enum Suit {
    Spade,
    Club,
    Heart,
    Diamond,
}

#[derive(PartialEq)]
enum Rank {
    Ace,
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
}

#[derive(PartialEq)]
struct Card {
    suit: Suit,
    rank: Rank,
}

// check equality of Card's suit
impl PartialEq&lt;Suit&gt; for Card {
    fn eq(&amp;self, other: &amp;Suit) -&gt; bool {
        self.suit == *other
    }
}

// check equality of Card's rank
impl PartialEq&lt;Rank&gt; for Card {
    fn eq(&amp;self, other: &amp;Rank) -&gt; bool {
        self.rank == *other
    }
}

fn main() {
    let AceOfSpades = Card {
        suit: Suit::Spade,
        rank: Rank::Ace,
    };
    assert!(AceOfSpades == Suit::Spade); // ✅
    assert!(AceOfSpades == Rank::Ace); // ✅
}

</code></pre></pre>
<p><code>Eq</code>是一个标记 trait，并且是<code>PartialEq&lt;Self&gt;</code>的一个 subtrait。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Eq: PartialEq&lt;Self&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们为一个类型实现了<code>Eq</code>，在<code>PartialEq</code>所要求的对称性和可传递性之上，我们还保证了反射性（reflexivity），也就是对于任意的<code>a</code>，都有<code>a == a</code>。从这种意义上来说，<code>Eq</code>对<code>PartialEq</code>进行了细化，因为它表示了一个更为严格的相等性。如果一个类型的所有成员都实现了<code>Eq</code>，那么<code>Eq</code>的实现可以派生到这个类型。</p>
<p>浮点型实现了<code>PartialEq</code>但是没有实现<code>Eq</code>，因为<code>NaN != NaN</code>。几乎所有其他的实现了<code>PartialEq</code>的类型都实现了<code>Eq</code>，除非它们包含浮点类型。</p>
<p>一旦一个类型实现了<code>PartialEq</code>和<code>Debug</code>，我们可以就可以在<code>assert_eq!</code>宏中使用它。我们还可以比较实现了<code>PartialEq</code>类型的集合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn example_assert(p1: Point, p2: Point) {
    assert_eq!(p1, p2);
}

fn example_compare_collections&lt;T: PartialEq&gt;(vec1: Vec&lt;T&gt;, vec2: Vec&lt;T&gt;) {
    // if T: PartialEq this now works!
    if vec1 == vec2 {
        // some code
    } else {
        // other code
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#hash" id="hash">Hash</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hash {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H);

    // provided default impls
    fn hash_slice&lt;H: Hasher&gt;(data: &amp;[Self], state: &amp;mut H);
}
<span class="boring">}
</span></code></pre></pre>
<p>这个 trait 没有与任何操作符关联，但是讨论它的最好时机就是在<code>PartialEq</code>和<code>Eq</code>之后，所以把它写在这里。<code>Hash</code>类型可以通过一个<code>Hasher</code>被（计算）哈希。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::Hasher;
use std::hash::Hash;

struct Point {
    x: i32,
    y: i32,
}

impl Hash for Point {
    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        hasher.write_i32(self.x);
        hasher.write_i32(self.y);
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>使用派生宏可以生成和上面一样的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Point {
    x: i32,
    y: i32,
}

<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型同时实现了<code>Hash</code>和<code>Eq</code>，那么这些实现必须达成一致，从而保证对于所有的<code>a</code>和<code>b</code>，如果<code>a == b</code>那么<code>a.hash() == b.hash()</code>。因此，当为一个类型同时实现这两个 trait 时，要么都用派生宏，要么都手动实现，但是不要混合，否则我们就有可能破坏上面的不变性。</p>
<p>为一个类型实现<code>Eq</code>和<code>Hash</code>的最大好处是，它让我们能够把类型作为 key 存储在<code>HashMap</code>和<code>HashSet</code>中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

// now our type can be stored
// in HashSets and HashMaps!
#[derive(PartialEq, Eq, Hash)]
struct Point {
    x: i32,
    y: i32,
}

fn example_hashset() {
    let mut points = HashSet::new();
    points.insert(Point { x: 0, y: 0 }); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#partialord--ord" id="partialord--ord">PartialOrd &amp; Ord</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Ordering {
    Less,
    Equal,
    Greater,
}

trait PartialOrd&lt;Rhs = Self&gt;: PartialEq&lt;Rhs&gt;
where
    Rhs: ?Sized,
{
    fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;;

    // provided default impls
    fn lt(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn le(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn gt(&amp;self, other: &amp;Rhs) -&gt; bool;
    fn ge(&amp;self, other: &amp;Rhs) -&gt; bool;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>PartialOrd&lt;Rhs&gt;</code>类型可以通过<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>操作符和<code>Rhs</code>类型比较。所有的<code>PartialOrd&lt;Rhs&gt;</code>实现必须保证比较时非对称和可传递的。这意味着，对于任意的<code>a</code>、<code>b</code>和<code>c</code>：</p>
<ul>
<li><code>a &lt; b</code>意味着<code>!(a&gt;b)</code>（非对称性）</li>
<li><code>a &lt; b &amp;&amp; b &lt; c</code> 意味着<code>a &lt; c</code>(传递性)</li>
</ul>
<p><code>PartialOrd</code>是<code>PartialEq</code>的一个 subtrait，并且它们的实现必须相互一致。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn must_always_agree&lt;T: PartialOrd + PartialEq&gt;(t1: T, t2: T) {
    assert_eq!(t1.partial_cmp(&amp;t2) == Some(Ordering::Equal), t1 == t2);
}

<span class="boring">}
</span></code></pre></pre>
<p>当比较<code>PartialEq</code>类型时，我们可以检查是否它们相等或者不相等，但是当比较<code>PartialOrd</code>类型时，我们除了可以检查是否它们相等或不相等自己哦之外，如果它们不相等，我们还可以检查它们不相等是因为第一项小于第二项或者是第一项大于第二项。</p>
<p>默认情况下，<code>Rhs == Self</code>，因为我们总是想要比较同一类型的实例，而不是对不同类型的实例。这也自动保证了我们的实现是对称的和可传递的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

#[derive(PartialEq, PartialOrd)]
struct Point {
    x: i32,
    y: i32
}

// Rhs == Self == Point
impl PartialOrd for Point {
    // impl automatically symmetric &amp; transitive
    fn partial_cmp(&amp;self, other: &amp;Point) -&gt; Option&lt;Ordering&gt; {
        Some(match self.x.cmp(&amp;other.x) {
            Ordering::Equal =&gt; self.y.cmp(&amp;other.y),
            ordering =&gt; ordering,
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型的所有成员都实现了<code>PartialOrd</code>，那么它就可以被派生：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, PartialOrd)]
struct Point {
    x: i32,
    y: i32,
}

#[derive(PartialEq, PartialOrd)]
enum Stoplight {
    Red,
    Yellow,
    Green,
}
<span class="boring">}
</span></code></pre></pre>
<p>派生宏<code>PartialOrd</code>根据字典序（lexicographical）对它们的成员进行排序：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// generates PartialOrd impl which orders
// Points based on x member first and
// y member second because that's the order
// they appear in the source code
#[derive(PartialOrd, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

// generates DIFFERENT PartialOrd impl
// which orders Points based on y member
// first and x member second
#[derive(PartialOrd, PartialEq)]
struct Point {
    y: i32,
    x: i32,
}

<span class="boring">}
</span></code></pre></pre>
<p><code>Ord</code>是<code>Eq</code>和<code>PartialOrd&lt;Self&gt;</code>的一个 subtrait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Ord: Eq + PartialOrd&lt;Self&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;

    // provided default impls
    fn max(self, other: Self) -&gt; Self;
    fn min(self, other: Self) -&gt; Self;
    fn clamp(self, min: Self, max: Self) -&gt; Self;
}

<span class="boring">}
</span></code></pre></pre>
<p>如果我们为一个类型实现了<code>Ord</code>，在<code>PartialOrd</code>保证了非对称性和传递性之上，我们还能保证整体的非对称性，即对于任意给定的<code>a</code>、<code>b</code>，<code>a &lt; b</code>、<code>a == b</code>或<code>a &gt; b</code>中必有一个为真。从这个角度来讲，<code>Ord</code>细化了<code>Eq</code>和<code>PartialOrd</code>，因为它表示一个更严格的比较。如果一个类型实现了<code>Ord</code>，我们就可以利用这个实现来实现<code>PartialOrd</code>、<code>PartialEq</code>和<code>Eq</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

// of course we can use the derive macros here
#[derive(Ord, PartialOrd, Eq, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

// note: as with PartialOrd, the Ord derive macro
// orders a type based on the lexicographical order
// of its members

// but here's the impls if we wrote them out by hand
impl Ord for Point {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        match self.x.cmp(&amp;other.x) {
            Ordering::Equal =&gt; self.y.cmp(&amp;other.y),
            ordering =&gt; ordering,
        }
    }
}
impl PartialOrd for Point {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}
impl PartialEq for Point {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.cmp(other) == Ordering::Equal
    }
}
impl Eq for Point {}

<span class="boring">}
</span></code></pre></pre>
<p>浮点型实现了<code>PartialOrd</code>但是没有实现<code>Ord</code>，因为<code>NaN &lt; 0 == false</code>和<code>NaN &gt;= 0 == false</code>都为真。几乎所有的其他的<code>PartialOrd</code>类型都实现了<code>Ord</code>，除非它们中包含有浮点型。</p>
<p>一旦一个类型实现了<code>Ord</code>，我们就可以把它存储在<code>BTreeMap</code>和<code>BTreeSet</code>，还可以在 slice 上使用 sort()方法对其进行排序，这同样适用于其他可以解引用为 slice 的类型，比如数组、<code>Vec</code>和<code>VecDeque</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::BTreeSet;

// now our type can be stored
// in BTreeSets and BTreeMaps!
#[derive(Ord, PartialOrd, PartialEq, Eq)]
struct Point {
    x: i32,
    y: i32,
}

fn example_btreeset() {
    let mut points = BTreeSet::new();
    points.insert(Point { x: 0, y: 0 }); // ✅
}

// we can also .sort() Ord types in collections!
fn example_sort&lt;T: Ord&gt;(mut sortable: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    sortable.sort();
    sortable
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#算术-traitarithmetic-traits" id="算术-traitarithmetic-traits">算术 Trait（Arithmetic Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Add</code></td><td>算术</td><td><code>+</code></td><td>相加</td></tr>
<tr><td><code>AddAssign</code></td><td>算术</td><td><code>+=</code></td><td>相加并赋值</td></tr>
<tr><td><code>BitAnd</code></td><td>算术</td><td><code>&amp;</code></td><td>按位与</td></tr>
<tr><td><code>BitAndAssign</code></td><td>算术</td><td><code>&amp;=</code></td><td>按位与并赋值</td></tr>
<tr><td><code>BitXor</code></td><td>算术</td><td><code>^</code></td><td>按位异或</td></tr>
<tr><td><code>BitXorAssign</code></td><td>算术</td><td><code>^=</code></td><td>按位异或并赋值</td></tr>
<tr><td><code>Div</code></td><td>算术</td><td><code>/</code></td><td>除</td></tr>
<tr><td><code>DivAssign</code></td><td>算术</td><td><code>/=</code></td><td>除并赋值</td></tr>
<tr><td><code>Mul</code></td><td>算术</td><td><code>*</code></td><td>乘</td></tr>
<tr><td><code>MulAssign</code></td><td>算术</td><td><code>*=</code></td><td>乘并赋值</td></tr>
<tr><td><code>Neg</code></td><td>算术</td><td><code>-</code></td><td>一元求反</td></tr>
<tr><td><code>Not</code></td><td>算术</td><td><code>!</code></td><td>一元逻辑求反</td></tr>
<tr><td><code>Rem</code></td><td>算术</td><td><code>%</code></td><td>求余</td></tr>
<tr><td><code>RemAssign</code></td><td>算术</td><td><code>%=</code></td><td>求余并赋值</td></tr>
<tr><td><code>Shl</code></td><td>算术</td><td><code>&lt;&lt;</code></td><td>左移</td></tr>
<tr><td><code>ShlAssign</code></td><td>算术</td><td><code>&lt;&lt;=</code></td><td>左移并赋值</td></tr>
<tr><td><code>Shr</code></td><td>算术</td><td><code>&gt;&gt;</code></td><td>右移</td></tr>
<tr><td><code>ShrAssign</code></td><td>算术</td><td><code>&gt;&gt;=</code></td><td>右移并赋值</td></tr>
<tr><td><code>Sub</code></td><td>算术</td><td><code>-</code></td><td>减</td></tr>
<tr><td><code>SubAssign</code></td><td>算术</td><td><code>-=</code></td><td>减并赋值</td></tr>
</tbody></table>
<p>我们没有必要把所有的算术操作符都仔细看一遍，毕竟它们中大多数都只作用于数值类型。我们将会讨论<code>Add</code>和<code>AddAssign</code>，因为<code>+</code>操作符经常被重载用来完成其他事情，比如往集合里添加一项，或者进行拼接操作，这样我们就可以从最有趣的地方入手而不会重复。</p>
<h4><a class="header" href="#add--addassign" id="add--addassign">Add &amp; AddAssign</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs = Self&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Add&lt;Rhs, Output = T&gt;</code>类型可以被加到<code>Rhs</code>类型上并产生一个<code>T</code>作为输出。</p>
<p>例如，在<code>Point</code>上实现<code>Add&lt;Point, Output = Point&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;
    fn add(self, rhs: Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = p1 + p2;
    assert_eq!(p3.x, p1.x + p2.x); // ✅
    assert_eq!(p3.y, p1.y + p2.y); // ✅
}

</code></pre></pre>
<p>但是，如果我们只有<code>Point</code>的引用，那该怎么办呢？我们还能把它们相加么？让我们试试：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = &amp;p1 + &amp;p2; // ❌
}
</code></pre></pre>
<p>显然不可以，编译器抛出下面的提示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0369]: cannot add `&amp;Point` to `&amp;Point`
  --&gt; src/main.rs:50:25
   |
50 |     let p3: Point = &amp;p1 + &amp;p2;
   |                     --- ^ --- &amp;Point
   |                     |
   |                     &amp;Point
   |
   = note: an implementation of `std::ops::Add` might be missing for `&amp;Point`

<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 的类型系统中，对于某个类型<code>T</code>，<code>T</code>、<code>&amp;T</code>、<code>&amp;mut T</code>都会被视作是完全不同的类型，这意味着我们必须分别为它们提供 trait 的实现。让我们为<code>&amp;Point</code>实现<code>Add</code>：</p>
<pre><pre class="playground"><code class="language-rust">impl Add for &amp;Point {
    type Output = Point;
    fn add(self, rhs: &amp;Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = &amp;p1 + &amp;p2; // ✅
    assert_eq!(p3.x, p1.x + p2.x); // ✅
    assert_eq!(p3.y, p1.y + p2.y); // ✅
}

</code></pre></pre>
<p>尽管如此，但是仍然感觉有些地方不太对。我们针对<code>Point</code>和<code>&amp;Point</code>实现了两份<code>Add</code>，它们恰好目前还做了相同的事情，但是我们不能保证将来也是如此。例如，假设我们决定，当我们把两个<code>Point</code>相加时，我们想要创建一个包含这两个<code>Point</code>的<code>Line</code>类型而不是创建一个新的<code>Point</code>，那么我们会把<code>Add</code>的实现更新：</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

#[derive(Copy, Clone)]
struct Line {
    start: Point,
    end: Point,
}

// we updated this impl
impl Add for Point {
    type Output = Line;
    fn add(self, rhs: Point) -&gt; Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

// but forgot to update this impl, uh oh!
impl Add for &amp;Point {
    type Output = Point;
    fn add(self, rhs: &amp;Point) -&gt; Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = p1 + p2; // ✅

    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = &amp;p1 + &amp;p2; // ❌ expected Line, found Point
}

</code></pre></pre>
<p>我们当前针对<code>&amp;Point</code>的<code>Add</code>实现就产生了一个不必要的维护负担，我们希望这个实现能够自动匹配<code>Point</code>的实现而无需我们每次在修改<code>Point</code>的实现时都手动维护更新。我们想要保持我们的代码尽可能地 DRY（Don't Repeat Yourself，不要重复自己）。幸运的是这是可以实现的：</p>
<pre><pre class="playground"><code class="language-rust">// updated, DRY impl
impl Add for &amp;Point {
    type Output = &lt;Point as Add&gt;::Output;
    fn add(self, rhs: &amp;Point) -&gt; Self::Output {
        Point::add(*self, *rhs)
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = p1 + p2; // ✅

    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let line: Line = &amp;p1 + &amp;p2; // ✅
}

</code></pre></pre>
<p><code>AddAssign&lt;Rhs&gt;</code>类型能够让我们和<code>Rhs</code>类型相加并赋值。该 trait 声明如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AddAssign&lt;Rhs = Self&gt; {
    fn add_assign(&amp;mut self, rhs: Rhs);
}
<span class="boring">}
</span></code></pre></pre>
<p>以<code>Point</code>和<code>&amp;Point</code>为例：</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::AddAssign;

#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32
}

impl AddAssign for Point {
    fn add_assign(&amp;mut self, rhs: Point) {
        self.x += rhs.x;
        self.y += rhs.y;
    }
}

impl AddAssign&lt;&amp;Point&gt; for Point {
    fn add_assign(&amp;mut self, rhs: &amp;Point) {
        Point::add_assign(self, *rhs);
    }
}

fn main() {
    let mut p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    p1 += &amp;p2;
    p1 += p2;
    assert!(p1.x == 7 &amp;&amp; p1.y == 10);
}

</code></pre></pre>
<h3><a class="header" href="#闭包-traitclosure-traits" id="闭包-traitclosure-traits">闭包 Trait（Closure Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Fn</code></td><td>闭包</td><td><code>(...args)</code></td><td>不可变闭包调用</td></tr>
<tr><td><code>FnMut</code></td><td>闭包</td><td><code>(...args)</code></td><td>可变闭包调用</td></tr>
<tr><td><code>FnOnce</code></td><td>闭包</td><td><code>(...args)</code></td><td>一次性闭包调用</td></tr>
</tbody></table>
<h4><a class="header" href="#fnonce-fnmut--fn" id="fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FnOnce&lt;Args&gt; {
    type Output;
    fn call_once(self, args: Args) -&gt; Self::Output;
}

trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    fn call(&amp;self, args: Args) -&gt; Self::Output;
}

<span class="boring">}
</span></code></pre></pre>
<p>虽然存在这些 trait，但是在 stable 的 Rust 中，我们无法为自己的类型实现这些 trait。我们能够创建的唯一能够实现这些 trait 的类型就是闭包。闭包根据其从环境中所捕获的内容来决定它到底是实现<code>FnOnce</code>、<code>FnMut</code>还是<code>Fn</code>。</p>
<p><code>FnOnce</code>闭包只能被调用一次，因为它会在执行过程中消耗掉某些值:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let range = 0..10;
    let get_range_count = || range.count();
    assert_eq!(get_range_count(), 10); // ✅
    get_range_count(); // ❌
}

</code></pre></pre>
<p>迭代器上的<code>.count()</code>方法会消耗迭代器，因此它只能被调用一次。因此，我们的闭包也只能调用一次。这也是为什么我们在尝试调用第二次的时候会得到下面的错误：</p>
<pre><code class="language-shell">error[E0382]: use of moved value: `get_range_count`
 --&gt; src/main.rs:5:5
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ----------------- `get_range_count` moved due to this call
5 |     get_range_count();
  |     ^^^^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `range` out of its environment
 --&gt; src/main.rs:3:30
  |
3 |     let get_range_count = || range.count();
  |                              ^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; src/main.rs:4:16
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ^^^^^^^^^^^^^^^

</code></pre>
<p><code>FnMut</code>闭包可以被多次调用，并且可以修改它从环境中捕获到的变量。我们可以说<code>FnMut</code>有副作用或者是有状态的（stateful）。下面是一个闭包的示例，通过从迭代器中追踪它见到的最小值来过滤所有非升序的值。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
    let mut min = i32::MIN;
    let ascending = nums.into_iter().filter(|&amp;n| {
        if n &lt;= min {
            false
        } else {
            min = n;
            true
        }
    }).collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(vec![0, 4, 8, 10, 15, 18], ascending); // ✅
}

</code></pre></pre>
<p><code>FnOnce</code>会获取它的参数的所有权并且只能被调用一次，但是<code>FnMut</code>仅要求获取参数的可变引用并且可以被多次调用，从这一点上来讲，<code>FnMut</code>细化了<code>FnOnce</code>。<code>FnMut</code>可以被用于任何可以使用<code>FnOnce</code>的地方。</p>
<p><code>Fn</code>闭包也可以被调用多次，但是它不能修改从环境中捕获的变量。我们可以说，<code>Fn</code>闭包没有副作用或者无状态的（stateless）。下面是一个示例，从一个迭代器中过滤出所有小于某个栈上变量的数字，该变量是它是环境中捕获到的：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![0, 4, 2, 8, 10, 7, 15, 18, 13];
    let min = 9;
    let greater_than_9 = nums.into_iter().filter(|&amp;n| n &gt; min).collect::&lt;Vec&lt;_&gt;&gt;();
    assert_eq!(vec![10, 15, 18, 13], greater_than_9); // ✅
}

</code></pre></pre>
<p><code>FnMut</code>要求可变引用并且可以被多次调用，<code>Fn</code>只要求不可变引用并可以被多次调用，从这一点来讲，<code>Fn</code>细化了<code>FnMut</code>。<code>Fn</code>可以被用于任何可以使用<code>FnMut</code>的地方，当然也包括可以使用<code>FnOnce</code>的地方。</p>
<p>如果一个闭包不从环境中捕获任何变量，从技术角度来讲它算不上是闭包，而只是一个被匿名声明的内联函数，并且可以作为一个普通函数指针（即<code>Fn</code>）被使用和传递，这包括可以使用<code>FnMut</code>和<code>FnOnce</code>的地方。</p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn main() {
    let mut fn_ptr: fn(i32) -&gt; i32 = add_one;
    assert_eq!(fn_ptr(1), 2); // ✅

    // capture-less closure cast to fn pointer
    fn_ptr = |x| x + 1; // same as add_one
    assert_eq!(fn_ptr(1), 2); // ✅
}

</code></pre></pre>
<p>下面是一个传递普通函数指针而不是闭包的示例：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nums = vec![-1, 1, -2, 2, -3, 3];
    let absolutes: Vec&lt;i32&gt; = nums.into_iter().map(i32::abs).collect();
    assert_eq!(vec![1, 1, 2, 2, 3, 3], absolutes); // ✅
}

</code></pre></pre>
<h3><a class="header" href="#其他-trait-other-traits" id="其他-trait-other-traits">其他 Trait （Other Traits）</a></h3>
<table><thead><tr><th>Trait(s)</th><th>分类（Category）</th><th>操作符（Operator(s)）</th><th>描述（Description）</th></tr></thead><tbody>
<tr><td><code>Deref</code></td><td>其他</td><td><code>*</code></td><td>不可变解引用</td></tr>
<tr><td><code>DerefMut</code></td><td>其他</td><td><code>*</code></td><td>可变解引用</td></tr>
<tr><td><code>Drop</code></td><td>其他</td><td>-</td><td>类型析构</td></tr>
<tr><td><code>Index</code></td><td>其他</td><td><code>[]</code></td><td>不可变索引</td></tr>
<tr><td><code>IndexMut</code></td><td>其他</td><td><code>[]</code></td><td>可变索引</td></tr>
<tr><td><code>RangeBounds</code></td><td>其他</td><td><code>..</code></td><td>区间</td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Deref {
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Deref&lt;Target = T&gt;</code>类型可以使用<code>*</code>操作符解引用为<code>T</code>类型。这在像<code>Box</code>和<code>Rc</code>这样的智能指针类型中有很明显的用例。尽管如此，但是我们在 Rust 代码中很少见到这种显式的解引用操作，这是因为 Rust 有一个被称为<code>解引用强制转换（deref coercion）</code>的特性。</p>
<p>当类型被作为函数参数传递、从函数返回或者作为方法调用的一部分时，Rust 会自动对这些类型进行解引用。这也解释了为什么我们可以在一个期望<code>&amp;str</code>和<code>&amp;[T]</code>的函数中可以传入<code>&amp;String</code>和<code>&amp;Vec&lt;T&gt;</code>，因为<code>String</code>实现了<code>Deref&lt;Target = str&gt;</code>并且<code>Vec&lt;T&gt;</code>实现了<code>Deref&lt;Target = [T]&gt;</code>。</p>
<p><code>Deref</code>和<code>DerefMut</code>应该仅被实现于智能指针类型。人们误用和滥用这些 trait 的最常见的方式是，试图把 OOP（面向对象程序设计）风格的数据继承塞进 Rust 中。这样是行不通的。Rust 不是 OOP。让我们进行一些测试，来看看它是在哪里、怎么样以及为什么行不通。让我们从下面的例子开始：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

struct Human {
    health_points: u32,
}

enum Weapon {
    Spear,
    Axe,
    Sword,
}

// a Soldier is just a Human with a Weapon
struct Soldier {
    human: Human,
    weapon: Weapon,
}

impl Deref for Soldier {
    type Target = Human;
    fn deref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Mount {
    Horse,
    Donkey,
    Cow,
}

// a Knight is just a Soldier with a Mount
struct Knight {
    soldier: Soldier,
    mount: Mount,
}

impl Deref for Knight {
    type Target = Soldier;
    fn deref(&amp;self) -&gt; &amp;Soldier {
        &amp;self.soldier
    }
}

enum Spell {
    MagicMissile,
    FireBolt,
    ThornWhip,
}

// a Mage is just a Human who can cast Spells
struct Mage {
    human: Human,
    spells: Vec&lt;Spell&gt;,
}

impl Deref for Mage {
    type Target = Human;
    fn deref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Staff {
    Wooden,
    Metallic,
    Plastic,
}

// a Wizard is just a Mage with a Staff
struct Wizard {
    mage: Mage,
    staff: Staff,
}

impl Deref for Wizard {
    type Target = Mage;
    fn deref(&amp;self) -&gt; &amp;Mage {
        &amp;self.mage
    }
}

fn borrows_human(human: &amp;Human) {}
fn borrows_soldier(soldier: &amp;Soldier) {}
fn borrows_knight(knight: &amp;Knight) {}
fn borrows_mage(mage: &amp;Mage) {}
fn borrows_wizard(wizard: &amp;Wizard) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types can be used as Humans
    borrows_human(&amp;human);
    borrows_human(&amp;soldier);
    borrows_human(&amp;knight);
    borrows_human(&amp;mage);
    borrows_human(&amp;wizard);
    // Knights can be used as Soldiers
    borrows_soldier(&amp;soldier);
    borrows_soldier(&amp;knight);
    // Wizards can be used as Mages
    borrows_mage(&amp;mage);
    borrows_mage(&amp;wizard);
    // Knights &amp; Wizards passed as themselves
    borrows_knight(&amp;knight);
    borrows_wizard(&amp;wizard);
}

<span class="boring">}
</span></code></pre></pre>
<p>乍看之下，上面的代码似乎还不错！但是，仔细观察之后它就没这么好了。首先，解引用强制转换仅作用于引用，因此，当我们想要传递所有权的时候它是行不通的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_human(human: Human) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types CANNOT be used as Humans
    takes_human(human);
    takes_human(soldier); // ❌
    takes_human(knight); // ❌
    takes_human(mage); // ❌
    takes_human(wizard); // ❌
}

<span class="boring">}
</span></code></pre></pre>
<p>此外，解引用强制转换在泛型上下文中是无法工作的。假定我们仅在 humans 上实现某个 trait：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Rest {
    fn rest(&amp;self);
}

impl Rest for Human {
    fn rest(&amp;self) {}
}

fn take_rest&lt;T: Rest&gt;(rester: &amp;T) {
    rester.rest()
}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types CANNOT be used as Rest types, only Human
    take_rest(&amp;human);
    take_rest(&amp;soldier); // ❌
    take_rest(&amp;knight); // ❌
    take_rest(&amp;mage); // ❌
    take_rest(&amp;wizard); // ❌
}

<span class="boring">}
</span></code></pre></pre>
<p>而且，尽管解引用强制转换在很多场景都可以使用，但它不是万能的。它无法作用于操作数，尽管操作符只是方法调用的语法糖。假定，我们想要<code>Mage（魔术师）</code>通过<code>+=</code>操作符学会<code>Spell（拼写）</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DerefMut for Wizard {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Mage {
        &amp;mut self.mage
    }
}

impl AddAssign&lt;Spell&gt; for Mage {
    fn add_assign(&amp;mut self, spell: Spell) {
        self.spells.push(spell);
    }
}

fn example(mut mage: Mage, mut wizard: Wizard, spell: Spell) {
    mage += spell;
    wizard += spell; // ❌ wizard not coerced to mage here
    wizard.add_assign(spell); // oof, we have to call it like this 🤦
}

<span class="boring">}
</span></code></pre></pre>
<p>在具有 OOP 风格的数据继承的编程语言中，一个方法中的<code>self</code>的值总是等于调用这个方法的类型，但是在 Rust 中，<code>self</code>的值永远等于实现这个方法的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Human {
    profession: &amp;'static str,
    health_points: u32,
}

impl Human {
    // self will always be a Human here, even if we call it on a Soldier
    fn state_profession(&amp;self) {
        println!(&quot;I'm a {}!&quot;, self.profession);
    }
}

struct Soldier {
    profession: &amp;'static str,
    human: Human,
    weapon: Weapon,
}

fn example(soldier: &amp;Soldier) {
    assert_eq!(&quot;servant&quot;, soldier.human.profession);
    assert_eq!(&quot;spearman&quot;, soldier.profession);
    soldier.human.state_profession(); // prints &quot;I'm a servant!&quot;
    soldier.state_profession(); // still prints &quot;I'm a servant!&quot; 🤦
}

<span class="boring">}
</span></code></pre></pre>
<p>当在一个新类型上实现<code>Deref</code>或<code>DerefMut</code>时，上面的陷阱令人震惊。假定我们想要创建一个<code>SortedVec</code>类型，它就是一个<code>Vec</code>只不过是有序的。下面是我们可能的实现方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SortedVec&lt;T: Ord&gt;(Vec&lt;T&gt;);

impl&lt;T: Ord&gt; SortedVec&lt;T&gt; {
    fn new(mut vec: Vec&lt;T&gt;) -&gt; Self {
        vec.sort();
        SortedVec(vec)
    }
    fn push(&amp;mut self, t: T) {
        self.0.push(t);
        self.0.sort();
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>显然，这里我们不能实现<code>DerefMut&lt;Target = Vec&lt;T&gt;&gt;</code>，否则任何使用<code>SortedVec</code>的人都能轻易打破已排好的顺序。但是，实现<code>Deref&lt;Target = Vec&lt;T&gt;&gt;</code>就一定安全么？试试找出下面程序中的 bug:</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct SortedVec&lt;T: Ord&gt;(Vec&lt;T&gt;);

impl&lt;T: Ord&gt; SortedVec&lt;T&gt; {
    fn new(mut vec: Vec&lt;T&gt;) -&gt; Self {
        vec.sort();
        SortedVec(vec)
    }
    fn push(&amp;mut self, t: T) {
        self.0.push(t);
        self.0.sort();
    }
}

impl&lt;T: Ord&gt; Deref for SortedVec&lt;T&gt; {
    type Target = Vec&lt;T&gt;;
    fn deref(&amp;self) -&gt; &amp;Vec&lt;T&gt; {
        &amp;self.0
    }
}

fn main() {
    let sorted = SortedVec::new(vec![2, 8, 6, 3]);
    sorted.push(1);
    let sortedClone = sorted.clone();
    sortedClone.push(4);
}

</code></pre></pre>
<p>我们未曾给<code>SortedVec</code>实现<code>Clone</code>，所以当我们调用<code>.clone()</code>方法时，编译器使用解引用强制转换把它解析为<code>Vec</code>上的方法调用，所以它会返回一个<code>Vec</code>而不是一个<code>SortedVec</code>！</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sorted: SortedVec&lt;i32&gt; = SortedVec::new(vec![2, 8, 6, 3]);
    sorted.push(1); // still sorted

    // calling clone on SortedVec actually returns a Vec 🤦
    let sortedClone: Vec&lt;i32&gt; = sorted.clone();
    sortedClone.push(4); // sortedClone no longer sorted 💀
}

</code></pre></pre>
<p>不管怎样，上面的限制、约束或者陷阱都不是 Rust 的错，因为 Rust 从来都没有被设计成一门 OO（面向对象）的语言或者把支持 OOP（面向对象程序设计）模式放在首位。</p>
<p>本节的要点在于不要试图在<code>Deref</code>和<code>DerefMut</code>的实现耍小聪明。它们仅仅适用于智能指针类型，目前只能在标准库中实现，因为智能指针类型目前需要 unstable 的特性和编译器的魔法才能工作。如果我们想要类似于<code>Deref</code>和<code>DerefMut</code>的功能和行为，我们可以去了解一下后面会提到的<code>AsRef</code>和<code>AsMut</code>。</p>
<h3><a class="header" href="#index--indexmut" id="index--indexmut">Index &amp; IndexMut</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Index&lt;Idx: ?Sized&gt; {
    type Output: ?Sized;
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}

trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt; where Idx: ?Sized {
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}

<span class="boring">}
</span></code></pre></pre>
<p>我们可以将<code>[]</code>索引到带有 T 值的<code>Index&lt;T, Output = U&gt;</code>类型，索引操作将返回<code>&amp;U</code>值。为了语法方便，编译器会自动在索引操作返回值的前面插入一个解引用操作符<code>*</code>：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so
    // indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...
    let vec = vec![1, 2, 3, 4, 5];
    let num_ref: &amp;i32 = vec[0]; // ❌ expected &amp;i32 found i32

    // above line actually desugars to
    let num_ref: &amp;i32 = *vec[0]; // ❌ expected &amp;i32 found i32

    // both of these alternatives work
    let num: i32 = vec[0]; // ✅
    let num_ref = &amp;vec[0]; // ✅
}

</code></pre></pre>
<p>为了展示我们自己如何实现<code>Index</code>，下面是一个有趣的示例，这个例子展示了我们如何使用一个新类型和<code>Index</code>trait 在<code>Vec</code>上实现环绕索引和非负索引：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Index;

struct WrappingIndex&lt;T&gt;(Vec&lt;T&gt;);

impl&lt;T&gt; Index&lt;usize&gt; for WrappingIndex&lt;T&gt; {
    type Output = T;
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        &amp;self.0[index % self.0.len()]
    }
}

impl&lt;T&gt; Index&lt;i128&gt; for WrappingIndex&lt;T&gt; {
    type Output = T;
    fn index(&amp;self, index: i128) -&gt; &amp;T {
        let self_len = self.0.len() as i128;
        let idx = (((index % self_len) + self_len) % self_len) as usize;
        &amp;self.0[idx]
    }
}

#[test] // ✅
fn indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[0_usize]);
    assert_eq!(2, wrapping_vec[1_usize]);
    assert_eq!(3, wrapping_vec[2_usize]);
}

#[test] // ✅
fn wrapping_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[3_usize]);
    assert_eq!(2, wrapping_vec[4_usize]);
    assert_eq!(3, wrapping_vec[5_usize]);
}

#[test] // ✅
fn neg_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[-3_i128]);
    assert_eq!(2, wrapping_vec[-2_i128]);
    assert_eq!(3, wrapping_vec[-1_i128]);
}

#[test] // ✅
fn wrapping_neg_indexes() {
    let wrapping_vec = WrappingIndex(vec![1, 2, 3]);
    assert_eq!(1, wrapping_vec[-6_i128]);
    assert_eq!(2, wrapping_vec[-5_i128]);
    assert_eq!(3, wrapping_vec[-4_i128]);
}

<span class="boring">}
</span></code></pre></pre>
<p>这里没有要求<code>Idx</code>类型是数值类型或者是一个<code>Range</code>，它也可以是一个枚举！下面是一个使用篮球位置在一支球队里检索球员的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Index;

enum BasketballPosition {
    PointGuard,
    ShootingGuard,
    Center,
    PowerForward,
    SmallForward,
}

struct BasketballPlayer {
    name: &amp;'static str,
    position: BasketballPosition,
}

struct BasketballTeam {
    point_guard: BasketballPlayer,
    shooting_guard: BasketballPlayer,
    center: BasketballPlayer,
    power_forward: BasketballPlayer,
    small_forward: BasketballPlayer,
}

impl Index&lt;BasketballPosition&gt; for BasketballTeam {
    type Output = BasketballPlayer;
    fn index(&amp;self, position: BasketballPosition) -&gt; &amp;BasketballPlayer {
        match position {
            BasketballPosition::PointGuard =&gt; &amp;self.point_guard,
            BasketballPosition::ShootingGuard =&gt; &amp;self.shooting_guard,
            BasketballPosition::Center =&gt; &amp;self.center,
            BasketballPosition::PowerForward =&gt; &amp;self.power_forward,
            BasketballPosition::SmallForward =&gt; &amp;self.small_forward,
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#drop" id="drop">Drop</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果一个类型实现了<code>Drop</code>，那么<code>drop</code>将会在该类型离开作用域但是销毁之前被调用。我们很少需要去为我们的类型实现它，但是如果一个类型中持有某些外部资源，这些资源需要在类型销毁时被清理，这种情况下就会用到了。</p>
<p>标准库中有一个<code>BufWriter</code>类型让我们能够把写入的数据缓冲到<code>Write</code>类型中。但是，如果<code>BufWriter</code>在它里面的内容被刷入到底层的<code>Write</code>类型之前就被销毁了，该怎么办呢？幸运的是那是不可能的！<code>BufWriter</code>实现了<code>Drop</code>trait，因此，无论什么它什么时候离开作用域，<code>flush</code>总会被调用！</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;W: Write&gt; Drop for BufWriter&lt;W&gt; {
    fn drop(&amp;mut self) {
        self.flush_buf();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>此外，Rust 中的<code>Mutexs</code>没有<code>unlock()</code>方法，因为它们不需要！在<code>Mutex</code>上调用<code>lock()</code>会返回一个<code>MutexGuard</code>，当<code>MutexGuard</code>离开作用域时，它会自动解锁（unlock）<code>Mutex</code>，这要归功于它的<code>Drop</code>实现:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.inner.raw_unlock();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一般而言，如果你正在实现对某类资源的抽象，这类资源需要在使用后被清理，那就是时候充分利用<code>Drop</code> trait 了。</p>
<h2><a class="header" href="#转换-traitsconversion-traits" id="转换-traitsconversion-traits">转换 Traits（Conversion Traits）</a></h2>
<h3><a class="header" href="#from--into" id="from--into">From &amp; Into</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>From&lt;T&gt;</code>类型允许我们把<code>T</code>转换为<code>Self</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Into&lt;T&gt;</code>类型允许我们把<code>Self</code>转换为<code>T</code>。
它们就像是一个硬币的两面。我们只能为自己的类型实现<code>From&lt;T&gt;</code>，因为<code>Into&lt;T&gt;</code>的实现会通过 generic blanket impl 自动提供：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>这两个 trait 之所以存在，是因为它能够让我们以稍微不同的方式来进行 trait 约束（bound）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T&gt;(t: T)
where
    // these bounds are equivalent
    T: From&lt;i32&gt;,
    i32: Into&lt;T&gt;
{
    // these examples are equivalent
    let example: T = T::from(0);
    let example: T = 0.into();
}
<span class="boring">}
</span></code></pre></pre>
<p>没有规则强制要求什么时候使用前者或后者，所以在每种情景下采用最合理的方式就可以了。现在让我们来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;[i32; 2]&gt; for Point {
    fn from([x, y]: [i32; 2]) -&gt; Self {
        Point { x, y }
    }
}

fn example() {
    // 使用 From
    let origin = Point::from((0, 0));
    let origin = Point::from([0, 0]);

    // 使用 Into
    let origin: Point = (0, 0).into();
    let origin: Point = [0, 0].into();
}

<span class="boring">}
</span></code></pre></pre>
<p>这个实现不是对称的，因此，如果我们想要把<code>Point</code>转为 tuple 和 array，我们必须显式地添加下面的内容：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;Point&gt; for (i32, i32) {
    fn from(Point { x, y }: Point) -&gt; Self {
        (x, y)
    }
}

impl From&lt;[i32; 2]&gt; for Point {
    fn from([x, y]: [i32; 2]) -&gt; Self {
        Point { x, y }
    }
}

impl From&lt;Point&gt; for [i32; 2] {
    fn from(Point { x, y }: Point) -&gt; Self {
        [x, y]
    }
}

fn example() {
    // 从 (i32, i32) 到 Point
    let point = Point::from((0, 0));
    let point: Point = (0, 0).into();

    // 从 Point 到 (i32, i32)
    let tuple = &lt;(i32, i32)&gt;::from(point);
    let tuple: (i32, i32) = point.into();

    // 从 [i32; 2] 到 Point
    let point = Point::from([0, 0]);
    let point: Point = [0, 0].into();

    // 从 Point 到 [i32; 2]
    let array = &lt;[i32; 2]&gt;::from(point);
    let array: [i32; 2] = point.into();
}

<span class="boring">}
</span></code></pre></pre>
<p><code>From&lt;T&gt;</code>的一个常见用法是精简模板代码。假定我们想要在程序中添加一个<code>Triangle</code>类型，它里面包含三个<code>Point</code>，下面是我们可以构造它的方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Point {
        Point { x, y }
    }
}

impl From&lt;(i32, i32)&gt; for Point {
    fn from((x, y): (i32, i32)) -&gt; Point {
        Point { x, y }
    }
}

struct Triangle {
    p1: Point,
    p2: Point,
    p3: Point,
}

impl Triangle {
    fn new(p1: Point, p2: Point, p3: Point) -&gt; Triangle {
        Triangle { p1, p2, p3 }
    }
}

impl&lt;P&gt; From&lt;[P; 3]&gt; for Triangle
where
    P: Into&lt;Point&gt;
{
    fn from([p1, p2, p3]: [P; 3]) -&gt; Triangle {
        Triangle {
            p1: p1.into(),
            p2: p2.into(),
            p3: p3.into(),
        }
    }
}

fn example() {
    // 手动构造
    let triangle = Triangle {
        p1: Point {
            x: 0,
            y: 0,
        },
        p2: Point {
            x: 1,
            y: 1,
        },
        p3: Point {
            x: 2,
            y: 2,
        },
    };

    // 使用 Point::new
    let triangle = Triangle {
        p1: Point::new(0, 0),
        p2: Point::new(1, 1),
        p3: Point::new(2, 2),
    };

    // 使用 From&lt;(i32, i32)&gt; for Point
    let triangle = Triangle {
        p1: (0, 0).into(),
        p2: (1, 1).into(),
        p3: (2, 2).into(),
    };

    // 使用 Triangle::new + From&lt;(i32, i32)&gt; for Point
    let triangle = Triangle::new(
        (0, 0).into(),
        (1, 1).into(),
        (2, 2).into(),
    );

    // 使用 From&lt;[Into&lt;Point&gt;; 3]&gt; for Triangle
    let triangle: Triangle = [
        (0, 0),
        (1, 1),
        (2, 2),
    ].into();
}

<span class="boring">}
</span></code></pre></pre>
<p>关于你应该什么时候，以什么方式、什么理由来为我们的类型实现<code>From&lt;T&gt;</code>，并没有强制规定，这取决于你对具体情况的判断。</p>
<p><code>Into&lt;T&gt;</code>一个常见的用途是，使得需要拥有值的函数具有通用性，而不必关心它们是拥有值还是借用值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
}

impl Person {
    // 接受:
    // - String
    fn new1(name: String) -&gt; Person {
        Person { name }
    }

    // 接受:
    // - String
    // - &amp;String
    // - &amp;str
    // - Box&lt;str&gt;
    // - Cow&lt;'_, str&gt;
    // - char
    // 因为上面所有的类型都可以转换为 String
    fn new2&lt;N: Into&lt;String&gt;&gt;(name: N) -&gt; Person {
        Person { name: name.into() }
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#错误处理error-handling" id="错误处理error-handling">错误处理（Error Handling）</a></h2>
<p>讨论错误处理和<code>Error</code> trait 的最好时机应该是紧跟在<code>Display</code>、<code>Debug</code>、<code>Any</code>、<code>From</code>之后，但是在<code>TryFrom</code>之前，这也是为什么把错误处理部分尴尬地嵌入在转换 trait 之间。</p>
<h3><a class="header" href="#error" id="error">Error</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Error: Debug + Display {
    // 提供默认实现
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;;
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt;;
    fn description(&amp;self) -&gt; &amp;str;
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中，错误（error）是被返回（return）的，而不是被抛出（throw）的，让我们看个例子。</p>
<p>因为整数除以 0 会 panic，如果我们想要让我们的程序更为安全，我们可以实现一个<code>safe_div</code>函数，它会返回一个<code>Result</code>，就像下面这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::error;

#[derive(Debug, PartialEq)]
struct DivByZero;

impl fmt::Display for DivByZero {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;division by zero error&quot;)
    }
}

impl error::Error for DivByZero {}

fn safe_div(numerator: i32, denominator: i32) -&gt; Result&lt;i32, DivByZero&gt; {
    if denominator == 0 {
        return Err(DivByZero);
    }
    Ok(numerator / denominator)
}

#[test] // ✅
fn test_safe_div() {
    assert_eq!(safe_div(8, 2), Ok(4));
    assert_eq!(safe_div(5, 0), Err(DivByZero));
}

<span class="boring">}
</span></code></pre></pre>
<p>因为错误是被返回而不是被抛出，所以这些错误必须被显式地处理，如果当前函数无法处理错误，该函数应该把错误传递给自己的调用者。传递错误的最常用方式是使用<code>?</code>操作符，它是现在已经弃用的<code>try!</code>宏的语法糖：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! try {
    ($expr:expr) =&gt; {
        match $expr {
            // if Ok just unwrap the value
            Ok(val) =&gt; val,
            // if Err map the err value using From and return
            Err(err) =&gt; {
                return Err(From::from(err));
            }
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>如果我们想要写一个函数，该函数读取文件内容到<code>String</code>里，我们可以像这样写：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Read;
use std::path::Path;
use std::io;
use std::fs::File;

fn read_file_to_string(path: &amp;Path) -&gt; Result&lt;String, io::Error&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error
    Ok(contents)
}
<span class="boring">}
</span></code></pre></pre>
<p>假定我们当前正在读取的文件内容是一串数字，并且我们想要把这些数字求和，我们可能会把函数更新成这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Read;
use std::path::Path;
use std::io;
use std::fs::File;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, /*这里放置什么? */&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>但是，现在我们的<code>Result</code>里的错误类型应该是什么？它要么返回一个<code>io::Error</code>，要么返回一个<code>ParseIntError</code>。我们尝试寻找第三种方式来解决这个问题，以最快最乱的方式开始，以最健壮的方式结束。</p>
<p>第一种方式就是，识别出所有实现了<code>Error</code>和<code>Display</code>的类型，这样我们把所有的错误映射（map）到<code>String</code>类型并把<code>String</code>作为我们的错误类型:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;
use std::path::Path;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, String&gt; {
    let mut file = File::open(path)
        .map_err(|e| e.to_string())?; // ⬆️ io::Error -&gt; String
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)
        .map_err(|e| e.to_string())?; // ⬆️ io::Error -&gt; String
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()
            .map_err(|e| e.to_string())?; // ⬆️ ParseIntError -&gt; String
    }
    Ok(sum)
}
<span class="boring">}
</span></code></pre></pre>
<p>但是，这种方式的缺点在于，我们会丢弃所有的错误类型信息，从而导致调用者在处理错误时十分困难。</p>
<p>另外一个不太明显的优点则是，我们可以定制字符串来提供更多的特定上下文信息。例如，<code>ParseIntError</code>通常会变成字符串<code>“invalid digit found in string”</code>，这个信息就非常模糊并且没有提及无效的字符串是什么或者它正在尝试解析到哪一类整数类型。如果我们正在调试这个问题，这个错误信息几乎没什么用。尽管如此，我们还可以自己动手提供所有的上下文信息来改善这个问题：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sum += line.parse::&lt;i32&gt;()
    .map_err(|_| format!(&quot;failed to parse {} into i32&quot;, line))?;

<span class="boring">}
</span></code></pre></pre>
<p>第二种方式则是充分利用标准库中的 generic blanket impl：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;E: error::Error&gt; From&lt;E&gt; for Box&lt;dyn error::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这意味着，任意的<code>Error</code>类型都可以通过<code>?</code>被隐式地转换为<code>Box&lt;dyn error::Error&gt;</code>，因此我们可以把任何可能产生错误的函数返回的<code>Result</code>中的错误类型设置为<code>Box&lt;dyn error::Error&gt;</code>，这样<code>?</code>操作符就可以帮我们完成剩下的工作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::error;

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, Box&lt;dyn error::Error&gt;&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;
    }
    Ok(sum)
}

<span class="boring">}
</span></code></pre></pre>
<p>虽然更为简洁，但是它似乎也存在着前面一种方式的缺点，即丢掉了类型信息。大多数情况下的确如此，但是如果调用者知道函数的实现细节，它们仍然可以通过使用<code>error::Error</code>上的<code>downcast_ref()</code>方法来处理不同的错误类型，这与它在<code>dyn Any</code>类型上的作用相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_sum_file_errors(path: &amp;Path) {
    match sum_file(path) {
        Ok(sum) =&gt; println!(&quot;the sum is {}&quot;, sum),
        Err(err) =&gt; {
            if let Some(e) = err.downcast_ref::&lt;io::Error&gt;() {
                // 处理 io::Error
            } else if let Some(e) = err.downcast_ref::&lt;ParseIntError&gt;() {
                // 处理 ParseIntError
            } else {
                // 我们知道 sum_file 只会返回上面错误中的其中一个
                // 所以不会到达这个分支
                unreachable!();
            }
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>第三种方法是最稳健和类型安全的方法，它可以汇总这些不同的错误，使用一个枚举类型构建我们自己的自定义错误类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::num::ParseIntError;
use std::fs::File;
use std::io;
use std::io::Read;
use std::path::Path;
use std::error;
use std::fmt;

#[derive(Debug)]
enum SumFileError {
    Io(io::Error),
    Parse(ParseIntError),
}

impl From&lt;io::Error&gt; for SumFileError {
    fn from(err: io::Error) -&gt; Self {
        SumFileError::Io(err)
    }
}

impl From&lt;ParseIntError&gt; for SumFileError {
    fn from(err: ParseIntError) -&gt; Self {
        SumFileError::Parse(err)
    }
}

impl fmt::Display for SumFileError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            SumFileError::Io(err) =&gt; write!(f, &quot;sum file error: {}&quot;, err),
            SumFileError::Parse(err) =&gt; write!(f, &quot;sum file error: {}&quot;, err),
        }
    }
}

impl error::Error for SumFileError {
    // 这个方法的默认实现总是返回 None
    //但是我们现在重写它，让它更有用    
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        Some(match self {
            SumFileError::Io(err) =&gt; err,
            SumFileError::Parse(err) =&gt; err,
        })
    }
}

fn sum_file(path: &amp;Path) -&gt; Result&lt;i32, SumFileError&gt; {
    let mut file = File::open(path)?; // ⬆️ io::Error -&gt; SumFileError
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?; // ⬆️ io::Error -&gt; SumFileError
    let mut sum = 0;
    for line in contents.lines() {
        sum += line.parse::&lt;i32&gt;()?; // ⬆️ ParseIntError -&gt; SumFileError
    }
    Ok(sum)
}

fn handle_sum_file_errors(path: &amp;Path) {
    match sum_file(path) {
        Ok(sum) =&gt; println!(&quot;the sum is {}&quot;, sum),
        Err(SumFileError::Io(err)) =&gt; {
            // 处理 io::Error
        },
        Err(SumFileError::Parse(err)) =&gt; {
            // 处理 ParseIntError
        },
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#继续转换类型conversion-traits-continued" id="继续转换类型conversion-traits-continued">继续转换类型（Conversion Traits Continued）</a></h2>
<h3><a class="header" href="#tryfrom--tryinto" id="tryfrom--tryinto">TryFrom &amp; TryInto</a></h3>
<p><code>TryFrom</code>和<code>TryInto</code>是<code>From</code>和<code>Into</code>的可能会失败的版本。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TryFrom&lt;T&gt; {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

trait TryInto&lt;T&gt; {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p>类似于<code>Into</code>，我们无法实现<code>TryInto</code>，因为它的实现是由 generic blanket impl提供：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; TryInto&lt;U&gt; for T
where
    U: TryFrom&lt;T&gt;,
{
    type Error = U::Error;

    fn try_into(self) -&gt; Result&lt;U, U::Error&gt; {
        U::try_from(self)
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>假定在我们的程序上下文环境中，<code>Point</code>中的<code>x</code>和<code>y</code>如果值小于<code>-1000</code>或者大于<code>1000</code>没有意义。下面是我们使用<code>TryFrom</code>重写之前的<code>From</code>实现来告诉用户，现在这种转换可以失败。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;
use std::error;
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

#[derive(Debug)]
struct OutOfBounds;

impl fmt::Display for OutOfBounds {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;out of bounds&quot;)
    }
}

impl error::Error for OutOfBounds {}

// 现在是可以出错的
impl TryFrom&lt;(i32, i32)&gt; for Point {
    type Error = OutOfBounds;
    fn try_from((x, y): (i32, i32)) -&gt; Result&lt;Point, OutOfBounds&gt; {
        if x.abs() &gt; 1000 || y.abs() &gt; 1000 {
            return Err(OutOfBounds);
        }
        Ok(Point { x, y })
    }
}

// 仍然是不会出错的
impl From&lt;Point&gt; for (i32, i32) {
    fn from(Point { x, y }: Point) -&gt; Self {
        (x, y)
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>下面是对<code>Triangle</code>的<code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code>实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::{TryFrom, TryInto};
use std::error;
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

#[derive(Debug)]
struct OutOfBounds;

impl fmt::Display for OutOfBounds {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;out of bounds&quot;)
    }
}

impl error::Error for OutOfBounds {}

impl TryFrom&lt;(i32, i32)&gt; for Point {
    type Error = OutOfBounds;
    fn try_from((x, y): (i32, i32)) -&gt; Result&lt;Self, Self::Error&gt; {
        if x.abs() &gt; 1000 || y.abs() &gt; 1000 {
            return Err(OutOfBounds);
        }
        Ok(Point { x, y })
    }
}

struct Triangle {
    p1: Point,
    p2: Point,
    p3: Point,
}

impl&lt;P&gt; TryFrom&lt;[P; 3]&gt; for Triangle
where
    P: TryInto&lt;Point&gt;,
{
    type Error = P::Error;
    fn try_from([p1, p2, p3]: [P; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Triangle {
            p1: p1.try_into()?,
            p2: p2.try_into()?,
            p3: p3.try_into()?,
        })
    }
}

fn example() -&gt; Result&lt;Triangle, OutOfBounds&gt; {
    let t: Triangle = [(0, 0), (1, 1), (2, 2)].try_into()?;
    Ok(t)
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#fromstr" id="fromstr">FromStr</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>FromStr</code> 类型允许执行一个从<code>&amp;str</code>到<code>Self</code>的可失败的转换。最常见的使用是在<code>&amp;str</code>上调用<code>.parse()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::str::FromStr;

fn example&lt;T: FromStr&gt;(s: &amp;'static str) {
    // 这些都是相等的
    let t: Result&lt;T, _&gt; = FromStr::from_str(s);
    let t = T::from_str(s);
    let t: Result&lt;T, _&gt; = s.parse();
    let t = s.parse::&lt;T&gt;(); // 最常见的
}
<span class="boring">}
</span></code></pre></pre>
<p>例如，在<code>Point</code>上的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error;
use std::fmt;
use std::iter::Enumerate;
use std::num::ParseIntError;
use std::str::{Chars, FromStr};

#[derive(Debug, Eq, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Self {
        Point { x, y }
    }
}

#[derive(Debug, PartialEq)]
struct ParsePointError;

impl fmt::Display for ParsePointError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;failed to parse point&quot;)
    }
}

impl From&lt;ParseIntError&gt; for ParsePointError {
    fn from(_e: ParseIntError) -&gt; Self {
        ParsePointError
    }
}

impl error::Error for ParsePointError {}

impl FromStr for Point {
    type Err = ParsePointError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let is_num = |(_, c): &amp;(usize, char)| matches!(c, '0'..='9' | '-');
        let isnt_num = |t: &amp;(_, _)| !is_num(t);

        let get_num =
            |char_idxs: &amp;mut Enumerate&lt;Chars&lt;'_&gt;&gt;| -&gt; Result&lt;(usize, usize), ParsePointError&gt; {
                let (start, _) = char_idxs
                    .skip_while(isnt_num)
                    .next()
                    .ok_or(ParsePointError)?;
                let (end, _) = char_idxs
                    .skip_while(is_num)
                    .next()
                    .ok_or(ParsePointError)?;
                Ok((start, end))
            };

        let mut char_idxs = s.chars().enumerate();
        let (x_start, x_end) = get_num(&amp;mut char_idxs)?;
        let (y_start, y_end) = get_num(&amp;mut char_idxs)?;

        let x = s[x_start..x_end].parse::&lt;i32&gt;()?;
        let y = s[y_start..y_end].parse::&lt;i32&gt;()?;

        Ok(Point { x, y })
    }
}

#[test] // ✅
fn pos_x_y() {
    let p = &quot;(4, 5)&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Ok(Point::new(4, 5)));
}

#[test] // ✅
fn neg_x_y() {
    let p = &quot;(-6, -2)&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Ok(Point::new(-6, -2)));
}

#[test] // ✅
fn not_a_point() {
    let p = &quot;not a point&quot;.parse::&lt;Point&gt;();
    assert_eq!(p, Err(ParsePointError));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>FromStr</code>和<code>TryFrom&lt;&amp;str&gt;</code>有着相同的签名。只要我们通过其中一个实现另一个，先实现哪个并不重要。下面是对<code>Point</code>实现<code>TryFrom&lt;&amp;str&gt;</code>，假定它已经实现了<code>FromStr</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TryFrom&lt;&amp;str&gt; for Point {
    type Error = &lt;Point as FromStr&gt;::Err;
    fn try_from(s: &amp;str) -&gt; Result&lt;Point, Self::Error&gt; {
        &lt;Point as FromStr&gt;::from_str(s)
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#asref--asmut" id="asref--asmut">AsRef &amp; AsMut</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsRef&lt;T: ?Sized&gt; {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

trait AsMut&lt;T: ?Sized&gt; {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef</code>被用于轻量级的引用到引用之间的转换。然而，它最常见的一个用途是使函数在是否获取所有权上具有通用性：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 接受:
//  - &amp;str
//  - &amp;String
fn takes_str(s: &amp;str) {
    // use &amp;str
}

// 接受:
//  - &amp;str
//  - &amp;String
//  - String
fn takes_asref_str&lt;S: AsRef&lt;str&gt;&gt;(s: S) {
    let s: &amp;str = s.as_ref();
    // 使用 &amp;str
}

fn example(slice: &amp;str, borrow: &amp;String, owned: String) {
    takes_str(slice);
    takes_str(borrow);
    takes_str(owned); // ❌
    takes_asref_str(slice);
    takes_asref_str(borrow);
    takes_asref_str(owned); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<p>另一个常见用途是返回一个内部私有数据的引用，该数据由一个保护不变性的类型所包裹。标准库中一个比较好的示例是<code>String</code>，它包裹了<code>Vec&lt;u8&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>内部的<code>Vec&lt;u8&gt;</code>不能被公开，因为如果这样的话，人们就会修改里面的字节并破坏<code>String</code>中有效的 UTF-8 编码。但是，暴露内部字节数组的一个不可变的只读引用是安全的，即下面的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AsRef&lt;[u8]&gt; for String;
<span class="boring">}
</span></code></pre></pre>
<p>一般而言，只有当一个类型包裹了其他类型用来为该内部类型提供了额外功能或者保护内部类型的不变性时，为这样的类型实现<code>AsRef</code>才有意义。
让我们来看一个<code>AsRef</code>的不合适使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    age: u32,
}

impl AsRef&lt;String&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }
}

impl AsRef&lt;u32&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;u32 {
        &amp;self.age
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>一开始是可行的，而且看上去还有点道理，但是当我们为<code>User</code>添加更多成员时，问题就出现了：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    email: String,
    age: u32,
    height: u32,
}

impl AsRef&lt;String&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;String {、
        //我们返回 name 还是 email?        
    }
}

impl AsRef&lt;u32&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;u32 {
        //我们返回 age 还是 height？
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><code>User</code>是由<code>String</code>和<code>u32</code>组成，但是它并不等同于一个<code>String</code>和一个<code>u32</code>，甚至我们还会有更多的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: Name,
    email: Email,
    age: Age,
    height: Height,
}
<span class="boring">}
</span></code></pre></pre>
<p>对于这样的类型实现<code>AsRef</code>没有什么意义，因为<code>AsRef</code>用于语义相等的事物之间引用到引用的转换，而且<code>Name</code>、<code>Email</code>、<code>Age</code>以及<code>Height</code>并不等同于一个<code>User</code>。</p>
<p>下面是一个好的示例，其中，我们会引入一个新类型<code>Moderator</code>，它只包裹了一个<code>User</code>并添加了特定的审核权限：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    name: String,
    age: u32,
}

//不幸地是，标准库并没有提供一个generic blanket impl来避免这种重复的实现
impl AsRef&lt;User&gt; for User {
    fn as_ref(&amp;self) -&gt; &amp;User {
        self
    }
}

enum Privilege {
    BanUsers,
    EditPosts,
    DeletePosts,
}

//尽管 Moderators 有一些特殊权限，它们仍然是普通的 User 
//并且应该做相同的事情
struct Moderator {
    user: User,
    privileges: Vec&lt;Privilege&gt;
}

impl AsRef&lt;Moderator&gt; for Moderator {
    fn as_ref(&amp;self) -&gt; &amp;Moderator {
        self
    }
}

impl AsRef&lt;User&gt; for Moderator {
    fn as_ref(&amp;self) -&gt; &amp;User {
        &amp;self.user
    }
}

//使用 User 和 Moderators （也是一种User）应该都是可以调用的
fn create_post&lt;U: AsRef&lt;User&gt;&gt;(u: U) {
    let user = u.as_ref();
    // etc
}

fn example(user: User, moderator: Moderator) {
    create_post(&amp;user);
    create_post(&amp;moderator); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<p>这是有效的，因为<code>Moderator</code>就是<code>User</code>。下面是<code>Deref</code>章节中的例子，我们用了<code>AsRef</code>来实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::AsRef;

struct Human {
    health_points: u32,
}

impl AsRef&lt;Human&gt; for Human {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        self
    }
}

enum Weapon {
    Spear,
    Axe,
    Sword,
}

// a Soldier is just a Human with a Weapon
struct Soldier {
    human: Human,
    weapon: Weapon,
}

impl AsRef&lt;Soldier&gt; for Soldier {
    fn as_ref(&amp;self) -&gt; &amp;Soldier {
        self
    }
}

impl AsRef&lt;Human&gt; for Soldier {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Mount {
    Horse,
    Donkey,
    Cow,
}

// a Knight is just a Soldier with a Mount
struct Knight {
    soldier: Soldier,
    mount: Mount,
}

impl AsRef&lt;Knight&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Knight {
        self
    }
}

impl AsRef&lt;Soldier&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Soldier {
        &amp;self.soldier
    }
}

impl AsRef&lt;Human&gt; for Knight {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.soldier.human
    }
}

enum Spell {
    MagicMissile,
    FireBolt,
    ThornWhip,
}

// a Mage is just a Human who can cast Spells
struct Mage {
    human: Human,
    spells: Vec&lt;Spell&gt;,
}

impl AsRef&lt;Mage&gt; for Mage {
    fn as_ref(&amp;self) -&gt; &amp;Mage {
        self
    }
}

impl AsRef&lt;Human&gt; for Mage {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.human
    }
}

enum Staff {
    Wooden,
    Metallic,
    Plastic,
}

// a Wizard is just a Mage with a Staff
struct Wizard {
    mage: Mage,
    staff: Staff,
}

impl AsRef&lt;Wizard&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Wizard {
        self
    }
}

impl AsRef&lt;Mage&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Mage {
        &amp;self.mage
    }
}

impl AsRef&lt;Human&gt; for Wizard {
    fn as_ref(&amp;self) -&gt; &amp;Human {
        &amp;self.mage.human
    }
}

fn borrows_human&lt;H: AsRef&lt;Human&gt;&gt;(human: H) {}
fn borrows_soldier&lt;S: AsRef&lt;Soldier&gt;&gt;(soldier: S) {}
fn borrows_knight&lt;K: AsRef&lt;Knight&gt;&gt;(knight: K) {}
fn borrows_mage&lt;M: AsRef&lt;Mage&gt;&gt;(mage: M) {}
fn borrows_wizard&lt;W: AsRef&lt;Wizard&gt;&gt;(wizard: W) {}

fn example(human: Human, soldier: Soldier, knight: Knight, mage: Mage, wizard: Wizard) {
    // all types can be used as Humans
    borrows_human(&amp;human);
    borrows_human(&amp;soldier);
    borrows_human(&amp;knight);
    borrows_human(&amp;mage);
    borrows_human(&amp;wizard);
    // Knights can be used as Soldiers
    borrows_soldier(&amp;soldier);
    borrows_soldier(&amp;knight);
    // Wizards can be used as Mages
    borrows_mage(&amp;mage);
    borrows_mage(&amp;wizard);
    // Knights &amp; Wizards passed as themselves
    borrows_knight(&amp;knight);
    borrows_wizard(&amp;wizard);
}

<span class="boring">}
</span></code></pre></pre>
<p><code>Deref</code>在之前的例子中没有起作用，是因为解引用强制转换是类型间的隐式转换，这就为人们制定错误的想法并对其行为方式的期望留下了空间。<code>AsRef</code>能够工作是因为它让类型之间的转换变为显式的，并且没有给开发者错误的想法和期望留有余地。</p>
<h3><a class="header" href="#borrow--borrowmut" id="borrow--borrowmut">Borrow &amp; BorrowMut</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Borrow&lt;Borrowed&gt;
where
    Borrowed: ?Sized,
{
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}

trait BorrowMut&lt;Borrowed&gt;: Borrow&lt;Borrowed&gt;
where
    Borrowed: ?Sized,
{
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut Borrowed;
}

<span class="boring">}
</span></code></pre></pre>
<p>这些 trait 被发明用于解决非常具体的问题，即使用<code>&amp;str</code>类型的值在<code>HashSet</code>、<code>HashMap</code>、<code>BTreeSet</code>和<code>BTreeMap</code>中查找<code>String</code>类型的 key。</p>
<p>我们可以把<code>Borrow&lt;T&gt;</code>和<code>BorrowMut&lt;T&gt;</code>看作更严格的<code>AsRef&lt;T&gt;</code>和<code>AsMut&lt;T&gt;</code>，它们返回的引用<code>&amp;T</code>与<code>Self</code>有等价性的<code>Eq</code>、<code>Hash</code>和<code>Ord</code>实现。通过下面的例子会更易于理解：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::Borrow;
use std::hash::Hasher;
use std::collections::hash_map::DefaultHasher;
use std::hash::Hash;

fn get_hash&lt;T: Hash&gt;(t: T) -&gt; u64 {
    let mut hasher = DefaultHasher::new();
    t.hash(&amp;mut hasher);
    hasher.finish()
}

fn asref_example&lt;Owned, Ref&gt;(owned1: Owned, owned2: Owned)
where
    Owned: Eq + Ord + Hash + AsRef&lt;Ref&gt;,
    Ref: Eq + Ord + Hash
{
    let ref1: &amp;Ref = owned1.as_ref();
    let ref2: &amp;Ref = owned2.as_ref();

    // refs aren't required to be equal if owned types are equal
    assert_eq!(owned1 == owned2, ref1 == ref2); // ❌

    let owned1_hash = get_hash(&amp;owned1);
    let owned2_hash = get_hash(&amp;owned2);
    let ref1_hash = get_hash(&amp;ref1);
    let ref2_hash = get_hash(&amp;ref2);

    // ref hashes aren't required to be equal if owned type hashes are equal
    assert_eq!(owned1_hash == owned2_hash, ref1_hash == ref2_hash); // ❌

    // ref comparisons aren't required to match owned type comparisons
    assert_eq!(owned1.cmp(&amp;owned2), ref1.cmp(&amp;ref2)); // ❌
}

fn borrow_example&lt;Owned, Borrowed&gt;(owned1: Owned, owned2: Owned)
where
    Owned: Eq + Ord + Hash + Borrow&lt;Borrowed&gt;,
    Borrowed: Eq + Ord + Hash
{
    let borrow1: &amp;Borrowed = owned1.borrow();
    let borrow2: &amp;Borrowed = owned2.borrow();

    // borrows are required to be equal if owned types are equal
    assert_eq!(owned1 == owned2, borrow1 == borrow2); // ✅

    let owned1_hash = get_hash(&amp;owned1);
    let owned2_hash = get_hash(&amp;owned2);
    let borrow1_hash = get_hash(&amp;borrow1);
    let borrow2_hash = get_hash(&amp;borrow2);

    // borrow hashes are required to be equal if owned type hashes are equal
    assert_eq!(owned1_hash == owned2_hash, borrow1_hash == borrow2_hash); // ✅

    // borrow comparisons are required to match owned type comparisons
    assert_eq!(owned1.cmp(&amp;owned2), borrow1.cmp(&amp;borrow2)); // ✅
}

<span class="boring">}
</span></code></pre></pre>
<p>意识到这些 trait 以及它们为什么存在是有益的，因为它有助于搞清楚<code>HashSet</code>、<code>HashMap</code>、<code>BTreeSet</code>以及<code>BTreeMap</code>的某些方法，但是我们很少需要为我们的类型实现这些 trait，因为我们很少需要创建一对儿类型，其中一个是另一个的借用版本。如果我们有某个类型<code>T</code>，<code>&amp;T</code>在 99.99%的情况下可以完成工作，并且因为 generic blanket impl，<code>T:Borrorw&lt;T&gt;</code>已经为所有的类型<code>T</code>实现了，所以我们不需要手动地实现它并且我们不需要创建一个<code>U</code>以用来<code>T:Borrow&lt;U&gt;</code>。</p>
<h3><a class="header" href="#toowned" id="toowned">ToOwned</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    fn to_owned(&amp;self) -&gt; Self::Owned;

    // 提供默认实现
    fn clone_into(&amp;self, target: &amp;mut Self::Owned);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>ToOwned</code>是<code>Clone</code>的一个更为通用的版本。<code>Clone</code>允许我们获取一个<code>&amp;T</code>并把它转为一个<code>T</code>，但是<code>ToOwned</code>允许我们拿到一个<code>&amp;Borrowed</code>并把它转为一个<code>Owned</code>，其中<code>Owned: Borrow&lt;Borrowed&gt;</code>。</p>
<p>换句话说，我们不能从一个<code>&amp;str</code>克隆一个<code>String</code>，或者从一个<code>&amp;Path</code>克隆一个<code>PathBuf</code>，或者从一个<code>&amp;OsStr</code>克隆一个<code>OsString</code>，因为<code>clone</code>方法签名不支持这种跨类型的克隆，这就是<code>ToOwned</code>产生的原因。</p>
<p>类似于<code>Borrow</code>和<code>BorrowMut</code>，知道这个 trait 并理解它什么存在同样是有益的，只是我们几乎不需要为我们的类型实现它。</p>
<h2><a class="header" href="#iteration-traits" id="iteration-traits">Iteration Traits</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // provided default impls
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
    fn count(self) -&gt; usize;
    fn last(self) -&gt; Option&lt;Self::Item&gt;;
    fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt;;
    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;;
    fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;;
    fn chain&lt;U&gt;(
        self, 
        other: U
    ) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator&lt;Item = Self::Item&gt;;
    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
    where
        U: IntoIterator;
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; B;
    fn for_each&lt;F&gt;(self, f: F)
    where
        F: FnMut(Self::Item);
    fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn filter_map&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn enumerate(self) -&gt; Enumerate&lt;Self&gt;;
    fn peekable(self) -&gt; Peekable&lt;Self&gt;;
    fn skip_while&lt;P&gt;(self, predicate: P) -&gt; SkipWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn take_while&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self, P&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn map_while&lt;B, P&gt;(self, predicate: P) -&gt; MapWhile&lt;Self, P&gt;
    where
        P: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn skip(self, n: usize) -&gt; Skip&lt;Self&gt;;
    fn take(self, n: usize) -&gt; Take&lt;Self&gt;;
    fn scan&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; Scan&lt;Self, St, F&gt;
    where
        F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt;;
    fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt;
    where
        F: FnMut(Self::Item) -&gt; U,
        U: IntoIterator;
    fn flatten(self) -&gt; Flatten&lt;Self&gt;
    where
        Self::Item: IntoIterator;
    fn fuse(self) -&gt; Fuse&lt;Self&gt;;
    fn inspect&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt;
    where
        F: FnMut(&amp;Self::Item);
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self;
    fn collect&lt;B&gt;(self) -&gt; B
    where
        B: FromIterator&lt;Self::Item&gt;;
    fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)
    where
        F: FnMut(&amp;Self::Item) -&gt; bool,
        B: Default + Extend&lt;Self::Item&gt;;
    fn partition_in_place&lt;'a, T, P&gt;(self, predicate: P) -&gt; usize
    where
        Self: DoubleEndedIterator&lt;Item = &amp;'a mut T&gt;,
        T: 'a,
        P: FnMut(&amp;T) -&gt; bool;
    fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; bool
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R
    where
        F: FnMut(B, Self::Item) -&gt; R,
        R: Try&lt;Ok = B&gt;;
    fn try_for_each&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R
    where
        F: FnMut(Self::Item) -&gt; R,
        R: Try&lt;Ok = ()&gt;;
    fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, Self::Item) -&gt; B;
    fn fold_first&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(Self::Item, Self::Item) -&gt; Self::Item;
    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; bool;
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;
    where
        P: FnMut(&amp;Self::Item) -&gt; bool;
    fn find_map&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt;
    where
        F: FnMut(Self::Item) -&gt; Option&lt;B&gt;;
    fn try_find&lt;F, R&gt;(
        &amp;mut self, 
        f: F
    ) -&gt; Result&lt;Option&lt;Self::Item&gt;, &lt;R as Try&gt;::Error&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; R,
        R: Try&lt;Ok = bool&gt;;
    fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        P: FnMut(Self::Item) -&gt; bool;
    fn rposition&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
    where
        Self: ExactSizeIterator + DoubleEndedIterator,
        P: FnMut(Self::Item) -&gt; bool;
    fn max(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn min(self) -&gt; Option&lt;Self::Item&gt;
    where
        Self::Item: Ord;
    fn max_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn max_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn min_by_key&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item) -&gt; B,
        B: Ord;
    fn min_by&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;
    fn rev(self) -&gt; Rev&lt;Self&gt;
    where
        Self: DoubleEndedIterator;
    fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)
    where
        Self: Iterator&lt;Item = (A, B)&gt;,
        FromA: Default + Extend&lt;A&gt;,
        FromB: Default + Extend&lt;B&gt;;
    fn copied&lt;'a, T&gt;(self) -&gt; Copied&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Copy;
    fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt;
    where
        Self: Iterator&lt;Item = &amp;'a T&gt;,
        T: 'a + Clone;
    fn cycle(self) -&gt; Cycle&lt;Self&gt;
    where
        Self: Clone;
    fn sum&lt;S&gt;(self) -&gt; S
    where
        S: Sum&lt;Self::Item&gt;;
    fn product&lt;P&gt;(self) -&gt; P
    where
        P: Product&lt;Self::Item&gt;;
    fn cmp&lt;I&gt;(self, other: I) -&gt; Ordering
    where
        I: IntoIterator&lt;Item = Self::Item&gt;,
        Self::Item: Ord;
    fn cmp_by&lt;I, F&gt;(self, other: I, cmp: F) -&gt; Ordering
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Ordering,
        I: IntoIterator;
    fn partial_cmp&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt;
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn partial_cmp_by&lt;I, F&gt;(
        self, 
        other: I, 
        partial_cmp: F
    ) -&gt; Option&lt;Ordering&gt;
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt;,
        I: IntoIterator;
    fn eq&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn eq_by&lt;I, F&gt;(self, other: I, eq: F) -&gt; bool
    where
        F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; bool,
        I: IntoIterator;
    fn ne&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn lt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn le&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn gt&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn ge&lt;I&gt;(self, other: I) -&gt; bool
    where
        I: IntoIterator,
        Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;;
    fn is_sorted(self) -&gt; bool
    where
        Self::Item: PartialOrd&lt;Self::Item&gt;;
    fn is_sorted_by&lt;F&gt;(self, compare: F) -&gt; bool
    where
        F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Option&lt;Ordering&gt;;
    fn is_sorted_by_key&lt;F, K&gt;(self, f: F) -&gt; bool
    where
        F: FnMut(Self::Item) -&gt; K,
        K: PartialOrd&lt;K&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p><code>Iterator&lt;Item = T&gt;</code>类型可以被迭代并产生<code>T</code>类型。没有<code>IteratorMut</code> trait。每个<code>Iterator</code>实现可以指定它返回的是不可变引用、可变引用还是拥有通过<code>Item</code>关联类型的值。</p>
<table><thead><tr><th><code>Vec&lt;T&gt;</code> 方法</th><th>返回</th></tr></thead><tbody>
<tr><td><code>.iter()</code></td><td><code>Iterator&lt;Item = &amp;T&gt;</code></td></tr>
<tr><td><code>.iter_mut()</code></td><td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td></tr>
<tr><td><code>.into_iter()</code></td><td><code>Iterator&lt;Item = T&gt;</code></td></tr>
</tbody></table>
<p>大多数类型没有它们自己的迭代器，这对于初级Rustaceans来说，并不明显，但中级Rustaceans认为这是理所当然的。如果一个类型是可迭代的，我们几乎总是实现自定义的迭代器类型来迭代它，而不是让它自己迭代。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct MyType {
    items: Vec&lt;String&gt;
}

impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        MyTypeIterator {
            index: 0,
            items: &amp;self.items
        }
    }
}

struct MyTypeIterator&lt;'a&gt; {
    index: usize,
    items: &amp;'a Vec&lt;String&gt;
}

impl&lt;'a&gt; Iterator for MyTypeIterator&lt;'a&gt; {
    type Item = &amp;'a String;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.index &gt;= self.items.len() {
            None
        } else {
            let item = &amp;self.items[self.index];
            self.index += 1;
            Some(item)
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>为了便于教学，上面的例子展示了如何从头开始实现一个迭代器，但在这种情况下，常用的解决方案是直接延用<code>Vec</code>的<code>iter</code>方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType {
    items: Vec&lt;String&gt;
}

impl MyType {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;String&gt; {
        self.items.iter()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>而且，这也是一个需要注意到的generic blanket impl：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;I: Iterator + ?Sized&gt; Iterator for &amp;mut I;
<span class="boring">}
</span></code></pre></pre>
<p>一个迭代器的可变引用也是一个迭代器。知道这一点是有用的，因为它让我们能够使用<code>self</code>作为接收器（receiver）的迭代器方法，就像<code>&amp;mut self</code>接收器一样。</p>
<p>举个例子，假定我们有一个函数，它处理一个数据超过三项的迭代器，但是函数的第一步是取出迭代器的前三项并在迭代完剩余项之前单独处理它们，下面是一个初学者可能会写出的函数实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.take(3).collect();
    for item in iter { // ❌ iter consumed in line above
        // process remaining items
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>这看起来有点让人头疼。<code>take</code>方法有一个<code>self</code>接收器，所以我们似乎不能在没有消耗整个迭代器的情况下调用它！下面是对上面代码的重构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = vec![
        iter.next().unwrap(),
        iter.next().unwrap(),
        iter.next().unwrap(),
    ];
    for item in iter { // ✅
        // process remaining items
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样是没问题的，但是实际中通常会这样重构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;I: Iterator&lt;Item = i32&gt;&gt;(mut iter: I) {
    let first3: Vec&lt;i32&gt; = iter.by_ref().take(3).collect();
    for item in iter { // ✅
        // process remaining items
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种写法不太常见，但不管怎样，现在我们知道了。</p>
<p>此外，对于什么类型可以或者不可以是迭代器，并没有规则或者约定。如果一个类型实现了<code>Iterator</code>，那么它就是一个迭代器。下面是标准库中一个新颖的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::channel;
use std::thread;

fn paths_can_be_iterated(path: &amp;Path) {
    for part in path {
        // iterate over parts of a path
    }
}

fn receivers_can_be_iterated() {
    let (send, recv) = channel();

    thread::spawn(move || {
        send.send(1).unwrap();
        send.send(2).unwrap();
        send.send(3).unwrap();
    });

    for received in recv {
        // iterate over received values
    }
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#intoiterator" id="intoiterator">IntoIterator</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIterator 
where
    &lt;Self::IntoIter as Iterator&gt;::Item == Self::Item, 
{
    type Item;
    type IntoIter: Iterator;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>正如其名，<code>IntoIterator</code>类型可以转化为迭代器。当一个类型在一个<code>for-in</code>循环里被使用的时候，该类型的<code>into_iter</code>方法会被调用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vec = Vec&lt;T&gt;
for v in vec {} // v = T

// above line desugared
for v in vec.into_iter() {}
<span class="boring">}
</span></code></pre></pre>
<p>不仅<code>Vec</code>实现了<code>IntoIterator</code>，如果我们想在不可变引用或可变引用上迭代，<code>&amp;Vec</code>和<code>&amp;mut Vec</code>同样也是如此。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vec = Vec&lt;T&gt;
for v in &amp;vec {} // v = &amp;T

// above example desugared
for v in (&amp;vec).into_iter() {}

// vec = Vec&lt;T&gt;
for v in &amp;mut vec {} // v = &amp;mut T

// above example desugared
for v in (&amp;mut vec).into_iter() {}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#fromiterator" id="fromiterator">FromIterator</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FromIterator&lt;A&gt; {
    fn from_iter&lt;T&gt;(iter: T) -&gt; Self
    where
        T: IntoIterator&lt;Item = A&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p>正如其名，<code>FromIterator</code>类型可以从一个迭代器创建而来。<code>FromIterator</code>最常用于<code>Iterator</code>上的<code>collect</code>方法调用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;;

<span class="boring">}
</span></code></pre></pre>
<p>下面是一个例子，搜集（collect）一个<code>Iterator&lt;Item = char&gt;</code> 到 <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn filter_letters(string: &amp;str) -&gt; String {
    string.chars().filter(|c| c.is_alphabetic()).collect()
}

<span class="boring">}
</span></code></pre></pre>
<p>标准库中所有的集合都实现了<code>IntoIterator</code>和<code>FromIterator</code>，从而使它们之间的转换更为简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{BTreeSet, HashMap, HashSet, LinkedList};

// String -&gt; HashSet&lt;char&gt;
fn unique_chars(string: &amp;str) -&gt; HashSet&lt;char&gt; {
    string.chars().collect()
}

// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;
fn ordered_unique_items&lt;T: Ord&gt;(vec: Vec&lt;T&gt;) -&gt; BTreeSet&lt;T&gt; {
    vec.into_iter().collect()
}

// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;
fn entry_list&lt;K, V&gt;(map: HashMap&lt;K, V&gt;) -&gt; LinkedList&lt;(K, V)&gt; {
    map.into_iter().collect()
}

// and countless more possible examples

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#io-traits" id="io-traits">I/O Traits</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    // provided default impls
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt;;
    fn is_read_vectored(&amp;self) -&gt; bool;
    unsafe fn initializer(&amp;self) -&gt; Initializer;
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;;
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;;
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt;;
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized;
    fn bytes(self) -&gt; Bytes&lt;Self&gt;
    where
        Self: Sized;
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
    where
        Self: Sized;
    fn take(self, limit: u64) -&gt; Take&lt;Self&gt;
    where
        Self: Sized;
}

trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    // provided default impls
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt;;
    fn is_write_vectored(&amp;self) -&gt; bool;
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt;;
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized;
}

<span class="boring">}
</span></code></pre></pre>
<p>值得关注的generic blanket impls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;R: Read + ?Sized&gt; Read for &amp;mut R;
impl&lt;W: Write + ?Sized&gt; Write for &amp;mut W;

<span class="boring">}
</span></code></pre></pre>
<p>也就是说，<code>Read</code>类型的任何可变引用也都是<code>Read</code>，<code>Write</code>同理。知道这些是有用的，因为它允许我们使用任何带有<code>self</code>接收器的方法，就像它有一个<code>&amp;mut self</code>接收器一样。我们已经在迭代器trait部分讲过了它是如何起作用的以及为什么很有用，所以这里不再赘述。</p>
<p>这里我想指出的是，<code>&amp;[u8]</code> 实现了<code>Read</code>，<code>Vec&lt;u8&gt;</code>实现了<code>Write</code>。因此我们可以对我们的文件处理函数进行简单的单元测试，通过使用<code>String</code>转换为<code>&amp;[u8]</code>以及从<code>Vec&lt;u8&gt;</code> 转换为<code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;
use std::fs::File;
use std::io::Read;
use std::io::Write;
use std::io;

// function we want to test
fn uppercase&lt;R: Read, W: Write&gt;(mut read: R, mut write: W) -&gt; Result&lt;(), io::Error&gt; {
    let mut buffer = String::new();
    read.read_to_string(&amp;mut buffer)?;
    let uppercase = buffer.to_uppercase();
    write.write_all(uppercase.as_bytes())?;
    write.flush()?;
    Ok(())
}

// in actual program we'd pass Files
fn example(in_path: &amp;Path, out_path: &amp;Path) -&gt; Result&lt;(), io::Error&gt; {
    let in_file = File::open(in_path)?;
    let out_file = File::open(out_path)?;
    uppercase(in_file, out_file)
}


// however in unit tests we can use Strings!
#[test] // ✅
fn example_test() {
    let in_file: String = &quot;i am screaming&quot;.into();
    let mut out_file: Vec&lt;u8&gt; = Vec::new();
    uppercase(in_file.as_bytes(), &amp;mut out_file).unwrap();
    let out_result = String::from_utf8(out_file).unwrap();
    assert_eq!(out_result, &quot;I AM SCREAMING&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#总结-16" id="总结-16">总结</a></h2>
<p>我们一起学到了很多! 事实上是太多了。这是我们现在的样子：</p>
<p><img src="https://gitee.com/praying/picbed/raw/master/2021-7-25/1627191055521-image.png" alt="" /></p>
<h1><a class="header" href="#rust-中的隐式类型转换" id="rust-中的隐式类型转换">Rust 中的隐式类型转换</a></h1>
<p>译者：<a href="https://github.com/iamazy">iamazy</a></p>
<blockquote>
<p>原文： <a href="https://www.possiblerust.com/guide/what-can-coerce-and-where-in-rust">https://www.possiblerust.com/guide/what-can-coerce-and-where-in-rust</a> </p>
</blockquote>
<hr />
<p>Rust 支持多种<a href="https://doc.rust-lang.org/reference/type-coercions.html">类型转换</a>，它可以<strong>隐式</strong>的将一种类型转换成另一种类型。与其他支持类型转换的语言一样，Rust 在易读性与易写性之间做了权衡。虽然对于 Rust 支持类型转换的清单是否最好存在分歧，但是学习类型转换是有意义的，因为有些是惯用的 (idiomatic) Rust 代码的核心。在本文中，我将描述 Rust 支持什么样的类型转换，以及在何处应用。</p>
<blockquote>
<p>说明：本文介绍的所有类型转换都是隐式强制转换，将简称为强转。</p>
</blockquote>
<h2><a class="header" href="#什么是类型强转" id="什么是类型强转">什么是(类型)强转</a></h2>
<p>在讨论类型强转之前，最好先弄清楚它的含义。Rust 支持多种类型转换的方式。<code>From</code>和<code>Into</code>特性用于库级别的可靠 (infallible) 转换。<code>TryFrom</code>和<code>TryInto</code>用于处理易出错的类型转换。<code>AsRef</code>，<code>AsMut</code>，<code>Borrow</code>和<code>ToOwned</code>提供了更多不同类型之间库级转换。但是，这些都是显式的。要执行转换，用户必须调用相关的函数。相比之下，强转是隐式的，这些转换的隐式属性意味着它们仅在其裨益依赖于易用性时才是可用的，并且隐式类型更改造成的潜在危害最小。使用<code>as</code>关键字完成的转换是显式的，并且允许的显式强转 (cast) 的种类比隐式强转 (coercion) 要多。</p>
<blockquote>
<p><strong>INFO 1</strong> ，<code>transmute</code> - unsafe 转换<br />
标准库中有一个函数<code>std::mem::transmute</code>，它可以将任意类型转换成其他类型。该函数是<code>unsafe</code>的，因为它不能保证输入类型的有效位可以表示为输出类型的有效位。确保这两种类型兼容由用户决定。</p>
<p>有一个致力于在 Rust 中开发“safe transmute”选项的工作，可以称之为“Project Safe Transmute”。他们的工作正在进行中，目的是当讨论的转化合法时，不需要使用<code>unsafe</code>版本的<code>transmute</code>(意味着源类型的有效位始终是目标类型中的有效位)。</p>
</blockquote>
<h2><a class="header" href="#有哪些类型强转-coercion-呢" id="有哪些类型强转-coercion-呢">有哪些类型强转 (coercion) 呢？</a></h2>
<p>Rust 支持多种隐式的类型强转，尽管它们的定义都是非正式的，但是仍然需要进行一定程度的标准化。事实上，这些转换的长期规范预计将成为最终标准化过程的一部分，因为它们对于理解 Rust 的类型系统至关重要。</p>
<blockquote>
<p><strong>INFO 2</strong>，标准化编程语言<br />
由于缺乏规范，Rust 不如 C/C++ 值得信赖的批评定期出现，在这里我要解释一下：首先，Rust 确实没有像 C/C++ 那样的规范(由国际标准组织发布和管理)，但这并不意味着 Rust 完全没有标准。
Rust 有一个 <a href="https://doc.rust-lang.org/reference/introduction.html">reference</a>，它编纂 (codify) 了该语言的大部分预期语义。它还具有管理语言变化的 <a href="https://github.com/rust-lang/rfcs">RFC 流程</a>，以及监督 (oversee) 语言发展的团队。这些团队包括不安全代码指南工作组 (Unsafe Code Guidelines Working Group)，旨在更好的指定影响 unsafe Rust 代码的语义，要求和保证。该小组开发了<code>miri</code>，这是 Rust 中的 MIR (Mid-Level Internal Representation) 语言的解释器，它可以自动验证 MIR 代码是否与 Rust 语义中的“stacked borrows”模型(由 UCG WG 提出)一致。主要的 Rust 编译器也经过彻底测试，包括实验特性变更和新编译器版本的自动回归测试。<br />
rustc 有一个可用的替代实现 - <a href="https://github.com/thepowersgang/mrustc">mrustc</a>，尽管它通常不供最终用户使用。在实现支持 Rust 的 GNU 编译器集合方面还有更新的工作，称为“<a href="https://rust-gcc.github.io/">rust-gcc</a>”。<br />
<a href="https://ferrous-systems.com/blog/sealed-rust-the-pitch/">Ferrocene</a> 一直在致力于获得 Rust 认证以用于关键的安全领域，包括航空电子(avionic) 和自动化行业。它由 Ferrous Systems (一家 Rust 咨询公司) 维护，其团队中包括主要的语言和社区贡献者。 
最终，正式指定的挑战以及证明 Rust 的保证已经在学术中得到解决，多个项目构建了模型，包括 Patina，Oxide，RustBelt，KRust 和 K-Rust。这些工作在 Alexa White 的硕士学位论文 <a href="https://digitalcommons.calpoly.edu/cgi/viewcontent.cgi?article=3804&amp;context=theses">Towards a Complete Formal Semantics of Rust</a> 中得到了研究和扩展，该论文是理解这些不同科研工作的一个很好的切入点。<br />
所有这些虽然不是标准，但是提高了 Rust 的水平，使其可以达到它所保证的能力。主 Rust 编译器中存在<a href="https://github.com/rust-lang/rust/labels/I-unsound">可靠性漏洞</a>，这些漏洞会随着时间的推移被跟踪解决。如 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md#soundness-changes">RFC 1122</a> 所述，Rust 稳定性策略为修复可靠性漏洞的破坏性更改留下了一个例外。<br />
还值得注意的是，C 语言在 1972 年引入，而 C 语言标准的第一个正式非草案版本在 1989 年问世 (ANSI X3.159-1989 “编程语言 - C,” 现已撤回)。C++ 于 1985 年推出，其标准的第一个非草案版本于 1998 年发布 (ISO/IEC 14882:1998 “编程语言 — C++”)。<br />
Rust 第一个公开版本是在 2010 年发布的，它在 2015 年 5 月 15 日对早期版本的语言进行了重大更改后，发布了 1.0 版本。从 1.0 发布之日算起，已经过去了 6 年。标准化需要时间，耐心是一种美德。</p>
</blockquote>
<h3><a class="header" href="#引用降级强转" id="引用降级强转">引用降级强转</a></h3>
<p>引用降级强转是一种非常常见的强转操作，它可以将<code>&amp;mut T</code>强转为<code>&amp;T</code>。显然，这种强转总是安全的，因为不可变引用会受到更多的限制。它还允许借用检查器接受一些你可能认为不会编译或正常工作的代码。</p>
<p>一个引用降级强转的例子如下所示：</p>
<pre><pre class="playground"><code class="language-rust">struct RefHolder&lt;'a&gt; {
    x: &amp;'a i64,
}

impl&lt;'a&gt; RefHolder&lt;'a&gt; {
    fn new(x: &amp;'a i64) -&gt; RefHolder&lt;'a&gt; {
        RefHolder { x }
    }
}

fn print_num(y: &amp;i64) {
    println!(&quot;y: {}&quot;, y);
}

fn main() {
    // Create `x`
    let mut x = 10;

    // Make sure `y` is `&amp;mut i64`.
    let y = &amp;mut x;

    // Package the downgraded reference into a struct.
    let z = RefHolder::new(y);
    
    // Print `y` downgrading it to an `&amp;i64`.
    print_num(y);
    
    // Use the `z` reference again.
    println!(&quot;z.x: {}&quot;, z.x);
}
</code></pre></pre>
<p>在该例中，我们可以看到<code>print_num</code>函数只需要<code>&amp;i64</code>，但它传入了一个<code>&amp;mut i64</code>。它可以正常运行是因为引用降级强转成了一个不可变引用。这也解决了给可变借用起别名的问题。<code>RefHolder</code>类型的构造函数也会发生同样的情况。</p>
<p>请注意该强转发生的次数。这里有一个类似的无法编译的例子。</p>
<pre><pre class="playground"><code class="language-rust">struct RefHolder&lt;'a&gt; {
    x: &amp;'a i64,
}

impl&lt;'a&gt; RefHolder&lt;'a&gt; {
    fn new(x: &amp;'a i64) -&gt; RefHolder&lt;'a&gt; {
        RefHolder { x }
    }
}

fn print_num(y: &amp;i64) {
    println!(&quot;y: {}&quot;, y);
}

fn main() {
    // Create `x`
    let mut x = 10;

    // Make sure `y` is `&amp;mut i64`.
    let y = &amp;mut x;

    // Package the downgraded reference into a struct.
    //
    //---------------------------------------------------
    // NOTE: this is a _fresh_ reference now, instead of
    //       being `y`.
    //---------------------------------------------------
    let z = RefHolder::new(&amp;mut x);
    
    // Print `y` and update it, downgrading it
    // to `&amp;i64`.
    print_num(y);
    
    // Use the `z` reference again.
    println!(&quot;z.x: {}&quot;, z.x);
}
</code></pre></pre>
<p>在该例中，即使引用在函数签名中降级，借用检查器仍然观察到在同一作用域内(针对同一内存)创建了两个可变引用，这是不被允许的。</p>
<h3><a class="header" href="#解引用强转" id="解引用强转">解引用强转</a></h3>
<p>下一种强转是 Rust 人体工程学 (ergonomics) 的基石 (cornerstone)。“解引用强转”是由两个特征的实现产生的强转：<code>Deref</code>和<code>DerefMut</code>。这些(特征)明确存在的目的是选择加入这种强转，让容器可以透明使用它们包含的类型(这些容器通常称为“智能指针”)。</p>
<p>这类特征定义如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    type Target: ?Sized;

    pub fn deref(&amp;self) -&gt; &amp;Self::Target;
}

pub trait DerefMut: Deref {
    pub fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p>第一个特征<code>Deref</code>定义了一个类型，可以提供对其他“目标”类型的引用。这个目标是一个关联类型，而不是一个类型参数，因为每个“智能指针”应该只能被解引用为一种类型。如果它被定义为<code>Deref&lt;Target&gt;</code>，则任何类型都可以提供尽可能多的实现，因为它们可以提供内部类型，然后编译器根据某种机制来选择正确的内部类型。解引用强转的关键在于它们是隐式的，因此通常明确的类型注释会与解引用强转功能的好处相冲突。</p>
<p><code>DerefMut</code>特征需要<code>Deref</code>作为超类型，这既可以让其访问 Target 关联类型，也可以确保<code>Deref</code>和<code>DerefMut</code>的目标类型始终一致。否则，你可能会在可变上下文中启用对一种类型的强转，而在不可变上下文中启用对另一种类型的强转。这种级别的灵活性为解引用强转增加了更多的复杂性，但没有明显的好处，因此它不可用。</p>
<p>这两个特征所需的方法<code>deref</code>和<code>deref_mut</code>，在实现这些特征的类型上调用方法时会被隐式调用。比如，在<code>Box&lt;T&gt;</code>上实现了<code>Deref&lt;Target = T&gt;</code>，因此可以透明地调用其包含类型的方法，这使得<code>Box&lt;T&gt;</code>比用户必须为每个操作显式访问其内容更符合人体工程学。</p>
<h3><a class="header" href="#裸指针强转" id="裸指针强转">裸指针强转</a></h3>
<p>Rust 的裸指针可能会从<code>*mut T</code>强转为<code>*const T</code>。尽管通过解引用来使用这些指针是 unsafe 的，并且受制于 Rust 对指针的<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">安全性要求</a>(即访问永远不会悬垂或未对齐)，但是这些转换是 safe Rust 的一部分(即不是为在 unsafe 上下文中使用而保留的功能)。</p>
<p>裸指针的强转示例如下所示：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct PtrHandle {
    ptr: *const i32,
}

fn main() {
    let mut x = 5;
    let ptr = &amp;mut x as *mut i32;

    // The coercion happens on this line, where
    // a `*mut i32` is set as the value for a field
    // with type `*const i32`, coercing to that type.
    let handle = PtrHandle { ptr };

    println!(&quot;{:?}&quot;, handle);
}
</code></pre></pre>
<blockquote>
<p><strong>INFO 3</strong> 指针转换的安全性<br />
Rust 还允许将<code>*const T</code>通过<code>as</code>转换成<code>*mut T</code>。<br />
虽然允许将<code>*const T</code>转换为<code>*mut T</code>似乎让人感到惊讶，但有时这种转换是必要的。例如，FFI 代码可能会从<code>Box::into_raw</code>中创建一个<code>*mut T</code>，但只想为 API 的 C 使用者提供一个<code>*const T</code>。因此 FFI 接口提供的等效删除函数需要将<code>*const T</code>作为参数，将其转换回<code>*mut T</code>以将其传递给<code>Box::from_raw</code>，从而使 Rust 在函数结束时对<code>Box</code>进行释放。<br />
虽然指针出处 (provenance) 的细节意味着这种转换并不总是未定义的行为，但如果指针的原始出处不是可变的，则它可能是未定义的行为。换句话说，如果一个值最初是<code>*mut T</code>类型，它可以在将来用作<code>*mut T</code>，即使类型在此期间 (interim) 被转换为<code>*const T</code>。</p>
</blockquote>
<h3><a class="header" href="#引用与裸指针强转" id="引用与裸指针强转">引用与裸指针强转</a></h3>
<p>你可以将<code>&amp;T</code>转换为<code>*const T</code>，将<code>&amp;mut T</code>转换为<code>*mut T</code>。尽管产生的裸指针只能在 unsafe 的代码块中解引用，但是这些强转是 safe 的。</p>
<p>和上一个例子类似，但是这一次是将引用转换成指针而不是改变指针类型的可变性。</p>
<pre><pre class="playground"><code class="language-rust">// Notice that these coercions work when
// generic types are present too.
#[derive(Debug)]
struct ConstHandle&lt;T&gt; {
    ptr: *const T,
}

#[derive(Debug)]
struct MutHandle&lt;T&gt; {
    ptr: *mut T,
}

fn main() {
    let mut x = 5;

    let c_handle = ConstHandle {
        // Coercing `&amp;i32` into `*const i32`
        ptr: &amp;x,
    };

    let m_handle = MutHandle {
        // Coercing `&amp;mut x` into `*mut i32`
        ptr: &amp;mut x,
    };

    println!(&quot;{:?}&quot;, c_handle);
    println!(&quot;{:?}&quot;, m_handle);
}
</code></pre></pre>
<h3><a class="header" href="#函数指针强转" id="函数指针强转">函数指针强转</a></h3>
<p>闭包是函数加上其执行的上下文。这使得它们在许多情况下非常有用，但有时它们携带的这种额外状态会阻碍 (impede) 它们的使用，特别是没有实际的状态捕获时。在 Rust 中，除了编译时生成的无名闭包类型之外，还有函数指针类型表示没有上下文环境的函数。为了使闭包尽可能灵活，，当且仅当它们不从上下文中捕获任何变量时，闭包才会强制使用指针。</p>
<p>一个函数指针的示例如下：</p>
<pre><pre class="playground"><code class="language-rust">// This function takes in a function pointer, _not_ a generic type
// which implements one of the function traits (`Fn`, `FnMut`, or
// `FnOnce`).
fn takes_func_ptr(f: fn(i32) -&gt; i32) -&gt; i32 {
    f(5)
}

fn main() {
    let my_func = |n| n + 2;

    // The coercion happens here, and is possible because `my_func`
    // doesn't capture any variables from its environment.
    println!(&quot;{}&quot;, takes_func_ptr(my_func));
}
</code></pre></pre>
<p>请注意，在 Rust 中使用泛型实现<code>Fn</code>，<code>FnMut</code>，<code>FnOnce</code>特征的方式比使用函数指针要常见的多。如果你想要传递或存储从上下文中捕获的闭包，则需要使用这三种特征的其中一个。</p>
<h3><a class="header" href="#子类型强转" id="子类型强转">子类型强转</a></h3>
<p>令某些人惊讶的是，Rust 支持子类型强转。虽然 Rust 的类型系统通常被认为仅支持参数多态性，但实际上它也支持子类型多态性，适用于生存期。当一个生存期比另一个生存期更长时，Rust 中的生存期会彼此形成子类型关系。在这种情况下，生存期较长的是子类型，生存期较短的是超类型。因为在子类型多态中，任何子类型都可以代替超类型，这对于生存期就意味着当预期的生存期较短时，可以安全地使用较长的生存期。</p>
<p>这种强转意味着允许在<strong>强转点</strong>“缩短”生存期，因此可以使用更长的生存期来代替函数所需的较短边界。对于 Rustacean 来说，这样做的最终结果是编译器可以接受更多的程序。</p>
<p>像 Rust 一样支持参数和子类型多态的语言中出现的一个共同问题是范型类型的子类型关系如何与其范型参数的子类型关系相关联。该属性称为型变 (variance)。</p>
<p>范型类型有三个有用的变型。它们每一个都与特定的通用类型相关；如果一个类型有多个范型参数，它将对每个参数进行单独的型变确定。</p>
<ul>
<li>
<p><strong>协变 (Covariance)</strong>：对于类型<code>A&lt;T&gt;</code>，如果<code>T</code>是<code>U</code>的子类型，则<code>A&lt;T&gt;</code>是<code>A&lt;U&gt;</code>的子类型。容器的子类型与其范型参数子类型相匹配。</p>
</li>
<li>
<p><strong>逆变 (Contravariance)</strong>：对于类型<code>A&lt;T&gt;</code>，如果<code>T</code>是<code>U</code>的子类型，则<code>A&lt;U&gt;</code>是<code>A&lt;T&gt;</code>的子类型。容器的子类型与其范型参数的子类型互逆。</p>
</li>
<li>
<p><strong>不变 (Invariance)</strong>：对于类型<code>A&lt;T&gt;</code>，在<code>A&lt;T&gt;</code>与<code>A&lt;U&gt;</code>之间不存在子类型关系。容器没有子类型。</p>
</li>
</ul>
<p>在 Rust 中，由于子类型只存在于生存期中，并且生存期表示数据存活的时间，这就意味着：</p>
<ul>
<li>
<p>协变类型的生存期允许比预期的更长(这些生存期允许“缩短”，这样不会有问题是因为引用的使用时间总是少于它们的有效时间)。</p>
</li>
<li>
<p>逆变类型的生存期允许延长(就像通过要求使用<code>'static</code>而不是<code>'a</code>的生存期，来避免函数指针携带引用类型)。</p>
</li>
<li>
<p>不变类型没有子类型关系，需要一个既不会缩短也不会延长的生存期。</p>
</li>
</ul>
<p>也许一个带有子类型强转的逆变生存期示例可以帮助理解：</p>
<pre><pre class="playground"><code class="language-rust">struct FnHolder {
    f: fn(&amp;'static str) -&gt; i32,
}

fn number_for_name&lt;'a&gt;(name: &amp;'a str) -&gt; i32 {
    match name {
        &quot;Jim&quot; =&gt; 32,
        _ =&gt; 5,
    }
}

fn main() {
    // Voila! A subtype coercion! In this case coercing a
    // lifetime in a contravariant context (the lifetime in
    // the function pointer type parameter) from `'a` to `'static`.
    //
    // `'static` is longer than `'a`, which in this case is safe
    // because it's always fine to make the function _less_ accepting.
    //
    // Once it's been assigned into the `FnHolder` type, it'll only
    // accept string literals (which have a `'static` lifetime).
    let holder = FnHolder { f: number_for_name };
    
    // The extra parentheses are part of the syntax for calling
    // functions as fields, to disambiguate between this and
    // calling a method on the `FnHolder` type.
    println!(&quot;{}&quot;, (holder.f)(&quot;Jim&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#never-强转" id="never-强转">never 强转</a></h3>
<p>Rust 类型系统中有一个特殊的类型 - never 类型(写作<code>!</code>)。此类型可以强转为其他所有类型，通常表示非终止 (non-termination)。例如，<code>unimplemented!</code>，<code>unreachable!</code>和<code>todo!</code>宏都返回<code>!</code>类型。<code>!</code>类型强转可以利用这些宏类型检查，如果它们在运行时中执行，则<code>!</code>被实现为当前线程有保证的 panic。退出当前进程的<code>std::process::exit</code>函数返回<code>!</code>也是出于相同的原因。</p>
<p>never 类型强转让程序可以使用 panic 或 exit 通过类型检查。</p>
<pre><pre class="playground"><code class="language-rust">// Turn off some warnings about unreachable code.
#![allow(unreachable_code)]
#![allow(unused_variables)]
#![allow(dead_code)]

struct Value {
    x: bool,
    y: String,
}

fn never() -&gt; ! {
    // `loop`s without some way to exit
    // like this have the `!` type, because
    // the expression (and, in this case,
    // the containing function) will never
    // terminate / return.
    loop {}
}

fn main() {
    let x = never();
    
    let v = Value {
        x: todo!(&quot;uhhh I haven't gotten to this&quot;),
        y: unimplemented!(&quot;oh, not this either&quot;),
    };
    
    // This program compiles because `never`,
    // `todo!`, and `unimplemented!` all return
    // the `!` type, which coerces into any type.
}
</code></pre></pre>
<h3><a class="header" href="#切片强转" id="切片强转">切片强转</a></h3>
<p>切片强转是指从数组到切片的转换。它们是“未知大小强转”集合(以及特征对象强转和 trailing unsized 强转)中的一部分。之所以这么称呼它们，是因为它们涉及从有大小的类型(在编译时已知大小并实现了<code>Sized</code>特征的类型)到未知大小的类型(在编译时不知道其类型的大小，并且没有实现 <code>Sized</code>特征)。在切片强转的过程中，已知大小的类型为<code>[T; n]</code>(具有固定大小 n 的 T 数组)，未知大小的类型为<code>[T]</code>(T 数组的切片)。</p>
<p>切片强转发生的次数可能比你想到的还要多：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct SliceHolder&lt;'a&gt; {
    slice: &amp;'a [i32],
}

fn main() {
    let nums = [1, 2, 3, 4, 5];
    
    // It may not look like, but there's a coercion here!
    //
    // The type of `&amp;nums` is `&amp;[i32; 5]`, which is coerced
    // into `&amp;[i32]` to match the `slice` field on `SliceHolder`.
    let holder = SliceHolder { slice: &amp;nums };
    
    println!(&quot;{:#?}&quot;, holder);
}
</code></pre></pre>
<p>请注意，虽然也可以将<code>Vec&lt;T&gt;</code>强转为<code>&amp;[T]</code>，但它不是切片强转，而是解引用强转。由于语言的历史原因，数组无法与 const 泛型一起使用(因为 const 泛型没有实现<code>Deref</code>)，因此需要特殊的强转将其静默转换成切片。</p>
<h3><a class="header" href="#特征对象强转" id="特征对象强转">特征对象强转</a></h3>
<p>特征对象是 Rust 的动态调度机制，并且特征对象强转的存在是为了可以轻松构建特征对象。这种强转从某种类型<code>T</code>转换成<code>dyn U</code>，其中<code>U</code>是被<code>T</code>实现的特征，并且<code>U</code>满足 Rust 的对象安全规则。<a href="https://www.possiblerust.com/pattern/3-things-to-try-when-you-can-t-make-a-trait-object#what-makes-a-trait-object-safe">我们之前已经讨论过对象安全规则</a>，但要点是对象特征类型必须是可构造的(这意味着它在任何地方都不依赖在编译时不确定的泛型类型(泛型不包括关联的函数，没有引用<code>Self</code>的方式 - 在编译时期无法确定，并且在不包含<code>Self: Sized</code>边界的情况下，不包括按值获取<code>Self</code>的函数)。</p>
<p>一个函数通过特征对象强转进行调用的示例：</p>
<pre><pre class="playground"><code class="language-rust">trait HasInt {
    fn get(&amp;self) -&gt; i32;
}

struct IntHolder {
    x: i32,
}

impl HasInt for IntHolder {
    fn get(&amp;self) -&gt; i32 {
        self.x
    }
}

fn print_int(x: &amp;dyn HasInt) {
    println!(&quot;{}&quot;, x.get());
}

fn main() {
    let holder = IntHolder { x: 5 };
    // The coercion happens here, from `&amp;IntHolder`
    // into `&amp;dyn HasInt`.
    print_int(&amp;holder);
}
</code></pre></pre>
<h3><a class="header" href="#trailing-unsized-强转" id="trailing-unsized-强转">trailing unsized 强转</a></h3>
<p>trailing unsized 强转意味着，如果类型<code>T</code>的最后一个字段是已知大小的且可以转换为未知大小的类型，并存在一个<code>U</code>类型，它是<code>T</code>类型但执行了最后一个字段的强转，那么<code>T</code>可以被强转为<code>U</code>。因为这个定义非常特殊，我们可以具体说明：</p>
<ul>
<li><code>T</code>必须是一个结构体</li>
<li><code>T</code>的字段<code>A</code>必须可以强转为未知大小的<code>B</code>类型</li>
<li><code>T</code>的最后一个字段必须包含<code>A</code></li>
<li><code>T</code>的其他字段不能包含<code>A</code></li>
<li>如果<code>T</code>最后一个字段本身就是包含<code>A</code>的结构体，则该结构体必须可以强转为另一种类型，该类型包含未知大小的，用来替换<code>A</code>的<code>B</code>类型。</li>
</ul>
<p>这比最初的解释更准确。本质上，当相关字段是最后一个字段时，允许在结构体内进行有限的 unsized 强转。</p>
<h3><a class="header" href="#最小上限强转" id="最小上限强转">最小上限强转</a></h3>
<p>有时 Rust 需要同时在多个强转点进行强转，这样它们都可以变成相同的类型。例如，这可能发生在<code>if/else</code>表达式中，其中条件的每个分支都返回一个需要强转的类型。在这种情况下，Rust 试图找到最通用的类型，这被称为“最小上限强转”。</p>
<p>该强转可以被以下情况触发：</p>
<ol>
<li>一系列<code>if/else</code>分支</li>
<li>一系列<code>match</code>分支</li>
<li>一系列数组元素</li>
<li>在闭包中的一系列<code>返回值</code></li>
<li>在函数中的一系列<code>返回值</code></li>
</ol>
<p>执行此强转的过程是遍历每个系列中的每种类型，检查它们是否可以转换为先前确定的相同类型。如果可以，则继续。如果不能，则尝试找出一种类型<code>C</code>，可以将先前看到的类型<code>A</code>与最新的类型<code>B</code>都强转为类型<code>C</code>。最终的类型<code>C</code>被确定为该系列中所有表达式的类型。</p>
<h3><a class="header" href="#传递性强转" id="传递性强转">传递性强转</a></h3>
<p>Rust 支持传递性强转，如果类型<code>A</code>可以强转为类型<code>B</code>，并且类型<code>B</code>可以强转为类型<code>C</code>，则类型<code>A</code>可以强转为类型<code>C</code>。这个特性目前正在开发，可能不是总是有效。</p>
<h2><a class="header" href="#哪里会发生强转" id="哪里会发生强转">哪里会发生强转</a></h2>
<p>代码中发生类型强转的位置被称为“强转点 (coercion sites)”，Rust 中有多种类型的强转点。</p>
<h3><a class="header" href="#强转点" id="强转点">强转点</a></h3>
<p>首先是变量的声明，不管是通过<code>let</code>，<code>const</code>还是<code>static</code>进行声明。在这些情况下，如果在左侧显式声明变量的类型，则右侧将被强转为该类型。如果无法进行这种强转，则会发出编译器错误。</p>
<p>接下来是函数参数，其中实参被强转为型参的类型。在方法调用中，接收者类型(<code>Self</code>的类型)只能使用 unsized 强转。</p>
<p>然后你就可以拥有任何结构或枚举的字面量实例。这些数据类型中的字段被实例化的位置是强转点，实际类型被强转为整体数据类型声明中定义的正式类型。</p>
<h3><a class="header" href="#强转传播的表达式" id="强转传播的表达式">强转传播的表达式</a></h3>
<p>有些表达式被认为是“强转传播 (coercion propagating)”，这意味着它们会将强转检查传递给它们的子表达式。</p>
<p>数组字面量是强转传播的，并传播到数组字面量声明的每个元素定义中。如果与重复语法一起使用，该语法将重复给定次数的元素的初始定义。</p>
<p>元组在它们内部的每个单独表达式上也类似的进行强转传播。</p>
<p>如果表达式带有括号，则强转将传播到括号内的表达式。如果它被括号括起来，使它成为一个块，那么强转将传播到该块的最后一行。</p>
<h2><a class="header" href="#unsized-强转和强转点" id="unsized-强转和强转点">unsized 强转和强转点</a></h2>
<p>与其他强转相比，unsized 强转(上述对切片，特征对象或 trailing unsized 类型的强转)可以在一个额外的上下文中发生。具体来说，如果有一个指向类型 T 的引用，裸指针或(有所有权的)指针，其中 T 具有对类型 U 的 usized 强转，则可以通过引用或指针类型进行强转。</p>
<p>这意味着以下强转点仅对 unsized 强转有效：</p>
<ul>
<li><code>&amp;T</code>到<code>&amp;U</code></li>
<li><code>&amp;mut T</code>到<code>&amp;mut U</code></li>
<li><code>*const T</code>到<code>*const U</code></li>
<li><code>*mut T</code>到<code>*mut U</code></li>
<li><code>Box&lt;T&gt;</code>到<code>Box&lt;U&gt;</code></li>
</ul>
<p>这就是为什么上述切片强转的示例可以正常运行的原因！这种情况下的强转发生在引用之后，将[i32; 5]强转为[i32]。</p>
<h2><a class="header" href="#结论-10" id="结论-10">结论</a></h2>
<p>强转功能十分强大，因为它们是隐式的，有时会引起争议 (controversial)。</p>
<p>无论你对正确使用强转有何看法，重要的是了解什么是可能的强转，以及它们可能发生的位置。在本文中，我们命名并描述了 Rust 中所有可能的强转，并描述了哪些类型的表达式可能包含强转，以及哪些表达式可以传播强转。希望这有助于使 Rust 中这个经常被隐藏的部分变得更加清晰。</p>
<h1><a class="header" href="#tokio-internal-之-任务调度" id="tokio-internal-之-任务调度">Tokio Internal 之 任务调度</a></h1>
<p>作者：韩冰（Tony） / 后期编辑：张汉东</p>
<blockquote>
<p>这是一个系列文章：Tokio Internal: <a href="https://tony612.github.io/tokio-internals/">https://tony612.github.io/tokio-internals/</a></p>
<p>本篇精选其中相对独立的一篇《Task scheduler》，对该系列感兴趣可以去看完整系列文章。</p>
</blockquote>
<hr />
<p>选择合适的 task 来运行是调度器非常重要的一个逻辑，如果处理不好，可能会使调度很慢，也可能会使不同的 task 没有被公平地执行，甚至有些 tasks 可能一直得不到执行。我们来看一下 tokio 中是怎么解决这些问题的。</p>
<h2><a class="header" href="#各种-run-queue" id="各种-run-queue">各种 run queue</a></h2>
<p>我们来看 Tokio 中取下一个 task（<code>next_task</code>）以及 <code>steal_task</code> 的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// core.next_task:
fn next_task(&amp;mut self, worker: &amp;Worker) -&gt; Option&lt;Notified&gt; {
    if self.tick % GLOBAL_POLL_INTERVAL == 0 {
        worker.inject().pop().or_else(|| self.next_local_task())
    } else {
        self.next_local_task().or_else(|| worker.inject().pop())
    }
}

--------------------------
// self.next_local_task:
fn next_local_task(&amp;mut self) -&gt; Option&lt;Notified&gt; {
    self.lifo_slot.take().or_else(|| self.run_queue.pop())
}

--------------------------
// core.steal_work:
let num = worker.shared.remotes.len();
let start = self.rand.fastrand_n(num as u32) as usize;

for i in 0..num {
    let i = (start + i) % num;

    // Don't steal from ourself! We know we don't have work.
    if i == worker.index {
        continue;
    }

    let target = &amp;worker.shared.remotes[i];
    if let Some(task) = target.steal.steal_into(&amp;mut self.run_queue) {
        return Some(task);
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://github.com/tokio-rs/tokio/blob/a5ee2f0d3d78daa01e2c6c12d22b82474dc5c32a/tokio/src/runtime/thread_pool/worker.rs#L447">link</a></p>
<p>可以看到，Worker 会从多个地方取 task，按顺序依次是：</p>
<ol>
<li>
<p>LIFO slot</p>
</li>
<li>
<p>自己的 local queue</p>
</li>
<li>
<p>global queue</p>
</li>
<li>
<p>从其他 worker 的 queue(remotes) 中 steal 任务</p>
</li>
</ol>
<p><img src="chapter_7/./image/tokio/03_scheduler.png" alt="" />
<a href="https://excalidraw.com/#json=4729047296770048,XgEpCO1t7wCLne3H8sStnA">link</a></p>
<p>Global queue 肯定需要，但如果只有一个 global queue，每个 worker 从其中取 task 时，都需要加锁，会影响性能。因此给每个 worker 增加自己的 local queue 是很自然的选择，worker 可以优先从自己的 local queue 中取任务。</p>
<p>global 和 local 这两种 queue 都是 FIFO 的，这对于公平性很好，先到先得嘛，但不好的地方是 locality 带来的性能，每个 task 切换执行时，之前 CPU 的缓存就没用了。LIFO slot 就是为了改善这种问题的，它 （似乎）是从 Go 里借鉴来的一个机制，可以解决一些场景 locality 问题。除非是 task 主动 yield，否则当 task 被调度时，会优先考虑放到 LIFO slot（相当于是 queue 的最前边），这个 task 会被优先执行。</p>
<p>比如在一个 task 中 spawn 了另外一个 task，并且有一些变量需要被 move 到新的 task 中，这时如果新的这个 task 能够先被运行的话，这些变量在 CPU 中的缓存就能得到有效利用。Tokio 代码中还提到了 LIFO 可以减少 message passing 中的延迟。比如，当一个 task 向另一个 task 通过 <a href="https://docs.rs/tokio/1.7.0/tokio/sync/index.html">channel</a> 发消息，如果 task 收到消息后可以先被执行，就可以减少因为在 run queue 中排队带来的延迟。</p>
<p>LIFO 可以带来更好的性能，但也会牺牲公平性，因此 LIFO slot 目前只有一个，当这个 LIFO slot 已被占用时，原来的任务就会被转移到 run queue 末尾，而新的 task 则会被放在 LIFO slot 中。LIFO slot 对于性能和公平性，可以实现一定程度上的平衡。</p>
<p>任务的窃取也是调度器中常见的机制，当 global 和 local queue 中都没有 task 可以执行，就会尝试去 &quot;steal&quot; 其他 worker 的任务，这样可以平衡不同 worker 的任务量。Tokio 会随机挑一个 worker 开始尝试窃取，并且会窃取一半的任务，如果那个 worker 也没有任务，就会尝试窃取下一个 worker。不过 LIFO slot 的任务并不会被窃取。</p>
<h2><a class="header" href="#starvation-问题" id="starvation-问题">Starvation 问题</a></h2>
<p>虽然不同类型的 queue 和 work stealing 机制可以带来不错的性能和公平性，但还不够，tasks 依然可能会被“饿死”（starvation）。下边描述了几种常见的场景，和 Tokio 中的解决方法。</p>
<h3><a class="header" href="#一个-task-执行过久" id="一个-task-执行过久">一个 task 执行过久</a></h3>
<p>如果一个 task 执行很久，最坏情况是进入了死循环，那当前 worker 的 queue 中的 tasks 就要等待更长时间才能得到执行，甚至是一直不会被执行。我们知道，目前 Rust runtime 中无法抢占式调度（preempt）这样的 task，主要还是需要开发者自己进行代码“协同”。</p>
<p>但 Tokio 也有机制来改善这类问题，比如在 <a href="chapter_7/./02_worker_thread_2.html">2.5</a> 见过的 <a href="https://github.com/tokio-rs/tokio/blob/a5ee2f0d3d78daa01e2c6c12d22b82474dc5c32a/tokio/src/coop.rs#L3"><code>coop</code></a> module，在 task 运行之前会调用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>coop::budget(|| {
})
<span class="boring">}
</span></code></pre></pre>
<p>它会创建一个 thread local 的 counter，目前初始值是 128。调用 <code>coop::poll_proceed</code> 会把 counter 减 1，当减小到 0 时，就会返回 Pending。而 Tokio 中在 poll 之前都会先调用 <code>coop::poll_proceed</code> 来判断是否超过 budget，如果超过，就会直接返回而不会调用实际的 poll。比如 <a href="chapter_7/./02_worker_thread_2.html">2.5</a> 中提过的 <code>poll_ready</code> 以及 <a href="https://docs.rs/tokio/0.1.16/tokio/sync/mpsc/index.html"><code>tokio mpsc</code></a> recv 等方法里都调用了它。</p>
<p>不过即便是有 <code>coop</code> ，如果是纯 CPU 的计算，Tokio 没办法了。当然这种还是用 <a href="https://docs.rs/tokio/0.2.22/tokio/task/fn.spawn_blocking.html"><code>tokio::task::spawn_blocking</code></a> 比较好。</p>
<h3><a class="header" href="#global-queue-中的任务被饿死" id="global-queue-中的任务被饿死">Global queue 中的任务被饿死</a></h3>
<p>因为 local queue 中任务的优先级比 global queue 要高，如果一个 task 一直没有执行结束，比如一个 TCP server 的连接不停有新的数据从 client 发过来，于是它不停被挂起、放在队列、运行，这样 global queue 的任务就一直得不到运行。</p>
<p>Tokio 会用 worker 的 tick（和 <a href="chapter_7/./03_slab_token_readiness.html">3.1</a> 的 driver tick 不同）来记录 worker 在循环中运行的次数，在运行 task 或者 park 之前就会把 tick 加 1。而当取 task 时，就会判断是否运行了一定次数，是的话，就会从先从 global queue 中取 task 来运行，其实就是本章第一段代码。<code>GLOBAL_POLL_INTERVAL</code> 目前取值是 61，是<a href="https://github.com/tokio-rs/tokio/blob/a5ee2f0d3d78daa01e2c6c12d22b82474dc5c32a/tokio/src/runtime/thread_pool/worker.rs#L273">从 Go 中 copy 来的</a>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn next_task(&amp;mut self, worker: &amp;Worker) -&gt; Option&lt;Notified&gt; {
    if self.tick % GLOBAL_POLL_INTERVAL == 0 {
        worker.inject().pop().or_else(|| self.next_local_task())
    } else {
        self.next_local_task().or_else(|| worker.inject().pop())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#lifo-slot-导致的饿死" id="lifo-slot-导致的饿死">LIFO slot 导致的饿死</a></h3>
<p>LIFO slot 因为改变了 task 的优先级，就可能会导致其他任务被饿死。有一种可能是，一个 worker 中的两个 task 一直在互相发消息，这两个 task 就会一直在 LIFO slot 中，导致 local queue 的任务得不到执行，<a href="https://github.com/tokio-rs/tokio/blob/a5ee2f0d3d78daa01e2c6c12d22b82474dc5c32a/tokio/tests/rt_common.rs#L1049">有个测试用例</a> 专门来测试这种场景。Tokio 的解决方法是，对 LIFO slot 做了特殊处理：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>coop::budget(|| {
    task.run();

    // As long as there is budget remaining and a task exists in the
    // `lifo_slot`, then keep running.
    loop {
        // Check for a task in the LIFO slot
        let task = match core.lifo_slot.take() {
            Some(task) =&gt; task,
            None =&gt; return Ok(core),
        };

        if coop::has_budget_remaining() {
            // Run the LIFO task, then loop
            *self.core.borrow_mut() = Some(core);
            task.run();
        } else {
            // Not enough budget left to run the LIFO task, push it to
            // the back of the queue and return.
            core.run_queue.push_back(task, self.worker.inject());
            return Ok(core);
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://github.com/tokio-rs/tokio/blob/a5ee2f0d3d78daa01e2c6c12d22b82474dc5c32a/tokio/src/runtime/thread_pool/worker.rs#L348">link</a></p>
<p>一个任务执行后，不会回到之前的 <code>next_task</code>的地方，而是直接看 LIFO slot 中是否有任务可以执行，有就执行 LIFO slot 任务，没有就返回。但这个逻辑是放在一个 <code>coop::budget</code> 调用里的，当没有剩余 budget 时，就把 LIFO 的任务放到 run queue 末尾，从而避免了一直循环执行这两个 LIFO slot 的任务。</p>
<h3><a class="header" href="#event-poll-被饿死" id="event-poll-被饿死">Event poll 被饿死</a></h3>
<p>之前说过 Tokio 的 worker 会优先执行 run queue 中的 tasks，当没有任务可执行时，会在 <code>park</code>中 poll events。问题很明显，如果 run queue 一直没有执行完，就不会 poll events。Tokio 用了和 Global queue 饿死问题一样的方案，在取 task 之前，会在 <code>maintenance</code> 里先判断 worker 的 tick 是否运行了 <code>GLOBAL_POLL_INTERVAL</code> 次，是的话就强制 <code>park</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn maintenance(&amp;self, mut core: Box&lt;Core&gt;) -&gt; Box&lt;Core&gt; {
    if core.tick % GLOBAL_POLL_INTERVAL == 0 {
        // Call `park` with a 0 timeout. This enables the I/O driver, timer, ...
        // to run without actually putting the thread to sleep.
        core = self.park_timeout(core, Some(Duration::from_millis(0)));

        // Run regularly scheduled maintenance
        core.maintenance(&amp;self.worker);
    }

    core
}
</code></pre></pre>
<p>注意这里调用了 <code>park_timeout</code>，并且超时时间为 <code>0</code>，如果当前没有事件的话，就会直接返回，继续执行 tasks，不会等在这里。</p>
<h2><a class="header" href="#总结-17" id="总结-17">总结</a></h2>
<p>Tokio 用了几种不同的 queue，分别解决了不同的问题，并且针对可能出现的 starvation 做了预防。可以看到，虽然并非完美，但 Tokio 在尽力平衡性能、公平性，并且还在不断被优化。</p>
<h2><a class="header" href="#为什么你不应该沉迷于-rust-的特性" id="为什么你不应该沉迷于-rust-的特性">为什么你不应该沉迷于 Rust 的“特性”</a></h2>
<p>译者：<a href="https://github.com/NiZerin">NiZerin</a></p>
<blockquote>
<p>原文链接：<a href="https://nullderef.com/blog/rust-features/#cargo-release">https://nullderef.com/blog/rust-features/#cargo-release</a></p>
</blockquote>
<hr />
<p>Rust 使得表达条件编译变得非常容易，特别是由于它的“特性”。它们很好地集成到语言中并且非常易于使用。但是我通过维护Rspotify（Spotify API 的库）学到的一件事 是，人们不应该对它们着迷。当条件编译是解决问题的唯一方法时，应该使用条件编译，原因有很多，我将在本文中解释。</p>
<p>这对某些人来说可能很明显，但对我来说，当我开始使用 Rust 时并没有那么清楚。即使您已经知道，这也可能是一个有趣的提醒；也许您在最新的项目中忘记了它并添加了一个不必要的功能。</p>
<p>条件编译也不是什么新鲜事。C 和 C++ 已经这样做了很长时间，一方面。所以同样的事情可以应用于这些情况。然而，根据我的经验，在 Rust 中使用条件编译要容易得多，这意味着它也更有可能被滥用。</p>
<h3><a class="header" href="#问题-2" id="问题-2">问题</a></h3>
<p>在决定如何在 Rspotify 中配置缓存令牌时，我遇到了这个困境 。所述库使您可以通过 JSON 文件持久管理身份验证令牌。这样，当程序再次启动时，可以重复使用前一个会话中的令牌，而无需再次执行完整的身份验证过程——也就是说，直到令牌过期。</p>
<p>最初，这将是一个名为cached_token. 我并没有想太多。如果您不需要它，为什么需要代码来保存和读取令牌文件？最简单的方法是使用一个功能，你可以在你的 Cargo.toml.</p>
<p>但是，我后来需要另一个非常相似的功能，refreshing_token. 当可选地启用时，客户端将自动刷新过期的令牌。随着这种模式在库中越来越多地出现，我想确保它的设计是最佳的。深入研究后，我开始发现功能的许多不便之处：</p>
<p>它们是不灵活的：你不能在同一个程序中拥有一个带有缓存令牌的客户端和另一个没有它们的客户端。这是一个图书馆范围的事情，所以你要么启用它们，要么不启用。显然，它们也不能在运行时进行配置；用户可能想选择什么样的行为遵循，而 在程序运行。</p>
<p>它们很丑：写作 <code>#[cfg(feature = &quot;cached_token&quot;)]</code>比普通的更奇怪和冗长 <code>if cached_token</code>。</p>
<p>它们很乱：代码库中的功能很难管理。你可以很容易地发现自己处于 Rust 中，相当于 <code>#ifdef</code> 地狱。</p>
<p>它们很难记录和测试：Rust 没有提供公开库功能的方法。您所能做的就是在文档的主页中手动列出它们。测试也更难，因为您必须弄清楚要使用哪些功能组合来覆盖整个代码库，并在您想要运行测试时应用它们。</p>
<p>仅仅保证二进制文件不会包含您不需要的代码，所有这些都被认为是重要的。但这有多真实，真的吗？它有多重要？</p>
<h3><a class="header" href="#替代" id="替代">替代</a></h3>
<p>事实证明，编译器可以实现的最简单的优化之一是常量的传播。这与去除死代码相结合，可以产生与特征完全相同的效果，但以更自然的方式。除了添加功能来配置程序的行为之外，您还可以对 Config 结构进行相同的操作。如果它只是一个要配置的选项，您甚至可能不需要结构体，但这样它就可以面向未来。例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Config {
    cached_token: bool,
    refreshing_token: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，您可以修改您的客户端，以便有选择地采用Config结构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Client {
    config: Config
}

impl Client {
    /// Uses the default configuration for the initialization
    fn new() -&gt; Client {
        Client {
            config: Config::default(),
        }
    }

    /// Uses a custom configuration for the initialization
    fn with_config(config: Config) -&gt; Client {
        Client {
            config,
        }
    }

    fn do_request(&amp;self) {
        if self.config.cached_token {
            println!(&quot;Saving cache token to the file!&quot;);
        }
        // The previous block used to be equivalent to:
        //
        // #[cfg(feature = &quot;cached_token&quot;)]
        // {
        //     println!(&quot;Saving cache token to the file!&quot;);
        // }

        if self.config.refreshing_token {
            println!(&quot;Refreshing token!&quot;);
        }

        println!(&quot;Performing request!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，用户可以以一种非常自然的方式在代码中自定义他们想要的客户端：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Option A
    let client = Client::new();

    // Option B
    let config = Config {
        cached_token: true,
        ..Default::default()
    };
    let client = Client::with_config(config);
}
</code></pre></pre>
<h3><a class="header" href="#证明你最终得到了相同的代码" id="证明你最终得到了相同的代码">证明你最终得到了相同的代码</a></h3>
<p>感谢出色的Compiler Explorer，我们可以使用以下代码段确保编译符合我们的预期：</p>
<p><img src="https://user-images.githubusercontent.com/18081398/125720306-c8b247fe-3f07-454f-9343-f1da72ef1325.png" alt="image" /></p>
<p>似乎从 Rust 1.53 开始，对于 <code>opt-level</code> 大于或等于 2 的值，已停用功能的代码甚至不会出现在程序集中（通过查看末尾的字符串很容易看到）。<code>cargo build --release</code> 配置 <code>opt-level</code> 为 3，因此对于生产二进制文件应该不是问题。</p>
<p>我们甚至没有使用 <code>const</code> ！我想知道在这种情况下会发生什么。使用 这个稍微修改的片段：</p>
<p><img src="https://user-images.githubusercontent.com/18081398/125720399-9729bbcb-ecae-4470-93be-6166b46022a4.png" alt="image" /></p>
<p>唔。我们实际上得到了相同的结果。生成的程序集完全相同，可选代码仅从 <code>opt-level=2</code>.</p>
<p>问题是这 <code>const</code> 仅仅意味着它的值可以（而不是必须）被内联。没有其他的。所以我们仍然没有任何保证，内联不足以简化函数内部的代码。</p>
<p>因此，对于我所调查的内容，最好不要担心它并使用变量而不是 <code>const</code>. 它看起来更好，并得到相同的结果。</p>
<h3><a class="header" href="#无论如何" id="无论如何">无论如何</a></h3>
<p>即使之前的优化没有实现，可选代码真的会对最终的二进制文件造成任何伤害吗？我们是否一如既往地过度设计了解决方案？事实是缓存/刷新令牌的可选代码甚至没有那么膨胀。</p>
<p>当然，这取决于，但在我看来，二进制膨胀对于更高级别的二进制文件来说并不是什么大问题。Rust 已经在每个二进制文件中静态嵌入了它的标准库、运行时和大量调试信息，总大小约为 3MB。您在运行时可能获得的唯一开销是分支。</p>
<h3><a class="header" href="#结论-11" id="结论-11">结论</a></h3>
<p>有时你只需要使用条件编译；没有办法解决它。您可能正在处理特定于平台的代码或想要减少 crate 的依赖项数量，在这种情况下，功能非常有用。</p>
<p>但这不是 Rspotify 的情况。条件编译绝对不是要走的路。当你准备向你的 crate 引入一个新特性时，想想自己，“我真的需要条件编译吗？”。</p>
<p>既不遵循通常的推理，cached_token也不refreshing_token遵循为什么可能会添加功能的原因。他们不允许访问新的功能/模块。它们无助于摆脱可选的依赖项。而且它们当然不是特定于平台的功能。他们只是配置库的行为。</p>
<p>为了避免这种情况，也许功能的命名可能会有所不同？启用对缓存令牌的支持听起来确实是一项“功能”，而特定于操作系统的代码似乎并不是真正的功能。有时我也觉得很困惑，谷歌在这一点上同意我的观点。寻找与 Rust 特性相关的信息可能会返回完全不相关的东西，因为结果有“特性”这个词，但意思是“程序的一个属性或方面”。有点像你必须谷歌“golang X”而不是“go X”，否则它没有意义。但无论如何，我的意见已经太迟了。</p>
<h1><a class="header" href="#rust-no-std-工程实践" id="rust-no-std-工程实践">Rust no-std 工程实践</a></h1>
<p>作者：苏胤榕</p>
<blockquote>
<p>改写std的库为支持no_std的库及写出一个支持std和no_std库的经验谈
github repo: https://github.com/DaviRain-Su/rust-no-std-source</p>
</blockquote>
<h2><a class="header" href="#简介-1" id="简介-1">简介</a></h2>
<p>首先介绍std和no_std的区别，然后介绍使用no_std库的方式，由于支持no_std的特性有两种不同的方式，因此使用no_std库也有两种方式。其次，验证一个库是否支持no_std特性的验证方式，如何改写一个std的库为同时支持std和no_std的特性方法。具体的如何写一个支持std和no_std的库。一些在std和no_std下都可以使用的primitive的仓库和相关的资源和文章。</p>
<h2><a class="header" href="#目录-2" id="目录-2">目录</a></h2>
<ul>
<li>std和no_std的区别</li>
<li>Rust中使用no_std的两种方式</li>
<li>验证一个库是否支持no_std特性的验证方式</li>
<li>具体的写一个支持std和no_std的库</li>
<li>一些no_std和std可以使用primitive类型的仓库和相关资源的文章</li>
</ul>
<h2><a class="header" href="#std和no_std的区别" id="std和no_std的区别">std和no_std的区别</a></h2>
<blockquote>
<h2><a class="header" href="#核心库" id="核心库">核心库</a></h2>
<p>Rust语言的语法由核心库和标准库共同提供。 
其中Rust核心库是标准库的基础。核心库中定义的是Rust语言的核心，不依赖于操作系统和网络等相关的库，甚至不知道堆分配，也不提供并发和I/O</p>
<p>可以通过在模块顶部引入#![no_std]来使用核心库。核心库和标准库的功能有一些重复，包括如下部分：</p>
<ul>
<li>基础的trait，如Copy、Debug、Display、Option等。</li>
<li>基本原始类型，如bool、char、i8/u8、i16/u16、i32/u32、i64/u64、isize/usize、f32/f64、str、array、slice、tuple、pointer等。</li>
<li>常用功能型数据类型，满足常见的功能性需求，如String、Vec、HashMap、Rc、Arc、Box等。</li>
<li>常用的宏定义，如println！、assert！、panic！、vec！等。 做嵌入式应用开发的时候，核心库是必需的。</li>
</ul>
<h2><a class="header" href="#标准库-1" id="标准库-1">标准库</a></h2>
<p>Rust标准库提供应用程序开发所需要的基础和跨平台支持。标准库包含的内容大概如下：</p>
<ul>
<li>与核心库一样的基本trait、原始数据类型、功能型数据类型和常用宏等，以及与核心库几乎完全一致的API。</li>
<li>并发、I/O和运行时。例如线程模块、用于消息传递的通道类型、Sync trait等并发模块，文件、TCP、UDP、管道、套接字等常见I/O。</li>
<li>平台抽象。os模块提供了许多与操作环境交互的基本功能，包括程序参数、环境变量和目录导航；路径模块封装了处理文件路径的平台特定规则。</li>
<li>底层操作接口，比如 std：：mem、std：：ptr、std：：intrinsics 等，操作内存、指针、调用编译器固有函数。</li>
<li>可选和错误处理类型Option和Result，以及各种迭代器等。</li>
</ul>
</blockquote>
<p>还有一些解释，#![no_std] 是一个crate level 级别的属性，表示core crate将链接到core crate而不是std crate。</p>
<p>下面是std crate和core crate的解释，其实这里也就解释了标准库与和核心库之间的区别。当让也内在的包括了std与no_std之间的区别。</p>
<p>首先是，std crate 是Rust 的标准库。它包含的功能假定程序将在操作系统上运行，而不是直接在裸系统上运行。std还假定操作系统是一个通用的操作系统，就像人们在服务器和台式机上看到的那样。出于这个原因，std为通常在这类操作系统中发现的功能提供了一个标准的API: 线程、文件、套接字、文件系统、进程等等。</p>
<p>然后是，core crate是std crate的一个子集，对程序运行的系统不做任何假设。因此它提供了基于语言的API，如浮点，字符串和切片，以及暴露处理器特性的API，如原子操作和SIMD指令。然而，它缺乏涉及堆内存分配和I/O的任何API。</p>
<p>对于一个应用程序来说，std所做的不仅仅是提供一种访问操作系统抽象的方式，std还负责涉及堆栈溢出保护，处理命令行参数，以及在程序的主函数被调用之前生成主线程。一个#![no_std]应用程序缺乏所有这些标准的运行时，所以它必须初始化自己的运行时，如果需要的话。</p>
<p>由于这些特性，#![no_std]应用程序可以是第一个或者唯一在系统上运行的代码。</p>
<h2><a class="header" href="#rust中no_std的一些使用方法" id="rust中no_std的一些使用方法">Rust中no_std的一些使用方法</a></h2>
<p>主要具体介绍第二种方式的使用no_std</p>
<p>具体如何使用，参见写一个no_std的库的第二种使用方式。</p>
<p>也可参考，实例:<a href="https://serde.rs/no-std.html">serde no-std的使用规范</a></p>
<h2><a class="header" href="#验证一个库是否支持no_std的验证方式" id="验证一个库是否支持no_std的验证方式">验证一个库是否支持no_std的验证方式</a></h2>
<p><code>cargo check --target wasm32-unknown-unknown</code></p>
<p>但是wasm环境不一定就是no_std，或者别的编译目标也可以，也就是裸露的编译目标环境不带有任何系统的环境。</p>
<p>参考文档: <a href="https://zhuanlan.zhihu.com/p/53064186">使用Rust编写操作系统（一）：独立式可执行程序</a></p>
<h2><a class="header" href="#具体的写一个no_std的库" id="具体的写一个no_std的库">具体的写一个no_std的库</a></h2>
<h3><a class="header" href="#创建一个no_std库的第一种方式使用no_std" id="创建一个no_std库的第一种方式使用no_std">创建一个no_std库的第一种方式（使用#![no_std])</a></h3>
<p>使用#![no_std]的话，默认的就是这个库是在no_std环境下的，然而又因为no_std下的库 一般来说都是核心库，而核心库又是标准库的子集，所以声明#![no_std]写出来的库，也可以在 std（标准库环境）下使用。</p>
<ol>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/cd90f28855cfe794c235976bb58c1c5ecb8c7fa9">创建一个仓库</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/d3c05920865a44ab7cbaf82a72f21c7b6b8beeb0">使用#![no_std]将这个仓库中的函数能支持在no_std和std下使用</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/8bcd0b909ee116d3dc9c6464c2548e1c008d672e">开始添加一个函数编译报错commit 1</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/ae94f9cf147b7ce37632cb4e9c36e20c5135b3ad">修复错误commit 2</a></li>
</ol>
<h3><a class="header" href="#创建no_std库的第二种方式使用cfg_attrnotfeatures--std-no_std-" id="创建no_std库的第二种方式使用cfg_attrnotfeatures--std-no_std-">创建no_std库的第二种方式（使用#![cfg_attr(not(features = &quot;std&quot;), no_std)] )</a></h3>
<ol>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/8cfd063be536028d9f8cfe1c7c04f16765825f8c">创建一个仓库</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/aa09b0d2e2807d788564aea5fa4fc8cbfc760043">使用#![cfg_attr(not(feature = &quot;std&quot;), no_std)]</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/aa09b0d2e2807d788564aea5fa4fc8cbfc760043">添加的一些函数和测试</a></li>
</ol>
<h2><a class="header" href="#使一些不能在no_std环境下运行的仓库也能在no_std下支持" id="使一些不能在no_std环境下运行的仓库也能在no_std下支持">使一些不能在no_std环境下运行的仓库也能在no_std下支持</a></h2>
<p>首先，要验证这个库能不能支持no_std的环境（见，验证一个库是否支持no_std的验证方式）。</p>
<p>找出这个库依赖的库支持no_std的方式，如果使用的是#![no_std] 那么这个库本身就是可以在std和no_std下同时的运行。</p>
<p>如果使用的是#![cfg_attr(not(features = &quot;std&quot;), no_std)],就需要打开default-features = false,进行配置。</p>
<p>最后可能需要做一些标准库的替换，使其能在no_std和std同时编译成功，一些可以使用的类型库有sp-std(这个库仅仅封装了一部分的类型，例如有些类型是没有的，string,File, IO)当然,IO,File，这些标准库在核心库当中是没有的。还有rust本身的alloc, core这些都是属于核心库的。也是在no_std环境下支持的。</p>
<p>具体的使用案例:</p>
<p><a href="https://github.com/confio/ics23/pull/41">相关的Pr,使ics23支持no_std</a></p>
<p><a href="https://github.com/confio/ics23/pull/41/commits/dac5c3d0fc368e0b92c4a4804b6787bd1c3fb168">有些代码也在no_std写测试很难。因为这里做了编译选择处理</a></p>
<h2><a class="header" href="#一些no_std和std可以使用的primitive-类型的仓库" id="一些no_std和std可以使用的primitive-类型的仓库">一些no_std和std可以使用的primitive 类型的仓库</a></h2>
<ul>
<li><a href="https://github.com/paritytech/substrate/tree/master/primitives/std">sp-std</a></li>
<li><a href="https://doc.rust-lang.org/alloc/index.html">rust Alloc crate</a></li>
<li><a href="https://doc.rust-lang.org/core/index.html">rust Core crate</a></li>
</ul>
<h2><a class="header" href="#引用及资源" id="引用及资源">引用及资源</a></h2>
<ul>
<li><a href="https://weread.qq.com/web/reader/0303203071848774030b9d6k9bf32f301f9bf31c7ff0a60">Rust 编程之道核心库和标准库的介绍</a></li>
<li><a href="https://docs.rust-embedded.org/book/intro/no-std.html">Rust embeded book</a></li>
<li><a href="https://users.rust-lang.org/t/best-practice-of-extending-a-no-std-crate/12281/5">扩展no_std crate 的最佳实践</a></li>
<li><a href="https://github.com/rust-lang/api-guidelines">Rust API guidelines</a></li>
<li><a href="https://rust-lang.github.io/api-guidelines/naming.html#c-feature">Rust API guidelines Nameing</a></li>
<li><a href="https://serde.rs/no-std.html">serde no_std的使用规范</a></li>
<li><a href="https://github.com/rust-embedded/awesome-embedded-rust#no-std-crates">awesome-embedded-rust#no-std-crates</a></li>
<li><a href="https://crates.io/categories/no-std">no standard library</a></li>
<li><a href="https://github.com/serde-rs/serde/blob/master/serde/src/lib.rs#L113-L193">serde使用的第二种方式</a> </li>
<li><a href="https://rust-lang.github.io/rfcs/1184-stabilize-no_std.html">Rust RFC Book no_std</a></li>
<li><a href="https://justjjy.com/Rust-no-std">Rust no_std DAQ</a></li>
<li><a href="https://blog.dbrgn.ch/2019/12/24/testing-for-no-std-compatibility/">testing-for-no-std-compatibility</a></li>
<li><a href="https://substrate.dev/docs/zh-CN/tutorials/add-a-pallet/import-a-pallet">substrate中关于cfg_attr的介绍</a></li>
</ul>
<h2><a class="header" href="#结论-12" id="结论-12">结论</a></h2>
<p>参照serder的使用以及一些论坛的讨论，推荐使用#![cfg_attr(not(feature = &quot;std&quot;), no_std ))]来同时支持std和no_std.</p>
<h1><a class="header" href="#rust-内存错误调试和动态分析工具分享" id="rust-内存错误调试和动态分析工具分享">Rust 内存错误调试和动态分析工具分享</a></h1>
<p>作者: 吴翱翔 / 后期编辑: 张汉东</p>
<blockquote>
<p>原文: <a href="https://pymongo.github.io/#/2021/07/debug_and_dynamic_analyzing_tools.md">gdb/lldb 调试 segfault</a></p>
</blockquote>
<p>相比静态分析工具例如 clippy/ra，动态分析工具则需要程序运行才能进行分析，例如官方的 bench, test</p>
<h2><a class="header" href="#为什么需要动态分析" id="为什么需要动态分析">为什么需要动态分析</a></h2>
<p><img src="chapter_7/./image/dynamic_analyzing_tools/flamegraph.png" alt="" /></p>
<p>以上是某个 Rust 程序<strong>动态分析</strong>生成的火焰图，通过火焰图可以很清晰的看到程序的性能瓶颈在频繁 alloc 分配内存</p>
<p>借助动态分析不仅能发现程序性能瓶颈，还能调试运行时的内存错误，也可以生成函数调用树让团队新成员能快速读懂项目代码</p>
<h2><a class="header" href="#目录---动态分析工具" id="目录---动态分析工具">目录 - 动态分析工具</a></h2>
<ol>
<li>常用调试工具和内存检测工具:
首先通过一个 segfault 案例，介绍常用调试工具如何检测该案例的内存错误:</li>
</ol>
<ul>
<li>coredumpctl</li>
<li>valgrind</li>
<li>gdb</li>
<li>lldb/vscode-lldb/Intellij-Rust</li>
</ul>
<ol start="2">
<li>火焰图/函数调用树等动态分析工具(profile)</li>
</ol>
<ul>
<li>dmesg</li>
<li>cargo-miri</li>
<li>pref</li>
<li>cargo-flamegraph</li>
<li>KCachegrind</li>
<li>gprof</li>
<li>uftrace</li>
<li>ebpf</li>
</ul>
<ol start="3">
<li>最后通过上述工具再分析几个内存错误案例:</li>
</ol>
<ul>
<li>SIGABRT/double-free</li>
<li>SIGABRT/free-dylib-mem</li>
</ul>
<h2><a class="header" href="#segfault-案例和常用调试工具" id="segfault-案例和常用调试工具">segfault 案例和常用调试工具</a></h2>
<p>以下是我重写 ls 命令的部分源码(以下简称<code>ls 应用</code>)，完整源码在<a href="https://github.com/pymongo/linux_commands_rewritten_in_rust/blob/main/examples/sigsegv_opendir_open_null.rs">这个代码仓库</a></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let dir = unsafe { libc::opendir(input_filename.as_ptr().cast()) };
    loop {
        let dir_entry = unsafe { libc::readdir(dir) };
        if dir_entry.is_null() {
            break;
        }
        // ...
    }
}
</code></pre></pre>
<p>跟原版 ls 命令一样，输入参数是一个文件夹时能列出文件夹内所有文件名</p>
<p>但当 ls 应用的参数不是文件夹时，就会 segfault 内存段错误:</p>
<pre><code>&gt; cargo r --bin ls -- Cargo.toml 
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/ls Cargo.toml`
Segmentation fault (core dumped)
</code></pre>
<h3><a class="header" href="#coredumpctl" id="coredumpctl">coredumpctl</a></h3>
<h4><a class="header" href="#systemd-coredump-配置" id="systemd-coredump-配置">systemd-coredump 配置</a></h4>
<p>首先查看系统配置文件 <code>/proc/config.gz</code> 看看是否已开启 coredump 记录功能</p>
<pre><code>&gt; zcat /proc/config.gz | grep CONFIG_COREDUMP
CONFIG_COREDUMP=y
</code></pre>
<p>由于 <code>/proc/config.gz</code> 是 <em>gzip</em> 二进制格式而非文本格式，所以要用 <code>zcat</code> 而非 <code>cat</code> 去打印</p>
<p>再看修改 coredumpctl 配置文件 <code>/etc/systemd/coredump.conf</code></p>
<p>把默认的 coredump 日志大小限制调到 20G 以上: <code>ExternalSizeMax=20G</code></p>
<p>然后重启: <code>sudo systemctl restart systemd-coredump</code></p>
<h4><a class="header" href="#查看最后一条-coredump-记录" id="查看最后一条-coredump-记录">查看最后一条 coredump 记录</a></h4>
<p>通过 <code>coredumpctl list</code> 找到最后一条 coredump 记录，也就是刚刚发生的 segfault 错误记录</p>
<blockquote>
<p>Tue 2021-07-06 11:20:43 CST 358976 1000 1001 SIGSEGV present  /home/w/repos/my_repos/linux_commands_rewritten_in_rust/target/debug/ls  30.6K</p>
</blockquote>
<p>注意用户 id 1000 前面的 358976 表示进程的 PID，用作 <code>coredumpctl info</code> 查询</p>
<blockquote>
<p>coredumpctl info 358976</p>
</blockquote>
<pre><code>           PID: 358976 (segfault_opendi)
// ...
  Command Line: ./target/debug/ls
// ...
       Storage: /var/lib/systemd/coredump/core.segfault_opendi.1000.d464328302f146f99ed984edc6503ca0.358976.1625541643000000.zst (present)
// ...
</code></pre>
<p>也可以选择用 gdb 解析 segfault 的 coredump 文件:</p>
<p><code>coredumpctl gdb 358976</code> 或者 <code>coredumpctl debug 358976</code></p>
<p>参考: <a href="https://wiki.archlinux.org/title/Core_dump">core dump - wiki</a></p>
<h3><a class="header" href="#valgrind-检查内存错误" id="valgrind-检查内存错误">valgrind 检查内存错误</a></h3>
<blockquote>
<p>valgrind --leak-check=full ./target/debug/ls</p>
</blockquote>
<pre><code>// ...
==356638== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==356638==  Access not within mapped region at address 0x4
==356638==    at 0x497D904: readdir (in /usr/lib/libc-2.33.so)
==356638==    by 0x11B64D: ls::main (ls.rs:15)
// ...
</code></pre>
<h3><a class="header" href="#gdb-调试分析错误原因" id="gdb-调试分析错误原因">gdb 调试分析错误原因</a></h3>
<p>§ gdb 打开 ls 应用的可执行文件:</p>
<blockquote>
<p>gdb ./target/debug/ls</p>
</blockquote>
<p>§ gdb 通过 <code>l</code> 或 <code>list</code> 命令打印可执行文件的代码:</p>
<blockquote>
<p>(gdb) l</p>
</blockquote>
<p>§ gdb运行 ls 应用且传入 <code>Cargo.toml</code> 文件名作为入参:</p>
<blockquote>
<p>(gdb) run Cargo.toml</p>
</blockquote>
<pre><code>Starting program: /home/w/repos/my_repos/linux_commands_rewritten_in_rust/target/debug/ls Cargo.toml
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.

Program received signal SIGSEGV, Segmentation fault.
0x00007ffff7e5a904 in readdir64 () from /usr/lib/libc.so.6
</code></pre>
<p>§ 查看 segfault 发生时的栈帧</p>
<blockquote>
<p>(gdb) backtrace</p>
</blockquote>
<pre><code>#0  0x00007ffff7e5a904 in readdir64 () from /usr/lib/libc.so.6
#1  0x0000555555568952 in ls::main () at src/bin/ls.rs:15
</code></pre>
<p>此时已经找到出问题的系统调用函数是 <code>readdir64</code>，上一个栈帧在 <code>ls.rs</code> 的 15 行</p>
<p>$ 查看问题代码的附近几行</p>
<blockquote>
<p>(gdb) list 15</p>
</blockquote>
<p>§ 查看问题栈帧的局部变量</p>
<ul>
<li><code>info variables</code> 能打印全局或 static 变量</li>
<li><code>info locals</code> 打印当前栈帧的局部变量</li>
<li><code>info args</code> 打印当前栈帧的入参</li>
</ul>
<blockquote>
<p>(gdb) frame 1 # select frame 1</p>
<p>(gdb) info locals</p>
</blockquote>
<pre><code>(gdb) frame 1
#1  0x0000555555569317 in ls::main () at src/bin/ls.rs:20
20              let dir_entry = unsafe { libc::readdir(dir) };
(gdb) info locals
dir = 0x0
// ...
</code></pre>
<p>此时发现 main 栈帧的 <code>dir = 0x0</code> 是空指针，导致 readdir 系统调用 segfault</p>
<h4><a class="header" href="#分析错误原因" id="分析错误原因">分析错误原因</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dir = unsafe { libc::opendir(input_filename.as_ptr().cast()) };
loop {
    let dir_entry = unsafe { libc::readdir(dir) };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>问题出在没有判断 <code>opendir</code> 系统调用是否成功，系统调用失败要么返回 NULL 要么返回 -1</p>
<p>如果 <code>opendir</code> 系统调用传入的文件类型不是 directory，就会调用失败</p>
<p>因此 Bug 解决方法是 <strong>检查上游的 opendir 创建的 dir 变量是否为 NULL</strong></p>
<h4><a class="header" href="#解决-segfault" id="解决-segfault">解决 segfault</a></h4>
<p>只需要在加上 dir 是否为 NULL 的代码，如果为 NULL 则打印系统调用的错误信息</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if dir.is_null() {
    unsafe { libc::perror(input_filename.as_ptr().cast()); }
    return;
}
<span class="boring">}
</span></code></pre></pre>
<p>再次测试 ls 应用读取非文件夹类型的文件</p>
<pre><code>&gt; cargo r --bin ls -- Cargo.toml 
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/ls Cargo.toml`
Cargo.toml: Not a directory
</code></pre>
<p>此时程序没有发生段错误，并且打印了错误信息 <code>Cargo.toml: Not a directory</code></p>
<p>关于修复 ls 应用 segfault 的代码改动<a href="https://github.com/pymongo/linux_commands_rewritten_in_rust/commit/b5f92f85ab1949e04ac713ad079d4359760e1cd1">在这个 commit</a></p>
<p>参考 gnu.org 的官方教程: <a href="https://www.gnu.org/software/gcc/bugs/segfault.html">https://www.gnu.org/software/gcc/bugs/segfault.html</a></p>
<h3><a class="header" href="#lldb-调试" id="lldb-调试">lldb 调试</a></h3>
<p>lldb 调试和 gdb 几乎一样，只是个别命令不同</p>
<blockquote>
<p>(lldb) thread backtrace # gdb is <code>backtrace</code></p>
</blockquote>
<pre><code>error: need to add support for DW_TAG_base_type '()' encoded with DW_ATE = 0x7, bit_size = 0
* thread #1, name = 'ls', stop reason = signal SIGSEGV: invalid address (fault address: 0x4)
  * frame #0: 0x00007ffff7e5a904 libc.so.6`readdir + 52
    frame #1: 0x0000555555568952 ls`ls::main::h5885f3e1b9feb06f at ls.rs:15:34
// ...
</code></pre>
<blockquote>
<p>(lldb) frame select 1 # gdb is <code>frame 1</code></p>
</blockquote>
<pre><code>frame #1: 0x0000555555569317 ls`ls::main::h5885f3e1b9feb06f at ls.rs:15:34
   12       
   13       let dir = unsafe { libc::opendir(input_filename.as_ptr().cast()) };
   14       loop {
-&gt; 15           let dir_entry = unsafe { libc::readdir(dir) };
   16           if dir_entry.is_null() {
   17               // directory_entries iterator end
   18               break;
</code></pre>
<p>§ lldb 变量打印上 <code>frame variable</code> 等于 gdb 的 <code>info args</code> 加上 <code>info locals</code></p>
<p><code>(gdb) info args</code> 等于 <code>(lldb) frame variable --no-args</code></p>
<p>除了 <strong>primitive types</strong>, lldb 还可以打印 String 类型变量的值，但是无法得知 <code>Vec&lt;String&gt;</code> 类型变量的值</p>
<h3><a class="header" href="#vscode-lldb-调试" id="vscode-lldb-调试">vscode-lldb 调试</a></h3>
<p>不打任何断点运行程序时，会指向以下代码</p>
<blockquote>
<p>7FFFF7E5A904: 0F B1 57 04                cmpxchgl %edx, 0x4(%rdi)</p>
</blockquote>
<p>此时应当关注 vscode 左侧 Debug 侧边栏的 <code>CALL STACK</code> 菜单 (也就 gdb backtrace)</p>
<p>call stack 菜单会告诉 readdir 当前汇编代码的上一帧(也就是 backtrace 第二个栈帧)是 main 函数的 15 行</p>
<p>点击 main 栈帧，相当于 <code>(gdb) frame 1</code>，就能跳转到出问题的源码所在行了</p>
<p>在 main 栈帧 下再通过 variable 菜单发现 readdir 传入的 dir 变量值为 NULL 导致段错误</p>
<h3><a class="header" href="#intellij-rust-调试" id="intellij-rust-调试">Intellij-Rust 调试</a></h3>
<p>Debug 运行直接能跳转到问题代码的所在行，并提示 <code>libc::readdir(dir)</code> 的 dir 变量的值为 NULL</p>
<hr />
<h2><a class="header" href="#动态分析工具" id="动态分析工具">动态分析工具</a></h2>
<h3><a class="header" href="#dmesg-查看-segfault-记录" id="dmesg-查看-segfault-记录">dmesg 查看 segfault 记录</a></h3>
<p><code>sudo dmesg</code> 能查看最近几十条内核消息，发生 segfault 后能看到这样的消息:</p>
<blockquote>
<p>[73815.701427] ls[165042]: segfault at 4 ip 00007fafe9bb5904 sp 00007ffd78ff8510 error 6 in libc-2.33.so[7fafe9b14000+14b000]</p>
</blockquote>
<h3><a class="header" href="#cargo-miri-检查-unsafe-代码" id="cargo-miri-检查-unsafe-代码">cargo-miri 检查 unsafe 代码</a></h3>
<p>可惜 miri 现在似乎还不支持 FFI 调用函数的检查</p>
<pre><code>[w@ww linux_commands_rewritten_in_rust]$ cargo miri run --example sigabrt_free_dylib_data
   Compiling linux_commands_rewritten_in_rust v0.1.0 (/home/w/repos/my_repos/linux_commands_rewritten_in_rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `/home/w/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri target/miri/x86_64-unknown-linux-gnu/debug/examples/sigabrt_free_dylib_data`
error: unsupported operation: can't call foreign function: sqlite3_libversion
 --&gt; examples/sigabrt_free_dylib_data.rs:5:19
  |
5 |         let ptr = sqlite3_libversion() as *mut i8;
  |                   ^^^^^^^^^^^^^^^^^^^^ can't call foreign function: sqlite3_libversion
</code></pre>
<h3><a class="header" href="#perf-函数调用树" id="perf-函数调用树">perf 函数调用树</a></h3>
<h4><a class="header" href="#检查-perf-配置" id="检查-perf-配置">检查 perf 配置</a></h4>
<p>首先通过 <code>perf record</code> 测试下 perf 的配置能否读取系统事件，如果返回 Error 则修改以下配置文件</p>
<blockquote>
<p>sudo vim /etc/sysctl.d/sysctl.conf</p>
</blockquote>
<p>在 sysctl.conf 配置文件下加上一行:</p>
<blockquote>
<p>kernel.perf_event_paranoid = -1</p>
</blockquote>
<p>然后重启 sysctl 进程重新加载配置:</p>
<blockquote>
<p>sudo systemctl restart systemd-sysctl.service</p>
</blockquote>
<h4><a class="header" href="#perf-call-graph" id="perf-call-graph">perf call-graph</a></h4>
<p>用 perf-record 记录 Rust 程序的调用信息:</p>
<blockquote>
<p>perf record -a --call-graph dwarf ./target/debug/tree</p>
</blockquote>
<p>Rust 程序运行结束后，会在当前目录生成 perf.data 数据文件</p>
<p>perf-report 会默认打开当前目录的 perf.data 文件，也可以通过 -i 参数制定数据文件</p>
<p>用 perf-report 解析 Rust 程序的函数调用树，会进入一个用 curses 写的类似 htop 的命令行 UI 界面:</p>
<blockquote>
<p>perf report --call-graph</p>
</blockquote>
<p><img src="chapter_7/./image/dynamic_analyzing_tools/perf.png" alt="" /></p>
<p>可以选中 tree::main 的函数符号按下回车，选择 <code>zoom into tree thread</code> 来展示 main 函数的子函数调用树</p>
<p>主要浏览方法是通过上下左右方向键移动光标，再通过**+**按键展开或折叠光标所在行的函数调用树</p>
<p>在作者的电脑上，Clion 默认的 profiler(性能探测器)就用的 perf</p>
<h3><a class="header" href="#cargo-flamegraph" id="cargo-flamegraph">cargo-flamegraph</a></h3>
<p>cargo-flamegraph 需要系统已装 perf ，能将 perf 数据渲染成火焰图</p>
<h3><a class="header" href="#kcachegrind" id="kcachegrind">KCachegrind</a></h3>
<blockquote>
<p>valgrind --tool=callgrind ./target/debug/tree</p>
</blockquote>
<p>通过 valgrind 生成 callgrind.out.887505 数据( 887505 是 PID )，再通过 KCachegrind 打开进行可视化</p>
<p><img src="chapter_7/./image/dynamic_analyzing_tools/3.png" alt="" /></p>
<p>参考: <a href="https://users.rust-lang.org/t/is-it-possible-to-print-the-callgraph-of-a-cargo-workspace/50369/6">https://users.rust-lang.org/t/is-it-possible-to-print-the-callgraph-of-a-cargo-workspace/50369/6</a></p>
<h3><a class="header" href="#gprof" id="gprof">gprof</a></h3>
<p>gcc/clang 加上 <code>-pg</code> 参数，会在运行程序结束后生成监控数据文件 <code>mon.out</code></p>
<p>然后 gprof 对 mon.out 文件进行分析，可惜 Rust 没有部分支持</p>
<h3><a class="header" href="#uftrace" id="uftrace">uftrace</a></h3>
<p>为了支持数据通过火焰图格式可视化，安装 utftrace 的同时也把火焰图装了:</p>
<blockquote>
<p>yay -S uftrace-git flamegraph-git</p>
</blockquote>
<p>跟 grpof/KCachegrind 类似，也是要收集数据，数据可视化分两步走</p>
<p>首先 Rust 编译程序时要加上类似 gcc 的 -pg 的参数:</p>
<blockquote>
<p>rustc -g -Z instrument-mcount main.rs</p>
</blockquote>
<p>或者用 gccrs 或 gcc 后端进行编译</p>
<blockquote>
<p>gccrs -g -pg main.rs</p>
</blockquote>
<p>然后 uftrace 开始记录数据:</p>
<p>uftrace record ./main</p>
<p>本文篇幅有限只介绍 uftrace 通过火焰图进行可视化的方式:</p>
<blockquote>
<p>uftrace dump --flame-graph | flamegraph &gt; ~/temp/uftrace_flamegraph.svg &amp;&amp; google-chrome-stable ~/temp/uftrace_flamegraph.svg</p>
</blockquote>
<p>uftrace 记录参数:</p>
<ul>
<li>--no-libcall: uftrace 可以加上 --no-libcall 参数不记录系统调用</li>
<li>--nest-libcall: 例如 new() 函数记录上内置的 malloc()</li>
<li>--kernel(need sudo): trace kernel function</li>
<li>--no-event: 不记录线程调度</li>
</ul>
<h3><a class="header" href="#ebpf" id="ebpf">ebpf</a></h3>
<p>ebpf 分析 Rust 程序应该是可行的，作者还没试过</p>
<hr />
<p>熟悉上述工具后，可以接下来看几个内存错误的案例</p>
<h2><a class="header" href="#sigabrtdouble-free-案例分享" id="sigabrtdouble-free-案例分享">SIGABRT/double-free 案例分享</a></h2>
<p>以下是 tree 命令深度优先搜索遍历文件夹的代码(省略部分无关代码，<a href="https://github.com/pymongo/linux_commands_rewritten_in_rust/blob/main/examples/sigabrt_closedir_wrong.rs">完整源码链接在这</a>)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn traverse_dir_dfs(dirp: *mut libc::DIR, indent: usize) {
    loop {
        let dir_entry = libc::readdir(dirp);
        if dir_entry.is_null() {
            let _sigabrt_line = std::env::current_dir().unwrap();
            return;
        }
        // ...
        if is_dir {
            let dirp_inner_dir = libc::opendir(filename_cstr);
            libc::chdir(filename_cstr);
            traverse_dir_dfs(dirp_inner_dir, indent + 4);
            libc::chdir(&quot;..\0&quot;.as_ptr().cast());
            libc::closedir(dirp);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这段代码运行时会报错:</p>
<pre><code>malloc(): unsorted double linked list corrupted

Process finished with exit code 134 (interrupted by signal 6: SIGABRT)
</code></pre>
<p>通过 gdb 调试能知道 <code>std::env::current_dir()</code> 调用报错了，但错误原因未知</p>
<h3><a class="header" href="#经验-sigabrt-可能原因" id="经验-sigabrt-可能原因">经验: SIGABRT 可能原因</a></h3>
<p>通过上述段错误的分析，我们知道 SIGSEGV 可能的原因是例如 <code>readdir(NULL)</code> 解引用空指针</p>
<p>根据作者开发经验，SIGABRT 的可能原因是 <strong>double free</strong></p>
<h3><a class="header" href="#valgrind-检查-double-free" id="valgrind-检查-double-free">valgrind 检查 double free</a></h3>
<p>顺着 double-free 的思路，通过 valgrind 内存检查发现，<code>libc::closedir(dirp)</code> 出现 InvalidFree/DoubleFree 的内存问题</p>
<h3><a class="header" href="#分析-double-free-原因" id="分析-double-free-原因">分析 double free 原因</a></h3>
<p>再细看源码，递归调用前创建的是子文件夹的指针，递归回溯时却把当前文件夹指针给 close 掉了</p>
<p>这就意味着，一旦某个目录有 2 个以上的子文件夹，那么当前的文件夹指针可能会被 free 两次</p>
<p>进而将问题的规模简化成成以下三行代码:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dirp = libc::opendir(&quot;/home\0&quot;.as_ptr().cast());
libc::closedir(dirp);
libc::closedir(dirp);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#double-free-的通用解决方法" id="double-free-的通用解决方法">double free 的通用解决方法</a></h3>
<p>C 语言编程习惯: free 某个指针后必须把指针设为 NULL</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut dirp = libc::opendir(&quot;/home\0&quot;.as_ptr().cast());
libc::closedir(dirp);
dirp = std::ptr::null_mut();
libc::closedir(dirp);
dirp = std::ptr::null_mut();
<span class="boring">}
</span></code></pre></pre>
<p>在「单线程应用」中，这种解决方法是可行的，</p>
<p>第一次 free 后 dirp 指针被成 NULL，第二次 free 时传入 dirp 则什么事都不会发生</p>
<p>因为大部分的 C/Java 函数第一行都会判断输入是否空指针 <code>if (ptr == null) return</code></p>
<h3><a class="header" href="#为什么有时-double-free-没报错" id="为什么有时-double-free-没报错">为什么有时 double free 没报错</a></h3>
<p>有个问题困惑了我: </p>
<ul>
<li>为什么连续写几行 closedir 进程会提前 SIGABRT?</li>
<li>为什么循环中多次 closedir 进程还能正常退出?</li>
<li>为什么循环中多次 closedir 调用 <code>std::env::current_dir()</code> 时就 SIGABRT?</li>
</ul>
<p>原因是 double free 不一定能及时被发现，可能立即让进程异常中止，也可能要等下次 malloc 时才会报错</p>
<p>正因为 <code>current_dir()</code> 用了 Vec 申请堆内存，内存分配器发现进程内存已经 corrupted 掉了所以中止进程</p>
<p>我摘抄了一些系统编程书籍对这一现象的解释:</p>
<blockquote>
<p>one reason malloc failed is the memory structures have been corrupted, When this happens, the program may not terminate immediately</p>
</blockquote>
<p>感兴趣的读者可以看这本书: <em>Beginning Linux Programming 4th edition</em> 的 260 页</p>
<h2><a class="header" href="#sigabrtfree-dylib-mem-案例分享" id="sigabrtfree-dylib-mem-案例分享">SIGABRT/free-dylib-mem 案例分享</a></h2>
<p>假设我想打印 sqlite 的版本，sqlite 版本信息以静态字符串的形式存储在 <code>/usr/lib/libsqlite3.so</code></p>
<pre><pre class="playground"><code class="language-rust">#[link(name = &quot;sqlite3&quot;)]
extern &quot;C&quot; {
    pub fn sqlite3_libversion() -&gt; *const libc::c_char;
}

fn main() {
    unsafe {
        let ptr = sqlite3_libversion() as *mut i8;
        let version = String::from_raw_parts(ptr.cast(), &quot;3.23.0\0&quot;.len(), &quot;3.23.0\0&quot;.len());
        println!(&quot;found sqlite3 version={}&quot;, version);
    }
}
</code></pre></pre>
<p>结果上述代码一运行就发生内存错误 SIGABRT 异常中止，通过 gdb 调试发现报错前一个栈帧在 unsafe 代码块的析构流程内</p>
<p>由于代码中只有 version 是 String 类型需要调用 drop 自动析构，所以就把问题锁定在 String 的析构错误上</p>
<p>根据操作系统进程内存管理相关知识，当 Rust 的进程想要释放不属于 Rust 进程而是属于 libsqlite3.so 动态链接库的内存时就会 SIGABRT</p>
<p>解决方法是通过 std::mem::forget 阻止 String 的析构函数调用，这也是 mem::forget API 最常用的应用场景</p>
<h2><a class="header" href="#更多的内存错误调试案例" id="更多的内存错误调试案例">更多的内存错误调试案例</a></h2>
<p>可以关注作者的 linux_commands_rewritten_in_rust 项目的 src/examples 文件夹</p>
<p>examples 目录下几乎都是各种内存错误的常见例子，也是作者踩过坑的各种内存 Bug</p>
<p>项目链接: &lt;<a href="https://github.com/pymongo/linux_commands_rewritten_in_rust/">https://github.com/pymongo/linux_commands_rewritten_in_rust/</a>&gt;</p>
<h1><a class="header" href="#使用macroquad在android设备上发布游戏" id="使用macroquad在android设备上发布游戏">使用Macroquad在Android设备上发布游戏</a></h1>
<img src="chapter_7/../image/Macroquad_game_1.png" width = "550" alt="Macroquad_game_1" align=center />
<p><strong>译者注：</strong> macroquad是一个简单易用的Rust游戏库。macroquad尝试避免任何Rust特定概念比如生命周期/借用，这使得它对初学者非常友好。</p>
<p>详见https://docs.rs/macroquad/0.3.7/macroquad/index.html</p>
<h1><a class="header" href="#1-简介" id="1-简介">1. 简介</a></h1>
<p>这篇教程基于在Google Play商店发布的 <a href="https://github.com/ozkriff/zemeroth">Zemeroth</a>游戏开发发布过程。目前这款游戏已经公开测试，点击<a href="https://play.google.com/store/apps/details?id=rust.zemeroth">这里</a>可以试玩！</p>
<p>本篇主题包括：</p>
<ul>
<li>构建一个适用于android设备的macroquad游戏</li>
<li>常见问题和调试技巧</li>
<li>构建并上传APK包到Google Play商店</li>
</ul>
<h1><a class="header" href="#2搭建开发环境" id="2搭建开发环境">2.搭建开发环境</a></h1>
<h2><a class="header" href="#使用docker配置环境并构建apk包" id="使用docker配置环境并构建apk包">使用docker配置环境并构建APK包</a></h2>
<p>在已经拉取所有NDK（Native Development Kit原生开发工具包）依赖的docker宿主机上构建开发环境非常简单，</p>
<pre><code class="language-shell">docker pull not-fl3/cargo-apk
</code></pre>
<p>推荐大家使用docker来构建适用于android设备的macroquad游戏。</p>
<h3><a class="header" href="#基于docker构建apk包" id="基于docker构建apk包">基于docker构建APK包</a></h3>
<p>只需一条命令即可完成构建APK包</p>
<pre><code class="language-shell">docker run 
  --rm 
  -v $(pwd):/root/src 
  -w /root/src 
  notfl3/cargo-apk cargo quad-apk build --release
</code></pre>
<p>上面的命令会生成APK包到 <code>target/android-artifacts/release/apk</code>。</p>
<p>这一步骤可能会耗费较长时间，因为每次docker调用都会完整构建三个android目标文件。</p>
<p>docker命令中加入<code>-v /tmp/registry\&quot;:/usr/local/cargo/registry\&quot;</code>会使得构建过程稍微快一些。这样做会使docker将宿主机的 <code>/tmp/registry</code>目录作为缓存目录注册到cargo，然后docker就无需在每次构建时都重新下载依赖。</p>
<p>另一种方法：运行docker交互模式，在同一个容器中完成多次构建。</p>
<pre><code>docker run 
  --rm 
  -v $(pwd):/root/src 
  -w /root/src 
  -it notfl3/cargo-apk /bin/bash
</code></pre>
<p>最后，在docker的shell中运行<code>cargo quad-apk build --release</code>。</p>
<h2><a class="header" href="#手工配置环境并构建apk包" id="手工配置环境并构建apk包">手工配置环境并构建APK包</a></h2>
<p>docker简化了安装android-sdk和android-ndk的过程。不过，有些时候使用原生构建流程可能会更方便。这里我们不太不推荐这样的构建方式，不过我们可以通过这个构建流程来阐述容器中是如何完成这个过程的。</p>
<h3><a class="header" href="#环境配置" id="环境配置">环境配置</a></h3>
<p>命令及路径写法取决于宿主机操作系统，我们这里使用的linux，其他操作系统下也是相同思路。</p>
<ul>
<li>
<p>安装JRE或者JDK</p>
<p>这一步骤不同的操作系统差别会很大，这里以ubuntu为例：</p>
<pre><code>sudo apt-get install openjdk-8-jdk
</code></pre>
</li>
<li>
<p>安装Rust android</p>
<p>利用rustup安装android相关库：</p>
<pre><code>rustup target add armv7-linux-androideabi
rustup target add aarch64-linux-android
rustup target add i686-linux-android
rustup target add x86_64-linux-android
</code></pre>
</li>
<li>
<p>安装Android SDK</p>
<pre><code># 创建目录存放所有前置安装内容
mkdir /this/may/be/any/path/android

cd android
wget -q https://dl.google.com/android/repository/sdk-tools-linux-4333796.zip
unzip -q sdk-tools-linux-4333796.zip
rm sdk-tools-linux-4333796.zip
tools/bind/sdkmanager &quot;platform-tools&quot;
tools/bin/sdkmanager &quot;platforms;android-29&quot;
tools/bin/sdkmanager &quot;build-tools;29.0.0&quot;
tools/bin/sdkmanager --update
</code></pre>
</li>
<li>
<p>安装Android NDK</p>
<pre><code># 到前一步android-sdk的目录
cd /path/from/previous/step/android

wget -q http://dl.google.com/android/repository/android-ndk-r20-linux-x86_64.zip
unzip -q android-ndk-r20-linux-x86_64.zip
rm android-ndk-r20-linux-x86_64.zip
</code></pre>
</li>
<li>
<p>安装Cargo APK</p>
<p>安装<code>cargo-quad-apk</code>cargo扩展。</p>
<pre><code>cargo install cargo-quad-apk
</code></pre>
</li>
</ul>
<h3><a class="header" href="#手工构建apk包" id="手工构建apk包">手工构建APK包</a></h3>
<pre><code>export ANDROID_HOME=/path/from/previous/step/android
export NDK_HOME=/path/from/previous/step/android/android-ndk-r20

# 构建debug版本
cargo quad-apk build
# 构建release版本
cargo quad-apk build --release
</code></pre>
<p>构建完成的apk文件在 <code>target/android-artifacts/debug/apk</code> 或 <code>target/android-artifacts/release/apk</code>下。</p>
<h1><a class="header" href="#3-调试android游戏" id="3-调试android游戏">3. 调试android游戏</a></h1>
<h2><a class="header" href="#资源目录" id="资源目录">资源目录</a></h2>
<p>假设目录结构如下：</p>
<pre><code>.
├── assets
├── └── nice_texture.png
├── src
├── └── main.rs
└── Cargo.toml
</code></pre>
<p>加入如下内容到你的Cargo.toml以引入资源目录到APK：</p>
<pre><code class="language-ini">[package.metadata.android]
assets = &quot;assets/&quot;
</code></pre>
<p>之后通过<code>load_texture(&quot;nice_texture.png&quot;)</code>来加载纹理贴图。</p>
<p>不过，在PC中通常使用<code>load_texture(&quot;assets/nice_texture.png&quot;)</code>，需包含assets到路径中。</p>
<p>为修复这个问题使得android和PC中使用的路径统一，我们需要借助 <a href="https://docs.rs/macroquad/0.3.6/macroquad/file/fn.set_pc_assets_folder.html">set_pc_assets_folder</a>来解决。</p>
<pre><code>macroquad::file::set_pc_assets_folder(&quot;assets&quot;);
</code></pre>
<p>这样我们就可以在不同的平台使用统一的<code>load_texture(&quot;nice_texture.png&quot;)</code>来加载纹理贴图了。</p>
<h2><a class="header" href="#高dpi适配" id="高dpi适配">高DPI适配</a></h2>
<img src="chapter_7/../image/Macroquad_game_2.png" width = "340" alt="Macroquad_game_2" align=center />
<p><em><a href="https://developer.android.com/training/multiscreen/screendensities">图片来源</a></em></p>
<p>不同android设备具有明显的像素密度差异。默认情况下，android操作系统会尝试用高像素密度来模拟低像素密度显示效果。</p>
<p>这意味着<code>screen_width()/screen_height()</code>得到的值低于实际的屏幕像素分辨率，不过之后android操作系统会自动缩放viewport来适配设备屏幕。</p>
<p>这样也许没问题，因为更小的viewport能够获得更高的FPS，如果我们不想让android操作系统自动缩放的话，我们需要告知android操作系统以支持高DPI屏幕。</p>
<pre><pre class="playground"><code class="language-rust">fn window_conf() -&gt; window::Conf {
    window::Conf {
        window_title: &quot;Zemeroth&quot;.to_owned(),
        high_dpi: true,
        ..Default::default()
    }
}

#[macroquad::main(window_conf)]
async fn main() {
}
</code></pre></pre>
<h2><a class="header" href="#屏幕方向" id="屏幕方向">屏幕方向</a></h2>
<p>默认情况下，Macroquad游戏是全屏幕的并且允许任何屏幕方向，我们可以在Cargo.toml文件中加入以下内容来限制支持的屏幕方向：</p>
<pre><code class="language-ini">[package.metadata.android.activity_attributes]
&quot;android:screenOrientation&quot; = &quot;userLandscape&quot;
</code></pre>
<h2><a class="header" href="#图标" id="图标">图标</a></h2>
<p><img src="chapter_7/../image/Macroquad_game_3.jpg" alt="icon" /></p>
<p>应用图标在APK内被视为一种特殊资源，我们将res目录加入APK：</p>
<pre><code class="language-ini">[package.metadata.android]
res = &quot;android_res&quot;
icon = &quot;@mipmap/ic_launcher&quot;
</code></pre>
<p>不同DPI的图标目录类似下面这样：</p>
<pre><code>android_res/
├── mipmap-hdpi
│   └── ic_launcher.png
├── mipmap-mdpi
│   └── ic_launcher.png
├── mipmap-xhdpi
│   └── ic_launcher.png
├── mipmap-xxhdpi
│   └── ic_launcher.png
└── mipmap-xxxhdpi
    └── ic_launcher.png
</code></pre>
<p>不同尺寸的图标需要手工生成。<a href="http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html">这里</a>提供了一种较为好用的方法。</p>
<h2><a class="header" href="#日志调试" id="日志调试">日志调试</a></h2>
<p>macroquad的所有<code>warn!</code>/<code>info!</code>/<code>debug!</code> 消息都会合并到android系统消息。我们可以通过 <code>adb logcat</code> 命令来访问，下面是几种过滤 <code>adb logcat</code> 的方法。</p>
<h3><a class="header" href="#通过tag来过滤-adb-logcat" id="通过tag来过滤-adb-logcat">通过tag来过滤 <code>adb logcat</code></a></h3>
<p>tag过滤针对的是macroquad产生的 <code>warn!</code>/<code>info!</code>/<code>debug!</code>消息。</p>
<pre><code>adb logcat -v brief SAPP:V &quot;*:S&quot;
</code></pre>
<p><code>-v brief</code> 会通过隐藏一些log元数据来优化显示结果；</p>
<p>之后的参数是过滤器参数；</p>
<p>SAPP:V - V(verbose)过滤器会应用到tag为SAPP的消息，这些消息都将被输出。*:S - S(silent)过滤器会应用到所有其他tag，这些消息都将被过滤掉。</p>
<h3><a class="header" href="#通过pid过滤" id="通过pid过滤">通过PID过滤</a></h3>
<p>一些应用在运行时会产生额外的系统消息，可能是系统警告或者未处理的原生库异常。但是这些消息在应用tag过滤时都将被过滤掉。</p>
<p>PID是进程ID，使用PID过滤可以获得包括任何tag在内的所有应用输出消息。</p>
<pre><code># Find out PID
&gt; adb shell pidof -s rust.CRATENAME
30243
# Get all the messages from a given PID
&gt;adb shell pidof -s 30243
</code></pre>
<p>以上的命令可以通过命令参数的形式简写如下：</p>
<pre><code>adb logcat --pid=$(adb shell pidof -s rust.CRATENAME)
</code></pre>
<h1><a class="header" href="#4-apk签名" id="4-apk签名">4. APK签名</a></h1>
<p>默认情况下，<code>cargo quad-apk</code>生成调试kestore文件并使用调试key来签名APK。这样的APK包可以在本地安装测试，但是不能上传至Google Play应用商店。</p>
<p>Google Play应用商店要求非调试kestore文件，这个文件将被上传到Play Console来验证开发者身份。</p>
<p>我们需要用<code>keytool</code> 来生成key，<code>keytool</code> 包含在<code>openjdk</code>中。然后使用 <code>apksigner</code>给APK签名， <code>apksigner</code>内置在Android SDK中。</p>
<pre><code>keytool -v -genkey -keystore mygame.keystore -alias mygame -keyalg RSA -validity 10000
</code></pre>
<p>现在所有的前置环节都已完成，这一步生成的key可以用于构建release包。</p>
<p>首先，我们使用参数通知<code>cargo-apk</code>停止使用调试keystore文件来签名APK，</p>
<p><code>cargo quad-apk build --release --nosign</code></p>
<p>然后再使用非调试keystore文件来签名APK。</p>
<pre><code>apksigner sign --ks mygame.keystore my-app.apk --ks-key-alias alias_name
</code></pre>
<p>最后使用下面的命令进行验证：</p>
<pre><code>apksigner verify my-app.apk
</code></pre>
<p><a href="https://developer.android.com/studio/publish/app-signing.html#signing-manually">点此查看APK签名官方文档</a></p>
<h2><a class="header" href="#提示如何在docker中获取keytoolapksigner" id="提示如何在docker中获取keytoolapksigner">提示：如何在docker中获取<code>keytool</code>/<code>apksigner</code></a></h2>
<p>假设android keystore文件在~/.android目录，并且待签名的.apk文件在当前工作目录：</p>
<pre><code>docker run --rm 
    -v (pwd):/root/src  
    -v(/home/USER/.android):/root/.android_secrets 
    -w /root/src -it notfl3/cargo-apk /bin/bash
</code></pre>
<p>这条命令会启动docker容器，并挂载当前工作目录到容器中<code>/root/src</code> ，挂载.android到容器中<code>/root/.android_secrets</code> ，然后在容器中使用下面的命令来签名APK：</p>
<pre><code>apksigner sign --ks my.keystore my-app.apk --ks-key-alias alias_name
</code></pre>
<h2><a class="header" href="#android目标设备" id="android目标设备">Android目标设备</a></h2>
<p>默认情况下，<code>cargo quad-apk</code> 会构建适用于三个不同平台的APK包。为满足Google Play应用商店要求，我们需要添加所有平台如下：</p>
<pre><code class="language-ini">[package.metadata.android]
..
build_targets = [ &quot;armv7-linux-androideabi&quot;, &quot;aarch64-linux-android&quot;, &quot;i686-linux-android&quot;, &quot;x86_64-linux-android&quot; ]
</code></pre>
<p>在调试期间为加快构建过程我们可以选择我们的测试设备在用的其中任一个平台。</p>
<pre><code class="language-ini">[package.metadata.android]
..
build_targets = [ &quot;armv7-linux-androideabi&quot; ]
</code></pre>
<h2><a class="header" href="#google-play版本管理" id="google-play版本管理">Google Play版本管理</a></h2>
<p>Google Play应用商店对上传的APK包有它自己的版本管理机制，每个APK都必须有独一无二的<code>version_code</code>。否则google开发者控制台会报错：<code>Version code 1 has already been used. Try another version code.</code></p>
<p>在Cargo.toml中设置app版本号<code>version_code</code>：</p>
<pre><code class="language-ini">[package.metadata.android]
..
version_code = 2
version_name = &quot;Version Name&quot;
</code></pre>
<p><a href="https://developer.android.com/studio/publish/versioning">点此查看APK版本管理官方文档</a></p>
<h2><a class="header" href="#商店app预览页面" id="商店app预览页面">商店APP预览页面</a></h2>
<p>为了提交游戏到Google Play应用商店用于审核及开放测试、正式发布，我们需要上传用于APP展示页面的游戏截图、描述信息等内容。APP上传过程中很多数据都被标记为必填（*），这里我们至少需要上传下面几种游戏图像：</p>
<ul>
<li>512x512 图标</li>
<li>1024x500 banner图</li>
<li>两个16:9截图</li>
</ul>
<p><a href="https://developer.android.com/studio/publish/versioning">关于预览页面的其他信息</a></p>
<h2><a class="header" href="#内部测试开放测试和正式发布" id="内部测试开放测试和正式发布">内部测试、开放测试和正式发布</a></h2>
<p><strong>内部测试、封闭测试和开放测试区别是什么？你可以在发布正式产品之前发布各种测试版本用于测试验证。</strong></p>
<p>**内部测试：**创建内部测试版本以快速分发至最多100测试用户，进行早期质量保证测试。</p>
<p>不需要搭建商店页面也不需要应用审核。用于帮助开发者确保签名过程有效、应用成功上传至商店。也允许通过邮件方式添加测试用户。</p>
<p>**封闭测试：**分发预发布版本至更大范围的测试用户用于收集更多反馈意见。</p>
<p>接近于开放测试，但是要求添加测试用户邮箱。</p>
<p>**开放测试：**创建开放测试版本可以将你的APP展示到Google Play应用商店进行大规模测试。这种情况下，任何人都可以加入你的测试并提交自己的反馈意见。</p>
<p>接近于正式发布状态，商店页面公开可用，测试用户无需其他额外步骤即可安装使用。</p>
<p><a href="https://support.google.com/googleplay/android-developer/answer/9845334?hl=en">关于测试发布流程的其他信息</a></p>
<h1><a class="header" href="#跨空间跳板内核" id="跨空间跳板内核">跨空间跳板内核</a></h1>
<p>作者：洛佳</p>
<hr />
<p>现代内核设计中，常运用地址空间来隔离内核与应用。在分页内存管理下这样的方法较为简便；但也有利用此类设计的安全漏洞出现。本文尝试将完整的地址空间交还给应用，空间中不再保留内核的部分，而由“跳板页”机制切换到内核，我们希望借此解决传统内核的一部分安全问题。</p>
<p>在前面的文章中，我们介绍了一种简单的生成器内核，它使用了较新的生成器语法，便于编写。现代的系统内核通常基于地址空间隔离不同的应用、应用与内核，本文中我们使用Rust语言编写内核，尝试将它的生成器语法与全隔离内核相结合，提出跨空间跳板内核的解决方案，以为完整的异步内核实现提供参考。</p>
<h2><a class="header" href="#1-全隔离内核" id="1-全隔离内核">1 全隔离内核</a></h2>
<p>传统内核的地址空间有时分为上下两部分：下部分由各个应用轮流占有，而上部分保留于内核使用。这种设计在运行用户程序时，限制用户访问上半部分内存，来避免内核数据本身受到破坏。这部分数据仍然保存在地址空间中，只是通过权限设置，让攻击者无法直接访问。</p>
<p>攻击者确实无法直接访问，于是侧信道攻击出现了。</p>
<p>访问这部分地址的数据，即使访问失败，它也被用于计算其它访问目标的地址，这个目标将进入处理核的高速缓存中。于是攻击者通过时间差，探测其它访问目标的访问时间，计算出最快的访问地址，从而倒推出禁止访问地址的数据值。这类攻击原理中最出名的是Meltdown攻击，它可以以数十千字节每秒的速度套出内核的机密信息。</p>
<p>我们可以采用一种比较新的地址空间设计，<a href="https://github.com/rcore-os/rCore-Tutorial-v3">rCore-Tutorial内核</a>就采用了类似的设计。在这种设计中，所有的地址全部交由应用使用，内核本身不保留地址。这种设计将无法访问的内核数据挡在地址空间切换之后，而不是留在高地址区域。因为它除了少量需的跳板页，完全不与内核本身共享内存空间，我们可以称之为“全隔离内核”。</p>
<p><img src="chapter_7/./image/trampoline-kernel/%E5%85%A8%E9%9A%94%E7%A6%BB%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%86%85%E6%A0%B8%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png" alt="全隔离和传统内核的地址空间布局" /></p>
<p>全隔离内核的用户空间中并非仍然存在不可访问的内核数据，而是完全挡在地址空间之外。除此之外，它为应用提供更多的地址位置，允许运行更大的应用程序，或加载更多的动态链接库，以便于提高用户程序设计的灵活性。</p>
<p>注意的是我们通过全隔离机制，可以减少通过其它通道获得内核数据的途径，并不能防止此类攻击命中用户程序的其它部分。针对此类攻击，重新设计处理核的电路仍然是最彻底的防御方法。</p>
<h2><a class="header" href="#2-跳板代码页和跳板数据页" id="2-跳板代码页和跳板数据页">2 跳板代码页和跳板数据页</a></h2>
<p>全隔离空间没有和内核本身交集的部分，会出现地址切换“尴尬的代码”问题。我们可以使用跳板页的思想来解决问题。</p>
<p>跳板页是内核和用户空间中保留的少量共享部分。在地址空间切换完成后，程序指针的值没有变化，在上一空间这个指针指着有效的代码，但下一个空间中，该地址就并非是有效的代码了。跳板页的思想是，在不同的地址空间中保留仅有地址相同的有效部分，它们能保证在切换完成后短暂的步骤内，处理核仍然能运行有效的代码。</p>
<p><img src="chapter_7/./image/trampoline-kernel/%E8%B7%B3%E6%9D%BF%E4%BB%A3%E7%A0%81%E9%A1%B5%E8%AE%BE%E8%AE%A1.png" alt="跳板代码页设计" /></p>
<p>这是跳板代码页的设计思路。切换完成后，应当有一部分的代码完成上下文的加载过程。上下文应该加载到哪儿呢？由于地址空间已经切换，全隔离内核中无法访问内核数据段的内容，因此我们专门设计“跳板数据页”，这是映射到用户空间的一个部分，用于保存当前用户的上下文。</p>
<p>进入用户态时，上下文在切换空间后恢复。为什么不能在之前恢复呢？是因为如果这样做，那么在系统调用、中断等情形需要陷入内核时，需要保存上下文，这些上下文包括内核的地址空间配置，此时就没有地方得知内核的地址空间如何设置了。所以上下文恢复应当在跳板页中用户空间执行的部分。因为每个用户程序需要一个上下文，因此每个处理核都应当有一个跳板数据页，而跳板代码页可以共享同一个。</p>
<p>我们注意到，地址空间切换完成后，特权级的切换并未立即完成。进入新的地址空间后，跳板页的剩余部分将完成特权级的切换流程。因此，跳板页在所有的地址空间下，无论是内核还是用户的空间，都应只有内核特权级可见。跳板代码页和跳板数据页都应当遵守这个规则。</p>
<h2><a class="header" href="#3-帧翻译算法" id="3-帧翻译算法">3 帧翻译算法</a></h2>
<p>我们的代码能够在程序间切换了。除了切换，它仍然需要使用操作系统的功能，需要提供部分数据给操作系统使用。在传统内核中，直接设置“以用户身份访问”位，即可直接通过当前地址空间访问用户。然而全隔离内核要求用户和系统的数据隔离，就需要额外的方法。</p>
<p>这里我们选择恢复到传统中模拟页表查询的流程。</p>
<p>不同于简单的页表查询，我们的代码将根据需要查询的缓冲区长度，增加虚拟页号的数值，访问多个页时，多次地查询页表。这样就能连续查询内核需要的所有用户数据了。</p>
<p>我们在分页空间的代码中加入下面的部分。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// impl&lt;M: PageMode, A: FrameAllocator + Clone&gt; PagedAddrSpace&lt;M, A&gt; 中的实现    
/// 根据虚拟页号查询物理页号，可能出错。
pub fn find_ppn(&amp;self, vpn: VirtPageNum) -&gt; Result&lt;(&amp;M::Entry, PageLevel), PageError&gt; {
    let mut ppn = self.root_frame.phys_page_num();
    for &amp;lvl in M::visit_levels_until(PageLevel::leaf_level()) {
        // 注意: 要求内核对页表空间有恒等映射，可以直接解释物理地址
        let page_table = unsafe { unref_ppn_mut::&lt;M&gt;(ppn) };
        let vidx = M::vpn_index(vpn, lvl);
        match M::slot_try_get_entry(&amp;mut page_table[vidx]) {
            Ok(entry) =&gt; if M::entry_is_leaf_page(entry) {
                return Ok((entry, lvl))
            } else {
                ppn = M::entry_get_ppn(entry)
            },
            Err(_slot) =&gt; return Err(PageError::InvalidEntry)
        }
    }
    Err(PageError::NotLeafInLowerestPage)
}
<span class="boring">}
</span></code></pre></pre>
<p>为了简化设计，我们假设内核具有恒等映射，可以直接通过虚拟地址访问物理地址。于是查找单个物理页号的过程完成了。</p>
<p>然后，我们可以编写完整的帧翻译流程。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 帧翻译：在空间1中访问空间2的帧。本次的实现要求空间1具有恒等映射特性
pub fn translate_frame_read&lt;/*M1, A1, */M2, A2, F&gt;(
    // as1: &amp;PagedAddrSpace&lt;M1, A1&gt;, 
    as2: &amp;PagedAddrSpace&lt;M2, A2&gt;, 
    vaddr2: VirtAddr, 
    len_bytes2: usize, 
    f: F
) -&gt; Result&lt;(), PageError&gt;
where 
    // M1: PageMode, 
    // A1: FrameAllocator + Clone,
    M2: PageMode, 
    A2: FrameAllocator + Clone,
    F: Fn(PhysPageNum, usize, usize) // 按顺序返回空间1中的帧
{
    let mut vpn2 = vaddr2.page_number::&lt;M2&gt;();
    let mut remaining_len = len_bytes2;
    let (mut entry, mut lvl) = as2.find_ppn(vpn2)?;
    let mut cur_offset = vaddr2.page_offset::&lt;M2&gt;(lvl);
    while remaining_len &gt; 0 {
        let ppn = M2::entry_get_ppn(entry);
        let cur_frame_layout = M2::get_layout_for_level(lvl);
        let cur_len = if remaining_len &lt;= cur_frame_layout.page_size::&lt;M2&gt;() {
            remaining_len
        } else {
            cur_frame_layout.page_size::&lt;M2&gt;()
        };
        f(ppn, cur_offset, cur_len);
        remaining_len -= cur_len;
        if remaining_len == 0 {
            return Ok(())
        }
        cur_offset = 0; // 下一个帧从头开始
        vpn2 = vpn2.next_page::&lt;M2&gt;(lvl);
        (entry, lvl) = as2.find_ppn(vpn2)?;
    }
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>如果内核不是通过恒等或线性映射布局的，可以维护一个反查询表，需要一个方法让内核直接访问物理空间。在物理空间大于虚拟空间时，这个做法还是有必要实现的。</p>
<p>帧翻译过程完成后，我们可以在空间1中访问空间2的帧了。我们来使用上刚写完的函数，来实现最简单的控制台输出系统调用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 核心部分代码。参数：let [fd, buf, len] = args;
let buf_vaddr = mm::VirtAddr(buf);
mm::translate_frame_read(user_as, buf_vaddr, len, |ppn, cur_offset, cur_len| {
    let buf_frame_kernel_vaddr = ppn.addr_begin::&lt;M&gt;().0 + cur_offset; // 只有恒等映射的内核有效
    let slice = unsafe { core::slice::from_raw_parts(buf_frame_kernel_vaddr as *const u8, cur_len) };
    for &amp;byte in slice {
        crate::sbi::console_putchar(byte as usize);
    }
}).expect(&quot;read user buffer&quot;);
SyscallOperation::Return(SyscallResult { code: 0, extra: len as usize })
<span class="boring">}
</span></code></pre></pre>
<p>用户使用系统调用时，提供了若干个变量。当用户传入缓冲区地址和它的长度，帧翻译函数将查询缓冲区占用的所有物理帧，然后内核访问物理帧，来获得它们的内容。内容按块读出，每块包括物理页号、页内的起始偏移地址和剩余长度。最终，本次系统调用将解释每一块内容，并打印到控制台中。</p>
<p>需要注意的是，本次的程序实现只能一块一块地读取数据。如果需要验证跨块的数据合法性，比如需要验证UTF-8字符串是否合法，要么使用方法映射到连续的虚拟地址上再运行，要么需要复制字符串后再运行，否则跨块的合法性验证将可能不正确。</p>
<p>测试程序，我们编写用户程序如下，直接编译，发现输出是对的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><img src="chapter_7/./image/trampoline-kernel/%E8%B7%A8%E7%A9%BA%E9%97%B4%E5%88%87%E6%8D%A2%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8.jpeg" alt="跨空间切换内核启动" /></p>
<p>事实上，如果将打印的字符串换为超过一帧的长度，也是可以成功打印的。有了跨地址空间访问内存的方法，其它的系统调用也可以开始实现了。</p>
<h2><a class="header" href="#4-跨空间生成执行器" id="4-跨空间生成执行器">4 跨空间生成执行器</a></h2>
<p>根据上文的分析，每次恢复到用户，先保存执行器上下文，然后切换空间，然后加载用户上下文。每次从用户陷入内核，执行相反的过程即可。</p>
<p>在RISC-V下，编写如下的汇编代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[naked]
#[link_section = &quot;.trampoline&quot;] 
unsafe extern &quot;C&quot; fn trampoline_resume(_ctx: *mut ResumeContext, _user_satp: usize) {
    asm!(
        // a0 = 生成器上下文, a1 = 用户的地址空间配置, sp = 内核栈
        &quot;addi   sp, sp, -15*8&quot;,
        &quot;sd     ra, 0*8(sp)
        sd      gp, 1*8(sp)
        ...... 依次保存tp, s10等寄存器 ......
        sd      s11, 14*8(sp)&quot;, // 保存子函数寄存器，到内核栈
        &quot;csrrw  a1, satp, a1&quot;, // 写用户的地址空间配置到satp，读内核的satp到a1
        &quot;sfence.vma&quot;, // 立即切换地址空间
        // a0 = 生成器上下文, a1 = 内核的地址空间配置, sp = 内核栈
        &quot;sd     sp, 33*8(a0)&quot;, // 保存内核栈位置
        &quot;mv     sp, a0&quot;, 
        // a1 = 内核的地址空间配置, sp = 生成器上下文
        &quot;sd     a1, 34*8(sp)&quot;, // 保存内核的地址空间配置
        &quot;ld     t0, 31*8(sp)
        ld      t1, 32*8(sp)
        csrw    sstatus, t0
        csrw    sepc, t1
        ld      ra, 0*8(sp)
        ld      gp, 2*8(sp)
        ...... 依次加载tp, t0等寄存器 ......
        ld      t5, 29*8(sp)
        ld      t6, 30*8(sp)&quot;, // 加载生成器上下文寄存器，除了a0
        // sp = 生成器上下文
        &quot;csrw   sscratch, sp&quot;,
        &quot;ld     sp, 1*8(sp)&quot;, // 加载用户栈
        // sp = 用户栈, sscratch = 生成器上下文
        &quot;sret&quot;, // set priv, j sepc
        options(noreturn)
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>它被链接到专门的跳板代码页中。为了避免和用户程序冲突，跳板代码页被放置在最高的位置上，比如<code>0xffffffffffff000</code>。根据跳板页的长度，我们可以计算它需要多少个页，然后在初始化代码中映射它们。</p>
<p>在后续的代码中，跳板代码页的权限被设置为仅可执行。跳板代码页应当只有内核特权层能访问，否则将可被需要拼接指令的攻击方法利用，或者产生一些逻辑错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_trampoline_text_paging_config&lt;M: mm::PageMode&gt;() -&gt; (mm::VirtPageNum, mm::PhysPageNum, usize) {
    let (trampoline_pa_start, trampoline_pa_end) = {
        extern &quot;C&quot; { fn strampoline(); fn etrampoline(); }
        (strampoline as usize, etrampoline as usize)
    };
    assert_ne!(trampoline_pa_start, trampoline_pa_end, &quot;trampoline code not declared&quot;);
    let trampoline_len = trampoline_pa_end - trampoline_pa_start;
    let trampoline_va_start = usize::MAX - trampoline_len + 1;
    let vpn = mm::VirtAddr(trampoline_va_start).page_number::&lt;M&gt;();
    let ppn = mm::PhysAddr(trampoline_pa_start).page_number::&lt;M&gt;();
    let n = trampoline_len &gt;&gt; M::FRAME_SIZE_BITS;
    (vpn, ppn, n)
}
<span class="boring">}
</span></code></pre></pre>
<p>为了跳转到跳板页，由于它在高地址上，我们提前得到函数地址保存，以便恢复函数找到跳板函数的位置。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在Runtime::new_user中得到跳板函数的位置
extern &quot;C&quot; { fn strampoline(); }
let trampoline_pa_start = strampoline as usize;
let resume_fn_pa = trampoline_resume as usize;
let resume_fn_va = resume_fn_pa - trampoline_pa_start + trampoline_va_start.0;
unsafe { core::mem::transmute(resume_fn_va) }
// 在初始化执行器函数中得到返回跳板的位置
pub fn init(trampoline_va_start: mm::VirtAddr) {
    extern &quot;C&quot; { fn strampoline(); }
    let trampoline_pa_start = strampoline as usize;
    let trap_entry_fn_pa = trampoline_trap_entry as usize;
    let trap_entry_fn_va = trap_entry_fn_pa - trampoline_pa_start + trampoline_va_start.0;
    let mut addr = trap_entry_fn_va;
    if addr &amp; 0x2 != 0 {
        addr += 0x2; // 必须对齐到4个字节
    }
    unsafe { stvec::write(addr, TrapMode::Direct) };
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，从用户层返回，我们使用相似的思路编写汇编代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[naked]
#[link_section = &quot;.trampoline&quot;]
unsafe extern &quot;C&quot; fn trampoline_trap_entry() {
    asm!(
        &quot;.p2align 2&quot;, // 对齐到4字节
        // sp = 用户栈, sscratch = 生成器上下文
        &quot;csrrw  sp, sscratch, sp&quot;, 
        // sp = 生成器上下文, sscratch = 用户栈
        &quot;sd     ra, 0*8(sp)
        sd      gp, 2*8(sp)
        ...... 保存tp到t5 ......
        sd      t6, 30*8(sp)&quot;,
        &quot;csrr   t0, sstatus
        sd      t0, 31*8(sp)&quot;,
        &quot;csrr   t1, sepc
        sd      t1, 32*8(sp)&quot;,
        // sp = 生成器上下文, sscratch = 用户栈
        &quot;csrrw  t2, sscratch, sp&quot;, 
        // sp = 生成器上下文, sscratch = 生成器上下文, t2 = 用户栈
        &quot;sd     t2, 1*8(sp)&quot;, // 保存用户栈
        &quot;ld     t3, 34*8(sp)&quot;, // t3 = 内核的地址空间配置
        &quot;csrw   satp, t3&quot;, // 写内核的地址空间配置；用户的地址空间配置将丢弃
        &quot;sfence.vma&quot;, // 立即切换地址空间
        &quot;ld     sp, 33*8(sp)&quot;, 
        // sp = 内核栈
        &quot;ld     ra, 0*8(sp)
        ld      gp, 1*8(sp)
        ...... 加载tp到s10 ......
        ld      s11, 14*8(sp)
        addi    sp, sp, 15*8&quot;, // sp = 内核栈
        &quot;jr     ra&quot;, // ret指令
        options(noreturn)
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>有了所有的代码之后，我们最终可以实现生成器语法实现的执行器运行时了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Generator for Runtime {
    type Yield = KernelTrap;
    type Return = ();
    fn resume(mut self: Pin&lt;&amp;mut Self&gt;, _arg: ()) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        (self.trampoline_resume)(
            unsafe { self.context_mut() } as *mut _,
            self.user_satp
        ); // 立即跳转到跳板页，来进入用户
        // 从用户返回
        let stval = stval::read();
        let trap = match scause::read().cause() {
            Trap::Exception(Exception::UserEnvCall) =&gt; KernelTrap::Syscall(),
            Trap::Exception(Exception::LoadFault) =&gt; KernelTrap::LoadAccessFault(stval),
            Trap::Exception(Exception::StoreFault) =&gt; KernelTrap::StoreAccessFault(stval),
            Trap::Exception(Exception::IllegalInstruction) =&gt; KernelTrap::IllegalInstruction(stval),
            // ..... 其它的异常和中断
            e =&gt; panic!(&quot;unhandled exception: ....&quot;)
        };
        GeneratorState::Yielded(trap)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>执行器语法降低了编写内核的思考量，开发者有更多的时间专注于异构计算外设的开发工作中。这种方法暂时相比原来的写法无性能提升，需要编译器技术更新后，对需要保存的执行器上下文有更精细的控制，就有性能提升了。</p>
<h2><a class="header" href="#5-一些思考" id="5-一些思考">5 一些思考</a></h2>
<p>我们用执行器语法编写了跨空间跳板内核，它采用了全隔离内核的思想，运用最新的执行器语义降低编程难度。在这之后，异步内核核心的共享内存概念得到了充分的设计经验考验。配合上共享调度器等等核心的概念，我们就可以更便捷、更高效地设计异步内核了。文件、网络等模块也可以更快地完成设计。</p>
<p>编写代码时，因为经常需要操作较高的虚拟地址，可能需要将减法放在运算的前面，或者使用取模回环运算，否则将可能出现运算溢出，干扰内核的正常运行。这种情况很容易在调试时找到。</p>
<p>使用文章的方法编写内核后，完整的地址空间就可以给用户使用了。用户可以把程序链接到<code>0x1000</code>等地址上，无需担心是否与内核冲突。用户的栈也是由内核分配的。</p>
<p>在编写这些代码时，无相之风团队的<a href="https://rvgj.qf.rs/">RISC-V二进制工具箱</a>给了我很大的帮助，让我能更快地完成页表调试过程。完整代码的地址保存在<a href="https://github.com/HUST-OS/luojia-os-labs-v2/">GitHub仓库</a>。</p>
<hr />
<p>作者简介：</p>
<p><strong>洛佳</strong></p>
<p>华中科技大学网络空间安全学院本科生，热爱操作系统、嵌入式开发。“无相之风”战队成员，飓风内核项目作者之一，3年Rust语言开发经验，社区活跃贡献者。目前致力于向科研、产业和教学界推广Rust语言。</p>
<h1><a class="header" href="#trait-upcasting-系列--part-i" id="trait-upcasting-系列--part-i">Trait Upcasting 系列 ｜ Part I</a></h1>
<p>作者： 张汉东 / 审校：crlf0710</p>
<hr />
<h2><a class="header" href="#引子-1" id="引子-1">引子</a></h2>
<p>记录 @crlf0710 的 Trait Upcasting系列 系列 PR 过程。因为后续我也参与其中一个 PR，所以先要理清楚 @crlf0710 的 PR 思路，以便后续我的参与。也借此机会分享出来，希望更多的人能参与到 Rust 语言贡献中。</p>
<p>PR 系列：</p>
<ol>
<li><a href="https://github.com/rust-lang/rust/pull/86291">Refactor vtable codegen #86291</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/86475">Change vtable memory representation to use tcx allocated allocations.#86475 </a></li>
<li><a href="https://github.com/rust-lang/rust/pull/86461">Refactor vtable format for upcoming trait_upcasting feature. #86461</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/86264">Trait upcasting (part1) #86264</a></li>
<li><a href="chapter_7/">Trait upcasting (part2) </a></li>
</ol>
<p>本文为 第一个 PR 的描述。</p>
<hr />
<h2><a class="header" href="#前情提要" id="前情提要">前情提要</a></h2>
<p>故事要从 <a href="https://github.com/rust-lang/rust/pull/60900">Trait upcasting #60900</a> 这个 PR 讲起 。</p>
<p>Trait upcasting ，是 trait 向上转型的意思。这个 PR 提出，当 <code>Foo: Bar</code> ，即 Foo trait 继承自 Bar trait 时，允许从 <code>dyn Foo</code>转到 <code>dyn Bar</code>。</p>
<p>目前 Rust 版本中，不支持此功能。因为目前trait 继承情况下， trait 对象的方法都是存储在同一个虚表中，无法区分哪个函数是属于哪个trait 对象。</p>
<p>社区内有一个通用的解决办法：</p>
<pre><pre class="playground"><code class="language-rust">trait Base {
    fn base(&amp;self) {
        println!(&quot;base...&quot;);
    }
}

trait AsBase {
    fn as_base(&amp;self) -&gt; &amp;dyn Base; //返回 Base trait对象
}

// blanket implementation
// 为所有实现 Base 的 T 来实现 AsBase
impl&lt;T: Base&gt; AsBase for T {
  	// 返回 Base trait对象
    fn as_base(&amp;self) -&gt; &amp;dyn Base {
        self
    }
}

trait Foo: AsBase {
    fn foo(&amp;self) {
        println!(&quot;foo..&quot;);
    }
}

#[derive(Debug)]
struct MyStruct;

impl Foo for MyStruct {}
impl Base for MyStruct {}

fn main() {
    let s = MyStruct;
    let foo: &amp;dyn Foo = &amp;s;
    foo.foo();
    let base: &amp;dyn Base = foo.as_base(); // 通过 as_base 来返回 Base trait对象达到 upcasting 的效果
    base.base();
}

</code></pre></pre>
<p>在 PR  #60900  中，作者给出了一些实现，但是因为太大了，需要对这份工作进行重构，然后这个 PR 就被关闭了。关于这个 PR 的相关讨论被记录于 <a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/object.20upcasting">rust-lang.zulipchat.</a></p>
<p>这份重构的工作，就由 <strong><a href="https://github.com/crlf0710">crlf0710</a></strong> 承接起来了，这就是这个系列 PR 的由来。相关提案：<a href="https://github.com/rust-lang/lang-team/issues/98">Trait Upcasting #98</a> ， 跟踪 issues :<a href="https://github.com/rust-lang/rust/issues/65991">Tracking issue for trait upcasting #65991 </a></p>
<h2><a class="header" href="#第一步工作-重构-vtable-代码生成" id="第一步工作-重构-vtable-代码生成">第一步工作： 重构 vtable 代码生成</a></h2>
<p>状态：这部分工作已经被合并。</p>
<p>相关PR: <a href="https://github.com/rust-lang/rust/pull/86291">Refactor vtable codegen #86291</a> 。</p>
<h3><a class="header" href="#修改文件概述" id="修改文件概述">修改文件概述</a></h3>
<p>本次修改涉及 十个文件。</p>
<ol>
<li><code>compiler/rustc_codegen_cranelift/src/vtable.rs </code></li>
<li><code>compiler/rustc_codegen_ssa/src/glue.rs</code></li>
<li><code>compiler/rustc_codegen_ssa/src/meth.rs </code></li>
<li><code>compiler/rustc_codegen_ssa/src/mir/block.rs</code></li>
<li><code>compiler/rustc_middle/src/query/mod.rs </code></li>
<li><code>compiler/rustc_middle/src/ty/mod.rs</code></li>
<li><code>compiler/rustc_mir/src/interpret/traits.rs </code></li>
<li><code>compiler/rustc_mir/src/monomorphize/collector.rs </code></li>
<li><code>compiler/rustc_trait_selection/src/traits/mod.rs </code></li>
<li><code>compiler/rustc_trait_selection/src/traits/select/confirmation.rs</code></li>
</ol>
<p>这十个文件涉及五个 crate：</p>
<ol>
<li><code>rustc_codegen_cranelift</code>，是 基于 cranelift 的编译器后端，专门用于 debug 模式。</li>
<li><code>rustc_codegen_ssa</code>，截至2021年1月，RustC_Codegen_SSA 为所有后端提供了一个抽象的接口，以允许其他Codegen后端（例如Cranelift）。</li>
<li><code>rustc_middle</code>，属于 rust 编译器的 main crate ，包含rustc“家族”中的其他crate使用的通用类型定义，包括 HIR/MIR/Types。</li>
<li><code>rustc_mir</code>，用于操作 MIR 的库。</li>
<li><code>rustc_trait_selection</code>，该库定义了 trait resolution 相关方法。详细内容：<a href="https://rustc-dev-guide.rust-lang.org/traits/resolution.html">Trait resolution (old-style)</a> 。</li>
</ol>
<h3><a class="header" href="#rustc_middle-库中的修改" id="rustc_middle-库中的修改">rustc_middle 库中的修改</a></h3>
<p>在 <code>compiler/rustc_middle/src/ty/mod.rs</code> 中新增了枚举类型：VtblEntry。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug, PartialEq, HashStable)]
pub enum VtblEntry&lt;'tcx&gt; {
    MetadataDropInPlace,
    MetadataSize,
    MetadataAlign,
    Vacant,
    Method(DefId, SubstsRef&lt;'tcx&gt;),
}

pub const COMMON_VTABLE_ENTRIES: &amp;[VtblEntry&lt;'_&gt;] =
    &amp;[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];

pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;
pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;
pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;
<span class="boring">}
</span></code></pre></pre>
<p>这是为了识别 vtable 中的不同 entry，这样才有可能识别 存储在vtable中的不同 trait 对象。</p>
<p>接下来，在 <code>compiler/rustc_middle/src/query/mod.rs </code> 中把  <code>query vtable_methods</code> 修改为 <code>query vtable_entries</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用的是一个宏
rustc_queries! {
   // ...
   query vtable_entries(key: ty::PolyTraitRef&lt;'tcx&gt;)
                        -&gt; &amp;'tcx [ty::VtblEntry&lt;'tcx&gt;] {
        desc { |tcx| &quot;finding all vtable entries for trait {}&quot;, tcx.def_path_str(key.def_id()) }
    }
  
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>在 rust_middle 中定义了 rustc 的 <a href="https://rustc-dev-guide.rust-lang.org/overview.html?highlight=query#queries">query 系统</a> 。Rust 使用查询系统，是为了支持增量编译。参考 <a href="https://rustcrustc.github.io/rustc-dev-guide-zh/overview.html#%E7%BC%96%E8%AF%91%E5%99%A8%E6%A6%82%E8%A7%88">编译器概览</a> 。</p>
<p>举个例子。假如有一条查询负责询问某个东西的类型， 而另一条查询负责询问某个函数的优化后的 MIR。这些查询可以相互调用并且由查询系统所跟踪。 查询的结果被缓存于硬盘上，这样我们就可以分辨相较于上次编译，哪些查询的结果改变了，并且仅重做这些查询。 这就是增量编译是如何工作的。</p>
<blockquote>
<p>类型上下文（TyCtxt），它是一个相当巨大的结构体， 是所有东西的中心。所有查询都被定义为在<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html"><code>TyCtxt</code></a>类型上 的方法，并且内存中的查询缓存也同样被存储在此。在代码中，通常会有一个名为<code>tcx</code>变量，它是 类型上下文上的一个句柄。有同样会见到名为<code>'tcx</code>的生命周期，这意味着有东西被和<code>TyCtxt</code>的 生命周期绑定在了一起（通常它会被存储或者被驻留化）。</p>
</blockquote>
<p><strong><a href="https://rustcrustc.github.io/rustc-dev-guide-zh/overview.html#tyty"><code>ty::Ty</code></a> 介绍</strong></p>
<p>类型在 Rust 中相当重要，并且形成了许多编译器分析的核心。用于表示类型（在用户程序中）的 主要类型（在编译器中）是 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>rustc_middle::ty::Ty</code></a>。它是如此的重要以至于我们为其 设置了一整章<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>ty::Ty</code></a>，但是对于现在而言，我们只想提到它存在并且是<code>rustc</code>用来表示类型的方法！</p>
<p>同样注意到<code>rustc_middle::ty</code>模块定义了我们之前提到的<code>TyCtxt</code>结构体。</p>
<h3><a class="header" href="#rustc_codegen_ssa-中的修改" id="rustc_codegen_ssa-中的修改">rustc_codegen_ssa 中的修改</a></h3>
<p>因为 rustc_codegen_ssa 是 后端 codegen 的接口，所以先看这里。</p>
<p>rustc_codegen_ssa 主要入口点： <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_crate.html"><code>rustc_codegen_ssa::base::codegen_crate</code></a></p>
<ul>
<li>它单态化并且产出 LLVM IR给一个代码生成单元。 它之后启动一个后台线程来运行一个之后必须被结合的LLVM。</li>
<li>单态化通过<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#method.monomorphize"><code>FunctionCx::monomorphize</code></a> 懒启动以及<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_instance.html"><code>rustc_codegen_ssa::base::codegen_instance</code></a></li>
</ul>
<p>在 rust_codgen_ssa 出现之前，生成代码都是由 rust_codgen_llvm 处理。</p>
<p>LLVM codegen的两个最重要的结构是<code>CodegenCx</code>和<code>Builder</code>。它们由多个生命期参数和Value的类型组成。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct CodegenCx&lt;'ll, 'tcx&gt; {
  /* ... */
}

struct Builder&lt;'a, 'll, 'tcx&gt; {
  cx: &amp;'a CodegenCx&lt;'ll, 'tcx&gt;,
  /* ... */
}
<span class="boring">}
</span></code></pre></pre>
<p><code>CodegenCx</code>是用来编译一个可以包含多个函数的 codegen-unit 的，而<code>Builder</code> 是为了编译一个基本块而创建的。<code>CodegenCx</code>和<code>Builder</code>将是实现所有定义后端接口的traits的结构。</p>
<p>这些 trait 被定义在<code>rustc_codegen_ssa/traits</code>文件夹中，所有与后端无关的代码都以它们为参数。</p>
<p>在  rustc_codegen_ssa 有个关键的 trait ：<code>BuilderMethods</code>，它表示后端实现的构建方法。那么实际上， rustc_codegen_cranelift 目前并没有依赖  rustc_codegen_ssa 的这个 BuilderMethods trait， 而 rustc_codegen_llvm 依赖了。看来目前 rustc_codegen_ssa 并未重构完成。</p>
<p>重构 vtable 的相关工作，主要涉及三个文件： </p>
<ol>
<li><code>rustc_codegen_ssa/src/meth.rs </code></li>
<li><code>rustc_codegen_ssa/src/glue.rs</code></li>
<li><code>rustc_codegen_ssa/src/mir/block.rs</code></li>
</ol>
<p><strong>在 <code>meth.rs</code> 中：</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_middle::ty::{self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES}; // 引入 rustc_middle 新加的枚举 VtblEntry 相关

impl&lt;'a, 'tcx&gt; VirtualIndex {
    pub fn from_index(index: usize) -&gt; Self {
        VirtualIndex(index as u64) // 修改虚表index ，之前是偏移 3 ，因为之前是没有 vtable Entry 的，所以 DESTRUCTOR（index 0）,SIZE（index 1）,ALIGN（index 2） 都展开放了，现在则不需要。
    }
  
    // ...
  
    // 修改
    pub fn get_vtable&lt;'tcx, Cx: CodegenMethods&lt;'tcx&gt;&gt;(
    cx: &amp;Cx,
    ty: Ty&lt;'tcx&gt;,
    trait_ref: Option&lt;ty::PolyExistentialTraitRef&lt;'tcx&gt;&gt;,
) -&gt; Cx::Value {
  			// ...
        // 新增
        // 当有  T: Trait 或 SubTrait: ParentTrait 这种形式出现时，就会有 trait_ref 
        // 所以，相当于是 如果是有 trait 继承的情况下，就利用 query vtable_entries 来查询该trait
        // 并返回 vtable_entries ，否则返回 COMMON_VTABLE_ENTRIES，代表是单一的trait 对象
  	    let vtable_entries = if let Some(trait_ref) = trait_ref {
            tcx.vtable_entries(trait_ref.with_self_ty(tcx, ty))
        } else {
            COMMON_VTABLE_ENTRIES
        };
  
  			let layout = cx.layout_of(ty); // 新增
    // /////////////////////////////////////////////////////////////////////////////////////////////
    // If you touch this code, be sure to also make the corresponding changes to
    // `get_vtable` in `rust_mir/interpret/traits.rs`.
      // /////////////////////////////////////////////////////////////////////////////////////////////
    // 新增
    // 迭代处理每个 vtable entry 的元信息：drop/大小/对齐/方法等
    let components: Vec&lt;_&gt; = vtable_entries
        .iter()
        .map(|entry| match entry {
            VtblEntry::MetadataDropInPlace =&gt; {
                cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty))
            }
            VtblEntry::MetadataSize =&gt; cx.const_usize(layout.size.bytes()),
            VtblEntry::MetadataAlign =&gt; cx.const_usize(layout.align.abi.bytes()),
            VtblEntry::Vacant =&gt; nullptr,
            VtblEntry::Method(def_id, substs) =&gt; cx.get_fn_addr(
                ty::Instance::resolve_for_vtable(
                    cx.tcx(),
                    ty::ParamEnv::reveal_all(),
                    *def_id,
                    substs,
                )
                .unwrap()
                .polymorphize(cx.tcx()),
            ),
        })
        .collect();
  
        // ...
  
     }
}
<span class="boring">}
</span></code></pre></pre>
<p>文档：<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_middle/ty/type.PolyExistentialTraitRef.html">rustc_middle::ty::PolyExistentialTraitRef</a> ，该类型表示 对一个已经擦除了 Self 的 trait 的存在性引用，所以使用 <code>with_self_ty</code> 来提供一个self占位。</p>
<p><strong>在 <code>src/glue.rs</code> 中：</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BuilderMethods 是通用后端接口，但目前只有llvm用这个
pub fn size_and_align_of_dst&lt;'a, 'tcx, Bx: BuilderMethods&lt;'a, 'tcx&gt;&gt;(
    bx: &amp;mut Bx,
    t: Ty&lt;'tcx&gt;,
    info: Option&lt;Bx::Value&gt;,
) -&gt; (Bx::Value, Bx::Value) {
  
 		// ...
  
  	match t.kind() {
        ty::Dynamic(..) =&gt; {
            // load size/align from vtable
            // 新增
            let vtable = info.unwrap();
            (
                meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_SIZE)
                    .get_usize(bx, vtable),
                meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_ALIGN)
                    .get_usize(bx, vtable),
            )
        }
    		// ...  
    }
  
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>问题： 既然目前 BuilderMethods 只有 llvm使用而 cranelift没有使用， 为什么 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_cranelift/src/unsize.rs#L131">rustc_codegen_cranelift/src/unsize.rs#L131</a> 中对应的 <code>size_and_align_of_dst</code> 函数不做对应修改？</p>
<p>答：因为 rustc_codegen_cranelift 中 vtable 要做相应修改，具体在后面描述。</p>
<p><code>src/glue.rs</code> 就是一个胶水模块，在生成底层指令的相关模块中，会调用该方法。</p>
<p><strong>在 <code>src/mir/block.rs</code> 中：</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TerminatorCodegenHelper&lt;'tcx&gt; {
    bb: mir::BasicBlock,
    terminator: &amp;'tcx mir::Terminator&lt;'tcx&gt;,
    funclet_bb: Option&lt;mir::BasicBlock&gt;,
}

impl&lt;'a, 'tcx&gt; TerminatorCodegenHelper&lt;'tcx&gt; {
    // ...
  
  	fn codegen_drop_terminator(
        &amp;mut self,
        helper: TerminatorCodegenHelper&lt;'tcx&gt;,
        mut bx: Bx,
        location: mir::Place&lt;'tcx&gt;,
        target: mir::BasicBlock,
        unwind: Option&lt;mir::BasicBlock&gt;,
    ) {
        // ...
         let (drop_fn, fn_abi) = match ty.kind() {
            // FIXME(eddyb) perhaps move some of this logic into
            // `Instance::resolve_drop_in_place`?
            ty::Dynamic(..) =&gt; {
                 // ...
                 // 新增
                 (
                   meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)
                        .get_fn(&amp;mut bx, vtable, &amp;fn_abi),
                    fn_abi,
                )
            }
            // ... 
          }
        // ...
    }
  
    // ...
  
}
<span class="boring">}
</span></code></pre></pre>
<p><code>src/mir/block.rs</code> 顾名思义，这个是和 MIR 生成 basicblock 有关。代码中，要生成 drop 相关的终止符，所以需要得到虚表中 <code>COMMON_VTABLE_ENTRIES_DROPINPLACE</code>相关 index信息。</p>
<h3><a class="header" href="#rustc_codegen_cranelift-库中的修改" id="rustc_codegen_cranelift-库中的修改">rustc_codegen_cranelift 库中的修改</a></h3>
<p>在 <code>compiler/rustc_codegen_cranelift/src/vtable.rs</code> 中，定义了一些自由函数，用于定义 trait 对象中 vtable相关。</p>
<p>因为在 rustc_codegen_ssa 做了一些相关修改，而目前 rustc_codegen_cranelift 并没有使用 rustc_codegen_ssa 的统一接口，所以需要修改 rustc_codegen_cranelift vtable相关代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use ty::VtblEntry; // 新增

pub(crate) fn drop_fn_of_obj(fx: &amp;mut FunctionCx&lt;'_, '_, '_&gt;, vtable: Value) -&gt; Value {
    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;
    fx.bcx.ins().load(
        pointer_ty(fx.tcx),
        vtable_memflags(),
        vtable,
        (ty::COMMON_VTABLE_ENTRIES_DROPINPLACE * usize_size) as i32, // 新增
    )
}

pub(crate) fn size_of_obj(fx: &amp;mut FunctionCx&lt;'_, '_, '_&gt;, vtable: Value) -&gt; Value {
    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;
    fx.bcx.ins().load(
        pointer_ty(fx.tcx),
        vtable_memflags(),
        vtable,
        (ty::COMMON_VTABLE_ENTRIES_SIZE * usize_size) as i32, // 新增
    )
}

pub(crate) fn min_align_of_obj(fx: &amp;mut FunctionCx&lt;'_, '_, '_&gt;, vtable: Value) -&gt; Value {
    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;
    fx.bcx.ins().load(
        pointer_ty(fx.tcx),
        vtable_memflags(),
        vtable,
        (ty::COMMON_VTABLE_ENTRIES_SIZE * usize_size) as i32, // 新增
    )
}

pub(crate) fn get_ptr_and_method_ref&lt;'tcx&gt;(
    fx: &amp;mut FunctionCx&lt;'_, '_, 'tcx&gt;,
    arg: CValue&lt;'tcx&gt;,
    idx: usize,
) -&gt; (Value, Value) {
    let (ptr, vtable) = if let Abi::ScalarPair(_, _) = arg.layout().abi {
        arg.load_scalar_pair(fx)
    } else {
        let (ptr, vtable) = arg.try_to_ptr().unwrap();
        (ptr.get_addr(fx), vtable.unwrap())
    };

    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();
    let func_ref = fx.bcx.ins().load(
        pointer_ty(fx.tcx),
        vtable_memflags(),
        vtable,
        (idx * usize_size as usize) as i32, // 修改，因为 idx 变了，之前是 idx+3
    );
    (ptr, func_ref)
}

fn build_vtable&lt;'tcx&gt;(
    fx: &amp;mut FunctionCx&lt;'_, '_, 'tcx&gt;,
    layout: TyAndLayout&lt;'tcx&gt;,
    trait_ref: Option&lt;ty::PolyExistentialTraitRef&lt;'tcx&gt;&gt;,
) -&gt; DataId {
    let tcx = fx.tcx;
    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;

    let drop_in_place_fn = import_function(
        tcx,
        fx.module,
        Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),
    );

    // 新增
    let vtable_entries = if let Some(trait_ref) = trait_ref {
        tcx.vtable_entries(trait_ref.with_self_ty(tcx, layout.ty))
    } else {
        ty::COMMON_VTABLE_ENTRIES
    };
  
     let mut data_ctx = DataContext::new();
     let mut data = ::std::iter::repeat(0u8)
         .take(vtable_entries.len() * usize_size)
         .collect::&lt;Vec&lt;u8&gt;&gt;()
         .into_boxed_slice();
      // 新增
      // 迭代处理 vtable entry
      for (idx, entry) in vtable_entries.iter().enumerate() {
          match entry {
              VtblEntry::MetadataSize =&gt; {
                  write_usize(fx.tcx, &amp;mut data, idx, layout.size.bytes());
              }
              VtblEntry::MetadataAlign =&gt; {
                  write_usize(fx.tcx, &amp;mut data, idx, layout.align.abi.bytes());
              }
              VtblEntry::MetadataDropInPlace | VtblEntry::Vacant | VtblEntry::Method(_, _) =&gt; {}
          }
      }
      data_ctx.define(data);

  
      // 迭代处理 vtable entry
      for (idx, entry) in vtable_entries.iter().enumerate() {
          match entry {
              VtblEntry::MetadataDropInPlace =&gt; {
                  let func_ref = fx.module.declare_func_in_data(drop_in_place_fn, &amp;mut data_ctx);
                  data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);
              }
              VtblEntry::Method(def_id, substs) =&gt; {
                  let func_id = import_function(
                      tcx,
                      fx.module,
                      Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), *def_id, substs)
                          .unwrap()
                          .polymorphize(fx.tcx),
                  );
                  let func_ref = fx.module.declare_func_in_data(func_id, &amp;mut data_ctx);
                  data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);
              }
              VtblEntry::MetadataSize | VtblEntry::MetadataAlign | VtblEntry::Vacant =&gt; {}
          }
      }

    // ... 
}
<span class="boring">}
</span></code></pre></pre>
<p>对 vtable 的修改，类似于 rustc_codegen_ssa  相关代码修改，只不过 rustc_codegen_cranelift 没有完全使用 rustc_codegen_ssa 的接口，所以需要另行单独处理。</p>
<h3><a class="header" href="#rustc_trait_selection-中的修改" id="rustc_trait_selection-中的修改">rustc_trait_selection 中的修改</a></h3>
<p>该库定义了 trait resolution 相关方法。Rust 编译器类型检查，mir层都依赖于该库。</p>
<p>Trait Resolution 主要用于判断该如何选择合理的 trait。 比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}
<span class="boring">}
</span></code></pre></pre>
<p>这个trait只有一个方法。它是最简单的。它从（隐含的）Self类型转换到Target类型。如果我们想允许isize和usize之间的转换，我们可以这样实现Convert。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize
<span class="boring">}
</span></code></pre></pre>
<p>现在想象一下，有一些像下面这样的代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: isize = .....;
let y = x.convert();
<span class="boring">}
</span></code></pre></pre>
<p>对convert的调用将为isize生成一个<code>trait reference Convert&lt;$Y&gt;</code>，其中<code>$Y</code>是代表y类型的类型变量。在我们可以看到的两个impls中，唯一匹配的是<code>Convert&lt;usize&gt; for isize</code>。因此，我们可以选择这个函数，这将导致<code>$Y</code>的类型被统一为<code>usize</code>。(注意，在组装候选程序时，我们在一个事务中进行初始统一，这样它们就不会相互影响。)</p>
<p>还有其他情况，可以参考 <a href="https://rustc-dev-guide.rust-lang.org/traits/resolution.html">Trait resolution (old-style)</a> 。</p>
<p>既然 vtable 已经修改，那也必须得修改该库中相关代码。</p>
<p>一共修改两个文件：<code>rustc_trait_selection/src/traits/mod.rs</code> 和 <code>rustc_trait_selection/src/traits/select/confirmation.rs</code>。</p>
<p><strong>在 <code>src/traits/mod.rs</code>中：</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_middle::ty::{
    self, GenericParamDefKind, ParamEnv, ToPredicate, Ty, TyCtxt, VtblEntry, WithConstness,
    COMMON_VTABLE_ENTRIES,
}; // 引入 新增的 VtblEntry类型

pub use self::util::{
    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,
    SupertraitDefIds, Supertraits,
};

/// Given a trait `trait_ref`, iterates the vtable entries
/// that come from `trait_ref`, including its supertraits.
// 修改 原方法
fn vtable_entries&lt;'tcx&gt;(
    tcx: TyCtxt&lt;'tcx&gt;,
    trait_ref: ty::PolyTraitRef&lt;'tcx&gt;,
) -&gt; &amp;'tcx [VtblEntry&lt;'tcx&gt;] {
    debug!(&quot;vtable_entries({:?})&quot;, trait_ref);

    let entries = COMMON_VTABLE_ENTRIES.iter().cloned().chain(
        supertraits(tcx, trait_ref).flat_map(move |trait_ref| {
            let trait_methods = tcx
                .associated_items(trait_ref.def_id())
                .in_definition_order()
                .filter(|item| item.kind == ty::AssocKind::Fn);

            // Now list each method's DefId and InternalSubsts (for within its trait).
            // If the method can never be called from this object, produce `Vacant`.
            trait_methods.map(move |trait_method| {
                debug!(&quot;vtable_entries: trait_method={:?}&quot;, trait_method);
                let def_id = trait_method.def_id;

                // Some methods cannot be called on an object; skip those.
                if !is_vtable_safe_method(tcx, trait_ref.def_id(), &amp;trait_method) {
                    debug!(&quot;vtable_entries: not vtable safe&quot;);
                    return VtblEntry::Vacant;
                }

                // The method may have some early-bound lifetimes; add regions for those.
                let substs = trait_ref.map_bound(|trait_ref| {
                    InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {
                        GenericParamDefKind::Lifetime =&gt; tcx.lifetimes.re_erased.into(),
                        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } =&gt; {
                            trait_ref.substs[param.index as usize]
                        }
                    })
                });

                // The trait type may have higher-ranked lifetimes in it;
                // erase them if they appear, so that we get the type
                // at some particular call site.
                let substs =
                    tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);

                // It's possible that the method relies on where-clauses that
                // do not hold for this particular set of type parameters.
                // Note that this method could then never be called, so we
                // do not want to try and codegen it, in that case (see #23435).
                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);
                if impossible_predicates(tcx, predicates.predicates) {
                    debug!(&quot;vtable_entries: predicates do not hold&quot;);
                    return VtblEntry::Vacant;
                }

                VtblEntry::Method(def_id, substs)
            })
        }),
    );

    tcx.arena.alloc_from_iter(entries)
}

/// Find slot base for trait methods within vtable entries of another trait
// 新增 ： 查找其他 trait 的VTable条目中的 trait 方法的位置
fn vtable_trait_first_method_offset&lt;'tcx&gt;(
    tcx: TyCtxt&lt;'tcx&gt;,
    key: (
        ty::PolyTraitRef&lt;'tcx&gt;, // trait_to_be_found
        ty::PolyTraitRef&lt;'tcx&gt;, // trait_owning_vtable
    ),
) -&gt; usize {
    let (trait_to_be_found, trait_owning_vtable) = key;

    let mut supertraits = util::supertraits(tcx, trait_owning_vtable);

    // For each of the non-matching predicates that
    // we pass over, we sum up the set of number of vtable
    // entries, so that we can compute the offset for the selected
    // trait.
    let vtable_base = ty::COMMON_VTABLE_ENTRIES.len()
        + supertraits
            .by_ref()
            .take_while(|t| *t != trait_to_be_found)
            .map(|t| util::count_own_vtable_entries(tcx, t))
            .sum::&lt;usize&gt;();

    vtable_base
}

// 修改
pub fn provide(providers: &amp;mut ty::query::Providers) {
    object_safety::provide(providers);
    structural_match::provide(providers);
    *providers = ty::query::Providers {
        // ...
      
        vtable_entries,
  
        // ...
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>在 <code>src/traits/select/confirmation.rs </code> 中：</strong></p>
<p>该模块用于确认选中的 trait 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn confirm_object_candidate(
        &amp;mut self,
        obligation: &amp;TraitObligation&lt;'tcx&gt;,
        index: usize,
    ) -&gt; Result&lt;ImplSourceObjectData&lt;'tcx, PredicateObligation&lt;'tcx&gt;&gt;, SelectionError&lt;'tcx&gt;&gt; {
    // ...
    let unnormalized_upcast_trait_ref =
            supertraits.nth(index).expect(&quot;supertraits iterator no longer has as many elements&quot;); // 修改
      
    // ...
    let vtable_base = super::super::vtable_trait_first_method_offset(
            tcx,
            (unnormalized_upcast_trait_ref, ty::Binder::dummy(object_trait_ref)),
        );
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#rustc_mir-中的修改" id="rustc_mir-中的修改">rustc_mir 中的修改</a></h3>
<p>在 rust_mir 中涉及两个文件修改: <code>rustc_mir/src/interpret/traits.rs </code> 和 <code>rustc_mir/src/monomorphize/collector.rs </code> 。</p>
<p><strong>在 <code>src/interpret/traits.rs</code> 中：</strong></p>
<p>interpret 是和 mir 转译为 llvm ir 相关。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_middle::ty::{
    self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,
    COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,
}; // 修改，引入 VtblEntry 相关新类型


// 修改原方法
// InterpCx 是 interpret 上下文
impl&lt;'mir, 'tcx: 'mir, M: Machine&lt;'mir, 'tcx&gt;&gt; InterpCx&lt;'mir, 'tcx, M&gt; {
    /// Creates a dynamic vtable for the given type and vtable origin. This is used only for
    /// objects.
    ///
    /// The `trait_ref` encodes the erased self type. Hence, if we are
    /// making an object `Foo&lt;Trait&gt;` from a value of type `Foo&lt;T&gt;`, then
    /// `trait_ref` would map `T: Trait`.
    pub fn get_vtable(
        &amp;mut self,
        ty: Ty&lt;'tcx&gt;,
        poly_trait_ref: Option&lt;ty::PolyExistentialTraitRef&lt;'tcx&gt;&gt;,
    ) -&gt; InterpResult&lt;'tcx, Pointer&lt;M::PointerTag&gt;&gt; {
        // ...
      
        // 获取 vtable entries
      	let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {
            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);
            let trait_ref = self.tcx.erase_regions(trait_ref);

            self.tcx.vtable_entries(trait_ref)
        } else {
            COMMON_VTABLE_ENTRIES
        };

        // ...
        // 新增
        ////////////////////////////////////////////////////////////////////////
        // If you touch this code, be sure to also make the corresponding changes to
        // `get_vtable` in `rust_codegen_llvm/meth.rs`.
        // /////////////////////////////////////////////////////////////////////
        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();
      
        // ...
        // 新增
        // No need to do any alignment checks on the memory accesses below, because we know the
        // allocation is correctly aligned as we created it above. Also we're only offsetting by
        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.
        // 迭代处理 vtable entries 中每个虚表的布局
        let scalars = vtable_entries
            .iter()
            .map(|entry| -&gt; InterpResult&lt;'tcx, _&gt; {
                match entry {
                    VtblEntry::MetadataDropInPlace =&gt; Ok(Some(drop.into())),
                    VtblEntry::MetadataSize =&gt; Ok(Some(Scalar::from_uint(size, ptr_size).into())),
                    VtblEntry::MetadataAlign =&gt; Ok(Some(Scalar::from_uint(align, ptr_size).into())),
                    VtblEntry::Vacant =&gt; Ok(None),
                    VtblEntry::Method(def_id, substs) =&gt; {
                        // Prepare the fn ptr we write into the vtable.
                        let instance =
                            ty::Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)
                                .ok_or_else(|| err_inval!(TooGeneric))?;
                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));
                        Ok(Some(fn_ptr.into()))
                    }
                }
            })
            .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
        let mut vtable_alloc =
            self.memory.get_mut(vtable.into(), vtable_size, ptr_align)?.expect(&quot;not a ZST&quot;);
        for (idx, scalar) in scalars.into_iter().enumerate() {
            if let Some(scalar) = scalar {
                let idx: u64 = u64::try_from(idx).unwrap();
                vtable_alloc.write_ptr_sized(ptr_size * idx, scalar)?;
            }
        }
        // ...  
      
        // 修改原方法
        /// Resolves the function at the specified slot in the provided
    /// vtable. Currently an index of '3' (`COMMON_VTABLE_ENTRIES.len()`)
    /// corresponds to the first method declared in the trait of the provided vtable.
    pub fn get_vtable_slot(
        &amp;self,
        vtable: Scalar&lt;M::PointerTag&gt;,
        idx: u64,
    ) -&gt; InterpResult&lt;'tcx, FnVal&lt;'tcx, M::ExtraFnVal&gt;&gt; {
        let ptr_size = self.pointer_size();
        let vtable_slot = vtable.ptr_offset(ptr_size * idx, self)?; // 新增
        let vtable_slot = self
            .memory
            .get(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?
            .expect(&quot;cannot be a ZST&quot;);
        let fn_ptr = vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?;
        self.memory.get_fn(fn_ptr)
    }

    /// Returns the drop fn instance as well as the actual dynamic type.
    pub fn read_drop_type_from_vtable(
        &amp;self,
        vtable: Scalar&lt;M::PointerTag&gt;,
    ) -&gt; InterpResult&lt;'tcx, (ty::Instance&lt;'tcx&gt;, Ty&lt;'tcx&gt;)&gt; {
        let pointer_size = self.pointer_size();
        // We don't care about the pointee type; we just want a pointer.
        let vtable = self
            .memory
            .get(
                vtable,
                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),
                self.tcx.data_layout.pointer_align.abi,
            )?
            .expect(&quot;cannot be a ZST&quot;);
        let drop_fn = vtable
            .read_ptr_sized(
                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_DROPINPLACE).unwrap(),
            )?
            .check_init()?;
          // ....
        }
      
        // ...
        // 修改原方法
        pub fn read_size_and_align_from_vtable(
        &amp;self,
        vtable: Scalar&lt;M::PointerTag&gt;,
        ) -&gt; InterpResult&lt;'tcx, (Size, Align)&gt; {
            let pointer_size = self.pointer_size();
            // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),
            // the size, and the align (which we read below).
            let vtable = self
                .memory
                .get(
                    vtable,
                    pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),
                    self.tcx.data_layout.pointer_align.abi,
                )?
                .expect(&quot;cannot be a ZST&quot;);
            let size = vtable
                .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap())?
                .check_init()?;
            let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();
            let align = vtable
                .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap())?
                .check_init()?;
            let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();
            let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;

            if size &gt;= self.tcx.data_layout.obj_size_bound() {
                throw_ub!(InvalidVtableSize);
            }
            Ok((Size::from_bytes(size), align))
        }
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>在 <code>src/monomorphize/collector.rs </code>中：</strong></p>
<p>monomorphize 意思是 单态化，意味着 这个模块用于 泛型单态化。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable, VtblEntry}; // 引入新的 VtablEntry 类型

/// Creates a `MonoItem` for each method that is referenced by the vtable for
/// the given trait/impl pair.
fn create_mono_items_for_vtable_methods&lt;'tcx&gt;(
    tcx: TyCtxt&lt;'tcx&gt;,
    trait_ty: Ty&lt;'tcx&gt;,
    impl_ty: Ty&lt;'tcx&gt;,
    source: Span,
    output: &amp;mut Vec&lt;Spanned&lt;MonoItem&lt;'tcx&gt;&gt;&gt;,
) {
   // ...
   if let ty::Dynamic(ref trait_ty, ..) = trait_ty.kind() {
       if let Some(principal) = trait_ty.principal() {
           // ...
           // Walk all methods of the trait, including those of its supertraits
           // 走查所有的 trait 方法，包括 supertrait 的
           let entries = tcx.vtable_entries(poly_trait_ref);
           let methods = entries
                .iter()
                .filter_map(|entry| match entry {
                    VtblEntry::MetadataDropInPlace
                    | VtblEntry::MetadataSize
                    | VtblEntry::MetadataAlign
                    | VtblEntry::Vacant =&gt; None,
                    VtblEntry::Method(def_id, substs) =&gt; ty::Instance::resolve_for_vtable(
                        tcx,
                        ty::ParamEnv::reveal_all(),
                        *def_id,
                        substs,
                    )
                    .filter(|instance| should_codegen_locally(tcx, instance)),
                })
                .map(|item| create_fn_mono_item(tcx, item, source));
            output.extend(methods);
       }
   }
   // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#小结-8" id="小结-8">小结</a></h2>
<p>第一步工作，主要是为了改进生成的 vtable结构，能够识别 多个trait 对象。</p>
<p>从 <code>rustc_middle -&gt; rustc_codgen_ssa -&gt; rustc_codegen_cranelift -&gt; rustc_trait_selection -&gt; rustc_mir</code> 这个过程，是从上到下，从抽象类型 到 能转译为 llvm IR 的 MIR。</p>
<p>如果 <code>rustc_codgen_cranelift</code> 能够完全使用 <code>rustc_codgen_ssa</code> ，那么代码修改起来应该更方便了。</p>
<p>后续：看到 <a href="https://github.com/antoyo/rustc_codegen_gcc">rustc_codegen_gcc</a> 就是基于 <code>rustc_codgen_ssa</code>来实现的。</p>
<h1><a class="header" href="#github-趋势榜-3" id="github-趋势榜-3">GitHub 趋势榜</a></h1>
<p>编辑：张汉东</p>
<blockquote>
<p>说明：记录一下本月在 GitHub 趋势榜单出现的 新的项目。</p>
<p>排名不分先后</p>
</blockquote>
<hr />
<h2><a class="header" href="#mdbook--rust-实现的电子书创建工具" id="mdbook--rust-实现的电子书创建工具">mdBook : Rust 实现的电子书创建工具</a></h2>
<p>使用 Markdown 文件来创建电子书，最近发布了新版本。 注意：RustMagazine 就是用了 mdBook。</p>
<p><a href="https://github.com/rust-lang/mdBook">https://github.com/rust-lang/mdBook</a></p>
<h2><a class="header" href="#datafuse-现代实时数据处理与分析的-dbms" id="datafuse-现代实时数据处理与分析的-dbms">Datafuse 现代实时数据处理与分析的 DBMS</a></h2>
<p>Datafuse 是一款现代实时数据处理与分析的 DBMS，云原生架构，基于 Rust 编写，受到 ClickHouse 启发并由 arrow-rs 赋能。</p>
<p>该框架秉持以下基本原则：</p>
<ul>
<li>无畏： 没有数据竞争，没有 unsafe，尽可能少的未处理错误</li>
<li>高性能： 所有执行都是并行的</li>
<li>高可扩展性： 所有组件都是分布式的</li>
<li>高可靠性： 该框架的首要目标就是要可靠</li>
</ul>
<p><a href="https://github.com/datafuselabs/datafuse">https://github.com/datafuselabs/datafuse</a></p>
<h2><a class="header" href="#websocat-websocket的命令行客户端" id="websocat-websocket的命令行客户端">websocat: websocket的命令行客户端</a></h2>
<p>用于测试 websocket 很好的工具。</p>
<p><a href="https://github.com/vi/websocat">https://github.com/vi/websocat</a></p>
<h2><a class="header" href="#zola-静态网站生成器" id="zola-静态网站生成器">zola: 静态网站生成器</a></h2>
<p>该项目也算是 Rust 生态里历史比较长的了。</p>
<ul>
<li><a href="https://github.com/getzola/zola">https://github.com/getzola/zola</a></li>
<li><a href="https://www.getzola.org/">https://www.getzola.org/</a></li>
</ul>
<h2><a class="header" href="#sixtyfps--为任何显示器开发流畅的图形用户界面" id="sixtyfps--为任何显示器开发流畅的图形用户界面">SixtyFPS : 为任何显示器开发流畅的图形用户界面</a></h2>
<p>SixtyFPS 是一个工具包，可以为任何显示器高效开发流畅的图形用户界面：嵌入式设备和桌面应用程序。 支持多种编程语言，例如 Rust、C++ 或 JavaScript。</p>
<p><a href="https://github.com/sixtyfpsui/sixtyfps">https://github.com/sixtyfpsui/sixtyfps</a></p>
<h2><a class="header" href="#broot--查看和导航目录树的新方法" id="broot--查看和导航目录树的新方法">broot : 查看和导航目录树的新方法</a></h2>
<p>此库值得你一用，功能比较丰富。</p>
<ul>
<li><a href="https://github.com/Canop/broot">https://github.com/Canop/broot</a></li>
<li><a href="https://dystroy.org/broot/">https://dystroy.org/broot/</a></li>
</ul>
<h2><a class="header" href="#fnm-nodejs-版本管理器" id="fnm-nodejs-版本管理器">fnm： node.js 版本管理器</a></h2>
<p>特点：简单/ 跨平台</p>
<p><a href="https://github.com/Schniz/fnm">https://github.com/Schniz/fnm</a></p>
<h2><a class="header" href="#mcfly-智能的-shell-历史命令推荐工具" id="mcfly-智能的-shell-历史命令推荐工具">mcfly: 智能的 shell 历史命令推荐工具</a></h2>
<p>McFly 通过一个小型神经网络实时确定优先级来进行shell命令推荐。</p>
<p><a href="https://github.com/cantino/mcfly">https://github.com/cantino/mcfly</a></p>
<h1><a class="header" href="#推荐项目--基础工具库-3" id="推荐项目--基础工具库-3">推荐项目 ｜ 基础工具库</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#pyre-http用-rust-实现的-python-http-server" id="pyre-http用-rust-实现的-python-http-server">pyre-http：用 Rust 实现的 Python HTTP Server</a></h2>
<p>目前还未到达生产可用级别。</p>
<p>pyre-http 几乎完全用 Rust 实现，为了兼容 python 的 ASGI/Asyncio生态系统，还使用了 PyO3。</p>
<p>具体来说，基本上用纯 Rust 重写了整个 asyncio 服务器和协议API，将Python调用减少到平均每个请求只有1-2个调用。</p>
<p>作者的一些心得：</p>
<blockquote>
<p>Rust和Python在一起工作很好，但有些地方开销很大。</p>
<p>在Rust中为异步Python写异步代码，需要从完全不同的角度来看待你在Python中写的东西，你最好以事件驱动的状态机风格来写代码，而不是Python中正常的基于回调的Future。</p>
<p>编写异步Python并不意味着编写高级的异步Rust，公平地说，在大多数情况下Python也是如此；通常你会期望看到大多数服务器代码是完全同步的。</p>
</blockquote>
<p><a href="https://github.com/Project-Dream-Weaver/pyre-http">https://github.com/Project-Dream-Weaver/pyre-http</a></p>
<h2><a class="header" href="#fang-后台任务处理库" id="fang-后台任务处理库">Fang: 后台任务处理库</a></h2>
<p>作者处理后台任务的心路历程：</p>
<ol>
<li>最初的方法（天真烂漫）</li>
</ol>
<p>在同一个线程中执行tokio任务中的每个同步工作。在并发量大的时候，出现了问题：有一些同步任务根本没有执行。开发者对tokio任务没有任何控制权，所以没有办法检查任务的总数和当前正在执行的任务等。</p>
<p>有趣的是，作者在2020年还为此写过一篇文章：<a href="https://www.badykov.com/rust/2020/06/28/you-dont-need-background-job-library/">在 Rust 里，你不需要后台任务框架</a></p>
<p>然而，现在作者萌生了实现简单后台任务处理库的想法。</p>
<ol start="2">
<li>
<p>Fang 的方案（简单，但不天真）</p>
<p>a. 任务被存储在 Postgres 数据库中。
b. Fang 启动指定数量的 Worker，每个 Worker 就是一个独立线程，用于执行任务。
c. 如果数据库中没有剩余的任务，Worker就会在指定的秒数内休眠。
d. 如果任何 worker 在任务执行过程中出现故障，它将被重新启动。</p>
</li>
</ol>
<p>Fang 的方案确实简单粗暴，并且还对 Postgres 数据库绑定很深。因为 需要保证每个 Worker 必须对任务只处理一次，所以 Fang 依赖了 Postgres 数据库的 <code>Locks(FOR UPDATE SKIP LOCKED)</code>。</p>
<p>个人观点：</p>
<p>这种方案其实比较传统，比如 Ruby 的 delayed_job ，或者 Sidekiq（依赖于 redis）。</p>
<p>其实在 Rust 社区，也有不少后台任务库，但很多就不维护了，可能和 Rust 异步生态不太稳定有关系。</p>
<p>有一个目前还维护（但不积极）的语言无关的后台任务库：<a href="https://github.com/davechallis/ocypod">ocypod</a>，是基于 redis 的，值得关注。但依赖的还是 tokio 0.2 。</p>
<p>Jonhoo 实现了一个 <a href="https://github.com/jonhoo/faktory-rs">faktory-rs</a>，是 高性能任务系统 Faktory 的 Rust 客户端和 worker 实现。<a href="https://github.com/contribsys/faktory">Faktory</a> 是 Sidekiq 作者（实现财富自由以后）的新产品(go语言实现)，支持异构系统，可以用任意语言做生产者和消费者。虽然褒贬不一，但毕竟作者已经有一个非常成功的Sidekiq实现了。</p>
<p>Faktory 特点：</p>
<ul>
<li>Faktory server（not worker）支持 retry 等特性</li>
<li>不特定依赖 redis，内置RocksDB做消息存储</li>
<li>提供类似 Sidekiq 的 WebUI</li>
<li>支持异构系统，并且保留了从 Sidekiq 积累下的一些好用的特性</li>
<li>Faktory 的接口格式很简单，核心是 queue、 jobtype 和 args</li>
<li>目前国内云服务商不提供 Faktory 相关服务，需要自己维护</li>
<li>已经发布1.5.1 版本</li>
</ul>
<p>Fang 相关链接：</p>
<ul>
<li><a href="https://github.com/ayrat555/fang">https://github.com/ayrat555/fang</a></li>
<li><a href="https://www.badykov.com/rust/2021/06/27/fang/">介绍文章</a></li>
</ul>
<h2><a class="header" href="#enarx--在可信执行环境的应用部署系统" id="enarx--在可信执行环境的应用部署系统">enarx : 在可信执行环境的应用部署系统</a></h2>
<p>据说是红帽和一些知名企业一起搞的。</p>
<p>Enarx是独立于CPU架构的，使相同的应用程序代码可以在多个目标上部署，抽象出诸如交叉编译和硬件供应商之间不同的认证机制等问题。目前，支持 AMD SEV和英特尔SGX的工作正在进行中。</p>
<p>Enarx 使用 WebAssembly 作为其隔离和可移植性的基础。</p>
<p><a href="https://github.com/enarx/enarx">https://github.com/enarx/enarx</a></p>
<h2><a class="header" href="#cargo-c-构建并安装c-abi兼容的动态和静态库" id="cargo-c-构建并安装c-abi兼容的动态和静态库">cargo-c ：构建并安装C-ABI兼容的动态和静态库。</a></h2>
<p>它生成并安装正确的PKG-Config文件，静态库和动态库，以及任何C（和C兼容）软件使用的C头。</p>
<p><a href="https://github.com/lu-zero/cargo-c">https://github.com/lu-zero/cargo-c</a></p>
<h2><a class="header" href="#macroquad游戏引擎分离出音频系统" id="macroquad游戏引擎分离出音频系统">macroquad游戏引擎分离出音频系统</a></h2>
<p>macroquad 游戏引擎在最近将其音频系统给单独提取出来，作为一个更通用的Rust包，该crate是对多个平台的多个音频后端的统一抽象，目前完成度如下：</p>
<ul>
<li>Web: WebAudio</li>
<li>Android: OpenSLES</li>
<li>Linux: Alsa</li>
<li>Mac: CoreAudio</li>
<li>Windows: Wasapi</li>
<li>IOS: CoreAudio(?)</li>
</ul>
<p><a href="https://github.com/not-fl3/quad-snd">https://github.com/not-fl3/quad-snd</a></p>
<h2><a class="header" href="#gloo-v030-发布" id="gloo-v030-发布">Gloo v0.3.0 发布</a></h2>
<p>Gloo 团队很高兴地宣布一个新的、姗姗来迟的 Gloo 版本：v0.3.0。Gloo 是一个模块化工具包，用于使用 Rust 和 WASM 构建快速、可靠的 Web 应用程序和库。</p>
<p><a href="https://gloo-rs.web.app/blog/release-0.3.0">https://gloo-rs.web.app/blog/release-0.3.0</a></p>
<h2><a class="header" href="#throne--用于游戏原型设计和故事逻辑的脚本语言" id="throne--用于游戏原型设计和故事逻辑的脚本语言">Throne ： 用于游戏原型设计和故事逻辑的脚本语言</a></h2>
<p>@tobmansf 一直在研究用于游戏原型设计和故事逻辑的脚本语言。它可以编译成 WebAssembly，可以在 <a href="https://t-mw.github.io/throne-playground/">https://t-mw.github.io/throne-playground/</a> 上试一试。</p>
<p><a href="https://github.com/t-mw/throne">https://github.com/t-mw/throne</a></p>
<h2><a class="header" href="#零成本反序列化框架-rkyv-发布-071-版本" id="零成本反序列化框架-rkyv-发布-071-版本">零成本反序列化框架 rkyv 发布 0.7.1 版本</a></h2>
<p><a href="https://github.com/djkoloski/rkyv">https://github.com/djkoloski/rkyv</a></p>
<h2><a class="header" href="#一个-rust-和-typescript-实现的-体素voxel引擎" id="一个-rust-和-typescript-实现的-体素voxel引擎">一个 Rust 和 TypeScript 实现的 体素（Voxel）引擎</a></h2>
<p>基于 actix-web 实现</p>
<ul>
<li><a href="https://github.com/ian13456/mine.js">https://github.com/ian13456/mine.js</a></li>
<li>在线玩：<a href="https://mine.iantheearl.io/?world=terrains">https://mine.iantheearl.io/?world=terrains</a></li>
</ul>
<h2><a class="header" href="#慢啃-rust-系列----gazebo-库-之-dupe" id="慢啃-rust-系列----gazebo-库-之-dupe">慢啃 Rust 系列   | Gazebo 库 之 Dupe</a></h2>
<p>原文标题：Rust Nibbles - Gazebo : Dupe </p>
<p>「Rust Nibbles」 翻译成 「慢啃 Rust 」 没毛病吧 ？ </p>
<p>这是 Facebook for Develpers 网站出的Rust Nibbles系列文章，介绍 facebook 开源的各种 Rust 库。</p>
<p>Gazebo 是 facebook 工程师 编写的基础库，Gazebo以独立模块的形式包含了一系列经过测试的Rust实用程序。这篇文章是介绍了 Gazebo 中的 Dupe trait 。</p>
<p>在Rust中，有两个用于 &quot;复制 &quot;一个值的相关特性--Copy和Clone。</p>
<p>在Gazebo中引入了第三个类似的trait，称之为Dupe，它可以在Gazebo Prelude中使用。（dupe 有复制物品/复制底片的意思）。</p>
<p>Copy 是 编译器的自动行为，复制成本也不高。而 Clone 则不然。为了降低 Clone  的成本，一般可以使用 Arc，但是 Arc 使得代码阅读成本提升。比如 <code>let xs = ys.clone();</code>，你可能需要查看大量上下文来弄清是 调用了 Clone 还是 Arc 。当然你可以使用 <code>let xs = Arc::clone(ys)</code>来提升可读性，但缺点是，它破坏了抽象。</p>
<p>所以，Gazebo 中引入了 Dupe trait, <code>let xs = ys.dupe()</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gazebo::prelude::*;
#[derive(Clone, Dupe)]
struct MyArc(Arc&lt;String&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>看了一下实现源码：<a href="https://github.com/facebookincubator/gazebo/blob/master/gazebo/src/dupe.rs">https://github.com/facebookincubator/gazebo/blob/master/gazebo/src/dupe.rs</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Dupe: Clone {
    fn dupe(&amp;self) -&gt; Self {
        self.clone()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>看上去和 Clone 很像，但它仅在 常量时或零分配下可用，比如 Arc。因为 Dupe 只给这些类型实现了。</p>
<p><a href="https://developers.facebook.com/blog/post/2021/07/06/rust-nibbles-gazebo-dupe/">https://developers.facebook.com/blog/post/2021/07/06/rust-nibbles-gazebo-dupe/</a></p>
<h2><a class="header" href="#想用-rust--写脚本吗" id="想用-rust--写脚本吗">想用 Rust  写脚本吗？</a></h2>
<p>rust-script ，可以在没有任何设置或编译步骤的情况下运行rust 文件和表达式。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>$ echo 'println!(&quot;Hello, World!&quot;);' &gt; hello.rs
$ rust-script hello.rs
Hello, World!
<span class="boring">}
</span></code></pre></pre>
<p>也支持 依赖 crate</p>
<pre><pre class="playground"><code class="language-rust">
#!/usr/bin/env rust-script
//! This is a regular crate doc comment, but it also contains a partial
//! Cargo manifest.  Note the use of a *fenced* code block, and the
//! `cargo` &quot;language&quot;.
//!
//! ```cargo
//! [dependencies]
//! time = &quot;0.1.25&quot;
//! 
fn main() {
    println!(&quot;{}&quot;, time::now().rfc822z());
}

</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ rust-script now
Wed, 28 Oct 2020 00:38:45 +0100
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><a href="https://rust-script.org/">https://rust-script.org/</a></li>
<li><a href="https://github.com/fornwall/rust-script">https://github.com/fornwall/rust-script</a></li>
</ul>
<h2><a class="header" href="#quilkin--一个用于游戏服务器的开源udp代理" id="quilkin--一个用于游戏服务器的开源udp代理">Quilkin : 一个用于游戏服务器的开源UDP代理</a></h2>
<p>由embark 和 Google Cloud 共同推出，目标是为任何游戏工作室提供和巨头同等的网络功能。</p>
<p><a href="https://medium.com/embarkstudios/say-hi-to-quilkin-an-open-source-udp-proxy-88577c795204">https://medium.com/embarkstudios/say-hi-to-quilkin-an-open-source-udp-proxy-88577c795204</a></p>
<h2><a class="header" href="#franzplot--rust-实现的教学软件" id="franzplot--rust-实现的教学软件">franzplot ： Rust 实现的教学软件</a></h2>
<p>米兰理工大学的一名研究助理，担任了 “设计的曲线和表面”课程的助教，这门课主要是为设计专业的学生解释三维数学概念。 因为没有趁手的教学工具，所以这位助教自己用 Rust 实现了一个。</p>
<p>第一个版本是 cpp 实现的。然后新版本用 Rust 重写了，为什么呢？</p>
<ol>
<li>他在cpp版本内亏欠的技术债务太多，不利于开源协同</li>
<li>OpenGL 已经被苹果废弃</li>
<li>想让工具变得更加强大</li>
</ol>
<p>所以，现在用 WebGPU + Rust 重写了这个工具。基于 <a href="https://github.com/gfx-rs/wgpu">https://github.com/gfx-rs/wgpu</a></p>
<p>FranzPlot目前是闭源的，未来可能会开源。因为尽管重新写了软件，也还需要处理一些技术债务。另外想完全使用 WGSL 而抛弃 GLSL ，还想将 界面替换为 纯 Rust 实现，比如 使用egui框架。现在是用了 imgui-rs。</p>
<p><a href="https://gfx-rs.github.io/stories/franzplot">https://gfx-rs.github.io/stories/franzplot</a></p>
<h2><a class="header" href="#delicate-一个轻量的分布式的任务调度平台" id="delicate-一个轻量的分布式的任务调度平台">delicate 一个轻量的分布式的任务调度平台</a></h2>
<p>特色大概有几点：</p>
<ol>
<li>丰富Rust生态。是一个中小型项目（代码量3W+）， 涉及的交互端包括（Front-end , Server ,  agent）  js &amp; rust 的交织， 可以让新同学作为参考实现一个Rust的工程。</li>
<li>里面的面对C端的交互都尽量设计的符合用户习惯，除了性能之外 项目很关心人使用的舒适度。</li>
<li>里面有一些新定义的概念比如绑定，任务不直接关联机器而是关联机器的一个抽象（绑定），当有成百上千的任务需要从  A 机器迁移到 B 机器 ，只需要修改一次关联关系，任务就自动完成了迁移。</li>
</ol>
<p><a href="https://github.com/BinChengZhao/delicate">https://github.com/BinChengZhao/delicate</a></p>
<h2><a class="header" href="#一个安全的可用于-no_std-asn1-的-解码器框架" id="一个安全的可用于-no_std-asn1-的-解码器框架">一个安全的可用于 <code>#[no_std]</code> ASN.1 的 解码器框架</a></h2>
<p><a href="https://github.com/XAMPPRocky/rasn">https://github.com/XAMPPRocky/rasn</a></p>
<h2><a class="header" href="#rust-实现的-windows-上的下一代包管理器非常快" id="rust-实现的-windows-上的下一代包管理器非常快">Rust 实现的 Windows 上的下一代包管理器，非常快</a></h2>
<p>现在只发布了 Alpha 版本，但是已经比目前 Windows 自带的包管理器快 5 倍了。</p>
<p><a href="https://github.com/novus-package-manager/novus">https://github.com/novus-package-manager/novus</a></p>
<h2><a class="header" href="#loadstone-发布一个安全的裸金属的-bootloader" id="loadstone-发布一个安全的裸金属的-bootloader">Loadstone 发布，一个安全的裸金属的 bootloader</a></h2>
<p>Rust 开始写 bootloader 了。看起来这是一个相当严肃的项目，目前已经发布了 1.0.0。提供了如下功能：</p>
<ul>
<li>多镜像操作：存储，拷贝，升级，验证和启动。可灵活配置</li>
<li>支持外部 flash 芯片</li>
<li>Golden image rollbacks （怎么翻译？）</li>
<li>自动或应用触发的升级</li>
</ul>
<p>搞底层的同学，请严重关注一下此项目。</p>
<p><a href="https://github.com/absw/loadstone">https://github.com/absw/loadstone</a></p>
<h2><a class="header" href="#一个研究型的-osnros" id="一个研究型的-osnros">一个研究型的 OS：NrOS</a></h2>
<p>Node Replicated Kernel (NRK) 最早是在 VMware Research 里面的一个原型研究型 Os 项目，现在已经做出了一些学术成果。主要特点是要探索未来操作系统的结构。</p>
<p><a href="https://nrkernel.systems/">https://nrkernel.systems/</a></p>
<h2><a class="header" href="#sycamore-v050发布" id="sycamore-v050发布">Sycamore v0.5.0发布</a></h2>
<p>Sycamore 是一个用于在 Rust 和 WebAssembly 中构建同构 Web 应用程序的库。v0.5.0 版本是Sycamore迄今为止最大的版本，包含大量新功能和错误修复。其中这个版本还引入了功能齐全的路由系统</p>
<p>文章链接：<a href="https://sycamore-rs.netlify.app/news/announcing-v0.5.0">https://sycamore-rs.netlify.app/news/announcing-v0.5.0</a></p>
<h2><a class="header" href="#nanorand-v06-发布" id="nanorand-v06-发布">nanorand v0.6 发布</a></h2>
<p>nanorand 是一个快速、轻量、高效的随机数生成器，其提供的 nanorand::WyRand 在 M1 Macbook Air 上速度可达 16.4 GB/s。</p>
<p>目前 nanorand 发布了 v0.6 ，RandomGen 支持带符号整数和浮点数，RandomRange 支持带符号整数。</p>
<p><a href="https://github.com/Absolucy/nanorand-rs">https://github.com/Absolucy/nanorand-rs</a></p>
<h2><a class="header" href="#hora-010" id="hora-010">Hora 0.1.0</a></h2>
<p>Hora，Rust 实现的近似最邻近搜索（Approximate Nearest Neighbor Search, ANNS）算法库。先发布了 v0.1.0，专注于近似最邻近搜索领域，已经实现了 HNSW（Hierarchical Navigable Small World Graph Index）索引，SSG（Satellite System Graph）索引，PQIVF（Product Quantization Inverted File）索引，BruteForceIndex，其他索引也即将推出。</p>
<p>Hora 可以部署在任何操作系统平台上，已经支持的 PC 操作系统 Linux，Mac OS，Windows，将支持移动设备操作系统 IOS 和Android，以及将来支持嵌入式系统（no_std），并将支持多语言绑定，包括 Python，Javascript，Java，Ruby，Swift 和 R。</p>
<p>相关链接信息：<a href="https://github.com/hora-search/hora">https://github.com/hora-search/hora</a></p>
<h1><a class="header" href="#推荐项目---框架引擎-3" id="推荐项目---框架引擎-3">推荐项目 |  框架引擎</a></h1>
<p>编辑： 张汉东</p>
<hr />
<h2><a class="header" href="#axum-tokio-出品的-web-框架" id="axum-tokio-出品的-web-框架">Axum: tokio 出品的 Web 框架</a></h2>
<p>这个框架一出，意味着 tokio 生态正在强势建立！ 算的上是Rust Web 开发领域的里程碑事件！让其他 web 框架顿时失色！当然，我并不是否认其他 web 框架的优秀！ </p>
<p>该框架全面整合 tokio 生态，并且由tokio 团队自己维护。这一点就很占优势了！</p>
<p>查了一下，Axum 这名字 有 king of kings 之意  😂，<a href="https://en.wikipedia.org/wiki/Kingdom_of_Aksum">https://en.wikipedia.org/wiki/Kingdom_of_Aksum</a></p>
<p><a href="https://tokio.rs/blog/2021-07-announcing-axum">https://tokio.rs/blog/2021-07-announcing-axum</a></p>
<h2><a class="header" href="#meilisearch-搜索引擎合并了前半年的重构工作" id="meilisearch-搜索引擎合并了前半年的重构工作">MeiliSearch 搜索引擎合并了前半年的重构工作</a></h2>
<p>改进摘要：</p>
<ol>
<li>改进索引系统。</li>
<li>设计了更快的过滤系统版本。</li>
<li>提供了一个新的Facet系统。</li>
<li>提供一个新的 Dashboard。</li>
<li>其他。</li>
</ol>
<ul>
<li><a href="https://twitter.com/Kerollmops/status/1410613829147324424?s=20">twitter thread</a></li>
<li><a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a></li>
</ul>
<h2><a class="header" href="#fluvio现代化可编程流处理平台" id="fluvio现代化可编程流处理平台">Fluvio：现代化可编程流处理平台</a></h2>
<p><a href="https://www.infinyon.com/blog/2021/06/introducing-fluvio/#fluvio-programmable-platform-for-data-in-motion">https://www.infinyon.com/blog/2021/06/introducing-fluvio/#fluvio-programmable-platform-for-data-in-motion</a></p>
<h2><a class="header" href="#quickwit--极具成本效益cost-efficient-的搜索引擎-诞生了" id="quickwit--极具成本效益cost-efficient-的搜索引擎-诞生了">Quickwit ： 极具成本效益（cost-efficient ）的搜索引擎 诞生了</a></h2>
<p>从成本角度看，当前有两类搜索模型：</p>
<ol>
<li>公共搜索引擎。比如 Google/ Twitter/ Wiki /GitHub/ Reddit 之类</li>
<li>私有搜索引擎。 有限的搜索集。比如你的服务日志 / 邮件</li>
</ol>
<p>如果你运营的是一家成功的电商，你付出昂贵的硬件成本在搜索上面，你的投资回报率可能比较高，所以你也不会在意这点成本。</p>
<p>但是当你还没有达到足够的投资回报率，而你的日志搜索就占了你硬件成本的很大部分，那你就该关心这个成本了。</p>
<p>Quickwit 搜索引擎主要是为了解决这个问题，基于 tantivy ，类似Lucene，的一个分布式搜索引擎。</p>
<p>这是我们的第一个版本，它为一个具有成本效益的搜索引擎奠定了基础。</p>
<p>具体来说，Quickwit 0.1采用了一个命令行界面的形式来创建、索引和提供搜索集群，其主要特点如下。</p>
<ul>
<li>由Tantivy支持的快速索引</li>
<li>改良的索引数据结构布局，可以直接在对象存储上打开并读取索引</li>
<li>具有无状态实例的分布式搜索</li>
<li>基于SWIM协议（Scalable Weakly-consistent Infection-style Process Group Membership Protocol， 可伸缩的弱一致性传染式进程组成员协议，由 gossip 协议发展而来）的集群形成，不用担心 leader 或 consensus</li>
<li>可配置的映射</li>
<li>自然查询语言</li>
</ul>
<p>Quickwit 如何节省成本：</p>
<ol>
<li>使用段复制方式优化索引，降低 cpu 使用时间</li>
<li>分离存储与计算，减少 cpu 空闲时间</li>
<li>使用 热启动 bundle，减少每次查询打开索引的花费</li>
<li>采用并发请求来解决 s3的低吞吐量问题</li>
<li>使用自定义索引格式，减少搜索关键路径</li>
</ol>
<p><a href="https://quickwit.io/blog/quickwit-first-release/">https://quickwit.io/blog/quickwit-first-release/</a></p>
<h2><a class="header" href="#---trillium--构建-异步-web-应用的-组件库" id="---trillium--构建-异步-web-应用的-组件库">🌱🦀🌱   trillium : 构建 异步 web 应用的 组件库</a></h2>
<ul>
<li>
<p>trillium 意思是 延龄草 ，或者三叶草。</p>
</li>
<li>
<p>trillium 整体架构受 Elixir Plug的启发，并打算成为plug和 tide 的混合体。</p>
</li>
<li>
<p>trillium 的特点是 组件化，一切都是 opt-in 的。</p>
</li>
<li>
<p>trillium 的核心概念是： Handlers/ Conn/ Adapters </p>
</li>
<li>
<p>Trillium 遵守<a href="https://12factor.net/config">12 factor</a>的配置方法，尽可能接受环境中的配置。</p>
</li>
<li>
<p><a href="https://trillium.rs/">https://trillium.rs/</a></p>
</li>
<li>
<p><a href="https://github.com/trillium-rs/trillium">https://github.com/trillium-rs/trillium</a></p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-188947685-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

        <script src="https://utteranc.es/client.js"
        repo="RustMagazine/rust_magazine_2021"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async></script>

    </body>
</html>
