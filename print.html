<!DOCTYPE HTML>
<html lang="zh_CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-magazine</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="send_word.html"><strong aria-hidden="true">2.</strong> 创刊寄语</a></li><li class="chapter-item expanded "><a href="chapter_1/toc.html"><strong aria-hidden="true">3.</strong> 一月刊（January）| 正式发布</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/lang.html"><strong aria-hidden="true">3.1.</strong> 本月简报 | Rust官方动态</a></li><li class="chapter-item expanded "><a href="chapter_1/hots.html"><strong aria-hidden="true">3.2.</strong> 本月简报 |社区热点</a></li><li class="chapter-item expanded "><a href="chapter_1/projects.html"><strong aria-hidden="true">3.3.</strong> 本月简报 | 推荐项目</a></li><li class="chapter-item expanded "><a href="chapter_1/learns.html"><strong aria-hidden="true">3.4.</strong> 本月简报 | 学习资源</a></li><li class="chapter-item expanded "><a href="chapter_1/rust_laoke.html"><strong aria-hidden="true">3.5.</strong> 本月简报 | Rust唠嗑室本月汇总</a></li><li class="chapter-item expanded "><a href="chapter_1/jit.html"><strong aria-hidden="true">3.6.</strong> RustChinaConf2020 精选 | 用Rust设计高性能JIT执行引擎</a></li><li class="chapter-item expanded "><a href="chapter_1/rust_async.html"><strong aria-hidden="true">3.7.</strong> RustChinaConf2020 精选 | Rust 异步与并发</a></li><li class="chapter-item expanded "><a href="chapter_1/1password.html"><strong aria-hidden="true">3.8.</strong> 生产实践 |「译」1password 的 Rust 实践</a></li><li class="chapter-item expanded "><a href="chapter_1/cita_protobuf-ext.html"><strong aria-hidden="true">3.9.</strong> 生产实践 | Cita: 用Rust写Protobuf扩展</a></li><li class="chapter-item expanded "><a href="chapter_1/rust-design-patterns/builder.html"><strong aria-hidden="true">3.10.</strong> 学习园地 | 「系列」Rust设计模式之创建者模式</a></li><li class="chapter-item expanded "><a href="chapter_1/io_uring_and_rust.html"><strong aria-hidden="true">3.11.</strong> 学习园地 | 关于 io_uring 与 Rust 的思考</a></li><li class="chapter-item expanded "><a href="chapter_1/graphql_in_rust/graphql_in_rust.html"><strong aria-hidden="true">3.12.</strong> 学习园地 | 「译」 GraphQL in Rust</a></li><li class="chapter-item expanded "><a href="chapter_1/rust_ownership.html"><strong aria-hidden="true">3.13.</strong> 学习园地 | 图解 Rust 所有权与生命周期</a></li><li class="chapter-item expanded "><a href="chapter_1/embedded_rust.html"><strong aria-hidden="true">3.14.</strong> 嵌入式领域的Rust语言</a></li><li class="chapter-item expanded "><a href="chapter_1/rcore_intro.html"><strong aria-hidden="true">3.15.</strong> 用Rust写操作系统 | rCore OS 教程介绍 </a></li><li class="chapter-item expanded "><a href="chapter_1/rust_security_part1.html"><strong aria-hidden="true">3.16.</strong> Rust Security 专题 | Rust生态安全漏洞总结系列 | Part 1</a></li><li class="chapter-item expanded "><a href="chapter_1/rustc_dev_guide_zh.html"><strong aria-hidden="true">3.17.</strong> Rust编译器专题 | Rust Dev Guide 中文翻译启动招募</a></li><li class="chapter-item expanded "><a href="chapter_1/rustc_part1.html"><strong aria-hidden="true">3.18.</strong> Rust编译器专题 | 图解 Rust 编译器与语言设计 Part 1</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> 二月刊（February）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> 三月刊（March）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">6.</strong> 四月刊（April）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> 五月刊（May）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> 六月刊（June）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> 七月刊（July）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> 八月刊（August）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> 九月刊（September）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">12.</strong> 十月刊（October）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">13.</strong> 十一月刊（November）| 待发布</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">14.</strong> 十二月刊（December）| 待发布</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">rust-magazine</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust语言开源杂志2021" id="rust语言开源杂志2021">Rust语言开源杂志（2021）</a></h1>
<p><strong>The roots aren't deep but the seeds are planted!</strong></p>
<p><img src="./image/rust_magazine3.png" alt="logo" /></p>
<p>为了丰富 Rust 社区成员的学习文化生活而特别推出此刊！</p>
<ul>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/">点此阅读</a></li>
<li><a href="https://github.com/RustMagazine/rust_magazine_2021">仓库地址</a></li>
</ul>
<hr />
<h3><a class="header" href="#编辑小组" id="编辑小组">编辑小组</a></h3>
<ul>
<li>
<p>张汉东（Chaos）</p>
</li>
<li>
<p><a href="https://www.yuque.com/lidongjies">李冬杰</a></p>
</li>
<li>
<p>柴杰</p>
</li>
<li>
<p><a href="https://github.com/DaviRain-Su">苏胤榕（DaviRain）</a></p>
</li>
<li>
<p>聂雷海（大海）</p>
</li>
<li>
<p>严炳（ryan）</p>
</li>
<li>
<p><a href="https://github.com/wangshengfei/">橘梦</a></p>
</li>
<li>
<p>&lt;其他成员招募位&gt; 招募条件见下方</p>
</li>
</ul>
<h3><a class="header" href="#编辑招募条件" id="编辑招募条件">编辑招募条件</a></h3>
<ul>
<li>热爱 Rust 语言</li>
<li>有时间参与编辑文章</li>
<li>有学习的心态</li>
</ul>
<p>有意者请联系。</p>
<h3><a class="header" href="#发刊渠道" id="发刊渠道">发刊渠道</a></h3>
<ul>
<li><a href="https://rustcc.cn">Rustcc 中文社区</a></li>
<li><a href="https://t.me/rust_daily_news">Rust 视界 Tg Channel</a></li>
<li><a href="https://juejin.cn/user/123560414944158">掘金</a></li>
<li><a href="https://talk.citahub.com">CITAHub社区</a></li>
</ul>
<h3><a class="header" href="#支持公司和高校" id="支持公司和高校">支持公司和高校</a></h3>
<p>感谢以下公司和高校大力支持 RustMagazine并贡献内容，排名不分先后。</p>
<ul>
<li>华为</li>
<li>PingCAP</li>
<li>蚂蚁集团</li>
<li>溪塔科技</li>
<li>国汽智控</li>
<li>清华大学</li>
<li>期待更多</li>
</ul>
<h3><a class="header" href="#特别感谢" id="特别感谢">特别感谢</a></h3>
<ul>
<li>Rustcc 中文社区</li>
<li>《Rust 日报》小组全体成员</li>
<li>《Rust 唠嗑室》组织者和全体参与者</li>
</ul>
<h3><a class="header" href="#许可" id="许可">许可</a></h3>
<p><img src="./image/cc.png" alt="cc" /></p>
<p>本电子杂志采用「<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-Hans">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)许可协议</a>」进行许可，非商业性转载请注明出处，其他需求请与我们联系。</p>
<h1><a class="header" href="#创刊寄语" id="创刊寄语">创刊寄语</a></h1>
<p><em>作者：张汉东</em></p>
<p><strong>The roots aren't deep but the seeds are planted!</strong></p>
<p>自从<code>2015</code>年<code>5</code>月<code>15</code>号 <code>Rust 1.0</code> 稳定版发布以来，<code>Rust</code>发展已经经历了五个半年头。</p>
<p>头三个年头，<code>Rust</code>发展是缓慢的。直到<code>Rust 2018 Edition</code>发布开始，<code>Rust</code>便逐渐开始走入各大企业。我在<code>2018</code>年发起《<code>Rust</code>日报》之初，全球范围内应用<code>Rust</code>的动态还是寥寥无几，我还在发愁去哪里寻找<code>Rust</code>的动态。但是到了<code>2020</code>年底，《<code>Rust</code>日报》已经不再为<code>Rust</code>动态而发愁，几乎每天都会有新的项目和文章冒出来，覆盖了<code>Rust</code>应用领域的方方面面。足以见证<code>Rust</code>的发展趋势。</p>
<p>然而，这些<code>Rust</code>动态，有<code>90%</code>都是出自国外社区。其实近两年，<code>Rust</code>在国内也陆陆续续有一些公司开始采用，国内也逐渐看了一些优秀的<code>Rust</code>学习原创文章。在去年 <code>RustChinaConf2020</code>大会上，我们也看到了很多国内公司和开源社区的个人项目。然而，目前国内各大应用<code>Rust</code>的公司和<code>Rust</code>社区都还缺乏很多原创的精品输出，或者，有很多精品输出，还被隐藏在互联网信息洪流中，未被我们发现。</p>
<p>在当前的这种背景环境下，办一份电子杂志的想法就由此诞生了。所以，各位<code>Rustacean</code>们，《<code>Rust</code>中文精选》今天创刊了！</p>
<p>《<code>Rust</code>中文精选》的目标就是要连接公司、社区、高校和个体，挖掘更多国内的<code>Rust</code>领域的精品原创内容，让大家沟通有无。《<code>Rust</code>中文精选》将是永久开源和非商业化的。</p>
<p><img src="./image/rustmagazine-connect.png" alt="rustmagzine_connect" /></p>
<p>《<code>Rust</code>中文精选》每月最后一天正式发刊，提供三种阅读方式：</p>
<ul>
<li>在线阅读。大家可以通过我们指定的渠道找到本刊的阅读入口，点击链接可直接在线阅读。暂时是通过<code>GitHub Page</code>，回头找时间在 <code>Gitee</code> 上面发布。</li>
<li>本地阅读。你也可以通过本刊源码仓库直接获取杂志，在本地执行<code>mdbook build &amp;&amp; mdbook watch --open</code> 就可阅读。</li>
<li>PDF 电子版。可以通过GitHub仓库和指定渠道下载。</li>
</ul>
<p>本刊内容希望涵盖且不限于以下内容：</p>
<ul>
<li><strong>Rust 本月简报</strong>。 从《<code>Rust</code> 日报》中摘录和整理本月的亮点。</li>
<li><strong>Rust in Production</strong>。介绍 <code>Rust</code> 在企业内的一些生产实践和心得。</li>
<li><strong>开源项目</strong>。从应用到实现原理和细节，介绍 <code>Rust</code> 的一些优秀开源项目。</li>
<li><strong>Rust 语言</strong>。 分享 <code>Rust</code> 语言概念、技巧、设计模式、工程实践等心得经验。</li>
<li><strong>Rust 编译器</strong>。分享 <code>Rust</code> 编译器整体架构、实现细节、贡献。</li>
<li><strong>Rust Security</strong>。分享 <code>Rust</code> 语言及生态中的一些安全漏洞诞生的原因和解决方案。</li>
<li><strong>游戏开发</strong>。分享 <code>Rust</code> 游戏开发和学习的方方面面。</li>
<li><strong>操作系统</strong>。分享 <code>Rust</code> 操作系统开发和学习的方方面面。</li>
<li><strong>嵌入式 Rust</strong>。分享 <code>Rust</code> 嵌入式开发中的点点滴滴。</li>
<li><strong>分布式开发</strong>。分享 <code>Rust</code> 在分布式领域的实践。</li>
<li><strong>网络开发</strong>。分享 <code>Rust</code> 网络开发领域的方方面面。</li>
<li><strong>云原生</strong>。分享 <code>Rust</code> 在云原生领域的实践。</li>
<li><strong>前端开发</strong>。 分享 <code>Rust</code> 和 <code>WebAssembly</code> 在前端的应用实践。</li>
<li><strong>图形化开发</strong>。分享 <code>Rust</code> 在 图形化开发方面的实践。</li>
<li><strong>大数据/人工智能</strong>。分享 <code>Rust</code> 在 大数据和人工智能开发方面的实践。</li>
<li><strong>Rust 算法</strong>。用 <code>Rust</code> 刷算法是什么体验？</li>
</ul>
<p>希望大家能踊跃投稿和参与编辑。可以直接给本刊<code>GitHub</code>仓库发<code>PR</code>，哪怕不一定能被入选，也可以发出你的声音！每个月一期，意味着你每个月精下心来创作一份精品文章，用来总结你在公司的实践和学习<code>Rust</code>的心得。</p>
<p>也希望越来越多的公司参与到期刊内容建设中来，对公司而言，不仅仅是经验分享，更是一种技术文化输出。</p>
<p><strong>在这浮躁的年代，希望这份期刊能帮助你找回技术的初心和野望。</strong></p>
<h1><a class="header" href="#一月刊" id="一月刊">一月刊</a></h1>
<p><img src="chapter_1/../image/rust_magazine3.png" alt="logo" /></p>
<h3><a class="header" href="#本月社区动态简报" id="本月社区动态简报">本月社区动态简报</a></h3>
<p>精选自《Rust日报》</p>
<ul>
<li><a href="chapter_1/./lang.html">Rust官方动态</a></li>
<li><a href="chapter_1/./hots.html">社区热点</a></li>
<li><a href="chapter_1/./projects.html">推荐项目</a></li>
<li><a href="chapter_1/./learns.html">学习资源</a></li>
<li><a href="chapter_1/./rust_laoke.html">Rust 唠嗑室本月汇总</a></li>
</ul>
<h3><a class="header" href="#rustchinaconf-2020-专题" id="rustchinaconf-2020-专题">RustChinaConf 2020 专题</a></h3>
<ul>
<li><a href="chapter_1/./jit.html">RustChinaConf2020 精选 | 用Rust设计高性能JIT执行引擎</a></li>
<li><a href="chapter_1/./rust_async.html">RustChinaConf2020 精选 | Rust 异步与并发</a></li>
</ul>
<h3><a class="header" href="#rust-in-production" id="rust-in-production">Rust in Production</a></h3>
<ul>
<li><a href="chapter_1/./1password.html">「翻译」1password 的 Rust 实践</a></li>
<li><a href="chapter_1/./cita_protobuf-ext.html">Cita: 用Rust写Protobuf扩展</a></li>
</ul>
<h3><a class="header" href="#学习园地" id="学习园地">学习园地</a></h3>
<ul>
<li><a href="chapter_1/./design_pattern.html">「系列」Rust设计模式</a></li>
<li><a href="chapter_1/./io_uring_and_rust.html">关于 io_uring 与 Rust 的思考</a></li>
<li><a href="chapter_1/./graphql_in_rust/graphql_in_rust.html">GraphQL in Rust</a></li>
<li><a href="chapter_1/./rust_ownership.html">图解 Rust 所有权与生命周期</a></li>
</ul>
<h3><a class="header" href="#嵌入式-rust-专题" id="嵌入式-rust-专题">嵌入式 Rust 专题</a></h3>
<ul>
<li><a href="chapter_1/./embedded_rust.html">嵌入式领域的Rust语言</a></li>
</ul>
<h3><a class="header" href="#操作系统专题" id="操作系统专题">操作系统专题</a></h3>
<ul>
<li><a href="chapter_1/./rcore_intro.html">用<code>Rust</code>写操作系统 | 清华 rCore OS 教程介绍 </a></li>
</ul>
<h3><a class="header" href="#rust-security-专题" id="rust-security-专题">Rust Security 专题</a></h3>
<ul>
<li><a href="chapter_1/./rust_security_part1.html"><code>Rust</code>生态安全漏洞总结系列 | Part1</a></li>
</ul>
<h3><a class="header" href="#rust-编译器专题" id="rust-编译器专题">Rust 编译器专题</a></h3>
<ul>
<li><a href="chapter_1/./rustc_dev_guide_zh.html">Rustc Dev Guide 中文翻译启动</a></li>
<li><a href="chapter_1/./rustc_part1.html">图解 Rust 编译器与语言设计 | Part 1</a></li>
</ul>
<h1><a class="header" href="#本月简报官方动态" id="本月简报官方动态">本月简报：官方动态</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
<li>专题编辑：张汉东</li>
</ul>
<hr />
<h2><a class="header" href="#rust-149-稳定版发布" id="rust-149-稳定版发布">Rust 1.49 稳定版发布</a></h2>
<p>2020年最后一天，Rust 1.49 稳定版发布了。稳定版 Rust 发布周期为六周一次。</p>
<p>值得关注的更新：</p>
<ul>
<li><code>aarch64-unknown-linux-gnu</code> 升级为<code>Tier 1</code>。</li>
<li><code>aarch64-apple-darwin</code> 和<code>aarch64-pc-windows-msvc</code> 得到<code>Tier 2</code> 级别的支持。</li>
<li>单元测试中线程中的print输出将会被捕获，默认不会在控制台打印出来了。如果不- 需要捕获，需要添加--nocapture参数。</li>
<li><code>union</code>支持 <code>impl Drop trait</code> 了
支持使用<code>ref</code>关键字让解构的字段不再被move 而是被借用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main(){
    let person = Person {
    name: String::from(&quot;Alice&quot;),
    age: 20,
    };

    // `name` is moved out of person, but `age` is referenced.
    let Person { name, ref age } = person;
    println!(&quot;{} {}&quot;, name, age);
}

</code></pre></pre>
<p><a href="https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html">https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html</a></p>
<h2><a class="header" href="#rust-将不再支持-windows-xp" id="rust-将不再支持-windows-xp">Rust 将不再支持 Windows XP</a></h2>
<p>目标i686-pc-windows-msvc和x86_64-pc-windows-msvc是个怪胎。它们对Windows 7+有Tier 1支持，但对Windows XP也有Tier 3支持。这是Firefox需要在XP上运行时的遗留问题。然而在他们放弃XP支持后的几年里，尽管偶尔会有修复，但大多都是任由它过期了。</p>
<p>因此有人建议，正式放弃这个Tier 3支持状态，可以更好地反映出目前对XP的实际支持程度，不再让一个Tier 1目标背负着实际上不支持Tier 3目标的担忧。</p>
<p>只要LLVM和他们的链接器仍然支持XP目标，移除官方的XP支持不会阻止任何人编译到XP（减去std）。</p>
<p>对Windows 7以上的目标的影响将是移除工作区和一个支持XP的运行时兼容性层。此外，还有可能使用更现代的API，而这些API可能曾经因为兼容性问题而被避免。</p>
<p>如果在未来，有人积极支持XP，那么最好的办法是为此创建一个新的目标。这可以从其自身的优点出发，而且它的开发不会影响到一级平台的开发。</p>
<p>官方团队接受了该建议。</p>
<p><a href="https://github.com/rust-lang/compiler-team/issues/378">https://github.com/rust-lang/compiler-team/issues/378</a></p>
<h2><a class="header" href="#rustup-宣布发布-1230-版本" id="rustup-宣布发布-1230-版本">Rustup 宣布发布 1.23.0 版本</a></h2>
<p>官方发布 1.23.0 版本，其中最激动人心的改变就是支持 Apple M1 设备。大家可以安心的买 M1 了！</p>
<p><a href="https://blog.rust-lang.org/2020/11/27/Rustup-1.23.0.html">原文链接</a></p>
<h2><a class="header" href="#rust-官方知名开发者陆续入职巨头科技公司" id="rust-官方知名开发者陆续入职巨头科技公司">Rust 官方知名开发者陆续入职巨头科技公司</a></h2>
<p><strong>Niko Matsakis，Esteband K 入职 Amazon</strong></p>
<p>Niko Matsakis 入职 Amazon 担任 Rust 团队的技术主管。</p>
<pre><code>Niko的博客链接: https://smallcultfollowing.com/babysteps/blog/2020/12/30/the-more-things-change/
</code></pre>
<p>Esteband K 入职 Amazon 研究 Rust 编译器和相关工具。</p>
<pre><code>Twitter 链接：https://mobile.twitter.com/ekuber/status/1345218814087053312
</code></pre>
<p><strong>Patrick Walton 入职 Facebook</strong></p>
<p>Patrick Walton 将领导 Facebook 的新 Rust 团队，致力于为 Rust 社区改善其编译器和生态。</p>
<pre><code>Twitter 链接：https://twitter.com/pcwalton/status/1345094455712333824
</code></pre>
<h2><a class="header" href="#futures-rs-039-发布" id="futures-rs-039-发布">futures-rs 0.3.9 发布</a></h2>
<ul>
<li>把<code>pin-project</code>这个<code>crate</code>替换成了<code>pin-project-lite</code>, 在<code>--no-default-features</code>的情况下大幅提高了编译速度.</li>
<li>增加了几个新的API方法
<ul>
<li>stream::repeat_with</li>
<li>StreamExt::unzip</li>
<li>sink::unfold</li>
<li>SinkExt::feed</li>
</ul>
</li>
</ul>
<p>链接：<a href="https://github.com/rust-lang/futures-rs/releases/tag/0.3.9">https://github.com/rust-lang/futures-rs/releases/tag/0.3.9</a></p>
<h2><a class="header" href="#rust官方项目工作组的工作范围是什么" id="rust官方项目工作组的工作范围是什么">Rust官方项目工作组的工作范围是什么？</a></h2>
<p>该小组的主要重点是继续进行小组成立前的错误处理相关工作。为此而努力系统地解决与错误处理相关的问题，以及消除阻碍RFC停滞不前的障碍。</p>
<p>在小组成立的最初几次会议上，制定了一些短期和长期目标，这些目标主要围绕下面三个主题：</p>
<ul>
<li>使 <code>Error</code> trait 在生态中应用更加普及。</li>
<li>提升错误处理的开发体验。</li>
<li>编写更多的关于错误处理的学习资源。</li>
</ul>
<p>下面具体来说。</p>
<p><strong>建立统一的标准<code>Error</code> trait。</strong></p>
<p><code>Error</code> trait 从 <code>1.0</code>开始就存在了，并暴露了两个方法。<code>Error::description</code>和<code>Error::cause</code>。由于它最初的构造，由于一些原因，它太过拘谨。<code>Failure</code> crate通过导出Fail trait解决了Error trait的许多缺点。</p>
<p>在这一点上，加强<code>std::error::Error</code> trait，使其可以作为<code>Error</code> trait被整个Rust社区采用，自2018年8月RFC 2504被合并以来，一直是一个持续的过程。</p>
<p>这个过程还涉及稳定许多<code>Error</code> trait API和<code>crates</code>，截至本文撰写时，这些API和crates只在Nightly使用。这些包括backtrace和chain方法，这两种方法对于处理错误类型非常有用。如果你有兴趣关注或贡献这项工作，请看一下这个问题。</p>
<p>另一个相关的举措是将<code>Error</code> trait迁移到核心，这样它就可以更广泛地用于不同的场景（比如在FFI或嵌入式上下文中）。</p>
<p><strong>增加通过回溯（backtrace）类型进行迭代的能力</strong></p>
<p>到目前为止，<code>backtrace</code> 类型只实现了<code>Display</code>和<code>Debug</code>特征。这意味着使用回溯类型的唯一方法是打印出来，这不是很理想。一个能够提供迭代堆栈框架的迭代器API将使用户能够控制他们的反向跟踪如何被格式化，这是一个必要的步骤，将<code>std::backtrace::Backtrace</code>支持添加到像<code>color-backtrace</code>这样的箱子中。</p>
<p>在研究了如何解决这个问题的策略后，我们发现回溯箱已经有了一个框架方法，可以很好地实现<code>Iterator</code> API。在std中公开一个相同的方法应该是一个相对简单的考验。</p>
<p>我们已经为此开了一个<code>[PR](https://github.com/rust-lang/rust/pull/78299)</code>，如果有人想看的话，可以去看看。</p>
<p><strong>通用成员访问</strong></p>
<p>目前，当我们想要获取一些与错误相关的额外上下文时，需要调用一些特定的方法来获取该上下文。例如，如果要查看一个错误的回溯，我们会调用回溯方法： <code>let backtrace = some_error.backtrace();</code>。这种方法的问题是，它不可能支持在<code>std</code>之外定义的类型。即使是存在于<code>std</code>内的类型，也需要定义一个方法来访问每个各自的类型，这使得事情变得很麻烦，而且更难维护。</p>
<p>顾名思义，通用成员访问，当它得到实现时，是一种类型无关的方法，可以从<code>Error</code> trait对象中访问不同的上下文。这有个类比示例，当你要把一个字符串解析成一个数字的时候，用这样的方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ten = &quot;10&quot;.parse::&lt;i32&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>或者通过迭代器来collect生成的内容时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

let a_to_z_set = ('a'..='z').collect::&lt;HashSet&lt;_&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>跟上面用法类似，您可以通过指定错误的类型ID来访问某个上下文片段。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let span_trace = some_error.context::&lt;&amp;SpanTrace&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>这可以用来获取与错误相关的其他上下文，如错误的回溯、错误的来源、状态码、替代的格式化表示（如&amp;dyn Serialize）。</p>
<p>这个功能将使我们计划在以后添加的其他功能成为可能，比如提供一种方法来报告程序中错误来源的所有位置，以及提供一种除了显示和调试之外的更一致的错误报告格式。</p>
<p>Jane在推动这些想法上做了很多工作。你可以查看相关的<a href="https://github.com/rust-lang/rfcs/pull/2895">RFC</a>。</p>
<p><strong>编写一本<code>Rust</code>错误处理最佳实践的书</strong></p>
<p>最后但并非最不重要的一点是，围绕创作<a href="https://github.com/rust-lang/project-error-handling">The Rust Error Book</a>的团队引起了很多兴趣。 本书的目的是根据各自的用例来整理和交流不同的错误处理最佳实践。 这可能包括FFI用例，或有关从程序返回错误代码的最佳实践。</p>
<p>这是一项持续不断的工作，在接下来的几周和几个月中将会看到许多进步！</p>
<p><strong>脚注</strong></p>
<ul>
<li><code>Error::description</code>方法只支持字符串片段，这意味着创建包含附加上下文的动态错误信息是不直接的。这个方法被弃用，改用<code>Display</code>。</li>
<li><code>Error::cause</code>方法，现在被称为<code>Error::source</code>，并没有强制要求错误具有 &quot;静态生命周期&quot;，这意味着 downcasting 错误源是不可能的，这使得使用动态错误处理程序来处理错误变得更加困难。</li>
</ul>
<h2><a class="header" href="#rustdoc-性能提升" id="rustdoc-性能提升">Rustdoc 性能提升</a></h2>
<p>有两个PR明确地旨在提高rustdoc的性能：</p>
<ul>
<li>Rustdoc：缓存已解析的链接<a href="https://github.com/rust-lang/rust/pull/77700">＃77700</a>。该<code>PR</code>将文档生成的链接的时间缩短了 <code>90%</code>。</li>
<li>不要在文档内链接中寻找覆盖实现（blanket-impls）<a href="https://github.com/rust-lang/rust/pull/79682">＃79682</a>。因为它从来没有起过作用，并且已经引起了严重的性能问题。</li>
</ul>
<p>Rustdoc 团队还清理了一些技术债务。比如 <code>jyn514</code> 不久前注意到，Rustdoc中的大部分工作都是重复的: 实际上有三种不同的抽象语法树(ast)！一个用于doctree，一个用于clean，还有一个是编译器使用的原始HIR。Rustdoc花费了大量的时间在它们之间进行转换。大部分的速度改进来自于完全去掉部分AST。</p>
<p>文章里也介绍了Rustdoc的工作原理：</p>
<ul>
<li>运行编译器的某些部分以获得需要的信息。</li>
<li>删除编译器提供的不需要的信息（例如，如果一个项目是doc(hidden)，就不需要它）。这一部分有很多话要说，也许会再写一篇博文来详细介绍。</li>
<li><code>doctree pass</code>，它在编译器的某些项目上添加了一些<code>rustdoc</code>需要的额外信息。</li>
<li><code>clean pass</code>将编译器类型转换为<code>rustdoc</code>类型：基本上，它将所有内容都转换为 &quot;可打印 &quot;内容。</li>
<li>渲染（render）通证，然后生成所需的输出（HTML 或，在Nightly，JSON）</li>
</ul>
<p>更多内容： <a href="https://blog.rust-lang.org/inside-rust/2021/01/15/rustdoc-performance-improvements.html">https://blog.rust-lang.org/inside-rust/2021/01/15/rustdoc-performance-improvements.html</a></p>
<h2><a class="header" href="#nightly的reference已上线const-generics的文档" id="nightly的reference已上线const-generics的文档">Nightly的Reference已上线Const Generics的文档</a></h2>
<p>Const Generics 计划在1.50版进入stable，官方今天在nightly的Reference上已更新好相关文档。</p>
<p>链接：<a href="https://doc.rust-lang.org/nightly/reference/items/generics.html#const-generics">https://doc.rust-lang.org/nightly/reference/items/generics.html#const-generics</a></p>
<h2><a class="header" href="#nightly-edition-guide-文档增加了-rust-2021-edition-小节" id="nightly-edition-guide-文档增加了-rust-2021-edition-小节">Nightly Edition Guide 文档增加了 Rust 2021 Edition 小节</a></h2>
<p>内容还在逐步更新，可以先关注。</p>
<p>链接： <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-next/index.html">https://doc.rust-lang.org/nightly/edition-guide/rust-next/index.html</a></p>
<h2><a class="header" href="#rfc-2945--c-unwind-abi-支持相关情况" id="rfc-2945--c-unwind-abi-支持相关情况">RFC 2945 : &quot;C unwind&quot; ABI 支持相关情况</a></h2>
<p>官方 FFI-Unwind 项目工作组已经将 RFC 2945 合并了。该 RFC 描述了对 &quot;C unwind&quot; ABI 的支持。</p>
<p>RFC 概要：</p>
<blockquote>
<p>引入了一个新的<code>ABI</code>字符串“<code>C-unwind</code>”，以支持从其他语言(如c++)到Rust框架的<code>unwind</code>，以及从<code>Rust</code>到其他语言的<code>unwind</code>。此外，当<code>unwind</code>操作以“non <code>Rust</code>”、“non <code>C-unwind</code>”ABI到达<code>Rust</code>函数边界时，我们为之前未定义的有限几种情况定义了行为。作为该规范的一部分，我们引入了术语“Plain Old Frame”(POF)。POF帧不会挂起析构函数，可以轻松地释放析构函数。这个RFC没有定义被外部异常展开的Rust框架中的catch unwind行为。</p>
</blockquote>
<p>引入动机：</p>
<blockquote>
<p>有些Rust项目需要跨语言展开以提供所需的功能。 一个主要的例子是<code>Wasm</code>解释器，包括<code>Lucet</code>和<code>Wasmer</code>项目。</p>
<p>还有一些现有的<code>Rust</code> crate（尤其是围绕libpng和libjpeg C库的包装器）会在<code>C</code>帧之间出现混乱。 这种展开的安全性取决于Rust的展开机制与<code>GCC</code>，<code>LLVM</code>和<code>MSVC</code>中的本机异常机制之间的兼容性。 尽管使用了兼容的展开机制，但是当前的<code>rustc</code>实现假定“extern <code>C</code>”函数无法展开，这允许LLVM在这种展开构成未定义行为的前提下进行优化。</p>
<p>之前已经在其他RFC（包括＃2699和＃2753）上讨论了对此功能的需求。</p>
</blockquote>
<p>RFC 2945: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md">https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md</a></p>
<p>现在 FFI-unwind 工作组正在为<code>C-unwind</code> ABI 指定新的行为（覆盖之前的未定义的行为），<a href="https://github.com/rust-lang/rust/pull/76570">RFC 2945 实现PR</a>。</p>
<p>然而，在起草 &quot;<code>C unwind</code> &quot; RFC 时，工作组发现围绕<code>longjmp</code>和类似函数的现有保证可以改进。虽然这与<code>unwind</code>并没有严格的关系，但它们有着密切的联系：它们都是 <code>non-local</code> 的控制流机制，防止函数正常返回。由于<code>Rust</code>项目的目标之一是让<code>Rust</code>与现有的<code>C</code>系语言互操作，而这些控制流机制在实践中被广泛使用，工作组认为<code>Rust</code>必须对它们有一定程度的支持。</p>
<p>这篇博文将解释该问题。如果你有兴趣帮助指定这种行为，欢迎参与!</p>
<p>官方博文地址：<a href="https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html">https://blog.rust-lang.org/inside-rust/2021/01/26/ffi-unwind-longjmp.html</a></p>
<h2><a class="header" href="#rust-playground-支持-vim-模式" id="rust-playground-支持-vim-模式">Rust Playground 支持 vim 模式</a></h2>
<p>Rust Playground <code>vim</code> 模式，可以通过输入 <code>:w</code> 回车运行编译，非常棒的使用体验。</p>
<h1><a class="header" href="#本月简报--社区热点" id="本月简报--社区热点">本月简报 | 社区热点</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：Rust 日报小组</li>
</ul>
<h2><a class="header" href="#async-std-v190-发布" id="async-std-v190-发布">Async-std v1.9.0 发布</a></h2>
<p>这个版本发布了稳定的 <code>async_std::channel</code> 子模块，并引入了 tokio v1.0 的功能，同时，移除了不赞成使用的<code>sync::channel</code>类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_std::channel;

let (sender, receiver) = channel::unbounded();

assert_eq!(sender.send(&quot;Hello&quot;).await, Ok(()));
assert_eq!(receiver.recv().await, Ok(&quot;Hello&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>链接，<a href="https://github.com/async-rs/async-std/releases/tag/v1.9.0">https://github.com/async-rs/async-std/releases/tag/v1.9.0</a></p>
<h2><a class="header" href="#deno-in-2020" id="deno-in-2020">Deno in 2020</a></h2>
<p>一直很火热的 Deno 官方最近发布了 Deno 的<a href="https://deno.land/posts/deno-in-2020">大事记表</a>。
其中 1 月份进行了将 libdeno 替换成 rusty_v8 的工作。之前是使用 libdeno（C++ 写的） 来进行绑定 V8 的操作。现在替换成 Rust 原生实现的 rusty_v8。并且 rusty_v8 是一个单独的 Rust crate。</p>
<h2><a class="header" href="#the-rust-on-raspberry-pi-pico-charity-live-stream" id="the-rust-on-raspberry-pi-pico-charity-live-stream">The Rust on Raspberry Pi Pico Charity Live Stream</a></h2>
<p>在树莓派上写 Rust 是一种怎样的体验？最近一位国外友人就尝试这么做了，并且进行了直播。具体详情可以<a href="https://www.reddit.com/r/rust/comments/l39jdo/the_rust_on_raspberry_pi_pico_charity_live_stream/">戳此链接</a>。
Rust 在嵌入式开发领域还是有非常大的潜力的。</p>
<p>想要看更多关于 Rust 的流媒体视频，可以关注这个项目 <a href="https://github.com/jamesmunns/awesome-rust-streaming">awesome-rust-streaming</a></p>
<h2><a class="header" href="#sequoia-pgp-发布-10-版本" id="sequoia-pgp-发布-10-版本">Sequoia PGP 发布 1.0 版本</a></h2>
<p>2018 年，三位 GnuPG 开发者开始着手开发 Sequoia，这是 OpenPGP 在 Rust 中的实现版本。OpenPGP 是一种非专有协议，为加密消息、签名、私钥和用于交换公钥的证书定义了统一标准。</p>
<p>通过<a href="https://sequoia-pgp.org/blog/2020/12/16/202012-1.0/">官方博客</a>可以看出团队对当前版本对于安全性的思考和对未来下一步的规划。</p>
<h2><a class="header" href="#firecracker" id="firecracker">Firecracker</a></h2>
<p>Firecracker 是一种开源虚拟化技术，专门用于创建和管理安全的，多租户容器和基于功能的服务。</p>
<p><a href="https://github.com/firecracker-microvm/firecracker">项目地址</a></p>
<h2><a class="header" href="#rust-gui-编程介绍" id="rust-gui-编程介绍">Rust GUI 编程介绍</a></h2>
<p>Rust GUI 方面的介绍以及目前 Rust GUI 库的现阶段状况</p>
<p><a href="https://dev.to/davidedelpapa/rust-gui-introduction-a-k-a-the-state-of-rust-gui-libraries-as-of-january-2021-40gl#comments">原文链接</a></p>
<h2><a class="header" href="#facebook-使用-rust-的简单介绍" id="facebook-使用-rust-的简单介绍">Facebook 使用 Rust 的简单介绍</a></h2>
<p>该 twitter 快速的介绍了 Rust 在 facebook 中的使用历程:</p>
<p>2017 年开始应用于一个资源控制项目，后来证明性能和稳定性都比 C++好。
之后，更多的工程师开始使用 Rust 在各种项目中，例如 Diem，Hack，Mononoke。
在 dev tools 中证明 Rust 可行之后, 开始在后端和手机应用中使用 Rust
很多工程师来自 python 和 javascript 语言，Rust 的强类型和高性能让这些工程师不再挣扎于运行时的 bug。
为了让 Rust 更广泛的使用，设立了一个专门的 Rust 小组来支持其他的工程师在不同的项目中使用 Rust。 该小组同时在 Rust 社区中也非常活跃，贡献代码。</p>
<p><a href="https://twitter.com/alexvoica/status/1350049393471324161">原文链接</a></p>
<h2><a class="header" href="#时隔一年-tower-终于发布新版本啦" id="时隔一年-tower-终于发布新版本啦">时隔一年 tower 终于发布新版本啦</a></h2>
<p>Tower 是一个模块化和可重用组件库，用于构建健壮的网络客户端和服务器。上一个版本 0.3.1 版本是 2020 年 1 月 17 发布的，新版本 0.4.0 是 2021 年 1 月 7 号发布的，这个版本包含了大量改动，包括使用了 tokio 1.0，将所有的中间件转移到了 tower crate，改造，添加了中间件 API。</p>
<p>不过这次变更并没有核心 Service 或者 Layer trait，所以新版本还是依赖着 tower- service 0.3 和 tower- layer 0.3，因此新版本是兼容使用这两个 crate 的库的。更多发布细节请移步下面的链接。</p>
<p><a href="https://github.com/tower-rs/tower/releases/tag/tower-0.4.0">原文链接</a></p>
<p><a href="https://crates.io/crates/tower/0.4.0">项目地址</a></p>
<h2><a class="header" href="#rust-search-extension-110-发布" id="rust-search-extension-110-发布">Rust Search Extension 1.1.0 发布</a></h2>
<p><a href="https://rust.extension.sh/">Rust Search Extension</a> 发布了最新版，同时也突破了 500 个 star，感谢大家的支持！这个版本主要功能如下：</p>
<ul>
<li>! 搜索改成了 docs.rs，!! 改成了 crates.io。</li>
<li>给 Rust 仓库的 release 页面增加了目录菜单。</li>
<li>Rust 标准库文档页面和源码页面所有 &quot;since&quot; 和 &quot;issue&quot; 标签分别会链接到仓库的 release 页面对应的版本和 GitHub 对应的 issue 页。</li>
</ul>
<h2><a class="header" href="#为什么-2021-年将成为系统程序员的-rust-年" id="为什么-2021-年将成为系统程序员的-rust-年">为什么 2021 年将成为系统程序员的 Rust 年？</a></h2>
<p>Gartner 今天的一篇博文报道了“Rust”：近年来，Rust 获得了很多粉丝，并且有充分的理由。Rust 旨在成为满足系统编程需求的 C++ 的可靠替代品。</p>
<p><a href="https://blogs.gartner.com/manjunath-bhat/2021/01/03/why-2021-will-be-a-rusty-year-for-system-programmers/">原文链接</a></p>
<h2><a class="header" href="#open-source-security-inc宣布为rust的gcc前端提供资金" id="open-source-security-inc宣布为rust的gcc前端提供资金">Open Source Security, Inc.宣布为Rust的GCC前端提供资金</a></h2>
<p>Open Source Security, Inc.宣布为Rust的GCC前端提供资金
开源安全公司（Open Source Security，Inc）自豪地宣布，它为Rust的GCC前端的全职和公共开发工作提供了资金。在此博客文章中，作者将详细介绍我们参与的动机以及公众将因这项努力而获得的利益。</p>
<p>原文链接 : <a href="https://opensrcsec.com/open_source_security_announces_rust_gcc_funding">https://opensrcsec.com/open_source_security_announces_rust_gcc_funding</a></p>
<h2><a class="header" href="#rust-gui框架的全调研" id="rust-gui框架的全调研">Rust GUI框架的全调研</a></h2>
<p>这篇文章对几乎目前Rust社区较为流行的GUI框架做了整体的调研，druid和iced表现还不错。</p>
<ul>
<li>原文链接： <a href="https://www.boringcactus.com/2020/08/21/survey-of-rust-gui-libraries.html">https://www.boringcactus.com/2020/08/21/survey-of-rust-gui-libraries.html</a></li>
<li>AreWeGuiYet 网站也可以看到 GUI 相关信息：<a href="https://www.areweguiyet.com/">https://www.areweguiyet.com/</a></li>
<li><a href="https://dev.to/davidedelpapa/rust-gui-introduction-a-k-a-the-state-of-rust-gui-libraries-as-of-january-2021-40gl#comments">另一篇<code>GUI</code>调研文章</a></li>
</ul>
<h2><a class="header" href="#redox-os-最近公布了2020年的财务明细" id="redox-os-最近公布了2020年的财务明细">Redox OS 最近公布了2020年的财务明细。</a></h2>
<p>主要的收入是通过捐赠，包括Patreon网站，paypal,和接收到的一些比特币和以太坊。 《Redox OS Summer of Code》是主要的支出预算，其他网站服务的支出，包括亚马逊的EC2，Jenkins服务器，Gitlab服务。</p>
<p>开源项目的明细能做到公开、明细还是非常值得社区学习的。</p>
<p>原文链接: <a href="https://www.redox-os.org/news/finances-2020/">https://www.redox-os.org/news/finances-2020/</a></p>
<h2><a class="header" href="#rust-官方团队-wesley-wiser-宣布入职微软" id="rust-官方团队-wesley-wiser-宣布入职微软">Rust 官方团队 Wesley Wiser 宣布入职微软</a></h2>
<p>From Twitter:</p>
<blockquote>
<p>Wesley Wiser: I'm very pleased to announce that I will be joining @Microsoftto work on the @rustlang compiler team they are forming!</p>
</blockquote>
<p>Wesley Wiser 在 twitter 宣布：加入微软，并且为「微软组织的<code>Rust</code>编译器团队」工作。Wesley Wiser 在 2020 年 12 月刚出任 官方 Rust 编译器团队 co-Leader。</p>
<p>到目前为止，编译器的三大 Leader ：Niko 和 Felix 去了亚马逊，Wesley Wiser 去了微软。之前 Facebook 也在招人组建 Rust 编译器团队，侧面反应出大厂们对 Rust 正在做战略布局。</p>
<p>原文链接：<a href="https://twitter.com/wesleywiser/status/1354896012113022984">https://twitter.com/wesleywiser/status/1354896012113022984</a></p>
<h1><a class="header" href="#本月简报--推荐项目" id="本月简报--推荐项目">本月简报 | 推荐项目</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：<code>Rust</code>日报小组</li>
</ul>
<h2><a class="header" href="#微软rust-for-windows" id="微软rust-for-windows">「微软」Rust for Windows</a></h2>
<ul>
<li><a href="https://github.com/microsoft/windows-rs">仓库链接</a></li>
<li><a href="https://microsoft.github.io/windows-docs-rs/doc/bindings/windows">文档链接</a></li>
<li><a href="https://crates.io/crates/windows">crate 链接</a></li>
</ul>
<p>这个仓库是 1 月 20 日微软发布的官方 Win32 API crate。</p>
<p>过去用 rust 为 Windows 开发应用程序时，若要调用 Win32 API，必须使用 <a href="https://github.com/retep998/winapi-rs">winapi-rs</a> 这样的 wrapper 库，此类库需要社区去人工维护和 Win32 API 的绑定。
为了改善这点，微软通过 <a href="https://github.com/microsoft/win32metadata">win32metadata</a> 项目来加强对 C/C++ 以外的编程语言的支持（<a href="https://blogs.windows.com/windowsdeveloper/2021/01/21/making-win32-apis-more-accessible-to-more-languages/">相关链接</a>），
其中就包括对 rust 的支持。</p>
<p>现在已经有使用该库实现的<a href="https://github.com/robmikh/minesweeper-rs">扫雷</a>程序, 除此之外，也有微软工程师发布了一些<a href="https://github.com/kennykerr/samples-rs">示例项目</a>。</p>
<h2><a class="header" href="#czkawka" id="czkawka">Czkawka</a></h2>
<ul>
<li><a href="https://github.com/qarmin/czkawka">仓库链接</a></li>
<li><a href="https://www.reddit.com/r/linux/comments/kjcbva/czkawka_200_multithread_support_similar_images/">reddit 讨论</a></li>
</ul>
<p><em>Czkawka</em> 是一个多平台的空间清理应用，可用于找出系统中的重复的文件、空文件夹、临时文件等。</p>
<p>项目采用 gtk3/gtk-rs 开发 GUI 部分, 同时也提供 CLI 程序。</p>
<p><img src="https://user-images.githubusercontent.com/41945903/103371136-fb9cae80-4ace-11eb-8d72-7b4c8ac44260.png" alt="czkawka" /></p>
<h2><a class="header" href="#artichoke" id="artichoke">Artichoke</a></h2>
<ul>
<li><a href="https://www.artichokeruby.org/">项目主页</a></li>
<li><a href="https://twitter.com/artichokeruby">推特主页</a></li>
<li><a href="https://github.com/artichoke/artichoke">仓库链接</a></li>
<li><a href="https://www.youtube.com/watch?v=QMni48MBqFw&amp;list=PLE7tQUdRKcyZDE8nFrKaqkpd-XK4huygU&amp;index=37">rubyconf 2019 上的相关演讲</a></li>
</ul>
<p><em>Artichoke</em> 是一个由 rust 开发的 ruby 实现，可以将 ruby 代码编译至 WebAssembly。</p>
<p>当前 Artichoke 依然依赖于 mruby backend，在与 mruby 进行 FFI 交互的同时，改进某些 Kernel 和库函数的实现。例如 <a href="https://github.com/artichoke/artichoke/tree/trunk/artichoke-backend/src/extn/core/regexp">regex</a> 部分就是由 rust 实现的。</p>
<p>作者表示在未来会开发出一个纯 rust 的实现。</p>
<h2><a class="header" href="#linfa" id="linfa">linfa</a></h2>
<ul>
<li><a href="https://github.com/rust-ml/linfa">仓库链接</a></li>
<li><a href="https://docs.rs/linfa/0.3.0/linfa/">文档链接</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/e4wh8c/linfa_taking_ml_to_production_with_rust_a_25x/">reddit 讨论</a></li>
</ul>
<p><em>linfa</em> 是一个机器学习的框架和工具集，其设计参照了 python 的 <code>scikit-learn</code> 库。</p>
<p>关于 rust 在机器学习方面的生态系统，可以参考 <a href="http://www.arewelearningyet.com/">arewelearningyet</a>。</p>
<h2><a class="header" href="#async-trait-static" id="async-trait-static">async-trait-static</a></h2>
<ul>
<li><a href="https://github.com/tiannian/async-trait-static">仓库链接</a></li>
<li><a href="https://docs.rs/async-trait-static/0.1.4/async_trait_static/">文档链接</a></li>
</ul>
<p><em>async-trait-static</em> 是一个用于在 trait 中声明 async 方法的库，可以在 <code>no_std</code> 下使用。</p>
<p>由于 rustc 的限制，<a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">要在 trait 中写出 async 方法是很困难的</a>。
针对这个问题，dtolnay 实现了 <a href="https://github.com/dtolnay/async-trait">async-trait</a>，将 <code>async fn</code> 的返回类型转化为 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code>。</p>
<p>async-trait-static 则采用了 GAT 来实现这个功能，无需用到 trait object。</p>
<p>当前 rust 的 GAT 依然不够完善，因此该库还是有些功能是缺失的。</p>
<h2><a class="header" href="#regexm" id="regexm">regexm</a></h2>
<ul>
<li><a href="https://github.com/TaKO8Ki/regexm">仓库链接</a></li>
<li><a href="https://docs.rs/regexm/0.1.0-beta.1/regexm/">文档链接</a></li>
<li><a href="https://github.com/TaKO8Ki/regexm/tree/main/examples">示例</a></li>
</ul>
<p><em>regexm</em> 是一个用于对正则表达式进行模式匹配的库：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let text1 = &quot;2020-01-01&quot;;
    regexm::regexm!(match text1 {
        r&quot;^\d{4}$&quot; =&gt; println!(&quot;y&quot;),
        r&quot;^\d{4}-\d{2}$&quot; =&gt; println!(&quot;y-m&quot;),
        // block
        r&quot;^\d{4}-\d{2}-\d{2}$&quot; =&gt; {
            let y_m_d = &quot;y-m-d&quot;;
            println!(&quot;{}&quot;, y_m_d);
        }
        _ =&gt; println!(&quot;default&quot;),
    });
}
</code></pre></pre>
<h2><a class="header" href="#swc" id="swc">swc</a></h2>
<ul>
<li><a href="https://swc.rs/">项目主页</a></li>
<li><a href="https://github.com/swc-project/swc">仓库链接</a></li>
</ul>
<p><em>swc</em> 是一个 typescript/javascript 的 transpiler，在运行速度上，单核比 babel 快 4 倍，4 核比 babel 快 70 倍，同时也具有 treeshaking 的功能。</p>
<p><em>swc</em> 被用于 deno 项目中，用于类型擦除。 swc 的作者是一名 97 年的大二学生，如今已经获得了 Deno 官方的顾问合同。</p>
<h2><a class="header" href="#rlink-rs" id="rlink-rs">rlink-rs</a></h2>
<p><em>国产项目</em></p>
<ul>
<li><a href="https://github.com/rlink-rs/rlink-rs">仓库链接</a></li>
</ul>
<p>rlink-rs是基于rust实现的流式计算引擎，用来作为Apache Flink的替代方案。</p>
<p>相对于在线业务，rlink-rs更关注海量数据的离线流式处理场景，提升吞吐能力、降低资源消耗。其特点是针对exactly once提供计算和输出两种语义；基于特殊的exactly once输出语义，结合rust内存管理模型，实现大部分场景的全内存计算，解决state和checkpoint引起的重量级IO操作。</p>
<p>rlink-rs的目标是成为一个计算驱动引擎，允许基于DAG定制你自己的计算流程、实现自己的计算语义。</p>
<p>目前状态：主要针对flink流计算这块做对比。已经实现基本窗口计算流程。</p>
<p>希望能从社区得到关于流引擎设计方面的帮助：</p>
<p>1.因为rust语言不如Java动态语言可以反射，在用户api上不那么优雅。
2.只是想在语义上实现类似flink的api，实现上还是想走一条新的路线，毕竟flink有历史包袱，它的实现我们不需要100%参考。</p>
<h2><a class="header" href="#rapier-2021的路线图" id="rapier-2021的路线图">Rapier 2021的路线图</a></h2>
<p>Rapier 是一个完全免费的开源物理引擎，可用于游戏，动画和机器人，完全使用 Rust 编程语言编写。 它着重于性能，可移植性和跨平台确定性（可选）。</p>
<p>Rapier 团队希望到2021年年底，Rapier 具有游戏物理引擎所期望的所有功能，实现流行的 C++ 物理引擎，比如：Box2d，Bullet Physics 和 PhysX 等同等的功能， 但是不打算在 GPU 上支持运行物理仿真。</p>
<p>2021 路线图链接：<a href="https://www.dimforge.com/blog/2021/01/01/physics-simulation-with-rapier-2021-roadmap/">https://www.dimforge.com/blog/2021/01/01/physics-simulation-with-rapier-2021-roadmap/</a></p>
<h2><a class="header" href="#psst使用rust和druid构建的第三方spotify客户端" id="psst使用rust和druid构建的第三方spotify客户端">Psst：使用Rust和Druid构建的第三方Spotify客户端</a></h2>
<ul>
<li><a href="https://github.com/jpochyla/psst">仓库链接</a></li>
</ul>
<p>Psst 是一款GUI的快速Spotify客户端，不带Electron，内置Rust。</p>
<p><a href="https://www.reddit.com/r/rust/comments/ksgtk7/druid_v070/">Druid</a>是一个原生Rust GUI库，支持Windows，macOS，Linux，之前是xi-editor的一部分。</p>
<h2><a class="header" href="#slotmap-10-released" id="slotmap-10-released">slotmap: 1.0 released</a></h2>
<ul>
<li><a href="https://github.com/orlp/slotmap">仓库链接</a></li>
</ul>
<p>slotmap 提供了三种 map 的实现, SlotMap, HopSlotMap 和 DenseSlotMap.</p>
<p>增加,删除,查询均为O(1)复杂度,而且额外开销非常低. 非常适合存储需要稳定和安全引用的 objects, 例如游戏中的 entities, graph 中的 nodes.</p>
<h2><a class="header" href="#rust-的-webdriver库" id="rust-的-webdriver库">Rust 的 WebDriver库</a></h2>
<ul>
<li><a href="https://github.com/stevepryde/thirtyfour">仓库链接</a></li>
</ul>
<p>Thirtyfour是一个用于Rust的Selenium / WebDriver库，用于自动化网站UI测试。</p>
<p>它支持完整的W3C WebDriver规范。经过Chrome和Firefox的测试，尽管任何与W3C兼容的WebDriver都可以使用。</p>
<h2><a class="header" href="#webrtcrs" id="webrtcrs">webrtc.rs</a></h2>
<ul>
<li><a href="https://webrtc.rs/">官网</a></li>
<li><a href="https://github.com/webrtc-rs/webrtc">仓库链接</a></li>
</ul>
<p>用 Rust 重写 Pion WebRTC (http://Pion.ly)。目前 v1.0 仍然处于开发中，欢迎开源贡献者提PR。</p>
<h2><a class="header" href="#rust中的科学计算" id="rust中的科学计算">Rust中的科学计算</a></h2>
<ul>
<li><a href="https://aftix.xyz/home/bacon/">文章链接</a></li>
<li><a href="https://github.com/aftix/bacon">仓库链接</a></li>
</ul>
<p>这篇文章中作者分享了在课余时间用Rust重写生物膜仿真过程中遇到的问题。</p>
<p>由于crates.io上找不到SciPy的代替品，作者自己实现了一个bacon-sci。</p>
<h2><a class="header" href="#shadow-rs-0514-支持自定义钩子" id="shadow-rs-0514-支持自定义钩子">shadow-rs 0.5.14 支持自定义钩子</a></h2>
<ul>
<li><a href="https://github.com/baoyachi/shadow-rs">仓库链接</a></li>
</ul>
<p>shadow-rs是一个使得程序能在运行时读取到编译过程中信息的库，这些信息包括：</p>
<ul>
<li>Cargo.toml 中的项目版本</li>
<li>依赖信息</li>
<li>git commit</li>
<li>编译中用到的Rust工具链</li>
<li>build类型，debug版还是release版</li>
</ul>
<p>之前想要增加加自定义信息会很麻烦，在0.5.14支持了自定义钩子后就容易多啦。</p>
<h2><a class="header" href="#ballista分布式计算平台" id="ballista分布式计算平台">Ballista：分布式计算平台</a></h2>
<ul>
<li><a href="https://github.com/ballista-compute/ballista">仓库链接</a></li>
</ul>
<p>Ballista 用 Rust 实现的概念验证分布式计算平台，使用 Apache Arrow 作为内存模型。它建立在一种体系结构之上，这种体系结构允许将其他编程语言作为一级公民进行支持，而不需要为序列化付出代价。</p>
<h2><a class="header" href="#德国亚琛工业大学研究项目rustyhermit-介绍" id="德国亚琛工业大学研究项目rustyhermit-介绍">德国亚琛工业大学研究项目：RustyHermit 介绍</a></h2>
<ul>
<li><a href="https://rust-osdev.com/showcase/rusty-hermit/">RustyHermit 介绍文章</a></li>
</ul>
<p>相关链接：</p>
<ul>
<li><a href="https://os.phil-opp.com/">Phil-Opp OS 教程</a></li>
<li><a href="https://github.com/hermitcore/libhermit-rs">libhermit-rs</a></li>
<li><a href="https://github.com/hermitcore/rusty-hermit">rusty-hermit</a></li>
</ul>
<p>RustyHermit 是一个 Unikernel（我理解这就是  Unique-Kernel 的缩写，独立内核？）。 Unikernel 被认为是有可能改变未来云生态格局的技术。</p>
<p>Unikernel是使用libOS(library os)构建的具有专门用途的单地址空间机器镜像。为了支撑程序的运行，开发者从模块栈中选择最小的类库集合，构建对应的OS。类库和应用代码、配置文件一起构建成固定用途的镜像，可以直接运行在hypervisor或者硬件上而无需Linux或者Windows这样的操作系统。所以，也有人称它为下一代容器技术。</p>
<p>Unikernel 其最大的卖点就是在，没有用户空间与内核空间之分，只有一个连续的地址空间。这样使得 Unikernel 中只能运行一个应用，而且对于运行的应用而言，没有硬件抽象可言，所有的逻辑，包括应用逻辑和操作硬件的逻辑，都在一个地址空间中。</p>
<p>但是目前 Unikernel 仍然出于研究阶段。</p>
<p>RustyHermit 是依赖于 libhermit-rs（库操作系统）实现的。</p>
<p>这两个项目都出自 亚琛工大，有意思的是，它们都是基于著名的 Rust实现操作系统教程phil-opp 衍生实现的。</p>
<h2><a class="header" href="#用-rust-编写现代操作系统" id="用-rust-编写现代操作系统">用 Rust 编写现代操作系统</a></h2>
<p><a href="https://github.com/theseus-os/Theseus">仓库链接</a></p>
<p>Theseus 是从Rust编写的新操作系统，尝试使用新颖的OS结构，更好的状态管理以及如何将OS职责（如资源管理）转移到编译器中。</p>
<p>我们一直在不断改进操作系统，包括其故障恢复能力，以提供更高的系统可用性而没有冗余，以及更轻松，更随意的实时演进和运行时灵活性。尽管仍然是一个不完整的原型，但我们认为These修斯将对高端嵌入式系统或边缘数据中心环境很有用。请参阅我们的已发表论文，以获取有关These修斯的设计原理和实现理念的更多信息，以及我们避免状态泄漏现象或尽可能减轻其影响的目标。</p>
<h2><a class="header" href="#evcxr-a-rust-repl-的解决方案" id="evcxr-a-rust-repl-的解决方案">Evcxr: A Rust REPL 的解决方案</a></h2>
<p>并且它还包含了 Jupyter Kernel 指南</p>
<p>该项目挂在 Google 的 GitHub 组织下。</p>
<ul>
<li><a href="https://github.com/google/evcxr">仓库链接</a></li>
<li><a href="https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb">Jupyter Kernel 指南</a></li>
</ul>
<h2><a class="header" href="#findomain-可提供子域监视服务" id="findomain-可提供子域监视服务">Findomain: 可提供子域监视服务</a></h2>
<ul>
<li><a href="https://github.com/Findomain/Findomain">仓库链接</a></li>
</ul>
<p>该服务可提供：目录模糊处理/端口扫描/漏洞发现（使用Nuclei），等等。 </p>
<p>允许您使用多个顶级工具（OWASP Amass，Sublist3r，Assetfinder和Subfinder）监视目标域，并在出现新的子域时将警报发送到Discord，Slack，Telegram，电子邮件或推送通知（Android / iOS / Smart Watch / Desktop）。 </p>
<p>您唯一要做的就是使用您的电子邮件地址（如果适用）或/和webhooks / Telegram聊天信息配置文件，然后将域放入另一个文件中。</p>
<p>一旦完成，您便拥有了一个完全自动化的子域监视服务，可以让您 包含最新发现的新子域，主机IP，HTTP状态，HTTP网站的屏幕快照，开放端口，子域CNAME等。 您所有的数据都安全地保存在关系数据库中，您可以随时请求转储数据。</p>
<h2><a class="header" href="#weylus让你的平板电脑用作电脑上的图形平板触摸屏" id="weylus让你的平板电脑用作电脑上的图形平板触摸屏">Weylus：让你的平板电脑用作电脑上的图形平板/触摸屏</a></h2>
<p>特点：</p>
<ul>
<li>用平板电脑控制鼠标</li>
<li>将屏幕镜像到平板电脑上</li>
</ul>
<p>上述功能在所有操作系统上都可以使用，但<code>Weylus</code>在<code>Linux</code>上效果最好。<code>Linux</code>上的其他功能有：</p>
<ul>
<li>
<p>支持手写笔/笔（支持压力和倾斜）。</p>
</li>
<li>
<p>多点触控。用支持多点触控的软件试试，- 比如Krita，你就会知道了。</p>
</li>
<li>
<p>捕捉特定的窗口，并只对其进行绘制。</p>
</li>
<li>
<p>更快的屏幕镜像</p>
</li>
<li>
<p>硬件加速视频编码</p>
</li>
<li>
<p>平板电脑作为第二屏幕</p>
</li>
<li>
<p><a href="https://github.com/H-M-H/Weylus">仓库链接</a></p>
</li>
</ul>
<h1><a class="header" href="#本月简报学习资源" id="本月简报学习资源">本月简报：学习资源</a></h1>
<ul>
<li>来源：<a href="https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f">Rust日报</a></li>
<li>作者：Rust 日报小组</li>
</ul>
<h2><a class="header" href="#rust-design-patterns-book" id="rust-design-patterns-book">🎈Rust Design Patterns Book</a></h2>
<p>非官方好书系列, 再次安利! Rust Design Patterns Book. 作者最近更新了很多东西。</p>
<p>看下翻译的中文引言吧。</p>
<h4><a class="header" href="#引言" id="引言">引言</a></h4>
<h4><a class="header" href="#设计模式" id="设计模式">设计模式</a></h4>
<p>在开发程序中，我们必须解决许多问题。一个程序可以看作是一个问题的解决方案。它也可以被看作是许多不同问题的解决方案的集合。所有这些解决方案共同解决一个更大的问题。</p>
<h4><a class="header" href="#在rust中的设计模式" id="在rust中的设计模式">在Rust中的设计模式</a></h4>
<p>有许多问题的形式是相同的，由于事实上，rust不是面向对象设计，模式不同于其他面向对象程序设计语言，虽然细节是不同的，因为他们有相同的形式，他们可以解决使用相同的基本方法。</p>
<p><a href="https://rust-unofficial.github.io/patterns/patterns/index.html">设计模式</a>是解决编写软件时常见问题的方法。</p>
<p><a href="https://rust-unofficial.github.io/patterns/anti_patterns/index.html">反模式</a>是解决这些相同问题的方法。</p>
<p>然而，尽管设计模式给我们带来了好处，反模式却带来了更多的问题。</p>
<p><a href="https://rust-unofficial.github.io/patterns/idioms/index.html">惯用法</a>，是编码是要遵守的指南，他们是社区的社区规范，你可以破他们，但如果你这样做，你应该有一个很好的理由。</p>
<p>TODO: 说明为什么Rust是一个有点特殊功能要素，类型系统，借用检查。</p>
<p><a href="https://rust-unofficial.github.io/patterns/">book 链接</a></p>
<h2><a class="header" href="#异步书翻译更新啦" id="异步书翻译更新啦">🎈异步书翻译更新啦</a></h2>
<p>这次翻译新增了 第八章-关于生态的叙述 （<a href="https://github.com/EthanYuan">@EthanYuan</a>) 以及 第九章 http服务器项目（<a href="https://github.com/huangjj27">@huangjj27</a>), 欢迎来指正错误或贡献~</p>
<p><a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">english book link</a></p>
<p><a href="https://huangjj27.github.io/async-book/index.html">中文翻译链接</a></p>
<p>​</p>
<h2><a class="header" href="#manning的rust新书refactoring-to-rust" id="manning的rust新书refactoring-to-rust">🎈Manning的Rust新书《Refactoring to Rust》</a></h2>
<p>这本书正在MEAP阶段，目前才更新了3章，感兴趣的同学可以看看。</p>
<p><a href="https://www.manning.com/books/refactoring-to-rust">Refactoring to Rust</a></p>
<h2><a class="header" href="#rust-书籍宝库" id="rust-书籍宝库">🎈Rust 书籍宝库</a></h2>
<p><a href="https://www.reddit.com/user/glynnormington/">glynnormington</a>整理了网络上大部分有关rust的mdbook，有官方的，也有非官方的。值得注意的一点是大家关注的rust宏小册很多人以为一直没有更新，但是其实有另一个团队重新在原来的基础上，更新了新的版本，目前已收录到该书库中。</p>
<p><a href="https://lborb.github.io/book/title-page.html">Rust 书籍宝库</a></p>
<p><a href="https://www.reddit.com/r/rust/comments/kwiwb8/the_little_book_of_rust_books/">Read More on reddit</a></p>
<h2><a class="header" href="#使用rust-编写一门语言" id="使用rust-编写一门语言">🎈使用Rust 编写一门语言</a></h2>
<p>有关使用<a href="https://rust-lang.org/">Rust</a>编程语言制作称为<a href="https://github.com/arzg/eldiro">Eldiro</a>的编程语言的系列文章。</p>
<p><a href="https://arzg.github.io/lang/">原文链接</a></p>
<h2><a class="header" href="#rust-错误处理-python-同学专用" id="rust-错误处理-python-同学专用">Rust 错误处理: python 同学专用</a></h2>
<p>本文是 python 同学专用, 介绍了 python 日常中的错误处理以及如何在 rust 中达到类似效果和最佳实践.</p>
<p><a href="https://theomn.com/rust-error-handling-for-pythonistas/">原文链接</a></p>
<h2><a class="header" href="#其他语言调用rust---c" id="其他语言调用rust---c">🎈其他语言调用Rust - C++</a></h2>
<p>作者选择Rust作为运行时库的实现语言，并且希望使同一库可用于不同的编程语言。</p>
<p>最初，选择从对三种语言的支持开始：</p>
<ul>
<li><strong>Rust</strong>：因为这是我们的实现语言。</li>
<li><strong>C ++</strong>：这是我们熟悉的低级语言，仍然是嵌入式设备领域中最成熟的语言之一。</li>
<li><strong>JavaScript / TypeScript</strong>：因为它是一种非常流行的动态语言。</li>
</ul>
<p><img src="https://sixtyfps.io/blog/expose-rust-library-to-other-languages/diagrams.png" alt="img" /></p>
<p>Rust库（也称为板条箱）分为两部分，共享实现板条箱和精简惯用的API条板箱。</p>
<p>对于JavaScript，我们使用<a href="https://github.com/neon-bindings/neon">Neon</a>公开API。Neon使我们能够方便地编写JavaScript API和创建NPM包。</p>
<p>C ++部分更具挑战性。</p>
<p><a href="https://sixtyfps.io/blog/expose-rust-library-to-other-languages.html">原文链接</a></p>
<h2><a class="header" href="#使用-rust-创建一个模拟器-part-1" id="使用-rust-创建一个模拟器-part-1">🎈使用 Rust 创建一个模拟器: part 1</a></h2>
<p>这个系列中, 作者会通过 神经网络 和 遗传算法 制作一个 进化模拟器.</p>
<p>作者首先会介绍 神经网络和遗传算法 是如何工作的, 然后会使用 Rust 来实现他们, 并且编译成 WebAssembly. 下图是一个预览图.</p>
<p>教程地址： <a href="https://pwy.io/en/posts/learning-to-fly-pt1/">https://pwy.io/en/posts/learning-to-fly-pt1/</a></p>
<h2><a class="header" href="#rust陷阱-reprtransparent" id="rust陷阱-reprtransparent">🎈Rust陷阱: repr(transparent)</a></h2>
<p>repr(transparent) 可以让类似 struct Foo(i32) 和 i32 有同样的内存分布方式. 他作用范围非常具体,只能有一个非 0 size 的字段.</p>
<p>本文章介绍了如何使用 repr(transparent) 以及一些陷阱.</p>
<p>原文链接：<a href="https://jack.wrenn.fyi/blog/semver-snares-transparent/">https://jack.wrenn.fyi/blog/semver-snares-transparent/</a></p>
<h2><a class="header" href="#unsafe-rust该如何或何时使用它" id="unsafe-rust该如何或何时使用它">🎈Unsafe Rust：该如何或何时使用它</a></h2>
<p>本文包含了以下内容：</p>
<ul>
<li>关于 Unsafe Rust 的五点迷思</li>
<li>什么时候不该用 Unsafe 的代码</li>
<li>处理未初始化的内存</li>
<li>内部可变性</li>
<li>内在动机</li>
<li>内联汇编</li>
<li>FFi</li>
<li>编写Unsafe Rust时候应该使用的工具</li>
</ul>
<p>原文链接：<a href="https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/">https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/</a></p>
<h2><a class="header" href="#mozilla-如何导出-rust-组件给-kotlin" id="mozilla-如何导出-rust-组件给-kotlin">🎈Mozilla: 如何导出 Rust 组件给 Kotlin</a></h2>
<p>Mozilla 应用服务平台这个仓库中提供了一个 login 组件可以很好地展示这个示例。</p>
<p>概要：</p>
<p>假设你已经的组件在./src/目录下编写了一个不错的Rust核心代码。</p>
<p>首先，你需要将 Rust API 扁平化为一组 FFI 绑定，通常是在 <code>./ffi/ </code>目录下。使用 <code>ffi_support</code> crate 来帮助实现这个功能，这将涉及到在核心 Rust 代码中实现一些特性。</p>
<p>接下来，你需要编写消耗<code>FFI</code>的<code>Kotlin</code>代码，通常是在<code>./android/</code>目录下。这段代码应该使用<code>JNA</code>通过共享库加载编译后的<code>Rust</code>代码，并将其作为一个漂亮的安全且易于使用的<code>Kotlin API</code>暴露出来。</p>
<p>似乎我们很可能在这里提供一个有用的模板来让你入门。但我们还没有这样做。</p>
<p>最后，将你的包添加到<code>android-components repo</code>中。</p>
<p>文章还回答了一些导出过程中的问题。</p>
<p>原文链接：<a href="https://github.com/mozilla/application-services/blob/020a3eb831da8cd9d21978e3d1fb7af3a6ffcfea/docs/howtos/exposing-rust-components-to-kotlin.md">https://github.com/mozilla/application-services/blob/020a3eb831da8cd9d21978e3d1fb7af3a6ffcfea/docs/howtos/exposing-rust-components-to-kotlin.md</a></p>
<h2><a class="header" href="#入门教程用rust写一个todo应用" id="入门教程用rust写一个todo应用">入门教程：用Rust写一个todo应用</a></h2>
<p>在这篇教程里，作者依照javscript的传统，教你用Rust写一个todo应用。 你会学到：</p>
<ul>
<li>Rust中的错误处理</li>
<li>Option的使用</li>
<li>Struct和impl</li>
<li>终端输入输出</li>
<li>文件操作</li>
<li>所有权和借用</li>
<li>模式匹配</li>
<li>迭代器和闭包</li>
<li>使用外部crate</li>
</ul>
<p>链接：<a href="https://www.freecodecamp.org/news/how-to-build-a-to-do-app-with-rust/">https://www.freecodecamp.org/news/how-to-build-a-to-do-app-with-rust/</a></p>
<h2><a class="header" href="#libhunt-根据reddit-被提及状态展示-rust-库的热度" id="libhunt-根据reddit-被提及状态展示-rust-库的热度">🎈LibHunt: 根据reddit 被提及状态展示 rust 库的热度</a></h2>
<p>LibHunt 根据 reddit 上大家提及到库的热度来排序出一些热门的 rust 库.</p>
<p>对于调研阶段的同学来说,是一个很好的工具.</p>
<p>libhunt的主页地址: <a href="https://www.libhunt.com/lang/rust">https://www.libhunt.com/lang/rust</a></p>
<h2><a class="header" href="#用-rust-实现一个-rest-client" id="用-rust-实现一个-rest-client">🎈用 Rust 实现一个 Rest Client</a></h2>
<p>这是 &lt;&lt; Zero To Production In Rust&gt;&gt; 的 这本书中的一个示例。在本文, 作者演示了:</p>
<ul>
<li>如何使用 reqwests 来写一个 REST API client.</li>
<li>如何来使用 wiremock 来进行测试.</li>
</ul>
<p>原文链接: <a href="https://www.lpalmieri.com/posts/how-to-write-a-rest-client-in-rust-with-reqwest-and-wiremock/">https://www.lpalmieri.com/posts/how-to-write-a-rest-client-in-rust-with-reqwest-and-wiremock/</a></p>
<h2><a class="header" href="#太素os基于-riscv-架构的-rust-系统内核实现中文教程和源码" id="太素os基于-riscv-架构的-rust-系统内核实现中文教程和源码">🎈太素OS：基于 RISCV 架构的 Rust 系统内核实现（中文）教程和源码</a></h2>
<p>构建于QEMU 之上，适合学习</p>
<ul>
<li>源码： <a href="https://github.com/belowthetree/TisuOS">https://github.com/belowthetree/TisuOS</a></li>
<li>教程： <a href="https://www.zhihu.com/column/c_1118934193425629184">https://www.zhihu.com/column/c_1118934193425629184</a></li>
</ul>
<h2><a class="header" href="#译asyncawait二-futures" id="译asyncawait二-futures">【译】Async/Await（二）—— Futures</a></h2>
<p>新的文章翻译来啦。</p>
<p>来自：公众号：「Rust 碎碎念」，翻译 by：Praying</p>
<ul>
<li>翻译链接： <a href="https://mp.weixin.qq.com/s/OL7_usSmY_gAZzYYydyr8A">https://mp.weixin.qq.com/s/OL7_usSmY_gAZzYYydyr8A</a></li>
<li>原文链接：<a href="https://os.phil-opp.com/async-await/#multitasking">https://os.phil-opp.com/async-await/#multitasking</a></li>
</ul>
<h2><a class="header" href="#rust-programming-language-the-ultimate-guide" id="rust-programming-language-the-ultimate-guide">Rust Programming Language: The Ultimate Guide</a></h2>
<p>这篇文章中作者从伪代码出发，一步步教你实现一个爱情计算器。</p>
<p>作者称这是线上最通俗易懂的Rust入门指南，你怎么认为呢？快来试试吧。</p>
<p>链接：<a href="https://masteringbackend.com/posts/rust-programming-the-ultimate-guide">https://masteringbackend.com/posts/rust-programming-the-ultimate-guide</a></p>
<h2><a class="header" href="#rust-initial-thoughts" id="rust-initial-thoughts">Rust: Initial thoughts</a></h2>
<p>作者分享了自己刚开始学Rust的一些想法和与其它语言的对比。</p>
<p><a href="https://dev.to/hb/rust-initial-thoughts-4jka">原文链接</a></p>
<h2><a class="header" href="#关于futurejoin设计的思考" id="关于futurejoin设计的思考">关于Future::join设计的思考</a></h2>
<p>这篇文章中作者分享了关于如何将<code>Future::{try_}join</code>和<code>{try_}join!</code>以一种更一致的形式加入标准库中的思考，以及对于const-eval可能起到的作用的讨论。</p>
<p><a href="https://blog.yoshuawuyts.com/future-join-and-const-eval/">原文链接</a></p>
<h3><a class="header" href="#rust-教程-从头开始学-rust" id="rust-教程-从头开始学-rust">Rust 教程: 从头开始学 Rust</a></h3>
<p>Rust 越来越被更多的人喜爱, 很多小伙伴也想入坑. 这篇教程可以帮助零基础的小伙伴了解 Rust.</p>
<p><img src="https://www.educative.io/api/page/5328531525992448/image/download/6018549143830528" alt="img" /></p>
<p><a href="https://www.educative.io/blog/rust-tutorial-from-scratch">原文链接</a></p>
<h3><a class="header" href="#ref-vs--in-variables" id="ref-vs--in-variables">ref vs &amp; in variables</a></h3>
<p>帖子讨论了ref 和&amp; 的使用，哪个使用更好。</p>
<p><a href="https://www.reddit.com/r/rust/comments/l451ux/ref_vs_in_variables/">原文链接</a></p>
<h3><a class="header" href="#在rust中包装错误" id="在rust中包装错误">在Rust中包装错误</a></h3>
<p>在开发时错误处理是必须，有时错误处理非常糟糕，文章中提高了warp Error 提高体验。</p>
<p><a href="https://edgarluque.com/blog/wrapping-errors-in-rust">原文链接</a></p>
<p><a href="https://www.reddit.com/r/rust/comments/l3x6p0/wrapping_errors_in_rust/">on reddit</a></p>
<h1><a class="header" href="#本月简报--rust-唠嗑室本月汇总" id="本月简报--rust-唠嗑室本月汇总">本月简报 | Rust 唠嗑室本月汇总</a></h1>
<ul>
<li>来源：<a href="https://space.bilibili.com/25566598">Rust 唠嗑室</a></li>
<li>主持人：MikeTang</li>
</ul>
<h2><a class="header" href="#rust-唠嗑室第-16-期---tensorbase-高性能数据仓库" id="rust-唠嗑室第-16-期---tensorbase-高性能数据仓库">《Rust 唠嗑室》第 16 期 - tensorbase 高性能数据仓库</a></h2>
<p><strong>时间</strong>: 2021/01/05 20:30-21:30</p>
<p><strong>主讲人</strong>：金明剑</p>
<p><strong>内容</strong>：金明剑老师在 RustChinaConf2020 上分享了《<a href="https://www.bilibili.com/video/BV1Yy4y1e7zR?p=25">基于 Rust 构建高性能新型开源数据仓库</a>》，很多人感兴趣 <a href="https://github.com/tensorbase/tensorbase">Tensorbase</a> 的技术内幕，这次唠嗑室一起来聊 Tensorbase。</p>
<p><a href="https://www.bilibili.com/video/BV1TA411H7ap">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<p><a href="https://www.bilibili.com/video/BV1Yy4y1e7zR">RustChinaConf2020 大会合集</a></p>
<hr />
<h2><a class="header" href="#rust-唠嗑室第-17-期---用-rust-写-protobuf-扩展" id="rust-唠嗑室第-17-期---用-rust-写-protobuf-扩展">《Rust 唠嗑室》第 17 期 - 用 Rust 写 Protobuf 扩展</a></h2>
<p><strong>时间</strong>: 2021/01/19 20:30-21:30</p>
<p><strong>主讲人</strong>：宁志伟</p>
<p><strong>内容</strong>：</p>
<p><a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Protocol Buffers</a> (简称 Protobuf ) ，是 Google 出品的序列化框架，与开发语言无关，和平台无关。具有体积小，速度快，扩展性好，与 <a href="https://en.wikipedia.org/wiki/GRPC">gRPC</a> 搭配好，支持的语言多等特点，是目前应用最广泛的序列化框架。</p>
<p><a href="https://github.com/cita-cloud">CITA-Cloud</a> 是一个以区块链技术为基础，融合云原生技术的柔性集成开放平台。区块链部分提供了非常灵活的微服务架构，可以适应各种各样的企业应用场景。</p>
<p>CITA-Cloud 计划提供一个框架，方便用户自定义交易和区块等核心数据结构。使用 Protobuf 的扩展能力，用户只需用 Protobuf 描述数据结构，框架会自动生成相关代码，得到一个定制的区块链。</p>
<p>这次主要来聊聊 Protobuf 扩展的原理，以及 Rust 已有的相关的库。最后通过一个 <a href="https://github.com/rink1969/proto_desc_printer">Demo</a> 展示如何使用 Rust 来写 Protobuf 扩展。</p>
<p><a href="https://www.bilibili.com/video/BV1Ff4y1k7Bo">查看回放</a></p>
<p><strong>扩展资料</strong>：</p>
<p><a href="https://github.com/cita-cloud">CITA-Cloud</a></p>
<p><a href="https://cita-cloud-docs.readthedocs.io/zh_CN/latest/">CITA-Cloud 文档</a></p>
<p><a href="https://github.com/cita-cloud/cita_cloud_proto">cita_cloud_proto</a></p>
<p><a href="https://github.com/dropbox/pb-jelly">Dropbox-pb-jelly</a></p>
<p><a href="https://github.com/stepancheg/rust-protobuf/">rust-protobuf</a></p>
<p><a href="https://crates.io/crates/prost">Prost</a></p>
<p><a href="https://github.com/rink1969/proto_desc_printer">Demo 代码</a></p>
<h1><a class="header" href="#rustchinaconf2020-精选--jit-开发实践" id="rustchinaconf2020-精选--jit-开发实践">RustChinaConf2020 精选 | JIT 开发实践</a></h1>
<p>说明：本文为视频演讲文字版，编者听录的时候可能会出现一些误差，欢迎指正。</p>
<p>后期编辑: 大海，编程爱好者，对技术充满热情。</p>
<p><strong>讲师:</strong></p>
<p><a href="https://github.com/losfair">周鹤洋</a>是<code>wasmer</code>核心开发者，南航2018级本科生，主要掌握编译/OS/VM/微架构等技术，2017年开始使用Rust.</p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1Yy4y1e7zR?p=18">https://www.bilibili.com/video/BV1Yy4y1e7zR?p=18</a></p>
<h3><a class="header" href="#jit技术含义及应用场合" id="jit技术含义及应用场合">JIT技术含义及应用场合</a></h3>
<p>​	JIT技术全名为 Just-In-Time compilation，翻译为&quot;即时编译&quot;，是在运行期进行编译的方法，是将源代码或更常见的字节码到机器码的转换，然后直接执行的方法。JIT技术主要应用在各种语言的虚拟机上。在其他场合，比如动态链接器，会在运行之前动态重启程序，对它进行链接; 在linux 内核中, ebpf技术和5.10版本最新引入的static calls机制都使用了类似JIT的机制。</p>
<p>​	以虚拟机(VM)为例来简单介绍下JIT技术的应用。VM技术，可以大致分为三类，简单的解释器，优化的解释器和即时编译。简单的解释器，类似wasmi，由于对标准的实现非常好，导致没有资源去做优化，没有为运行效率做优化。其次是优化解释器，比如CPython,wasm3,BEAM(erlang 解释器). 而第三种则包括绝大多数高性能运行时虚拟机，JVM，CLR，V8，LuaJIT，Wasmer，Wasmtime.</p>
<p>​	虚拟机主要应用于当我们需要执行的目标代码格式与机器指令格式不一致时，需要翻译处理的情况。然而当出现我们无法直接静态地翻译到目标机器指令的特性，比如说动态特性( javascript的一些动态约束)，硬件层面难以实现的沙盒特性，比如WebAssembly的内存隔离, 不同的指令集，比如从riscv动态编译到aarch64或者x86-64指令集情况下，我们就需要使用二进制翻译器去进行Jit编译。</p>
<p>​	jit的优点很明显，可以让程序更效率地运行，可以① 动态优化代码②高效支持语言动态特性和安全要求③ 在一些特殊场合比如static call机制和动态链接器，支持运行环境的初始化操作来避免运行时的大量开销。</p>
<p>​	<strong>我们现在从动态优化方面来讲述jit相对传统静态编译的关键点。</strong></p>
<p><img src="chapter_1/../image/Jan_Jit7.PNG" alt="" /></p>
<center>图1 不同引擎在各JIT优化级别所采用的编译器后端</center>
<p>​	如图1所示，以JavaScriptCore,V8,Wasmer三个引擎为例，他们均实现了用户可以自由选择后端的操作或者在运行时自动在不同后端间切换的方式，使得可以支持编译优化从低优化级别切换到高优化级别，并且经过未经优化代码的时候，再切换回去的操作。</p>
<p>​	这里动态优化的流程是我们通过不断Profile,追踪运行状态，去编译优化等级更高的代码，同时编译开销变大，也会做deoptimize操作，当优化的代码做一些错误的假设时，我们就需要回滚。</p>
<p><strong>而用来实现动态切换优化级别的主要技术是OSR技术 ，即栈上替换(on-stack replacement).</strong></p>
<p><img src="chapter_1/../image/Jan_Jit1.PNG" alt="" /></p>
<center>图2 切换优化等级:OSR</center>
<p>​	让我们来看看OSR技术的简易流程。如图2所示，调用栈出现了左边的假想情况时，函数Baz代码优化从解释执行提升到 jit级别1 时， 运行时就会触发函数baz的编译，一旦编译完成，则会发生调用栈的重构，使得 原调用栈中所有函数Baz的记录映射到Jit级别1 的堆栈结构上，使得在原来状态基础之上，以Jit级别1的机器码上继续运行。代价 是 提升了计算的复杂度。</p>
<p>​	我曾经的一个工作，  在wasmer中实现的OSR技术。 OSR入口动态加载Image,在OSR退出的时候把image提取出来(从调用栈到wasm抽象表示，回到另一种优化等级的wasmer调用栈内的结构。(<font color=red>8:39</font>)</p>
<p><img src="chapter_1/../image/Jan_Jit2.PNG" alt="" /></p>
<center>图3 动态切换机制实例随时间变化的性能曲线</center>
<p>​	图3则是我当时项目benchmark的表现。在图3中，singlepass是我编写的编译最快，运行最慢的后端。llvm是优化等级最高的后端。红线为使用LLVM后端的性能曲线，蓝线为前面2s左右使用singlepass后端，后面使用llvm后端的性能曲线。</p>
<p>​	如果我们直接用llvm编译的话，我们就需要在程序执行之前，在测试程序中等待2s左右。如果我们引入动态切换机制，在程序启动时可以先使用编译快，但执行满的引擎去做执行，当优化等级高的编译器准备好之后，就动态地切换执行流，得到二者的平衡。红线和蓝线后面没有重合，只是由于我们在蓝线上针对一些做了一些额外操作,性能理论上还是一样的。</p>
<p>​	**我要介绍的第二钟动态优化技术 是 内联缓存inline caching。**我了解到有两种典型的用例。</p>
<ol>
<li>
<p>一些动态语言中的method lookup （方法查找）</p>
<pre><code class="language-javascript">for (let x of list){
    document.write(x); // method lookup
}
</code></pre>
<p>​	其中write函数是可以被动态重写的，但是这种情况发生的概率非常小，所以说我们在运行时可以假设它不变，去编译生成机器码。当假设不成立的时候，回滚。本来需要从哈希表中查找该方法，对缓存不友好，运行速度慢。</p>
<p>​	所以我们可以直接对该指令映射为一个缓存槽(slot)，把write函数对应的某些标记和write函数地址写入，检查运行条件是否符合，符合就可以直接执行，避免哈希表查找的开销，否则进行回滚。</p>
</li>
<li>
<p>RISC-V二进制翻译</p>
<p><img src="chapter_1/../image/Jan_Jit8.PNG" alt="" /></p>
<center>图4  RISC-V 二进制翻译代码示例 </center>
<p>​	在RISC-V当中，主要有访存指令和跳转指令会涉及到较大的内存结构查找开销。</p>
<p>​	① 对于全系统模拟的访存指令(load/store)，需要在内存管理单元钟进行tlb lookup，用软件实现非常慢，遍历4层页表。或者在一些高层次结构的模拟时，在b-tree结构去查找内存空间，效率也很低。</p>
<p>​	对于这种指令，我们可以对指令关联一个缓存槽，当该指令第一次需求查表的时候，将查表预期的虚拟地址范围和真实物理地址  写入到缓存槽中，以后每次执行到该指令时，我们就直接用缓存信息直接提取内存信息即可。</p>
<p>​	② 如图4，jalr指令，间接跳转指令的例子。对于这种指令，除了需要mmu lookup , 还需要查找Jit 翻译，即被翻译后的字节码(translation lookup)，共两层查找。 而内联缓存技术就可以消除这两层查找的开销。</p>
</li>
</ol>
<p>让我来介绍一下关于内联缓存我所做的简单应用吧。 rvjt-aa64项目 是我所完成的riscv到aarch64的jit引擎(<a href="https://github.com/losfair/rvjit-aa64">rvjit-aa64</a>)</p>
<p><img src="chapter_1/../image/Jan_Jit3.PNG" alt="" /></p>
<center>图5 rvjit-aa64 快速路径(从内存加载数据)</center>
<p>​	图5展示了访存指令的快速路径，可以看见我们分配了关于上界和下界的两个缓存槽。检查目标虚拟地址是否位于预期界限当中，如果在范围内，就直接加载，不用回滚到解释执行了。否则就走慢速路径，执行查表处理。</p>
<p><img src="chapter_1/../image/Jan_Jit4.PNG" alt="" /></p>
<center>图6 rvjit-aa64慢速路径(从内存加载数据)</center>
<p>​	图6展示了访存指令的慢速路径。当发生<code>load/store miss</code>时，我们就会针对地址addr进行查表， 检查读写权限和相关信息，如果可以的话就将其写入缓存槽内，下次就可以快速执行。</p>
<p>​	<strong>接下来我来介绍有关内存安全方面的内容。</strong></p>
<p>​	我们知道rust作为一个以安全性著称的语言，保证safe代码内存安全。所以我们就需要在运行时通过动态的机制确保内存安全。</p>
<p>​	我以空指针检查和访问越界检查为例来介绍Jit如何确保内存安全。</p>
<p>​	①空指针检查:</p>
<p>​	比如在java,c#这类有空指针的语言中，我们会遇到一个很常见的情况。当引用为空的时候，我们不应该对它解引用并且成功。我们应该检查它是否为空，如果为空，应该产生异常而非解引用。一个显而易见的方法是<code>if (a == null){ throw Exception(...)}</code>，但这样开销很大。如同下面代码所展示的，在<code>mov</code>指令前需要插入<code>cmp</code>和<code>je</code>指令，就会增加额外的分支预测的开销。</p>
<pre><code class="language-assembly">1: 1 cmp $0, %rdi
2: je null_pointer_exception 
3: mov %rdi,16(rsp)
...

null_pointer_exception:
	call host_npe_handler
	...
</code></pre>
<p>​	所以我们可以尝试一些别的方法。利用硬件trap机制，访问空指针时，从第三行mov指令直接trap到sigsegv异常(以Linux为例)，从而让硬件去检查我们的指针有效性。</p>
<p>​	②访问越界检查</p>
<p>​	对于webassembly中线性内存访问 的处理也可以使用trap机制,比如wasmer和wasmtime的处理方法是，直接分配6GB的虚拟地址空间，只对其中有webassembly分配的区域去做映射。一旦访问到存在映射区域以外的区域时,就会抛出异常,被sigsegv处理器捕获。这样是以慢速路径中的时间增加为代价去换取快速路径上的开销,因为慢速路径钟加入了sigsegv异常处理机制，而快速路径则不再需要界限判断。</p>
<p>​	当然具体的细节会复杂一些，比如wasmer中一段代码,采用Unix信号处理同步异常.调用low level的system api去绑定,关联这些异常信号到处理器上,处理器会分发,然后进一步找出路径.</p>
<p>​	<strong>最后我们来介绍一下linux kernel中运用到jit方法的一些技术。</strong></p>
<p>​	①比如ebpf,是一种允许用户代码安全接入内核的机制. 他有interpreter和jit两种实现方式.大多数主流架构都是用Jit实现.</p>
<p><img src="chapter_1/../image/Jan_Jit5.PNG" alt="" /></p>
<center>图7  Retpoline, Static call机制处理间接跳转的简要代码</center>
<p>​		②linux 5.10引入的static call机制。 在此之前，为了缓解 spectre 系列漏洞,特别是spectre v2 漏洞,我们会采用retpoline技术.</p>
<p>依赖于RSB(Return Stack Buffer), 它的目的是所有间接调用不经过分支目标缓存(Branch Target Buffer),这样保证攻击无法生效. </p>
<p>​	为方便大家理解Retpoline原理，我这里参考了<a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/03/24/retpoline">retpoline: 原理与部署</a>一文来作原理的解释。如图7所示，jmp指令通过rax值进行间接跳转，在original方式下，CPU会询问indirect branch preditor。如果有攻击者之前训练过该分支，就会导致CPU跳转执行特定代码。而retpoline机制阻止CPU的投机执行。在Retpoline方式下，</p>
<p>​	①执行<code>call L2</code>后，会将<code>lfence</code>地址压栈，并填充到Return Stack Buffer(RSB)，然后跳转到L2位置。</p>
<p>​	②<code>mov %rax, (%rsp)</code>指令将间接跳转地址(<code>*%rax</code>)放到栈顶，此时栈顶地址和RSB中地址不同。</p>
<p>​	③此时对于<code>ret</code>指令如果CPU投机执行时，会使用第一步中放入RSB中的地址，而<code>lfence</code>，<code>jmp L1</code>指令会导致一个死循环。</p>
<p>​	④CPU发现内存栈上的返回地址和RSB投机地址不同，所以投机执行终止，跳转到<code>*%rax</code></p>
<p>​	这样Retpoline机制就避免了CPU的投机执行。	</p>
<p>​	但是在 linux内核中我们发现,有很多pattern的间接调用目标是一定的,比如虚表所以我们会把它装化成两次直接调用,第二次直接调用代码使用jit重写,如图7  <code>_trampoline</code>所示, 这样我们消除了spectre v2的可能性, 而且也减少了间接调用的开销(因为使用了直接调用)</p>
<h3><a class="header" href="#在我的项目中是否应该使用jit" id="在我的项目中是否应该使用jit">在我的项目中是否应该使用jit?</a></h3>
<p><img src="chapter_1/../image/Jan_Jit6.PNG" alt="" /></p>
<center>图8 wasm引擎执行效率与工程复杂度的表现</center>
<p>​	如图8所示，wasm3虽然是一个解释器，但是相较于Wasmer,LLVM(最好的wasmer jit实现)性能低了10倍，对于解释器来说，是一个非常好的性能表现。并且wasm3的工程复杂度也低了许多。</p>
<p>​	考虑到 执行效率与工程复杂性的关系, 工程复杂性低,意味着出现的Bug数量少, 项目代码也就更安全.。所以对于安全要求高的话,就需要 谨慎考虑jit.	</p>
<p>​	在今年linux内核中 ebpf jit发现了两个LPE bug(CVE-2020-8835, CVE-2020-27194), 即使在使用开发人员众多的linux内核中，较小的语言ebpf当中仍出现了比较严重的bug, 这说明Jit编译器工程复杂度很高,需要团队巨大的资源支持维护.</p>
<h3><a class="header" href="#用rust实现jit的体验" id="用rust实现jit的体验">用rust实现jit的体验</a></h3>
<p>​	使用过程宏 处理汇编很方便, 编写一些Low  level的jit体验非常好. rust语言作为源语言去实现目标语言的编译,无法保证其语言之外的安全性,这可以说是一种局限性吧.rust语言相对于c和c++还是比较有优势的.</p>
<h2><a class="header" href="#提问环节" id="提问环节">提问环节</a></h2>
<p>问题1: (猜测: 图3使用的Benchenmark使用了hashmap吗？)</p>
<p>回答: 我使用的Benchmark用hashmap会慢50%左右, 因为hashmap对缓存不友好。</p>
<p>问题2: 在jit空指针检查中，将普通的软件判断替换成trap，变成硬件中断，会提升效率吗？</p>
<p>回答:  trap可以类比为rust当中panic,比如数组越界等,在绝大多数情况下都会执行快速路径,当程序出现bug才会执行trap路径.</p>
<p>问题3: 有关内存越界的问题，如果a内存和b内存相邻，a内存已经被映射了，此时越界访问到b内存，这个检查是否失效？</p>
<p>回答: 因为我们在内联缓存中，存储了上界与下界的缓存。我们会对访问的内存比较上界和下界，如果越界就排除在外了。对于这里的比较开销，我们经过一层的比较，对缓存是友好的，并且相较于查表，开销很大。</p>
<p>问题4: wasmer如何兼容x86和arm指令集?</p>
<p>回答:  我们使用的编译器后端<a href="https://crates.io/crates/wasmer-compiler-singlepass">singlepass</a>和llvm后端都是支持arm指令的.</p>
<p><strong>补充</strong>:  通过硬件来提高jit的性能</p>
<p>wasmer 在运行时会做一些检查,比如跳转时要查询某个表,然后在表中找到目标地址,然后跳转.这样我们就需要在代码中做分支处理. 如果在risc-v Physical Memory Protection (PMP)的扩展下,就可以在一些情况避免上面查表的开销. 而苹果m1 中兼容x86的机制,通过硬件上添加一个x86 的<a href="https://www.cs.utexas.edu/%7Ebornholt/post/memory-models.html">total store ordering</a> (TSO)开关去使用x86内存顺序,提升模拟效率. 同时我们可以看到，arm指令集这几个版本也引入了支持javascript-operations 的一些指令，可以使得我们常用的一些jit目标语言提高执行效率。</p>
<p>参考文章:</p>
<ol>
<li><a href="https://github.com/terenceli">Terenceli</a>  <a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/03/24/retpoline">retpoline: 原理与部署</a></li>
<li><a href="https://www.infoq.com/profile/Sergio-De-Simone/">Sergio De Simone</a>  <a href="https://www.infoq.com/news/2020/11/rosetta-2-translation/">How x86 to arm64 Translation Works in Rosetta 2</a></li>
</ol>
<p>​</p>
<h1><a class="header" href="#rustchinaconf2020-精选--rust-异步与并发" id="rustchinaconf2020-精选--rust-异步与并发">RustChinaConf2020 精选 | Rust 异步与并发</a></h1>
<p>说明：本文为视频演讲文字版，编者听录的时候可能会出现一些误差，欢迎指正。</p>
<p>讲师：赖智超 - Onchain 区块链架构师</p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1Yy4y1e7zR?p=14">https://www.bilibili.com/video/BV1Yy4y1e7zR?p=14</a></p>
<p>后期编辑：李冬杰，阿里巴巴淘系技术部，花名齐纪，。</p>
<p>————————</p>
<h2><a class="header" href="#自我介绍" id="自我介绍">自我介绍</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-1.png" alt="自我介绍" /></p>
<p>大家好，今天我跟大家分享一下 Rust 的异步模型，以及实现这个模型时面临的一些并发方面的挑战。首先介绍一下 Rust 在我们公司的应用情况，我们公司在区块链是布局比较早的，现在大概成立有四年多了，目前我们公司主要还是 golang 为核心的技术栈，但是在 Rust 方面我们也在积极探索，有一些应用的实践。首先我们的区块链支持 wasm 虚拟机，使用 Rust 基于 cranelift/wasmtime 实现了 JIT 的版本，目前已经运行了一年多了。有了 wasm 虚拟机的支持后，我们也在智能合约和配套的工具链上下了功夫，目前团队智能合约开发首选 Rust，它具有开发效率高和迭代速度快的优点，前些天统计我们使用 Rust 开发的智能合约代码已经上 10 万了。还有密码学库，我们也是用的 Rust。</p>
<ol>
<li>区块链 wasm JIT 虚拟机：基于 cranelift/wasmtime;</li>
<li>智能合约开发库和配套的工具链：目前合约开发都首选 Rust，开发效率高，迭代速度快；</li>
<li>密码学库；</li>
</ol>
<h2><a class="header" href="#同步任务多线程池" id="同步任务多线程池">同步任务多线程池</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-2.png" alt="同步任务多线程池" /></p>
<p>为了讲解异步编程模型，我们先来看一看大家都比较熟悉的同步任务多线程池的实现，一个比较典型的实现如 PPT 左图所示，有一个全局的队列（Global Task Queue），由用户调用 <code>spawn</code> 把任务压到全局队列，全局队列关联着一个或者多个 <code>worker</code> 线程，每个工作线程都会轮询的从全局队列中把任务拿出来执行，用代码实现也比较简单。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use crossbeam::channel::{unbounded, Sender};
use once_cell::sync::Lazy;

type Task = Box&lt;dyn FnOnce() + Send + 'static&gt;;

static QUEUE: Lazy&lt;Sender&lt;Task&gt;&gt; = Lazy::new(|| {
    let (sender, reciver) = unbounded::&lt;Task&gt;();
    for _ in 0..4 {
        let recv = reciver.clone();
        thread::spawn(|| {
            for task in recv {
                task();
            }
        })
    }
    sender
});

fn spawn&lt;F&gt;(task: F) where F: FnOnce() + Send + 'static {
    QUEUE.send(Box::new(task)).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>首先我们在第5行代码定义了什么叫做同步任务，因为同步任务的话只需要执行一次就行了，所以是 <code>FnOnce()</code>，因为这个任务是从用户线程 push 
到全局队列，跨线程到工作线程，所以需要有<code>Send</code>约束和 <code>static</code> 生命周期，然后封装到 Box 中。第 8 行构建了一个并发的队列，起了 4 
个线程，每个线程拿到队列的接收端，然后在一个循环中执行 task，当然执行 task 的过程可能会 panic，这里为了演示我就没有处理。第17行 <code>sender</code> 就保存着在全局静态变量 QUEUE 上，当用户调用 <code>spawn</code>时，拿到 <code>QUEUE</code> 调用 <code>send</code> 方法，将任务 push 到队列中。</p>
<h2><a class="header" href="#异步任务的多线程" id="异步任务的多线程">异步任务的多线程</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-3.png" alt="异步任务的多线程" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Task = Box&lt;dyn FnMut() -&gt; bool + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>接下来我们看一下异步任务的多线程池，首先定义不能立即完成，需要多次执行的任务为异步任务，因此 <code>FnOnce()</code> 就不满足了，需要使用 
<code>FnMut </code>，它返回的结果是个布尔值，表示是否执行完任务。但是这样定义就有个问题，如果这个函数没有被工作线程执行完，工作线程就不知道接下来该怎么办了，如果一直等着直到这个任务能够执行，全局队列中的其他任务就不能被执行；直接扔掉这个任务也不行。因此Rust的设计用了一个很巧妙的办法，<code>Exector</code> 就不关心这个任务什么时候好，在执行的时候创建一个 <code>Waker</code>，然后告诉 task，“如果你什么时候好了，可以通过 <code>Waker</code> 把它重新放到全局队列里去” 以便再次执行，这样的话 Task 的定义就多出了 <code>Waker</code> 参数，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Task = Box&lt;dyn FnMut(&amp;Waker) -&gt; bool + Send + 'static&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>这样异步任务执行没有 ready 的时候，可以将拿到 <code>Waker</code> 注册到能监控任务状态的 <code>Reactor</code> 中，如 ioepoll、timer 等，<code>Reactor</code> 发现任务 ready 后调用 <code>Waker</code> 把任务放到全局队列中。</p>
<h3><a class="header" href="#异步任务的多线程-executor" id="异步任务的多线程-executor">异步任务的多线程 Executor</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-4.png" alt="异步任务的多线程 Executor" /></p>
<p>在Rust中，对于异步计算的标准定义是Future trait</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}

pub trait Future {
    type Output;
    fn poll(&amp;mut self, cx: &amp;Waker) -&gt; Poll&lt;Self::Output&gt;;
    // fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>poll 方法返回的是一个枚举类型 <code>Poll</code>，它和返回布尔值是类似的，只不过语义会更清晰一些，如果没好的话就返回一个 <code>Pending</code>，好了的话就返回一个 
<code>Ready</code>。标准库里用的不是<code>&amp;mut self</code>，而是<code>Pin&lt;&amp;mut Self&gt;</code>，因为 30 分钟讲不完，所以在这里先跳过。下面就是整个异步任务多线程的模型图：</p>
<p><img src="chapter_1/../image/rust-china-config-async-5.png" alt="异步任务的多线程 Executor" /></p>
<p>首先用户通过 <code>spawn</code> 函数把异步任务 push 到全局队列里去，然后工作线程会拿到 task 执行，并且创建一个 <code>Waker</code>，传给执行的 <code>Future</code>，如果任务执行完成了，那就 
ok 了；如果没执行完成，<code>Future</code> 负责把 <code>Waker</code> 注册到 <code>Reactor</code> 上面，<code>Reactor</code> 负责监听事件，收到事件后会把 <code>Waker</code> 唤醒，把 task 
放到全局队列中，这样下次其他线程可以拿到这个 task 继续执行，这样循环重复直到任务执行完毕。</p>
<h3><a class="header" href="#waker-接口的要求" id="waker-接口的要求">Waker 接口的要求</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-6.png" alt="Waker 使用方" /></p>
<p><code>Waker</code> 在这个过程中充当着十分重要的角色，我们来看一下 Waker 的接口需要满足哪些要求：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Waker {
    pub fn wake(self);
}

impl Clone for Waker;

impl Send for Waker;

impl Sync for Waker;
<span class="boring">}
</span></code></pre></pre>
<p>对于使用方的要求，首先 <code>Waker</code> 本身是唤醒的功能，所以它要提供一个 <code>wake</code> 方法。异步任务可能会关心多个事件源，比如说定时器、IO，也就是说 <code>Waker</code> 可能对应不同的 
<code>Reactor</code>，因为 <code>Future</code> 在 <code>poll</code> 的时候只是传了一个 <code>Waker</code>，现在要把 <code>Waker</code> 注册到多个 <code>Reactor</code> 上，就需要 <code>clone</code>。然后 
<code>Executor</code> 和 <code>Waker</code> 可能不在一个线程里面，<code>Waker</code> 需要跨线程发送到 <code>Reactor</code> 上面，所以也就需要一个 <code>Send</code> 
的约束。最后多个事件源可能同时调用这个 <code>Waker</code>，这里就存在并发调用的问题，要满足并发调用的话就需要实现<code>Sync</code>约束。这是对 <code>Waker</code> 使用方的要求。</p>
<p><img src="chapter_1/../image/rust-china-config-async-7.png" alt="Waker 提供方" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Waker {
    pub unsafe fn from_raw(waker: RawWaker) -&gt; Waker
}

pub struct RawWaker {
    data: *const (),
    vtable: &amp;'static RawWakerTable,
}

pub struct RawWakerTable {
    clone: unsafe fn(*const ()) -&gt; RawWaker,
    wake: unsafe fn(*const ()),
    wake_by_ref: unsafe fn(*const ()),
    drop: unsafe fn(*const ())
}
<span class="boring">}
</span></code></pre></pre>
<p>不同的 <code>Executor</code> 有不同的内部实现，而 <code>Waker</code> 又是一个公共统一的 API。有的<code>Executor</code>有一个全局队列，有的是一个线程局部队列，有的 
<code>Executor</code> 可能只支持单个 task 的执行，因此他们的唤醒机制是完全不一样的。要构造统一的 <code>Waker</code> 必然涉及多态，Rust 中是采用自定义虚表的方式实现的，通过 
<code>RawWaker</code> 来构造 <code>Waker</code>，<code>RawWaker</code> 有个数据字段，和一个静态的虚表，不同的 <code>Executor</code> 就是要把这些虚表中的方法全部实现，</p>
<h3><a class="header" href="#waker-实现需要考虑的并发问题" id="waker-实现需要考虑的并发问题">Waker 实现需要考虑的并发问题</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-8.png" alt="Waker 实现需要考虑的并发问题" /></p>
<p><code>Waker</code> 在实现上可能会有一些并发上的问题，我们先说第一个问题，<code>wake</code> 调用之间的并发，需要保证只将任务push执行队列一次。如果有两(多)个 <code>Reactor</code> 同时执行 
<code>Waker::wake</code> 的话，两个 <code>Reactor</code> 都成功把任务 push 到全局队列里去，如果第一次push的让线程 A 拿到了，第二次pushed让线程 B 拿到了，线程 A 和 B 
现在同时调用<code>poll</code>，因为 <code>poll</code> 本身 <code>Self</code> 参数是 <code>&amp;mut self</code> 的，也就是说是互斥的，这样就会造成线程安全问题。</p>
<p>第二个问题，<code>wake</code> 调用和 <code>poll</code> 之间的并发，一个任务正在执行<code>poll</code>，但是之前调用<code>poll</code>的时候把已经<code>Waker</code>注册到一个 <code>Reactor</code> 中，这个 <code>Reactor</code> 
突然好了，现在它调用<code>Waker::wake</code>试图把任务push到并发队列里去，如果push能成功的话，那么另一个线程从队列里取到任务，并尝试调用<code>poll</code>，而当前这个任务又在<code>poll </code>的过程中，因此会导致和上面一样的并发问题。</p>
<p><code>async-task</code> 完美的解决了这些并发问题，并且它提供了十分优雅的 API，我把<a href="https://zhuanlan.zhihu.com/p/92679351">源码解析</a>放在了知乎上面，大家有兴趣可以看一下。</p>
<h3><a class="header" href="#异步任务多线程-executor" id="异步任务多线程-executor">异步任务多线程 Executor</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-9.png" alt="异步任务多线程 Executor" /></p>
<p>如果用 <code>async-task</code> 处理这个问题，代码应该是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use crossbeam::channel::{unbounded, Sender};
use once_cell::sync::Lazy;
use async_task;

static QUEUE: Lazy&lt;Sender&lt;async_task::Task&lt;()&gt;&gt;&gt; = Lazy::new(|| {
    let (sender, reciver) = unbounded::&lt;Task&gt;();
    for _ in 0..4 {
        let recv = reciver.clone();
        thread::spawn(|| {
            for task in recv {
                task();
            }
        })
    }
    sender
});

fn spawn&lt;F, R&gt;(future: F) -&gt; async_task::JoinHandle&lt;R, ()&gt; 
where 
    F: Future&lt;Output = R&gt; + Send + 'static,
    R: Send + 'static,
{
    let schedule = |task| QUEUE.send(task).unwrap();
    let (task, handle) = async_task::spawn(future, schedule, ());
    task.schedule();
    handle
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看到和之前的同步任务多线程池相比，工作线程的代码基本一致，<code>spawn</code> 函数有一些区别。使用 <code>async_task</code> 很简单实现了异步任务多线程池的处理。</p>
<h3><a class="header" href="#future-和-reactor-之间的并发" id="future-和-reactor-之间的并发">Future 和 Reactor 之间的并发</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-10.png" alt="Future 和 Executor 之间的并发" /></p>
<p><code>Future</code> 如果<code>poll</code>的时候没有好的话，它负责把 <code>Waker</code> 注册到 <code>Reactor</code> 里去，这里面会有一个 <code>Waker</code> 过期的问题。第一次调用 <code>poll</code> 和第二次调用 
<code>poll</code> 时，<code>Executor</code> 传的 <code>Waker</code> 可能不是同一个，只有最新的 <code>Waker</code> 能把 task 唤醒，老的 <code>Waker</code> 就唤不醒，这样导致的问题是每次 <code>poll</code> 
的时候都要把 <code>waker</code> 更新到 <code>Reactor</code> 里，以确保能够唤醒 task。</p>
<p>比如上图中的例子，<code>Future</code> 同时对两个事件感兴趣，对应着两个 <code>Reactor</code>。<code>Future</code> 在 <code>poll</code> 的时候需要向 Reactor1 注册 <code>waker</code>，也要向 
Reactor2 注册 <code>waker</code>，当它下次 <code>poll</code> 的时候每次都要把两个 <code>waker</code> 更新，那么现在问题来了，<code>Future</code> 的 <code>poll</code> 执行在 <code>Executor</code> 线程，<code>Reactor</code> 执行在 <code>Reactor</code> 线程，一个线程往里面写，另一个线程试图从里面读，并发问题就出现了。为了处理这个问题，最简单的方式就是加一把锁，每个 <code>Reactor</code> 都要加锁解锁，这个操作本身就比较复杂，比较耗时。</p>
<p><img src="chapter_1/../image/rust-china-config-async-11.png" alt="AtomicWaker" /></p>
<p><code>AtomicWaker</code> 完美处理了这个问题，它通过单生产者多消费者的模式，将 <code>waker</code> 放到 <code>AtomicWaker</code> 里面，<code>AtomicWaker</code> 被多个 <code>Reactor</code> 
共享，<code>Waker</code>只需要更新一次，所有 <code>Reactor</code> 就能拿到最新的 <code>waker</code>。</p>
<h2><a class="header" href="#future-的可组合性" id="future-的可组合性">Future 的可组合性</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-12.png" alt="Future 的可组合性" /></p>
<p>异步任务本身是可以组合的，比如发起一个 HTTPS 请求涉及查询 DNS 拿到 IP，建立 TLS 
链接，发送请求数据，拿到响应数据，过程中的每一步都是异步任务，把这些异步任务组合到一起就是一个大的异步任务。 <code>Future</code>本身设计也是可组合的，比如下面的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>future1
    .map(func)
    .then(func_return_future)
    .join(future2);
<span class="boring">}
</span></code></pre></pre>
<p>因为 <code>Future</code> 要执行的话必须发到 <code>Executor</code> 里面，因此上面的代码还没有发到 <code>Executor</code> 里面去，所以它本身是没有执行的。上面的代码等于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Join::new(
    Then::new(
        Map::new(future1, func), 
        func_return_future
    ), 
    future2
);
<span class="boring">}
</span></code></pre></pre>
<p>它是一个声明式的，最终会产生一个结构体，是一个如上图所示的树形结构，当整个任务丢到 <code>Executor</code> 里去执行的时候，<code>poll</code> 方法 <code>Future</code> 的树根结点开始，执行到叶子节点，最底层的叶子节点 futrue 是专门跟 <code>Reactor</code> 打交道的，所以大部分开发者是不需要关心 <code>Reactor</code> 的，因此可能对 <code>Reactor</code> 概念可能了解不多。</p>
<p>当一个叶子节点没好的时候，它会把传下来的 <code>waker</code> 注册到 <code>Reactor</code> 里面去。当<code>Reactor</code> 发现任务可以继续推进了，会调用 <code>waker</code> 把 任务
放入到全局队列中，某个线程拿到任务后，会重新从根节点 poll。以上就是整个的执行过程。</p>
<h3><a class="header" href="#joinn-组合的效率" id="joinn-组合的效率">JoinN 组合的效率</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-13.png" alt="JoinN 组合的效率" /></p>
<p>上面的 <code>Future</code> 组合模型涉及到一个 <code>JoinN</code> 组合的效率问题，问题是怎么产生的呢？<code>waker</code> 只用于唤醒整个task，但是没有携带任何唤醒信息，比如 task 
是怎么被唤醒的。<code>JoinN</code> 负责把多个 <code>Future</code> 组合在一起同时并发的执行，<code>oin4</code> 把 4 个 <code>Future</code> 组合，每次 <code>poll</code> 
的时候挨个去执行子 <code>Future</code>，如果没有好的话就会注册到 <code>Reactor</code> 里面，假设第二个突然就好了，下一次 <code>poll</code> 时，Join4 
并不知道自己为什么被唤醒了，只能挨个再遍历一遍 <code>Future</code>，但其实第一、三、四都是浪费掉的。</p>
<p><img src="chapter_1/../image/rust-china-config-async-14.png" alt="Waker 的拦截和包装" /></p>
<p>怎么解决这个问题呢？<code>futures-rs</code> 里面有一个 <code>FuturesUnordered</code> 专门处理这个事情，可以管理成千上万个子 <code>Future</code>，它内置了一个并发队列，维护已经 
ready 的子 <code>Future</code>。当 <code>Executor</code> 在 <code>poll</code> 整个任务的时候，它只遍历并发队列，挨个拿出来执行，执行的时候并不是把 <code>waker</code> 
原封不动的传下去，而是进行了一次包装拦截：<code>wake</code>调用的时候，它会先把 <code>Future</code> 添加到自己的ready队列里面去，再去通知<code>Executor</code>的全局队列，<code>Executor</code> 
下次再 
<code>poll</code> 
的时候直接从内置的并发队列去执行 <code>Future</code>，这样能达到效率最大化。</p>
<h2><a class="header" href="#异步任务之间的同步" id="异步任务之间的同步">异步任务之间的同步</a></h2>
<p><img src="chapter_1/../image/rust-china-config-async-15.png" alt="异步任务之间的同步" /></p>
<p>传统多个线程之间也有同步的需求，比如说锁。异步任务之间也不可能是完全隔离的，它们之间可能做一些消息的交互，我们比较一下线程和 Task 之间的区别：</p>
<p>｜｜ 线程 ｜ Task ｜
｜----｜----｜----｜
｜睡眠｜ thread::park｜return Pending｜
｜唤醒｜thread::unpark｜Waker::wake｜
｜获取方式｜thread::current()｜poll的参数｜</p>
<p>线程如果想暂停工作可以调用 <code>thread::park</code>，task想暂停工作可以直接 <code>return Pending</code>；线程可以通过 <code>thread::unpark</code> 唤醒，task 
需要调用 <code>Waker::wake</code>；获取方式上，线程直接调用 <code>thread::current</code>，task 是通过 <code>poll</code> 的参数拿到 <code>waker</code>。</p>
<h3><a class="header" href="#异步任务之间的同步-mutex" id="异步任务之间的同步-mutex">异步任务之间的同步 Mutex</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-16.png" alt="异步任务之间的同步 Mutex" /></p>
<p><code>Mutex</code> 数据结构里面有一个数据字段，表示要锁的数据，一个 <code>locked</code> 
原子变量表示有没有被锁住，还有一个等待队列，异步任务想拿锁却没有拿到，它就只能进入等待队列里面，等着别人去通知它。先看一下拿锁的过程，如果 <code>waker</code> 拿到锁之前 <code>locked</code> 是 
false，表示拿锁成功了，如果没拿到失败了的话，就只能等，把 <code>waker</code> 丢到等待队列里。拿到锁的任务想释放这把锁的时候，把 <code>locked</code> 改成 false，并从等待队列中拿一个 
<code>waker</code> 出来，去唤醒相应的task。</p>
<p>这里跟大家讲一个很多人误区的地方，很多人认为异步任务里面是必须要用异步锁的，同步锁有阻塞就不行，这是不对的。大部分的等待队列的实现都是用了同步锁，也就是说 <code>Mutex</code> 
也不是完全异步的，它本身有个同步锁在里面。如果你在应用里面只是想保护一段数据，对共享的数据做点加减操作，那么应该用 std 
里面的同步锁，因为用异步锁的话，更新内部的等待队列需要加同步锁，这个开销可能比你直接用同步锁更新共享数据还要复杂很多。</p>
<p>那么什么时候用异步锁呢？在保护 IO 资源的时候，当你的锁需要跨越多个 <code>.await</code>，时间差的比较大的时候，那应该优先使用异步锁。</p>
<h3><a class="header" href="#异步任务之间的同步-oneshot" id="异步任务之间的同步-oneshot">异步任务之间的同步 Oneshot</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-17.png" alt="异步任务之间的同步 Oneshot" /></p>
<p><code>Oneshot</code> 是做什么事情的呢？它负责在两个线程之间传递一个数据，一个 task 在执行，另一个 task 在等待，前者执行完会通过 <code>Oneshot</code> 把数据传递给后者。图上所示就是 <code>Oneshot</code> 的数据结构，<code>state</code> 中纪录了很多元信息，比如数据是否已经写了，<code>sender</code> 是否应析构掉了，<code>TxWaker</code> 是否已经存了，<code>RxWaker</code> 是否已经存了，<code>receiver</code> 是否已经 <code>drop</code> 掉了。</p>
<p>发送端发送数据的时候，首先在修改state前， data是完全由 <code>sender</code> 自由访问的，写完 data 后把 <code>state</code> 状态改掉，表示这个 data 已经写完了。然后把接收端的 
<code>RxWaker</code> 取出来然后唤醒，唤醒之后 task 下次执行就可以把数据拿到了。如果 <code>sender</code> 没有发送数据，现在要把它析构掉，析构时要注意接收端还在一直等，因此 <code>sender</code> 
析构是也要把 <code>state</code> 修改掉，把相关的 <code>RxWaker</code> 唤醒，通知 <code>reciver</code> 不要再等了。</p>
<p>接收端的实现是一个 <code>Future</code>，它本身在 <code>poll</code> 的时候会读取 <code>state</code>，如果有数据那就说明发送端数据已经写完了，直接读取数据。如果没有数据的话就要等待，把它的 
<code>waker</code> 存在 <code>Oneshot</code> 的 <code>RxWaker</code> 里面，同时也更新相应的 <code>state</code>，表示接收端的 <code>RxWaker</code> 已经存在。接收端在 <code>drop</code> 的时候，也要通知 
<code>sender</code>，表示“我现在对你的数据没有兴趣了，你可以不用继续计算下去&quot;，所以接受端在 drop 的时候也要修改 <code>state</code>，从 <code>Oneshot</code> 里面拿到发送端的 
<code>TxWaker</code>，把发送端唤醒。</p>
<h3><a class="header" href="#异步任务之间的同步-waitgroup" id="异步任务之间的同步-waitgroup">异步任务之间的同步 WaitGroup</a></h3>
<p><img src="chapter_1/../image/rust-china-config-async-18.png" alt="异步任务之间的同步 WaitGroup" /></p>
<p>接下来讲一下我自己实现的 <code>WaitGroup</code>，它在 golang 里面是非常常见的。它可以构造出多个子任务，等待所有的子任务完成后，再继续执行下去，下面是一个演示代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use waitgroup::WaitGroup;
use async_std::task;

async {
    let wg = WaitGroup::new();
    for _ in 0..100 {
        let w = wg.worker();
        task::spawn(async move {
            drop(w);
        });
    }
    wg.wait().await;
}
<span class="boring">}
</span></code></pre></pre>
<p>首先先构造一个 <code>WaitGroup</code>，然后创建 100 个 <code>worker</code>，在每个任务执行完后，只要把 <code>worker</code> drop 掉，就说明任务已经完成了。然后 <code>WaitGroup</code> 
等到所有的子任务完成后继续执行。下面介绍一下它的实现，其实比较简单：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Inner {
    waker: AtomicWaker,
}

impl Drop for Inner {
    fn drop(&amp;mut self) {
        self.waker.wake();
    }
}

pub struct Worker {
    inner: Arc&lt;Inner&gt;,
}

pub struct WaitGroup {
    inner: Weak&lt;Inner&gt;
}

impl Future for WaitGroup {
    type Output = ();

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        match self.inner.upgrade() {
            Some(inner) =&gt; {
                inner.waker.register(cx.waker());
                Poll::Pending
            }
            None =&gt; Poll::Ready(())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>注意到如果某一个 <code>worker</code> 完成了 task，它并不需要去唤醒 <code>Waker</code>，<code>WaitGroup</code> 只关心所有任务都结束了，只需要让最后一个 <code>worker</code> 去唤醒 
<code>waker</code>。什么时候是最后一个 <code>worker</code> 呢？我们可以借用标准库里的 <code>Arc</code>，<code>Arc</code> 是一个共享引用，当所有的 <code>Arc</code> 
强引用都销毁的时候，就会析构内部的数据，只要在 <code>Arc</code> 包装的数据的 <code>drop</code> 方法里面把 <code>waker</code> 唤醒就可以了。</p>
<p><code>WaitGroup</code> 持有一个弱引用，所有的 <code>Worker</code> 都持有强引用，<code>WaitGroup</code> 在 <code>poll</code> 
的时候试图把弱引用升级成强引用，如果升级失败了，说明所有的强引用都没了，也就是任务都执行完了，就可以返回 <code>Ready</code>。如果升级成功了，说明现在至少还有一个强引用，那就把 <code>waker</code> 注册到 <code>AtomicWaker</code> 里面。这里有一个边界条件，在升级结束的瞬间，所有的 <code>worker</code> 全部 <code>drop</code> 掉了，这时还不会调用 
<code>wake</code>，因为在升级成功时，会产生一个临时的强引用 
<code>inner</code>，这时更新waker后，在这个临时的强引用销毁的时候调用 <code>drop</code>，然后调用 <code>waker.wake()</code> 把任务唤醒，因此不会丢失通知。整个过程就完整了。</p>
<h1><a class="header" href="#生产实践-译1password-的-rust-实践" id="生产实践-译1password-的-rust-实践">生产实践 |「译」1password 的 Rust 实践</a></h1>
<hr />
<p><a href="https://serokell.io/blog/rust-in-production-1password">英文原文</a></p>
<p>Rust已经风靡编程语言界。自2015年发布1.0版本以来，它一直是最受喜爱的编程语言之一，拥有一批忠实的开发者和贡献者。</p>
<p>为何 Rust 在软件开发者中会如此受宠？为了解答这个疑问，我们踏上了一段关于 Rust 软件开发的新旅程。我们将采访一些在重要项目中使用 Rust 的技术人员。这些重要项目涉及但不限于手机应用、服务程序、初创公司的最小可行化产品。</p>
<p>在本系列的第一期中，我们采访了 <a href="https://1password.com/">1Password</a> 的工程副总裁 Michael Fey。他们为什么选择 Rust 做开发？Rust 给安全软件带来了哪些好处？如果你想使用 Rust 开发类似的软件，应该关注哪些库？如果你想知道这些问题的答案，请继续阅读。</p>
<p><strong>你能给我们介绍下关于公司和你的一些情况吗?</strong></p>
<p>1Password 是一款已经被数百万人和70,000家企业采用的优秀的密码管理软件，用于保护他们的敏感数据。它支持主流浏览器、桌面和移动设备. 它能帮助你记住所有你没有必要去记住的密码。</p>
<p>我是 1Password 客户端开发的工程副总裁。如果您曾在 Mac、Windows PC、iPhone、iPad、Android 手机、平板电脑或浏览器中使用过1Password，那么您就使用了我们团队开发的软件。从2004年开始，我们就专注于打造这款软件。这是一款体验绝佳的安全产品，为此我们感到非常自豪。</p>
<p><img src="chapter_1/../image/password.jpg" alt="" /></p>
<p><strong>你能谈谈 1Password 的技术栈吗？你们的代码中有多大一部分是用 Rust 编写的?</strong></p>
<p>我们在 1Password 中使用Rust已经有好几年了。我们的 Windows 团队是这项工作的领头羊。Windows版的1Password 7 中大约 70% 的代码是用 Rust 编写的。我们还在2019年底把 1Password Brian (一种浏览器填充逻辑的引擎) 从 Go 移植到 Rust，然后把 Rust 编译为 WebAssembly，最后再部署到浏览器插件中。这样我们就可以利用到 WebAssembly 的速度和性能。</p>
<p>它们得益于产品采用了Rust，在过去几年我们取得了巨大成功。现在我们正在对几乎整个产品线进行重写，Rust 在其中扮演主要角色。我们正在使用 Rust 创建一个headless 1Password 应用: 把所有的业务逻辑、加密解密、数据库访问、服务器通信等统统包裹到一个薄薄的 UI 层中，然后作为原生应用部署到系统中。</p>
<p><strong>1Password 采用 Rust 的原因是什么，是看中它的高性能或类型/内存安全吗？</strong></p>
<p>最初吸引我们使用 Rust 的主要原因之一是内存安全; Rust 可以增强我们对保护客户数据安全的信心，这无疑让我们兴奋不已。不过，除了内存安全之外，我们对Rust生态系统的喜爱还有很多。没有传统的运行时是一个显著的性能优势；例如，我们不再担心垃圾收集器的性能开销。Rust提供了一种 &quot;程序正确性 &quot;的形式和许多针对运行时未定义行为的保证。强类型系统在编译时会强制保证这些规则。仔细地将应用逻辑与Rust的强类型规则对齐，使API难以被误用。同时，因为不需要对约束和不变量进行运行时检查，所以可以写出简洁的代码。在程序执行之前，编译器就可以保证: 不存在无效的运行时代码路径, 不会因此产生程序异常。因为运行时状态验证更少，所以写出的代码会更干净、更高效、更内聚、质量也更高。与其他语言相比，Rust 很少需要运行时调试。如果能编译通过，你就可以相当确定它不会表现出未定义行为。它可能不是你想要的，但它会是 &quot;正确的&quot;</p>
<p>Rust 的另一个非常强大却常被忽视的特性是程序化宏系统[1]。它使我们能够编写一种工具：可以自动将 Rust 中定义的类型与我们的客户端语言 (Swift、Kotlin和 TypeScript) 共享。这种工具的输出会自动处理序列化/反序列化过程。这意味着客户端开发人员在与 Rust 库交互时，可以继续使用他们选择的语言进行编程，同时又可以消除使用 FFI 进行 JSON 解析的烦恼。除了上述这些益处，我们还能获得每一种目标语言在编译期类型检查的好处。我们已经把这个工具集成到持续集成服务器中，这意味着对Rust模型的改变会导致客户端应用程序的编译失败，而这些失败情况会在代码评审中被发现。</p>
<p>这个工具已经成为我们开发过程中不可或缺的组成部分，让我们的进度比以前快得多。一旦我们的类型在Rust中被定义，我们就能立即在客户端语言中生成等价类型。这使我们的开发人员能够专注于解决问题。而不必去捋模版代码，再使用 FFI 进行通信</p>
<p><strong>Rust对开发像1Password这样以安全为中心的应用程序的支持（库和其他）有多好？</strong></p>
<p>对于实现安全软件的大部分基础组件来说，那是绰绰有余的。有两个大型的、突出的密码学平台( <a href="https://github.com/briansmith/ring">ring</a>  和<a href="https://github.com/RustCrypto">Rust Crypto</a> 组)，它们提供了丰富的功能。正如我在前面提到的，用 Rust 编写程序会让你对内存的使用充满信心，也让你更难意外引入与内存相关的漏洞。还有一个很好的系统，用来跟踪Rust crates中不时出现的漏洞：<a href="https://rustsec.org/">RustSec</a> 数据库。它是由其他 Rust 开发者提供的社区资源，并且经常更新。此外，Rust 和 Cargo 还包含了 batteries-included 测试框架。这意味着你总是有一种容易的方式来编写单元测试套件，以保证关键代码(比如加密函数)的正确性。</p>
<p>如果存在 Rust 原生安全库，那当然是最理想的 (而且它们会及时出现) 。如果没有也不必担心，我们还有其他选项：使用C语言或原生平台库中的一些东西。在我们的Rust代码中，我们将这一点发挥得淋漓尽致，比如调用生物识别解锁的原生实现（Touch ID、Face ID、Windows Hello）和特定平台的设置实现(比如苹果平台上的NSUserDefaults)。</p>
<p><strong>其中有什么特别的Rust库是你想介绍一下的吗？</strong></p>
<p>当然有。1Password 使用了 Tokio、Hyper/Reqwest、Ring 和Neon。得益于这些 Rust 库，我们才能完成这个雄心勃勃的项目。你也应该看看我们在 <a href="http://crates.io/">crates.io</a> 上的 <a href="https://crates.io/crates/password-rules-parser">密码规则解析器</a>  。它主要基于苹果支持的规范。他们的工具和文档可以在 <a href="https://developer.apple.com/password-rules/">这里</a> 找到。</p>
<p><strong>在用 Rust 开发 1Password 的过程中，遇到的最大挑战是什么？</strong></p>
<p>我们团队中的许多人都是Rust的新手，他们经历了典型的学习曲线，这与它的内存管理和所有权模型有关。我们还发现编译时间很长；我们的CPU和风扇肯定会受到锻炼。😄</p>
<p><strong>你对结果满意吗？</strong></p>
<p>绝对满意</p>
<p><strong>你有什么关键的心得想跟我们的观众分享吗？</strong></p>
<p>如果你是Rust的新手，请从小处着手，并在此基础上进行改进。我们在刚开始的时候进行了大量的实验，试图找到基于Rust的最佳解决方案。当你的实验成功后，回顾一下你过去使用其他语言的工作方式，看看你的代码能否从Rust的理念中获益。</p>
<p>如果你是1Password的新用户，今天就可以通过这个链接注册，家庭和个人账户第一年可以节省50%的费用。如果你正在做一个开源项目，你可以免费获得一个1Password Teams账户。请前往我们的 GitHub 仓库了解更多信息。</p>
<p>附录</p>
<p>[1]  指的是<a href="https://github.com/1Password/typeshare">typeshare</a>. 它的功能是把一些用rust 写的结构体生成为其他语言的结构体，比如下面的rust 的一个struct</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
struct Teacher {
    name: String,
    age: u64,
    id: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>转化为typescript的变成如下:</p>
<pre><code class="language-typescript">export interface Teacher {
    name: string;
    age: number;
    id: number;
}
</code></pre>
<p>它同时支持typescript,swift,java. 它把Rust写的struct生成了团队其他中定义各语言结构体的规范。所以该规范也只是1password团队内部定义domain层的规范。不一定适合其他团队。</p>
<p>[2]  另一款开源的密码管理器<a href="https://bitwarden.com/">bitwarden</a>.  也有rust 实现后台<a href="https://github.com/dani-garcia/bitwarden_rs">bitwarden_rs</a>.  有兴趣可以进一步阅读。</p>
<hr />
<p>译者简介：</p>
<p>柴杰，中国科学技术大学集成电路工程专业，在读硕士研究生。兴趣与专长为虚拟内存系统、分布式系统。</p>
<p>审校：</p>
<ul>
<li>严炳（ryan），算法，大数据开发从业者，喜欢和有开源精神的人一起共事。</li>
</ul>
<h1><a class="header" href="#cita-用rust写protobuf扩展" id="cita-用rust写protobuf扩展">Cita: 用Rust写Protobuf扩展</a></h1>
<p>作者： 宁志伟</p>
<p>本文为《Rust 唠嗑室》第 17 期 - 《用 Rust 写 Protobuf 扩展》的文字版本。</p>
<hr />
<h2><a class="header" href="#protobuf" id="protobuf">Protobuf</a></h2>
<p><code>Protocol Buffers</code> (简称 <code>Protobuf</code> ) ，是 <code>Google</code> 出品的序列化框架，与开发语言无关，和平台无关。具有体积小，速度快，扩展性好，与 <code>gRPC</code> 搭配好，支持的语言多等特点，是目前应用最广泛的序列化框架。</p>
<p>使用场景一般是在微服务架构中，用来定义微服务之间的 <code>gRPC</code> 接口，以及相关的参数/返回值等数据结构的定义。</p>
<p>通过官方的编译器 <code>protoc</code> 以及相应的插件可以方便的生成不同语言的实现代码。这样不同的微服务可以使用不同的开发语言，同时还能顺利进行交互。</p>
<h2><a class="header" href="#cita-cloud中的protobuf" id="cita-cloud中的protobuf"><code>CITA-Cloud</code>中的<code>Protobuf</code></a></h2>
<p><code>CITA-Cloud</code> 采用了<a href="https://cita-cloud-docs.readthedocs.io/zh_CN/latest/blockchain.html">微服务架构</a>，因此也采用了 <code>Protobuf</code> 和 <code>gRPC</code> 的组合。</p>
<p>但是因为 <code>Protobuf</code> 语言无关的特性和广泛的应用，使得其具有抽象和通用的特点。因此也可以把 <code>Protobuf</code> 当作一种建模语言来使用，<a href="https://zhuanlan.zhihu.com/p/162839054">参见文章</a>。</p>
<p><code>CITA-Cloud</code> 目前是在<a href="https://github.com/cita-cloud/cita_cloud_proto">协议</a>中直接把交易和区块等数据结构固定下来的。但是最近的思考发现，其中的很多字段都是为了实现某种应用层面的协议而存在的。比如交易中的 <code>nonce</code> 字段就是为了实现应用层面的去重协议。</p>
<p>因此，后续计划提供一个框架，方便用户自定义交易和区块等核心数据结构，以及相关的处理函数。但是 <code>Protobuf</code> 通常只能生成数据结构，以及相关的 <code>get/set</code> 等模式比较固定的代码，如果要生成复杂的成员函数，就需要一些扩展能力。</p>
<h2><a class="header" href="#protobuf扩展" id="protobuf扩展"><code>Protobuf</code>扩展</a></h2>
<p><code>Protobuf</code> 的扩展能力可以分为两种： <code>Protobuf</code> 本身的扩展和 <code>Protobuf</code> 插件。</p>
<p><code>Protobuf</code> 其实是个标准的编译器架构。我们可以把 <code>.proto </code>文件视作源码，官方的 <code>protoc</code> 编译器可以对应到编译器前端。</p>
<p><code>protoc</code> 接收一个或者一批 <code>.proto</code> 文件作为输入，解析之后输出一种中间描述格式，对应编译器中的 <code>IR</code> 。</p>
<p>但是有意思的是，这种中间描述格式是二进制的，其结构依旧由 <code>Protobuf</code> 本身描述。详细可以参见<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto">descriptor.proto</a>。</p>
<p><code>Protobuf</code> 插件可以对应到编译器后端，接收中间描述格式，解析其中的信息，据此生成具体语言的代码。</p>
<p>这里其实有个非常有意思的问题。插件在解析中间描述格式的数据时，因为这种格式是由 <code>descriptor.proto</code> 描述的，所以得先有个插件能把 <code>descriptor.proto</code> 生成开发插件所使用的开发语言的代码。</p>
<p>上面的话有点绕，举个具体的例子。比如我想用 <code>Rust</code> 实现一个插件，假如目前还没有 <code>Protobuf</code> 相关的 <code>Rust</code> 库，那就没办法用 <code>Rust</code> 代码来解析 <code>descriptor.proto</code> 对应的中间描述格式的数据，也就没法实现插件了。</p>
<p>这个问题其实就对应编译器里的自举问题。比如，想用 <code>Rust</code> 来写 <code>Rust</code> 编译器，那么一开始就是个死结了。解决办法也很简单，最开始的 <code>Rust</code> 编译器是用 <code>Ocaml</code> 实现的，然后就可以用 <code>Rust</code> 来写 <code>Rust</code> 编译器，实现编译器的 <code>Rust</code> 代码用前面 <code>Ocaml</code> 实现的版本去编译就可以解决自举问题了。</p>
<p><code>Protobuf</code> 这里也是同样的，官方提供了 <code>Java/Go/C++/Python</code> 等版本的实现，可以先用这些语言来过渡。</p>
<p>另外一种扩展方式是 <code>Protobuf</code> 本身提供了语法上的<a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">扩展机制</a>。这个功能可以对应到编程语言提供的宏等元编程功能。</p>
<p><code>Protobuf</code> 这个扩展能力有点类似<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266265125480448"><code>AOP</code></a>，可以方便的在已经定义的 <code>Message</code> 中增加一些成员。</p>
<p>更有意思的是，前面提到过，所有的 <code>.proto</code> 文件，经过 <code>protoc </code>之后，会被转换成由 <code>descriptor.proto</code> 对应的中间描述格式。而 <code>descriptor.proto</code> 中的 <code>Message</code> 也同样支持上述扩展功能，因此可以实现一种类似全局 <code>AOP</code> 的功能。</p>
<p>通过扩展 <code>descriptor.proto</code> 中的 <code>Message</code> ，可以实现给所有的 <code>Message</code> 都加一个 <code>option</code> 这样的操作。</p>
<h2><a class="header" href="#rust中相关的库" id="rust中相关的库"><code>Rust</code>中相关的库</a></h2>
<p><code>dropbox</code> 实现了一个 <code>Protobuf </code>库<a href="https://github.com/dropbox/pb-jelly"><code>pb-jelly</code></a>，它就是用 <code>Python</code> 来实现生成 <code>Rust</code> 代码部分的功能。具体实现其实比较简单，就是在拼 <code>Rust</code> 代码字符串。</p>
<p><a href="https://github.com/stepancheg/rust-protobuf"><code>rust-protobuf</code></a>是一个实现比较完整的 <code>Protobuf</code> 库，支持 <code>gRPC</code> 和相关的扩展能力。其中实现分为两部分，生成数据结构 <code>Rust</code> 代码的插件和生成 <code>gRPC</code> 相关代码的插件。具体实现封装的稍微好了一点，但是基本上还是在拼 <code>Rust</code> 代码字符串。</p>
<p><a href="https://github.com/danburkert/prost"><code>prost</code></a>是一个比较新的 <code>Protobuf</code> 库实现。功能上有点欠缺，不支持扩展。库本身只支持生成数据结构的<code>Rust</code> 代码。生成 <code>gRPC</code> 相关代码的功能在<a href="https://github.com/hyperium/tonic"><code>tonic-build</code></a>里，这个有点奇怪。</p>
<p>但是 <code>prost</code> 采用了很多新的技术。前面提到，插件只会生成数据结构相关的 <code>get/set</code> 等模式比较固定的代码， <code>prost</code> 实现了一个 <code>derive</code> 来自动给数据结构增加这些成员函数，这样生成的 <code>Rust</code> 代码就大大简化了，<a href="https://github.com/cita-cloud/cita_cloud_proto/blob/master/src/common.rs">参见例子</a>。</p>
<p>这也跟编译器架构能对应上：一个选择是把编译器后端做的很复杂，直接生成所有的代码，运行时比较薄；另外一个选择是编译器后端做的很简单，生成的代码也简单，但是运行时比较厚重。</p>
<p>另外 <code>gRPC</code> 相关的代码比较复杂， <code>tonic-build</code> 在生成的时候用了<a href="https://github.com/dtolnay/quote"><code>quote</code></a>库，提供类似<code> Rust</code> 代码语法树上的 <code>sprintf</code> 方法的功能，不管是便利性还是代码的可读性都比之前两个库好很多。</p>
<h2><a class="header" href="#后续计划" id="后续计划">后续计划</a></h2>
<p>后续计划使用 <code>Protobuf</code> 及其扩展能力，实现一个框架，不但用来描述交易和区块等核心数据结构，也以一种可配置的方式生成一些比较复杂的相关代码。</p>
<p>最重要的第一步就是要能解析出 <code>Protobuf</code> 扩展相关的信息，因为正常的 <code>.proto</code> 文件只能用于描述数据结构，扩展的 <code>option</code> 是唯一可以赋值的地方。</p>
<p>目前实现了一个<a href="https://github.com/rink1969/proto_desc_printer"><code>proto_desc_printer</code></a>，可以解析中间描述格式，特别是其中的扩展信息。</p>
<p>后续可以在这个基础上去做代码生成部分的工作，这里可以从 <code>prost</code> 吸取很多好的经验。</p>
<hr />
<p>作者简介：</p>
<p>宁志伟</p>
<p>溪塔科技首席架构师
首个微服务架构区块链<code>CITA</code> 首席架构师，区块链+云原生框架 <code>CITA-Cloud</code> 设计者。前阿里巴巴、华为技术专家，超过 <code>10</code> 年分布式系统架构设计，编程语言和虚拟机方面工作经验。</p>
<ul>
<li>
<p>Blog   : <a href="https://rink1969.github.io/">https://rink1969.github.io</a></p>
</li>
<li>
<p>GitHub : <a href="https://github.com/rink1969">https://github.com/rink1969</a></p>
</li>
<li>
<p>为国产自主云原生区块链<code>CITA-Cloud</code>点赞<a href="https://github.com/cita-cloud/cita_cloud_proto">https://github.com/cita-cloud/cita_cloud_proto
</a></p>
</li>
</ul>
<p>后期编辑：</p>
<p><a href="https://github.com/higker">丁 烁(Jarvib Ding)</a>，Rust 爱好者。</p>
<h1><a class="header" href="#建造者模式builder" id="建造者模式builder">建造者模式（Builder)</a></h1>
<h2><a class="header" href="#概述" id="概述">概述</a></h2>
<p>构建者模式是一种设计模式，提供一种灵活的解决方案，已解决面向对象程序设计中的各种对象创建问题。Builder设计模式的目的是将复杂对象的构造与其表示分离开来。是&quot;是四人帮&quot;设计模式之一[wiki]。建造者模式是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<p>定义：Builder设计模式的目的是将复杂对象的构造与其表示分离开来。通过这样做，同样的构造过程可以创建不同的表示。</p>
<h2><a class="header" href="#历史" id="历史">历史</a></h2>
<p>假如有一个复杂的对象，需要对其进行构造时需要对诸多成员变量和嵌套对象进行繁杂的初始化工作。有时这些初始化代码通常深藏于一个包含众多参数且让人看不懂的构造函数中；或者这些代码散落在客户端代码的多个位置。</p>
<ol>
<li>例如，创建一个房子，不同种类的房子有不同的风格，为每一种类型的房子创建一个子类，这可能会导致程序变得过于复杂。</li>
<li>或者无需生成子类，但是需要创建一个包括所有可能参数的超级构造函数，并用它来控制房屋对象的创建。这样虽然可以避免生成子类，但是会造成当拥有大量输入参数的构造函数不是每次都要全部用上。通常情况下，绝大部分的参数都没有使用，这使得对于构造函数的调用十分不简洁。</li>
</ol>
<h2><a class="header" href="#建造者模式-的使用" id="建造者模式-的使用">建造者模式 的使用</a></h2>
<p>建造者模式建议将对象构造的代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。每次创建对象时，都需要通过生成器对象执行一系列步骤。重点在于无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤。</p>
<h2><a class="header" href="#适用场景" id="适用场景">适用场景</a></h2>
<ul>
<li>使用建造者设计模式可以避免“重叠构造函数”的出现。
<ul>
<li>假设复杂函数中有十几个可选参数，那么调用这些函数会非常不方便，因此需要重载这个构造函数，新建几个只有较少参数的简化版本。</li>
<li>建造者设计模式让你可以分步骤生成对象，而且允许你仅适用必须的步骤。</li>
</ul>
</li>
<li>当使用代码创建不同形式的产品时，可使用生成器模式
<ul>
<li>如果你需要创建各种形式的产品，他们的制造过程相似且仅有细节上的差异，此时可使用生成器模式。</li>
<li>基本生成器接口中定义了所有可能的制造步骤，具体生成器将实现这些步骤来制造特定形式的产品。</li>
</ul>
</li>
<li>使用构造者模式构造其他复杂对象
<ul>
<li>构造者模式让你能分步骤构造产品，你可以延迟执行某些步骤而不会影响最终产品。</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#优点" id="优点">优点</a></h2>
<ul>
<li>可以分步骤创建对象，暂缓创建步骤或者递归运行创建步骤。</li>
<li>生成不同形式的产品，你可以复用相同的制造代码</li>
<li>单一职责原则，可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<h2><a class="header" href="#缺点" id="缺点">缺点</a></h2>
<p>由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。</p>
<h2><a class="header" href="#描述" id="描述">描述</a></h2>
<p>通过使用构建者助手创建一个对象。</p>
<h2><a class="header" href="#例子" id="例子">例子</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    println!(&quot;foo = {:?}&quot;, foo);
    println!(&quot;foo from builfer = {:?}&quot;, foo_from_builder);
}

#[derive(Debug, PartialEq)]
pub struct Foo {
    // lots of complicated fields
    bar : String,
}

pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new() -&gt; Self {
        // set the minimally required fields of Foo.
        Self {
            bar: String::from(&quot;x&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // set the name on the builder iteself,
        // and return the builder by value.
        self.bar = bar;
        self 
    }
    // if we can get away with not consuming the builder here, that is an 
    // advantage. It means we can use the FooBuilder as a template for constructing many Foo.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from Foo the FooBuilder, applying all settings in FooBuilder to Foo. 
        Foo { bar: self.bar }
    }
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Rust 编程之道. P234
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
    fn new() -&gt; CircleBuilder {
        CircleBuilder {
            x: 0.0, y: 0.0, radius: 1.0,
        }
    }
}

impl CircleBuilder {
    fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.x = coordinate;
        self
    }
    fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.y = coordinate;
        self
    }
    fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn build(&amp;self) -&gt; Circle {
        Circle {
            x: self.x, y: self.y, radius: self.radius,
        }
    }
}

fn main() {
  let c = Circle::new().x(1.0).y(2.0).radius(2.0).build();
  println!(&quot;area = {:?}&quot;, c.area());
  println!(&quot;c.x = {:?}&quot;, c.x);
  println!(&quot;c.y = {:?}&quot;, c.y);
}
</code></pre></pre>
<h2><a class="header" href="#动机" id="动机">动机</a></h2>
<p>当你需要许多不同的构造函数或者当构造有副作用时，这种方法有用。</p>
<h2><a class="header" href="#优点-1" id="优点-1">优点</a></h2>
<p>将构造方法与其他方法分离。</p>
<p>防止构造函数的扩散</p>
<p>可用于单次初始化以及更加复杂的构造。</p>
<h2><a class="header" href="#缺点-1" id="缺点-1">缺点</a></h2>
<p>比直接创建结构对象或简单的的构造函数更复杂。</p>
<h2><a class="header" href="#讨论" id="讨论">讨论</a></h2>
<p>这种模式在Rust（以及简单对象）中比在其他许多语言中更常见，这是因为Rust缺乏重载。由于你只能使用给定名称的单个方法，因此在Rust中使用多个构造函数要比C++、Java或其他语言好。</p>
<p>这种模式通常用于构建器对象本身就很有用的地方，而不仅仅是一个构建器。例如：std::process::Command 是Child的构建器。在这种情况下，不使用T和TBuilder的命名模式。</p>
<p>该示例通过值获取并返回生成器。接受并返回构建器作为可变引用通常更符合人体工程学（并且更有效）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut fb = FooBuilder::new();
fb.a();
fb.b();
let f = fb.builder();
<span class="boring">}
</span></code></pre></pre>
<p>以及FooBuilder::new().a().b().builder()样式。</p>
<h2><a class="header" href="#参见" id="参见">参见</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html">Description in the style guide</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>, a crate for automatically implementing this pattern while avoiding the boilerplate.</li>
<li><a href="https://rust-unofficial.github.io/patterns/idioms/ctor.html">Constructor pattern</a> for when construction is simpler.</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern (wikipedia)</a></li>
<li><a href="https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder">Construction of complex values</a></li>
<li>Rust编程之道 ch7,p234</li>
</ul>
<h2><a class="header" href="#项目中的使用" id="项目中的使用">项目中的使用</a></h2>
<h3><a class="header" href="#tokio-中的建造者模式-struct-a-hrefhttpsdocsrstokio110tokioindexhtmltokioaa-hrefhttpsdocsrstokio110tokioruntimeindexhtmlruntimeaa-hrefhttpsdocsrstokio110tokioruntimestructbuilderhtmlbuildera" id="tokio-中的建造者模式-struct-a-hrefhttpsdocsrstokio110tokioindexhtmltokioaa-hrefhttpsdocsrstokio110tokioruntimeindexhtmlruntimeaa-hrefhttpsdocsrstokio110tokioruntimestructbuilderhtmlbuildera">Tokio 中的建造者模式 Struct <a href="https://docs.rs/tokio/1.1.0/tokio/index.html">tokio</a>::<a href="https://docs.rs/tokio/1.1.0/tokio/runtime/index.html">runtime</a>::<a href="https://docs.rs/tokio/1.1.0/tokio/runtime/struct.Builder.html">Builder</a></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Builder {
    /// Runtime type
    kind: Kind,

    /// Whether or not to enable the I/O driver
    enable_io: bool,

    /// Whether or not to enable the time driver
    enable_time: bool,

    /// The number of worker threads, used by Runtime.
    ///
    /// Only used when not using the current-thread executor.
    worker_threads: Option&lt;usize&gt;,

    /// Cap on thread usage.
    max_blocking_threads: usize,

    /// Name fn used for threads spawned by the runtime.
    pub(super) thread_name: ThreadNameFn,

    /// Stack size used for threads spawned by the runtime.
    pub(super) thread_stack_size: Option&lt;usize&gt;,

    /// Callback to run after each thread starts.
    pub(super) after_start: Option&lt;Callback&gt;,

    /// To run before each worker thread stops
    pub(super) before_stop: Option&lt;Callback&gt;,

    /// Customizable keep alive timeout for BlockingPool
    pub(super) keep_alive: Option&lt;Duration&gt;,
}

pub fn new_current_thread() -&gt; Builder // 设置current thread 类型
//Returns a new builder with the current thread scheduler selected.
//Configuration methods can be chained on the return value.

pub fn new_multi_thread() -&gt; Builder // 设置 multi thread 类型
//This is supported on crate feature rt-multi-thread only.
//Returns a new builder with the multi thread scheduler selected.
//Configuration methods can be chained on the return value.

pub fn enable_all(&amp;mut self) -&gt; &amp;mut Self
// Enables both I/O and time drivers.
// Doing this is a shorthand for calling enable_io and enable_time individually. If additional components are added to Tokio in the future, enable_all will include these future components.

pub fn worker_threads(&amp;mut self, val: usize) -&gt; &amp;mut Self // 设置的runtime 用于工作的线程数
// Sets the number of worker threads the Runtime will use.
// This should be a number between 0 and 32,768 though it is advised to keep this value on the smaller side.

pub fn max_blocking_threads(&amp;mut self, val: usize) -&gt; &amp;mut Self // 设置生成的用于阻塞操作的线程最大数
//Specifies limit for threads spawned by the Runtime used for blocking operations.
//Similarly to the worker_threads, this number should be between 1 and 32,768.
//The default value is 512.
//Otherwise as worker_threads are always active, it limits additional threads (e.g. for blocking annotations).

pub fn thread_name(&amp;mut self, val: impl Into&lt;String&gt;) -&gt; &amp;mut Self // 设置线程的名字
//Sets name of threads spawned by the Runtime's thread pool.
//The default name is &quot;tokio-runtime-worker&quot;.

// .....

pub fn build(&amp;mut self) -&gt; Result&lt;Runtime&gt; // 构造出tokio中的runtime结构
//Creates the configured Runtime.
//The returned Runtime instance is ready to spawn tasks.

//etc..

//example
// build runtime
let runtime = Builder::new_multi_thread()
                .worker_threads(4)
                .thread_name(&quot;my-custom-name&quot;)
                .thread_stack_size(3 * 1024 * 1024)
                .build()
                .unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>从Builder的build函数可以知道Builder结构是Runtime的辅助结构体用来帮助构造Runtime的。</p>
<h2><a class="header" href="#futures-中的建造者设计模式-struct-a-hrefhttpsdocsrsfutures0312futuresindexhtmlfuturesaa-hrefhttpsdocsrsfutures0312futuresexecutorindexhtmlexecutoraa-hrefhttpsdocsrsfutures0312futuresexecutorstructthreadpoolbuilderhtmlthreadpoolbuildera" id="futures-中的建造者设计模式-struct-a-hrefhttpsdocsrsfutures0312futuresindexhtmlfuturesaa-hrefhttpsdocsrsfutures0312futuresexecutorindexhtmlexecutoraa-hrefhttpsdocsrsfutures0312futuresexecutorstructthreadpoolbuilderhtmlthreadpoolbuildera">Futures 中的建造者设计模式 Struct <a href="https://docs.rs/futures/0.3.12/futures/index.html">futures</a>::<a href="https://docs.rs/futures/0.3.12/futures/executor/index.html">executor</a>::<a href="https://docs.rs/futures/0.3.12/futures/executor/struct.ThreadPoolBuilder.html">ThreadPoolBuilder</a></a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A general-purpose thread pool for scheduling tasks that poll futures to
/// completion.
///
/// The thread pool multiplexes any number of tasks onto a fixed number of
/// worker threads.
///
/// This type is a clonable handle to the threadpool itself.
/// Cloning it will only create a new reference, not a new threadpool.
///
/// This type is only available when the `thread-pool` feature of this
/// library is activated.
#[cfg_attr(docsrs, doc(cfg(feature = &quot;thread-pool&quot;)))]
pub struct ThreadPool {
    state: Arc&lt;PoolState&gt;,
}

/// Thread pool configuration object.
///
/// This type is only available when the `thread-pool` feature of this
/// library is activated.
#[cfg_attr(docsrs, doc(cfg(feature = &quot;thread-pool&quot;)))]
pub struct ThreadPoolBuilder {
    pool_size: usize,
    stack_size: usize,
    name_prefix: Option&lt;String&gt;,
    after_start: Option&lt;Arc&lt;dyn Fn(usize) + Send + Sync&gt;&gt;,
    before_stop: Option&lt;Arc&lt;dyn Fn(usize) + Send + Sync&gt;&gt;,
}


struct PoolState {
    tx: Mutex&lt;mpsc::Sender&lt;Message&gt;&gt;,
    rx: Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;,
    cnt: AtomicUsize,
    size: usize,
}

enum Message {
    Run(Task),
    Close,
}

impl ThreadPoolBuilder {
    /// Create a default thread pool configuration.
    ///
    /// See the other methods on this type for details on the defaults.
    pub fn new() -&gt; Self {
        Self {
            pool_size: cmp::max(1, num_cpus::get()),
            stack_size: 0,
            name_prefix: None,
            after_start: None,
            before_stop: None,
        }
    }

    /// Set size of a future ThreadPool
    ///
    /// The size of a thread pool is the number of worker threads spawned. By
    /// default, this is equal to the number of CPU cores.
    ///
    /// # Panics
    ///
    /// Panics if `pool_size == 0`.
    pub fn pool_size(&amp;mut self, size: usize) -&gt; &amp;mut Self {
        assert!(size &gt; 0);
        self.pool_size = size;
        self
    }

    /// Set stack size of threads in the pool, in bytes.
    ///
    /// By default, worker threads use Rust's standard stack size.
    pub fn stack_size(&amp;mut self, stack_size: usize) -&gt; &amp;mut Self {
        self.stack_size = stack_size;
        self
    }

    /// Set thread name prefix of a future ThreadPool.
    ///
    /// Thread name prefix is used for generating thread names. For example, if prefix is
    /// `my-pool-`, then threads in the pool will get names like `my-pool-1` etc.
    ///
    /// By default, worker threads are assigned Rust's standard thread name.
    pub fn name_prefix&lt;S: Into&lt;String&gt;&gt;(&amp;mut self, name_prefix: S) -&gt; &amp;mut Self {
        self.name_prefix = Some(name_prefix.into());
        self
    }

    /// Execute the closure `f` immediately after each worker thread is started,
    /// but before running any tasks on it.
    ///
    /// This hook is intended for bookkeeping and monitoring.
    /// The closure `f` will be dropped after the `builder` is dropped
    /// and all worker threads in the pool have executed it.
    ///
    /// The closure provided will receive an index corresponding to the worker
    /// thread it's running on.
    pub fn after_start&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self
        where F: Fn(usize) + Send + Sync + 'static
    {
        self.after_start = Some(Arc::new(f));
        self
    }

    /// Execute closure `f` just prior to shutting down each worker thread.
    ///
    /// This hook is intended for bookkeeping and monitoring.
    /// The closure `f` will be dropped after the `builder` is droppped
    /// and all threads in the pool have executed it.
    ///
    /// The closure provided will receive an index corresponding to the worker
    /// thread it's running on.
    pub fn before_stop&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self
        where F: Fn(usize) + Send + Sync + 'static
    {
        self.before_stop = Some(Arc::new(f));
        self
    }
	
  	// 从ThreadBuilder的create函数可以看到ThreadPoolBuilder根据配置采纳数创建ThreadPool， 是ThreadPool的辅助结构体 
    /// Create a [`ThreadPool`](ThreadPool) with the given configuration.
    pub fn create(&amp;mut self) -&gt; Result&lt;ThreadPool, io::Error&gt; {
        let (tx, rx) = mpsc::channel();
        let pool = ThreadPool {
            state: Arc::new(PoolState {
                tx: Mutex::new(tx),
                rx: Mutex::new(rx),
                cnt: AtomicUsize::new(1),
                size: self.pool_size,
            }),
        };

        for counter in 0..self.pool_size {
            let state = pool.state.clone();
            let after_start = self.after_start.clone();
            let before_stop = self.before_stop.clone();
            let mut thread_builder = thread::Builder::new();
            if let Some(ref name_prefix) = self.name_prefix {
                thread_builder = thread_builder.name(format!(&quot;{}{}&quot;, name_prefix, counter));
            }
            if self.stack_size &gt; 0 {
                thread_builder = thread_builder.stack_size(self.stack_size);
            }
            thread_builder.spawn(move || state.work(counter, after_start, before_stop))?;
        }
        Ok(pool)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>从ThreadBuilder的create函数可以看到ThreadPoolBuilder根据配置采纳数创建ThreadPool， 是ThreadPool的辅助结构体 </p>
<h2><a class="header" href="#surf中的建造者设计模式" id="surf中的建造者设计模式">Surf中的建造者设计模式</a></h2>
<pre><pre class="playground"><code class="language-rust">/// Request Builder
///
/// Provides an ergonomic way to chain the creation of a request.
/// This is generally accessed as the return value from `surf::{method}()`,
/// however [`Request::builder`](crate::Request::builder) is also provided.
///
/// # Examples
///
/// ```rust
/// use surf::http::{Method, mime::HTML, Url};
/// # #[async_std::main]
/// # async fn main() -&gt; surf::Result&lt;()&gt; {
/// let mut request = surf::post(&quot;https://httpbin.org/post&quot;)
///     .body(&quot;&lt;html&gt;hi&lt;/html&gt;&quot;)
///     .header(&quot;custom-header&quot;, &quot;value&quot;)
///     .content_type(HTML)
///     .build();
///
/// assert_eq!(request.take_body().into_string().await.unwrap(), &quot;&lt;html&gt;hi&lt;/html&gt;&quot;);
/// assert_eq!(request.method(), Method::Post);
/// assert_eq!(request.url(), &amp;Url::parse(&quot;https://httpbin.org/post&quot;)?);
/// assert_eq!(request[&quot;custom-header&quot;], &quot;value&quot;);
/// assert_eq!(request[&quot;content-type&quot;], &quot;text/html;charset=utf-8&quot;);
/// # Ok(())
/// # }
/// ```
///
/// ```rust
/// use surf::http::{Method, Url};
/// # #[async_std::main]
/// # async fn main() -&gt; surf::Result&lt;()&gt; {
/// let url = Url::parse(&quot;https://httpbin.org/post&quot;)?;
/// let request = surf::Request::builder(Method::Post, url).build();
/// # Ok(())
/// # }
/// ```

pub struct RequestBuilder {
    /// Holds the state of the request.
    req: Option&lt;Request&gt;,
    /// Hold an optional Client.
    client: Option&lt;Client&gt;,
    /// Holds the state of the `impl Future`.
    fut: Option&lt;BoxFuture&lt;'static, Result&lt;Response&gt;&gt;&gt;,
}

impl RequestBuilder {
    /// Create a new instance.
    ///
    /// This method is particularly useful when input URLs might be passed by third parties, and
    /// you don't want to panic if they're malformed. If URLs are statically encoded, it might be
    /// easier to use one of the shorthand methods instead.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// use surf::http::{Method, Url};
    ///
    /// let url = Url::parse(&quot;https://httpbin.org/get&quot;)?;
    /// let req = surf::RequestBuilder::new(Method::Get, url).build();
    /// # Ok(()) }
    /// ```
    pub fn new(method: Method, url: Url) -&gt; Self {
        Self {
            req: Some(Request::new(method, url)),
            client: None,
            fut: None,
        }
    }

    pub(crate) fn with_client(mut self, client: Client) -&gt; Self {
        self.client = Some(client);
        self
    }

    /// Sets a header on the request.
    ///
    /// # Examples
    ///
    /// ```
    /// let req = surf::get(&quot;https://httpbin.org/get&quot;).header(&quot;header-name&quot;, &quot;header-value&quot;).build();
    /// assert_eq!(req[&quot;header-name&quot;], &quot;header-value&quot;);
    /// ```
    pub fn header(mut self, key: impl Into&lt;HeaderName&gt;, value: impl ToHeaderValues) -&gt; Self {
        self.req.as_mut().unwrap().insert_header(key, value);
        self
    }

    /// Sets the Content-Type header on the request.
    ///
    /// # Examples
    ///
    /// ```
    /// # use surf::http::mime;
    /// let req = surf::post(&quot;https://httpbin.org/post&quot;).content_type(mime::HTML).build();
    /// assert_eq!(req[&quot;content-type&quot;], &quot;text/html;charset=utf-8&quot;);
    /// ```
    pub fn content_type(mut self, content_type: impl Into&lt;Mime&gt;) -&gt; Self {
        self.req
            .as_mut()
            .unwrap()
            .set_content_type(content_type.into());
        self
    }

    /// Sets the body of the request.
    ///
    /// # Examples
    ///
    /// ```
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// use serde_json::json;
    /// let mut req = surf::post(&quot;https://httpbin.org/post&quot;).body(json!({ &quot;any&quot;: &quot;Into&lt;Body&gt;&quot;})).build();
    /// assert_eq!(req.take_body().into_string().await.unwrap(), &quot;{\&quot;any\&quot;:\&quot;Into&lt;Body&gt;\&quot;}&quot;);
    /// # Ok(())
    /// # }
    /// ```
    pub fn body(mut self, body: impl Into&lt;Body&gt;) -&gt; Self {
        self.req.as_mut().unwrap().set_body(body);
        self
    }

    /// Set the URL querystring.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use serde::{Deserialize, Serialize};
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// #[derive(Serialize, Deserialize)]
    /// struct Index {
    ///     page: u32
    /// }
    ///
    /// let query = Index { page: 2 };
    /// let mut req = surf::get(&quot;https://httpbin.org/get&quot;).query(&amp;query)?.build();
    /// assert_eq!(req.url().query(), Some(&quot;page=2&quot;));
    /// assert_eq!(req.url().as_str(), &quot;https://httpbin.org/get?page=2&quot;);
    /// # Ok(()) }
    /// ```
    pub fn query(mut self, query: &amp;impl Serialize) -&gt; std::result::Result&lt;Self, Error&gt; {
        self.req.as_mut().unwrap().set_query(query)?;

        Ok(self)
    }

    /// Submit the request and get the response body as bytes.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// let bytes = surf::get(&quot;https://httpbin.org/get&quot;).recv_bytes().await?;
    /// assert!(bytes.len() &gt; 0);
    /// # Ok(()) }
    /// ```
    pub async fn recv_bytes(self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        let mut res = self.send().await?;
        Ok(res.body_bytes().await?)
    }

    /// Submit the request and get the response body as a string.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// let string = surf::get(&quot;https://httpbin.org/get&quot;).recv_string().await?;
    /// assert!(string.len() &gt; 0);
    /// # Ok(()) }
    /// ```
    pub async fn recv_string(self) -&gt; Result&lt;String&gt; {
        let mut res = self.send().await?;
        Ok(res.body_string().await?)
    }

    /// Submit the request and decode the response body from json into a struct.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use serde::{Deserialize, Serialize};
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// #[derive(Deserialize, Serialize)]
    /// struct Ip {
    ///     ip: String
    /// }
    ///
    /// let uri = &quot;https://api.ipify.org?format=json&quot;;
    /// let Ip { ip } = surf::get(uri).recv_json().await?;
    /// assert!(ip.len() &gt; 10);
    /// # Ok(()) }
    /// ```
    pub async fn recv_json&lt;T: serde::de::DeserializeOwned&gt;(self) -&gt; Result&lt;T&gt; {
        let mut res = self.send().await?;
        Ok(res.body_json::&lt;T&gt;().await?)
    }

    /// Submit the request and decode the response body from form encoding into a struct.
    ///
    /// # Errors
    ///
    /// Any I/O error encountered while reading the body is immediately returned
    /// as an `Err`.
    ///
    /// If the body cannot be interpreted as valid json for the target type `T`,
    /// an `Err` is returned.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use serde::{Deserialize, Serialize};
    /// # #[async_std::main]
    /// # async fn main() -&gt; surf::Result&lt;()&gt; {
    /// #[derive(Deserialize, Serialize)]
    /// struct Body {
    ///     apples: u32
    /// }
    ///
    /// let url = &quot;https://api.example.com/v1/response&quot;;
    /// let Body { apples } = surf::get(url).recv_form().await?;
    /// # Ok(()) }
    /// ```
    pub async fn recv_form&lt;T: serde::de::DeserializeOwned&gt;(self) -&gt; Result&lt;T&gt; {
        let mut res = self.send().await?;
        Ok(res.body_form::&lt;T&gt;().await?)
    }
		
  	// 从build函数可以知道最后RequestBuilder是Request的辅助结构体，用来构造返回Request
  	// 这个函数返回的是Request
    /// Return the constructed `Request`.
    pub fn build(self) -&gt; Request {
        self.req.unwrap()
    }

    /// Create a `Client` and send the constructed `Request` from it.
    pub async fn send(mut self) -&gt; Result&lt;Response&gt; {
        self.client
            .take()
            .unwrap_or_else(Client::new_shared_or_panic)
            .send(self.build())
            .await
    }
}
</code></pre></pre>
<p>从build函数可以知道最后RequestBuilder是Request的辅助结构体，用来构造返回Request</p>
<h2><a class="header" href="#reqwest中的建造者设计模式" id="reqwest中的建造者设计模式">Reqwest中的建造者设计模式</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A request which can be executed with `Client::execute()`.
pub struct Request {
    method: Method,
    url: Url,
    headers: HeaderMap,
    body: Option&lt;Body&gt;,
    timeout: Option&lt;Duration&gt;,
}

/// A builder to construct the properties of a `Request`.
///
/// To construct a `RequestBuilder`, refer to the `Client` documentation.
#[must_use = &quot;RequestBuilder does nothing until you 'send' it&quot;]
pub struct RequestBuilder {
    client: Client,
    request: crate::Result&lt;Request&gt;,
}

impl Request {
    /// Constructs a new request.
    #[inline]
    pub fn new(method: Method, url: Url) -&gt; Self {
        Request {
            method,
            url,
            headers: HeaderMap::new(),
            body: None,
            timeout: None
        }
    }

    /// Get the method.
    #[inline]
    pub fn method(&amp;self) -&gt; &amp;Method {
        &amp;self.method
    }

    /// Get a mutable reference to the method.
    #[inline]
    pub fn method_mut(&amp;mut self) -&gt; &amp;mut Method {
        &amp;mut self.method
    }

    /// Get the url.
    #[inline]
    pub fn url(&amp;self) -&gt; &amp;Url {
        &amp;self.url
    }

    /// Get a mutable reference to the url.
    #[inline]
    pub fn url_mut(&amp;mut self) -&gt; &amp;mut Url {
        &amp;mut self.url
    }

    /// Get the headers.
    #[inline]
    pub fn headers(&amp;self) -&gt; &amp;HeaderMap {
        &amp;self.headers
    }

    /// Get a mutable reference to the headers.
    #[inline]
    pub fn headers_mut(&amp;mut self) -&gt; &amp;mut HeaderMap {
        &amp;mut self.headers
    }

    /// Get the body.
    #[inline]
    pub fn body(&amp;self) -&gt; Option&lt;&amp;Body&gt; {
        self.body.as_ref()
    }

    /// Get a mutable reference to the body.
    #[inline]
    pub fn body_mut(&amp;mut self) -&gt; &amp;mut Option&lt;Body&gt; {
        &amp;mut self.body
    }

    /// Get the timeout.
    #[inline]
    pub fn timeout(&amp;self) -&gt; Option&lt;&amp;Duration&gt; {
        self.timeout.as_ref()
    }

    /// Get a mutable reference to the timeout.
    #[inline]
    pub fn timeout_mut(&amp;mut self) -&gt; &amp;mut Option&lt;Duration&gt; {
        &amp;mut self.timeout
    }

    /// Attempt to clone the request.
    ///
    /// `None` is returned if the request can not be cloned, i.e. if the body is a stream.
    pub fn try_clone(&amp;self) -&gt; Option&lt;Request&gt; {
        let body = match self.body.as_ref() {
            Some(ref body) =&gt; Some(body.try_clone()?),
            None =&gt; None,
        };
        let mut req = Request::new(self.method().clone(), self.url().clone());
        *req.timeout_mut() = self.timeout().cloned();
        *req.headers_mut() = self.headers().clone();
        req.body = body;
        Some(req)
    }

    pub(super) fn pieces(self) -&gt; (Method, Url, HeaderMap, Option&lt;Body&gt;, Option&lt;Duration&gt;) {
        (self.method, self.url, self.headers, self.body, self.timeout)
    }
}

impl RequestBuilder {
    pub(super) fn new(client: Client, request: crate::Result&lt;Request&gt;) -&gt; RequestBuilder {
        let mut builder = RequestBuilder { client, request };

        let auth = builder
            .request
            .as_mut()
            .ok()
            .and_then(|req| extract_authority(&amp;mut req.url));

        if let Some((username, password)) = auth {
            builder.basic_auth(username, password)
        } else {
            builder
        }
    }

    /// Add a `Header` to this Request.
    pub fn header&lt;K, V&gt;(self, key: K, value: V) -&gt; RequestBuilder
    where
        HeaderName: TryFrom&lt;K&gt;,
        &lt;HeaderName as TryFrom&lt;K&gt;&gt;::Error: Into&lt;http::Error&gt;,
        HeaderValue: TryFrom&lt;V&gt;,
        &lt;HeaderValue as TryFrom&lt;V&gt;&gt;::Error: Into&lt;http::Error&gt;, 
    {
        self.header_sensitive(key, value, false)
    }

    /// Add a `Header` to this Request with ability to define if header_value is sensitive.
    fn header_sensitive&lt;K, V&gt;(mut self, key: K, value: V, sensitive: bool) -&gt; RequestBuilder
    where
        HeaderName: TryFrom&lt;K&gt;,
        &lt;HeaderName as TryFrom&lt;K&gt;&gt;::Error: Into&lt;http::Error&gt;,
        HeaderValue: TryFrom&lt;V&gt;,
        &lt;HeaderValue as TryFrom&lt;V&gt;&gt;::Error: Into&lt;http::Error&gt;,
    {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            match &lt;HeaderName as TryFrom&lt;K&gt;&gt;::try_from(key) {
                Ok(key) =&gt; match &lt;HeaderValue as TryFrom&lt;V&gt;&gt;::try_from(value) {
                    Ok(mut value) =&gt; {
                        value.set_sensitive(sensitive);
                        req.headers_mut().append(key, value);
                    }
                    Err(e) =&gt; error = Some(crate::error::builder(e.into())),
                },
                Err(e) =&gt; error = Some(crate::error::builder(e.into())),
            };
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Add a set of Headers to the existing ones on this Request.
    ///
    /// The headers will be merged in to any already set.
    pub fn headers(mut self, headers: crate::header::HeaderMap) -&gt; RequestBuilder {
        if let Ok(ref mut req) = self.request {
            crate::util::replace_headers(req.headers_mut(), headers);
        }
        self
    }

    /// Enable HTTP basic authentication.
    pub fn basic_auth&lt;U, P&gt;(self, username: U, password: Option&lt;P&gt;) -&gt; RequestBuilder
    where
        U: fmt::Display,
        P: fmt::Display,
    {
        let mut header_value = b&quot;Basic &quot;.to_vec();
        {
            let mut encoder = Base64Encoder::new(&amp;mut header_value, base64::STANDARD);
            // The unwraps here are fine because Vec::write* is infallible.
            write!(encoder, &quot;{}:&quot;, username).unwrap();
            if let Some(password) = password {
                write!(encoder, &quot;{}&quot;, password).unwrap();
            }
        }

        self.header_sensitive(crate::header::AUTHORIZATION, header_value, true)
    }

    /// Enable HTTP bearer authentication.
    pub fn bearer_auth&lt;T&gt;(self, token: T) -&gt; RequestBuilder
    where
        T: fmt::Display,
    {
        let header_value = format!(&quot;Bearer {}&quot;, token);
        self.header_sensitive(crate::header::AUTHORIZATION, header_value, true)
    }

    /// Set the request body.
    pub fn body&lt;T: Into&lt;Body&gt;&gt;(mut self, body: T) -&gt; RequestBuilder {
        if let Ok(ref mut req) = self.request {
            *req.body_mut() = Some(body.into());
        }
        self
    }

    /// Enables a request timeout.
    ///
    /// The timeout is applied from when the request starts connecting until the
    /// response body has finished. It affects only this request and overrides
    /// the timeout configured using `ClientBuilder::timeout()`.
    pub fn timeout(mut self, timeout: Duration) -&gt; RequestBuilder {
        if let Ok(ref mut req) = self.request {
            *req.timeout_mut() = Some(timeout);
        }
        self
    }

    /// Sends a multipart/form-data body.
    ///
    /// ```
    /// # use reqwest::Error;
    ///
    /// # async fn run() -&gt; Result&lt;(), Error&gt; {
    /// let client = reqwest::Client::new();
    /// let form = reqwest::multipart::Form::new()
    ///     .text(&quot;key3&quot;, &quot;value3&quot;)
    ///     .text(&quot;key4&quot;, &quot;value4&quot;);
    ///
    ///
    /// let response = client.post(&quot;your url&quot;)
    ///     .multipart(form)
    ///     .send()
    ///     .await?;
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = &quot;multipart&quot;)]
    pub fn multipart(self, mut multipart: multipart::Form) -&gt; RequestBuilder {
        let mut builder = self.header(
            CONTENT_TYPE,
            format!(&quot;multipart/form-data; boundary={}&quot;, multipart.boundary()).as_str(),
        );

        builder = match multipart.compute_length() {
            Some(length) =&gt; builder.header(CONTENT_LENGTH, length),
            None =&gt; builder,
        };

        if let Ok(ref mut req) = builder.request {
            *req.body_mut() = Some(multipart.stream())
        }
        builder
    }

    /// Modify the query string of the URL.
    ///
    /// Modifies the URL of this request, adding the parameters provided.
    /// This method appends and does not overwrite. This means that it can
    /// be called multiple times and that existing query parameters are not
    /// overwritten if the same key is used. The key will simply show up
    /// twice in the query string.
    /// Calling `.query([(&quot;foo&quot;, &quot;a&quot;), (&quot;foo&quot;, &quot;b&quot;)])` gives `&quot;foo=a&amp;foo=b&quot;`.
    ///
    /// # Note
    /// This method does not support serializing a single key-value
    /// pair. Instead of using `.query((&quot;key&quot;, &quot;val&quot;))`, use a sequence, such
    /// as `.query(&amp;[(&quot;key&quot;, &quot;val&quot;)])`. It's also possible to serialize structs
    /// and maps into a key-value pair.
    ///
    /// # Errors
    /// This method will fail if the object you provide cannot be serialized
    /// into a query string.
    pub fn query&lt;T: Serialize + ?Sized&gt;(mut self, query: &amp;T) -&gt; RequestBuilder {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            let url = req.url_mut();
            let mut pairs = url.query_pairs_mut();
            let serializer = serde_urlencoded::Serializer::new(&amp;mut pairs);

            if let Err(err) = query.serialize(serializer) {
                error = Some(crate::error::builder(err));
            }
        }
        if let Ok(ref mut req) = self.request {
            if let Some(&quot;&quot;) = req.url().query() {
                req.url_mut().set_query(None);
            }
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Send a form body.
    pub fn form&lt;T: Serialize + ?Sized&gt;(mut self, form: &amp;T) -&gt; RequestBuilder {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            match serde_urlencoded::to_string(form) {
                Ok(body) =&gt; {
                    req.headers_mut().insert(
                        CONTENT_TYPE,
                        HeaderValue::from_static(&quot;application/x-www-form-urlencoded&quot;),
                    );
                    *req.body_mut() = Some(body.into());
                }
                Err(err) =&gt; error = Some(crate::error::builder(err)),
            }
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Send a JSON body.
    ///
    /// # Optional
    ///
    /// This requires the optional `json` feature enabled.
    ///
    /// # Errors
    ///
    /// Serialization can fail if `T`'s implementation of `Serialize` decides to
    /// fail, or if `T` contains a map with non-string keys.
    #[cfg(feature = &quot;json&quot;)]
    pub fn json&lt;T: Serialize + ?Sized&gt;(mut self, json: &amp;T) -&gt; RequestBuilder {
        let mut error = None;
        if let Ok(ref mut req) = self.request {
            match serde_json::to_vec(json) {
                Ok(body) =&gt; {
                    req.headers_mut()
                        .insert(CONTENT_TYPE, HeaderValue::from_static(&quot;application/json&quot;));
                    *req.body_mut() = Some(body.into());
                }
                Err(err) =&gt; error = Some(crate::error::builder(err)),
            }
        }
        if let Some(err) = error {
            self.request = Err(err);
        }
        self
    }

    /// Disable CORS on fetching the request.
    ///
    /// # WASM
    ///
    /// This option is only effective with WebAssembly target.
    ///
    /// The [request mode][mdn] will be set to 'no-cors'.
    ///
    /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/Request/mode
    pub fn fetch_mode_no_cors(self) -&gt; RequestBuilder {
        self
    }
  
 
		// 从RequestBuilder的build函数可以知道，RequestBuilder是用来帮助构造Request的辅助结构体
    /// Build a `Request`, which can be inspected, modified and executed with
    /// `Client::execute()`.
    pub fn build(self) -&gt; crate::Result&lt;Request&gt; {
        self.request
    }

    /// Constructs the Request and sends it to the target URL, returning a
    /// future Response.
    ///
    /// # Errors
    ///
    /// This method fails if there was an error while sending request,
    /// redirect loop was detected or redirect limit was exhausted.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use reqwest::Error;
    /// #
    /// # async fn run() -&gt; Result&lt;(), Error&gt; {
    /// let response = reqwest::Client::new()
    ///     .get(&quot;https://hyper.rs&quot;)
    ///     .send()
    ///     .await?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn send(self) -&gt; impl Future&lt;Output = Result&lt;Response, crate::Error&gt;&gt; {
        match self.request {
            Ok(req) =&gt; self.client.execute_request(req),
            Err(err) =&gt; Pending::new_err(err),
        }
    }

    /// Attempt to clone the RequestBuilder.
    ///
    /// `None` is returned if the RequestBuilder can not be cloned,
    /// i.e. if the request body is a stream.
    ///
    /// # Examples
    ///
    /// ```
    /// # use reqwest::Error;
    /// #
    /// # fn run() -&gt; Result&lt;(), Error&gt; {
    /// let client = reqwest::Client::new();
    /// let builder = client.post(&quot;http://httpbin.org/post&quot;)
    ///     .body(&quot;from a &amp;str!&quot;);
    /// let clone = builder.try_clone();
    /// assert!(clone.is_some());
    /// # Ok(())
    /// # }
    /// ```
    pub fn try_clone(&amp;self) -&gt; Option&lt;RequestBuilder&gt; {
        self.request
            .as_ref()
            .ok()
            .and_then(|req| req.try_clone())
            .map(|req| RequestBuilder {
                client: self.client.clone(),
                request: Ok(req),
            })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>从RequestBuilder的build函数可以知道，RequestBuilder是用来帮助构造Request的辅助结构体。</p>
<p>参考链接：</p>
<p>https://docs.rs/tokio/1.1.0/tokio/runtime/struct.Builder.html</p>
<p>https://docs.rs/reqwest/0.11.0/src/reqwest/async_impl/request.rs.html#36-39</p>
<p>https://github.com/http-rs/surf/blob/31315743b91ff003231183c1ec5a3cd2b698c58a/src/request_builder.rs</p>
<p>https://docs.rs/futures/0.3.12/futures/executor/struct.ThreadPoolBuilder.html</p>
<h1><a class="header" href="#关于-io_uring-与-rust-的思考" id="关于-io_uring-与-rust-的思考">关于 io_uring 与 Rust 的思考</a></h1>
<p>io_uring 是 Linux 5.x 时代加入的一套全新的异步机制，被钦定为 Linux 异步的未来。</p>
<p>本文将探讨在 Rust 中安全封装 io_uring 的一系列设计问题，并提出一些可能的解决方案。</p>
<h2><a class="header" href="#io_uring-的工作方式" id="io_uring-的工作方式">io_uring 的工作方式</a></h2>
<p>io_uring 分为两个队列，提交队列 SQ (Submission Queue) 和完成队列 CQ (Completion Queue)。提交队列存放正在等待执行的异步任务，完成队列存放完成事件。</p>
<p>io_uring 的结构由内核分配，用户态通过 mmap 拿到相关结构的内存访问权限，这样就能让内核态与用户态共享内存，绕过系统调用双向传递数据。</p>
<p>概念工作流程具有三个阶段</p>
<ol>
<li>准备：应用程序获取一些提交队列项 SQE (Submission Queue Entry)，将每个异步任务分别设置到每个 SQE 中，用操作码、参数初始化。</li>
<li>提交：应用程序向 SQ 中推入一些需要提交的 SQE，通过一次系统调用告诉内核有新的任务，或者让内核不停轮询来获取任务。</li>
<li>收割：应用程序从 CQ 中取得一些完成队列事件 CQE (Completion Queue Event)，通过 user_data 识别并唤醒应用程序中的线程/协程，传递返回值。</li>
</ol>
<p>epoll 是 Reactor 模型的实现，而 io_uring 是 Proactor 模型的实现。</p>
<p>这意味着基于 epoll 设计的程序难以直接迁移到 io_uring。</p>
<p><strong>问题 1</strong>: 改变异步模型并不是一件容易的事，除非以部分性能为代价抹平差异。</p>
<p><strong>问题 2</strong>: io_uring 需要较高版本的内核，现阶段，应用程序不得不考虑在没有 io_uring 高版本特性时要怎么回退 (fallback)。</p>
<h2><a class="header" href="#io_uring-的约束" id="io_uring-的约束">io_uring 的约束</a></h2>
<p>在阻塞同步模型和非阻塞同步模型(如 epoll)中，用户态 IO 操作是一锤子买卖，无需担心生存期。</p>
<p>但 io_uring 是 Proactor，是非阻塞异步模型，对资源的生存期有所约束。</p>
<p>以 read 为例，它有 fd 和 buf 两个资源参数，当准备 IO 操作时，我们需要把 fd、buf 指针和 count 填入 SQE，并且<strong>保证在内核完成或取消该任务之前，fd 和 buf 都必须有效</strong>。</p>
<h3><a class="header" href="#fd-意外替换" id="fd-意外替换">fd 意外替换</a></h3>
<pre><code class="language-c">fd = 6, buf = 0x5678;
准备 SQE;
close fd = 6;
open -&gt; fd = 6;
提交 SQE;
内核执行 IO;
</code></pre>
<p>在提交 SQE 之前，应用程序“不小心”关闭又打开了文件，这将导致 IO 操作意外地被执行到一个完全无关的文件上。</p>
<h3><a class="header" href="#栈内存-uaf" id="栈内存-uaf">栈内存 UAF</a></h3>
<pre><code class="language-c">char stack_buf[1024];
fd = 6, buf = &amp;stack_buf;
准备 SQE;
提交 SQE;
函数返回;
内核执行 IO;
</code></pre>
<p>内核执行的 IO 会操作已被释放的栈上内存，出现“释放后使用”(use-after-free) 漏洞。</p>
<h3><a class="header" href="#堆内存-uaf" id="堆内存-uaf">堆内存 UAF</a></h3>
<pre><code class="language-c">char* heap_buf = malloc(1024);
fd = 6, buf = heap_buf;
准备 SQE;
提交 SQE;
执行其他代码出错;
free(heap_buf);
函数返回错误码;
内核执行 IO;
</code></pre>
<p>内核执行的 IO 会使用已被释放的堆上内存，又一个 UAF 漏洞。</p>
<h3><a class="header" href="#移动后使用" id="移动后使用">移动后使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Buf&lt;T&gt;(T);
let mut buf1: Buf&lt;[u8;1024]&gt; = Buf([0;1024]);
fd = 6, buf = buf1.0.as_mut_ptr();
unsafe {
    准备 SQE;
}
提交 SQE;
let buf2 = Box::new(buf1);
内核执行 IO;
<span class="boring">}
</span></code></pre></pre>
<p>当内核执行 IO 时，buf1 已被移动，指针失效。出现“移动后使用”的漏洞，本文称为 UAM 漏洞。</p>
<h3><a class="header" href="#取消后使用" id="取消后使用">取消后使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() -&gt; io::Result&lt;()&gt; {
    let mut buf1: [u8;1024] = [0;1024];
    fd = 6, buf = buf1.as_mut_ptr();
    unsafe {
        准备 SQE;
    }
    提交 SQE;
    bar().await
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 的 async 函数会生成无栈协程，栈变量保存在一个结构体中。如果这个结构体被析构，底层的叶 Future 就会被析构，同时取消异步操作。</p>
<p>然而析构函数是同步的，<strong>当协程析构时，内核仍然可能正在占用缓冲区来执行 IO</strong>。如果不做处理，就会出现 UAF 漏洞。</p>
<h3><a class="header" href="#关闭后使用" id="关闭后使用">关闭后使用</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>准备 SQE;
提交 SQE;
io_uring_queue_exit(&amp;ring)
???
<span class="boring">}
</span></code></pre></pre>
<p>内核在 io_uring_queue_exit 之后会立即取消正在执行的 IO 吗？</p>
<p>// TODO: 找到答案</p>
<p>如果会立即取消，那么用户态程序也无法得到取消事件，无法唤醒任务或释放资源。</p>
<p>如果不会立即取消，那么内核对资源的占用会超出 io_uring 实例的生存期，带来更加麻烦的问题。</p>
<p>这似乎说明 io_uring 实例必须为 static 生存期，与线程本身活得一样长。或者采取某种引用计数的方式，推迟 exit 时机。</p>
<h2><a class="header" href="#具有-rust-特色的-io_uring" id="具有-rust-特色的-io_uring">具有 Rust 特色的 io_uring</a></h2>
<p>Rust 的底线是内存安全，不允许出现内存安全漏洞或数据竞争。Rust 的所有权规则为此提供了很好的保障。</p>
<h3><a class="header" href="#迁移所有权" id="迁移所有权">迁移所有权</a></h3>
<p>“迁移所有权” 是本文中自行创造的概念，它表示要进行某个操作就必须放弃对参数的所有权，把参数的所有权“迁移”到其他地方。</p>
<p>当使用 io_uring 时，相当于内核持有资源的所有权。用户态必须放弃对资源的控制权，除非它可以安全地并发操作。IO 操作完成或取消时，内核占用的所有资源会被返还给用户态。</p>
<p>但内核不可能真的去持有所有权，实际上是由异步运行时来存储这些资源，并模拟出“迁移所有权”的模型。</p>
<p><code>BufRead</code> trait 表示一个包含内部缓冲区的可读取类型。<code>BufReader&lt;File&gt;</code> 是一个典型用法。</p>
<p><code>BufReader&lt;File&gt;</code> 可以匹配 io_uring 的工作模式。</p>
<pre><code>准备 fd, buf
准备 SQE
提交 SQE
等待唤醒
拿到返回值
回收 fd, buf
暴露 buf 的共享引用
</code></pre>
<p><strong>问题 3</strong>: 当 Future 被取消时，buf 仍然被内核占用，<code>BufReader&lt;File&gt;</code> 处于无效状态。再次进行 IO 时，它只能选择死亡。</p>
<p>想象这样一个底层 Future</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Read&lt;F, B&gt;
where
    F: AsRawFd + 'static,
    B: AsMut&lt;[u8]&gt; + 'static,
{
    fd: F,
    buf: B,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>buf 可以是 <code>[u8; N]</code>，也满足 <code>AsMut&lt;[u8]&gt; + 'static</code>，但它不能被取指针传递给 io_uring。</p>
<p>buf 在这个 Future 被析构时失效，不满足 io_uring 的约束。</p>
<p>修复方案有两种：在准备 SQE 之前就把 fd 和 buf 都移动到堆上，或者限制 buf 为可安全逃逸的缓冲区类型。</p>
<h3><a class="header" href="#堆分配" id="堆分配">堆分配</a></h3>
<p>如果要在准备 SQE 之前确保 fd 和 buf 不会被析构，只能堆分配了。</p>
<p>这样 fd 和 buf 在 IO 操作完成或取消之前就不会被移动或析构，保证了有效性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Read&lt;F, B&gt;
where
    F: AsRawFd + 'static,
    B: AsMut&lt;[u8]&gt; + 'static,
{
    state: ManualDrop&lt;Box&lt;State&lt;F, B&gt;&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>然而，大部分时候 buf 都是指向堆上动态大小缓冲区的智能指针，为指针本身去堆分配是不太值得的，要提高效率必须以某种方式实现自定义分配器。</p>
<h3><a class="header" href="#逃逸" id="逃逸">逃逸</a></h3>
<p>通常的“逃逸分析”是分析对象的动态范围，如果对象有可能离开函数作用域，就把它分配到堆上。</p>
<p>本文提出的“逃逸”是指让结构体成员逃脱析构，转移到一个稳定的地方。</p>
<p>可安全逃逸的缓冲区类型在移动时不会改变缓冲区的内存地址。</p>
<p><code>[u8;N]</code> 在移动时完全改变了缓冲区的地址范围，而 <code>Box&lt;[u8]&gt;</code> 和 <code>Vec&lt;u8&gt;</code> 不会改变。</p>
<p><code>SmallVec&lt;[u8;N]&gt;</code> 在容量不大于 N 时会把数据存储在栈上，过大时存储在堆上。</p>
<p><code>Box&lt;[u8]&gt;</code> 和 <code>Vec&lt;u8&gt;</code> 作为缓冲区可以安全逃逸，<code>[u8;N]</code> 和 <code>SmallVec&lt;[u8;N]&gt;</code> 不可以。</p>
<p>如果限制 buf 为可安全逃逸的缓冲区类型，那么在最理想的情况下，进行 IO 操作时不需要系统调用，不需要额外的堆分配，缓冲区由调用者控制，几乎完美。</p>
<p><strong>问题 4</strong>: 如何在不传染 unsafe 的情况下表达这种约束？</p>
<p>定义一个 unsafe trait 自然省事，但无法对所有符合条件的缓冲区通用，还可能受孤儿规则影响，让用户必须去写 newtype 或 unsafe。</p>
<p>可以意识到，这里的“安全逃逸”和 <code>Pin</code> 的概念有某种相关，有没有办法联系起来？</p>
<h3><a class="header" href="#send" id="send">Send</a></h3>
<p>io_uring 的收割可以由本线程做，也可以由一个专门的驱动线程做。</p>
<p>目前 SQ 不支持多线程提交，全局共享需要上锁。io_uring 更匹配每个线程自带一个 ring 的实现。</p>
<p>考虑这样一个 Future，当它析构时，里面的资源会逃逸到堆上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Read&lt;F, B&gt;
where
    F: AsRawFd + 'static,
    B: EscapedBufMut + 'static,
{
    fd: F,
    buf: B,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>如果由全局驱动线程做最终析构，那么资源就会从当前线程转移到驱动线程，这需要资源满足 Send。</p>
<p>如果由本线程做最终析构，那么资源不需要转移，可以不满足 Send。</p>
<p><strong>问题 5</strong>: 收割和析构策略也会影响 API 的泛型约束，如何设计合适的 API？</p>
<h3><a class="header" href="#拷贝" id="拷贝">拷贝</a></h3>
<p>缓冲区必须能在 Future 析构之后保持有效，这意味着我们无法把临时的 <code>&amp;mut [u8]</code> 或 <code>&amp;[u8]</code> 传入 io_uring，无法做原地读取或写入。</p>
<p>而 epoll 可以等待 fd 可读或可写后，再原地读取或写入。</p>
<p>无论如何，把缓冲区放在堆上这一步是不可避免的，区别在于缓冲区是由异步类型本身来控制还是由调用者来控制。</p>
<p>让调用者来控制缓冲区，能避免额外拷贝，但会加大安全审查的难度，必须限制传入的缓冲区具有良好的行为。</p>
<p>异步类型内置缓冲区，会增加额外拷贝，但安全性由库的作者保证，减小了出现漏洞的可能性。</p>
<p><strong>问题6</strong>: io_uring 加大了实现用户态零拷贝的难度。</p>
<h2><a class="header" href="#生态" id="生态">生态</a></h2>
<p><a href="https://github.com/ringbahn/uring-sys">uring-sys</a>： liburing 的绑定。</p>
<p><a href="https://github.com/ringbahn/iou">iou</a>：Rust 风格的低层 io_uring 接口。</p>
<p><a href="https://github.com/ringbahn/ringbahn">ringbahn</a>：实验性的 io_uring 高层封装</p>
<p><a href="https://github.com/ringbahn/maglev">maglev</a>：实验性的 io_uring 异步驱动/运行时</p>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<p>划个重点</p>
<p><strong>问题 1</strong>: epoll 是 Reactor 模型的实现，而 io_uring 是 Proactor 模型的实现。改变异步模型并不是一件容易的事，除非以性能为代价抹平差异。</p>
<p><strong>问题 2</strong>: io_uring 需要较高版本的内核，现阶段，应用程序不得不考虑在没有 io_uring 高版本特性时要怎么回退 (fallback)。</p>
<p><strong>问题 3</strong>: 当 Future 被取消时，buf 仍然被内核占用，异步类型可能处于无效状态。再次进行 IO 时，它只能选择死亡。</p>
<p><strong>问题 4</strong>: 如果选择限制 buf 为可安全逃逸的缓冲区类型，如何在不传染 unsafe 的情况下表达这种约束？</p>
<p><strong>问题 5</strong>: 收割和析构策略也会影响 API 的泛型约束，如何设计合适的 API？</p>
<p><strong>问题 6</strong>: io_uring 加大了实现用户态零拷贝的难度。</p>
<p>如果不考虑最高性能，我们有各种方案来封装一个能用的 io_uring 库。</p>
<p>如果不考虑通用，我们可以在自己的程序中谨慎地用 io_uring，锁死类型。</p>
<p>Rust 对安全、性能、通用的追求给封装 io_uring 带来了较高的难度。</p>
<p><a href="https://github.com/ringbahn/ringbahn">ringbahn</a> 的设计思路是其中一种可能的方向。社区还需要探索什么才是最完美的设计。</p>
<h2><a class="header" href="#扩展阅读" id="扩展阅读">扩展阅读</a></h2>
<p><a href="http://kernel.dk/io_uring.pdf">Efficient IO with io_uring</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/62682475">AIO 的新归宿：io_uring</a></p>
<p><a href="http://icebergu.com/archives/go-iouring">Go 与异步 IO - io_uring 的思考</a></p>
<p><a href="https://without.boats/blog/io-uring/">Notes on io-uring</a></p>
<p><a href="https://without.boats/blog/ringbahn/">Ringbahn: a safe, ergonomic API for io-uring in Rust</a></p>
<p><a href="https://without.boats/blog/ringbahn-ii/">Ringbahn II: the central state machine</a></p>
<p><a href="https://without.boats/blog/ringbahn-iii/">Ringbahn III: A deeper dive into drivers</a></p>
<p><a href="https://github.com/axboe/liburing/issues/109">feature requests: submit requests from any thread</a></p>
<hr />
<p>本文首发于知乎专栏 「<a href="https://zhuanlan.zhihu.com/p/346219893">Rust 日常</a>」</p>
<p>作者简介：</p>
<p>王徐旸，大三学生，2018 年开始学习和使用 Rust 语言，造轮子爱好者。</p>
<p>GitHub ID: <a href="https://github.com/Nugine">Nugine</a></p>
<h1><a class="header" href="#学习园地--译-graphql-in-rust" id="学习园地--译-graphql-in-rust">学习园地 | 「译」 GraphQL in Rust</a></h1>
<h2><a class="header" href="#译者序" id="译者序">译者序</a></h2>
<p>Roman Kudryashov(<a href="https://romankudryashov.com">博客</a>)是一名来自莫斯科的资深后端开发人员，在日常工作中用Rust/Java/Kotlin来完成服务的持久层，微服务之间的集成等工作。在<code>Async-graphql</code>的开发过程中给予了非常多的<a href="https://github.com/async-graphql/async-graphql/issues?q=is%3Aissue+author%3Arkudryashov">帮助</a>，然后根据这些经验总结出来这篇入门教程（<a href="https://romankudryashov.com/blog/2020/12/graphql-rust/">英文原版</a>）。</p>
<p>译者老油条（<a href="https://github.com/sunli829">孙黎</a>），<code>Async-graphql</code>库作者，连续创业者，处女座码农，之前日常工作由C++和Golang完成，两年前一个偶然的机会邂逅Rust语言，并不由自主的爱上了它，之后再也没有碰过其它编程语言，工作中用Rust语言完成所有的事情，是不折不扣的Rust语言狂热粉丝。Rust是我这么多年编程生涯中真正遇到的完美编程语言，无GC，并发安全以及类似Python等脚本语言才提供的高级语法，让我产生给它做一些力所能及的贡献的想法，<a href="https://github.com/sunli829/nvg">nvg</a>和<a href="https://github.com/sunli829/xactor">Xactor</a>是刚学Rust不久之后的小试牛刀，而<a href="https://github.com/async-graphql/async-graphql">Async-graphql</a>是Rust 1.39异步稳定之后的产物。</p>
<p><em>学习Rust的过程很艰辛，需要保持一颗修行的心，当你能够越过那一座座阻碍在面前的高山，也许才能够发现它真正的美好。</em></p>
<h2><a class="header" href="#目录" id="目录">目录</a></h2>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E4%BB%8B%E7%BB%8D">介绍</a>
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%A6%82%E8%A7%88">概览</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%8A%80%E6%9C%AF%E6%A0%88">技术栈</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a></li>
</ul>
</li>
<li>实现
<ul>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E4%BE%9D%E8%B5%96%E5%BA%93">依赖库</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD">核心功能</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">查询和类型定义</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%A7%A3%E5%86%B3N+1%E9%97%AE%E9%A2%98">解决N+1问题</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89">接口定义</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%87%8F">自定义标量</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AE%9A%E4%B9%89%E5%8F%98%E6%9B%B4(Mutation)">定义变更(Mutation)</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AE%9A%E4%B9%89%E8%AE%A2%E9%98%85(Subscription)">定义订阅(Subscription)</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#GraphQL%E5%AE%A2%E6%88%B7%E7%AB%AF">GraphQL客户端</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#API%E5%AE%89%E5%85%A8">API安全</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE">定义枚举</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86">日期处理</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%94%AF%E6%8C%81ApolloFederation">支持Apollo Federation</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#ApolloServer">Apollo Server</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92">数据库交互</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%BF%90%E8%A1%8C%E5%92%8CAPI%E6%B5%8B%E8%AF%95">运行和API测试</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E8%AE%A2%E9%98%85%E6%B5%8B%E8%AF%95">订阅测试</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#CI/CD">CI/CD</a></li>
</ul>
</li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E7%BB%93%E8%AE%BA">结论</a></li>
<li><a href="chapter_1/graphql_in_rust/graphql_in_rust.html#%E6%9C%89%E7%94%A8%E7%9A%84%E9%93%BE%E6%8E%A5">有用的链接</a></li>
</ul>
<p>在今天的文章中，我将描述如何使用Rust及其生态系统创建GraphQL后端服务。 本文提供了创建GraphQL API时最常见任务的实现示例。最后，将使用Apollo Server和Apollo Federation将三个微服务组合为一个端点。 这使客户端可以同时从任意数量的源中获取数据，而无需知道哪些数据来自哪个源。</p>
<h2><a class="header" href="#介绍" id="介绍">介绍</a></h2>
<h3><a class="header" href="#概览" id="概览">概览</a></h3>
<p>在功能方面，所描述的项目与我上一篇文章中所描述的非常相似，但是现在它是使用Rust编写的。 该项目的架构如下所示：</p>
<p><img src="chapter_1/graphql_in_rust/architecture.png" alt="architecture" /></p>
<p>架构的每个组件都回答了在实现GraphQL API时可能出现的几个问题。整个模型包括有关太阳系中的行星及其卫星的数据。该项目具有多模块结构，并包含以下模块：</p>
<ul>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/planets-service">planets-service</a> (Rust)</p>
</li>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/satellites-service">satellites-service</a> (Rust)</p>
</li>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/auth-service">auth-service</a> (Rust)</p>
</li>
<li>
<p><a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/apollo-server">apollo-server</a> (JS)</p>
</li>
</ul>
<p>在Rust中有两个库来创建GraphQL后端：<a href="https://github.com/graphql-rust/juniper">Juniper</a>和<a href="https://github.com/async-graphql/async-graphql">Async-graphql</a>，但是只有后者支持Apollo Federation，因此我在项目中选择了它（Juniper中的Federation支持存在未解决的<a href="https://github.com/graphql-rust/juniper/issues/376">问题</a>）。 这两个库都遵循<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/">代码优先</a>方法。</p>
<p>同样，PostgreSQL用于持久层实现，<a href="https://jwt.io/">JWT</a>用于认证，而Kafka用于消息传递。</p>
<h3><a class="header" href="#技术栈" id="技术栈">技术栈</a></h3>
<p>下表总结了该项目中使用的主要技术栈：</p>
<table><thead><tr><th>类型</th><th>名字</th><th>网站</th><th>代码仓库</th></tr></thead><tbody>
<tr><td>语言</td><td>Rust</td><td><a href="https://www.rust-lang.org/">link</a></td><td><a href="https://github.com/rust-lang/rust">link</a></td></tr>
<tr><td>GraphQL服务端库</td><td>Async-graphql</td><td><a href="https://async-graphql.github.io/async-graphql/zh-CN/index.html">link</a></td><td><a href="https://github.com/async-graphql/async-graphql">link</a></td></tr>
<tr><td>GraphQL网关</td><td>Apollo Server</td><td><a href="https://www.apollographql.com/docs/apollo-server/">link</a></td><td><a href="https://github.com/apollographql/apollo-server">link</a></td></tr>
<tr><td>Web框架</td><td>Actix-web</td><td><a href="https://actix.rs/">link</a></td><td><a href="https://github.com/actix/actix-web">link</a></td></tr>
<tr><td>数据库</td><td>PostgreSQL</td><td><a href="https://www.postgresql.org/">link</a></td><td><a href="https://github.com/postgres/postgres">link</a></td></tr>
<tr><td>消息队列</td><td>Apache Kafka</td><td><a href="https://kafka.apache.org/">link</a></td><td><a href="https://github.com/apache/kafka">link</a></td></tr>
<tr><td>容器编排</td><td>Docker Compose</td><td><a href="https://docs.docker.com/compose/">link</a></td><td><a href="https://github.com/docker/compose">link</a></td></tr>
</tbody></table>
<p>另外还有一些需要依赖的Rust库:</p>
<table><thead><tr><th>类型</th><th>名字</th><th>网站</th><th>代码仓库</th></tr></thead><tbody>
<tr><td>ORM</td><td>Diesel</td><td><a href="https://diesel.rs/">link</a></td><td><a href="https://github.com/diesel-rs/diesel">link</a></td></tr>
<tr><td>Kafka客户端</td><td>rust-rdkafka</td><td><a href="https://crates.io/crates/rdkafka">link</a></td><td><a href="https://github.com/fede1024/rust-rdkafka">link</a></td></tr>
<tr><td>密码哈希库</td><td>argonautica</td><td><a href="https://crates.io/crates/argonautica">link</a></td><td><a href="https://github.com/bcmyers/argonautica">link</a></td></tr>
<tr><td>JWT</td><td>jsonwebtoken</td><td><a href="https://crates.io/crates/jsonwebtoken">link</a></td><td><a href="https://github.com/Keats/jsonwebtoken">link</a></td></tr>
<tr><td>测试</td><td>Testcontainers-rs</td><td><a href="https://crates.io/crates/testcontainers">link</a></td><td><a href="https://github.com/testcontainers/testcontainers-rs">link</a></td></tr>
</tbody></table>
<h3><a class="header" href="#开发工具" id="开发工具">开发工具</a></h3>
<p>要在本地启动项目，你只需要<code>Docker Compose</code>。 如果没有<code>Docker</code>，可能需要安装以下内容：</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust</a></li>
<li><a href="https://diesel.rs/guides/getting-started/">Diesel CLI</a> (运行 <code>cargo install diesel_cli --no-default-features --features postgres</code>)</li>
<li><a href="https://releases.llvm.org/download.html">LLVM</a>(<code>argonautica</code>依赖)</li>
<li><a href="https://cmake.org/install/">CMake</a> (<code>rust-rdkafka</code>依赖)</li>
<li><a href="https://www.postgresql.org/download/">PostgreSQL</a></li>
<li><a href="https://kafka.apache.org/quickstart">Apache Kafka</a></li>
<li><a href="https://www.npmjs.com/get-npm">npm</a></li>
</ul>
<h3><a class="header" href="#实现" id="实现">实现</a></h3>
<p><em>清单1. 根<code>Cargo.toml</code>指定三个应用和一个库:</em></p>
<p>根<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/Cargo.toml">Cargo.toml</a></p>
<pre><code class="language-toml">[workspace]
members = [
    &quot;auth-service&quot;,
    &quot;planets-service&quot;,
    &quot;satellites-service&quot;,
    &quot;common-utils&quot;,
]
</code></pre>
<p>让我们从<a href="https://github.com/rkudryashov/graphql-rust-demo/tree/master/planets-service">planets-service</a>开始。</p>
<h3><a class="header" href="#依赖库" id="依赖库">依赖库</a></h3>
<p>这是Cargo.toml：</p>
<p><em>清单2. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/Cargo.toml">Cargo.toml</a></em></p>
<pre><code class="language-toml">[package]
name = &quot;planets-service&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
common-utils = { path = &quot;../common-utils&quot; }
async-graphql = &quot;2.4.3&quot;
async-graphql-actix-web = &quot;2.4.3&quot;
actix-web = &quot;3.3.2&quot;
actix-rt = &quot;1.1.1&quot;
actix-web-actors = &quot;3.0.0&quot;
futures = &quot;0.3.8&quot;
async-trait = &quot;0.1.42&quot;
bigdecimal = { version = &quot;0.1.2&quot;, features = [&quot;serde&quot;] }
serde = { version = &quot;1.0.118&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.60&quot;
diesel = { version = &quot;1.4.5&quot;, features = [&quot;postgres&quot;, &quot;r2d2&quot;, &quot;numeric&quot;] }
diesel_migrations = &quot;1.4.0&quot;
dotenv = &quot;0.15.0&quot;
strum = &quot;0.20.0&quot;
strum_macros = &quot;0.20.1&quot;
rdkafka = { version = &quot;0.24.0&quot;, features = [&quot;cmake-build&quot;] }
async-stream = &quot;0.3.0&quot;
lazy_static = &quot;1.4.0&quot;

[dev-dependencies]
jsonpath_lib = &quot;0.2.6&quot;
testcontainers = &quot;0.9.1&quot;
</code></pre>
<p><code>Async-graphql</code>是GraphQL服务端库，<code>Actix-web</code>是Web服务框架，而<code>Async-graphql-actix-web</code>提供它们之间的集成。</p>
<h3><a class="header" href="#核心功能" id="核心功能">核心功能</a></h3>
<p>我们转到<code>main.rs</code>：</p>
<p><em>清单3. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/main.rs">main.rs</a></em></p>
<pre><pre class="playground"><code class="language-rust">#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    dotenv().ok();
    let pool = create_connection_pool();
    run_migrations(&amp;pool);

    let schema = create_schema_with_context(pool);

    HttpServer::new(move || App::new()
        .configure(configure_service)
        .data(schema.clone())
    )
        .bind(&quot;0.0.0.0:8001&quot;)?
        .run()
        .await
}
</code></pre></pre>
<p>这里，使用<code>lib.rs</code>中定义的功能配置环境和HTTP服务器：</p>
<p><em>清单4. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">lib.rs</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn configure_service(cfg: &amp;mut web::ServiceConfig) {
    cfg
        .service(web::resource(&quot;/&quot;)
            .route(web::post().to(index))
            .route(web::get().guard(guard::Header(&quot;upgrade&quot;, &quot;websocket&quot;)).to(index_ws))
            .route(web::get().to(index_playground))
        );
}

async fn index(schema: web::Data&lt;AppSchema&gt;, http_req: HttpRequest, req: Request) -&gt; Response {
    let mut query = req.into_inner();

    let maybe_role = common_utils::get_role(http_req);
    if let Some(role) = maybe_role {
        query = query.data(role);
    }

    schema.execute(query).await.into()
}

async fn index_ws(schema: web::Data&lt;AppSchema&gt;, req: HttpRequest, payload: web::Payload) -&gt; Result&lt;HttpResponse&gt; {
    WSSubscription::start(Schema::clone(&amp;*schema), &amp;req, payload)
}

async fn index_playground() -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_type(&quot;text/html; charset=utf-8&quot;)
        .body(playground_source(GraphQLPlaygroundConfig::new(&quot;/&quot;).subscription_endpoint(&quot;/&quot;)))
}

pub fn create_schema_with_context(pool: PgPool) -&gt; Schema&lt;Query, Mutation, Subscription&gt; {
    let arc_pool = Arc::new(pool);
    let cloned_pool = Arc::clone(&amp;arc_pool);
    let details_batch_loader = Loader::new(DetailsBatchLoader {
        pool: cloned_pool
    }).with_max_batch_size(10);

    let kafka_consumer_counter = Mutex::new(0);

    Schema::build(Query, Mutation, Subscription)
        .data(arc_pool)
        .data(details_batch_loader)
        .data(kafka::create_producer())
        .data(kafka_consumer_counter)
        .finish()
}
<span class="boring">}
</span></code></pre></pre>
<p>这些函数执行以下操作：</p>
<ul>
<li><code>index</code> - 处理GraphQL<a href="https://graphql.org/learn/queries/">查询和变更</a></li>
<li><code>index_ws</code> - 处理GraphQL<a href="https://www.apollographql.com/docs/react/data/subscriptions/">订阅</a></li>
<li><code>index_playground</code> - 提供Graph Playground IDE</li>
<li><code>create_schema_with_context</code> - 使用可在运行时访问的全局上下文数据（例如数据库连接池）创建GraphQL模式</li>
</ul>
<h3><a class="header" href="#查询和类型定义" id="查询和类型定义">查询和类型定义</a></h3>
<p>让我们考虑如何定义查询：</p>
<p><em>清单5. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">定义查询</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl Query {
    async fn get_planets(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Vec&lt;Planet&gt; {
        repository::get_all(&amp;get_conn_from_ctx(ctx)).expect(&quot;Can't get planets&quot;)
            .iter()
            .map(|p| { Planet::from(p) })
            .collect()
    }

    async fn get_planet(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
        find_planet_by_id_internal(ctx, id)
    }

    #[graphql(entity)]
    async fn find_planet_by_id(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
        find_planet_by_id_internal(ctx, id)
    }
}

fn find_planet_by_id_internal(ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
    let id = id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't get id from String&quot;);
    repository::get(id, &amp;get_conn_from_ctx(ctx)).ok()
        .map(|p| { Planet::from(&amp;p) })
}
<span class="boring">}
</span></code></pre></pre>
<p>每个查询都使用<code>repository</code>从数据库获取数据并将获得的记录转换为GraphQL DTO（这使我们可以保留每个结构的单一职责）。 可以从任何GraphQL IDE访问<code>get_planets</code>和<code>get_planet</code>查询，例如：</p>
<p><em>清单6. 查询示例</em></p>
<pre><code class="language-graphql">{
  getPlanets {
    name
    type
  }
}
</code></pre>
<p><code>Planet</code>对象定义如下：</p>
<p><em>清单7. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">GraphQL类型定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct Planet {
    id: ID,
    name: String,
    planet_type: PlanetType,
}

#[Object]
impl Planet {
    async fn id(&amp;self) -&gt; &amp;ID {
        &amp;self.id
    }

    async fn name(&amp;self) -&gt; &amp;String {
        &amp;self.name
    }

    /// From an astronomical point of view
    #[graphql(name = &quot;type&quot;)]
    async fn planet_type(&amp;self) -&gt; &amp;PlanetType {
        &amp;self.planet_type
    }

    #[graphql(deprecation = &quot;Now it is not in doubt. Do not use this field&quot;)]
    async fn is_rotating_around_sun(&amp;self) -&gt; bool {
        true
    }

    async fn details(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Details {
        let loader = ctx.data::&lt;Loader&lt;i32, Details, DetailsBatchLoader&gt;&gt;().expect(&quot;Can't get loader&quot;);
        let planet_id = self.id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't convert id&quot;);
        loader.load(planet_id).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们为每个字段定义一个Resolver。另外，在某些字段中，指定了描述（Rust文档注释）和弃用原因。 这些将显示在GraphQL IDE中。</p>
<h3><a class="header" href="#解决n1问题" id="解决n1问题">解决N+1问题</a></h3>
<p>如果<code>Planet</code>的<code>details</code>函数的实现是直接从数据库中查询对应<code>id</code>的<code>planet</code>对象则将导致N+1问题，如果你发出这样的请求：</p>
<p><em>清单8: 可能消耗过多资源的GraphQL请求的示例</em></p>
<pre><code class="language-graphql">{
  getPlanets {
    name
    details {
      meanRadius
    }
  }
}
</code></pre>
<p>这将对每个<code>plant</code>对象的<code>details</code>字段执行单独的SQL查询，因为<code>details</code>是与<code>planet</code>关联的类型，并存储在其自己的表中。</p>
<p>但借助<code>Async-graphql</code>的<a href="https://github.com/graphql/dataloader">DataLoader</a>实现，可以将Resolver定义如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn details(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;Details&gt; {
    let data_loader = ctx.data::&lt;DataLoader&lt;DetailsLoader&gt;&gt;().expect(&quot;Can't get data loader&quot;);
    let planet_id = self.id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't convert id&quot;);
    let details = data_loader.load_one(planet_id).await?;
    details.ok_or_else(|| &quot;Not found&quot;.into())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>data_loader</code>是通过以下方式定义的应用程序范围的对象：</p>
<p><em>清单10. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">DataLoader定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let details_data_loader = DataLoader::new(DetailsLoader {
    pool: cloned_pool
}).max_batch_size(10)
<span class="boring">}
</span></code></pre></pre>
<p><code>DetailsLoader</code>的实现：</p>
<p>_清单11. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">DetailsLoader定义</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DetailsLoader {
    pub pool: Arc&lt;PgPool&gt;
}

#[async_trait::async_trait]
impl Loader&lt;i32&gt; for DetailsLoader {
    type Value = Details;
    type Error = Error;

    async fn load(&amp;self, keys: &amp;[i32]) -&gt; Result&lt;HashMap&lt;i32, Self::Value&gt;, Self::Error&gt; {
        let conn = self.pool.get().expect(&quot;Can't get DB connection&quot;);
        let details = repository::get_details(keys, &amp;conn).expect(&quot;Can't get planets' details&quot;);

        Ok(details.iter()
            .map(|details_entity| (details_entity.planet_id, Details::from(details_entity)))
            .collect::&lt;HashMap&lt;_, _&gt;&gt;())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>此方法有助于我们防止N+1问题，因为每个<code>DetailsLoader.load</code>调用仅执行一个SQL查询，返回多个<code>DetailsEntity</code>。</p>
<h1><a class="header" href="#接口定义" id="接口定义">接口定义</a></h1>
<p>GraphQL接口及其实现通过以下方式定义：</p>
<p><em>清单12. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">GraphQL接口定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Interface, Clone)]
#[graphql(
    field(name = &quot;mean_radius&quot;, type = &quot;&amp;CustomBigDecimal&quot;),
    field(name = &quot;mass&quot;, type = &quot;&amp;CustomBigInt&quot;),
)]
pub enum Details {
    InhabitedPlanetDetails(InhabitedPlanetDetails),
    UninhabitedPlanetDetails(UninhabitedPlanetDetails),
}

#[derive(SimpleObject, Clone)]
pub struct InhabitedPlanetDetails {
    mean_radius: CustomBigDecimal,
    mass: CustomBigInt,
    /// In billions
    population: CustomBigDecimal,
}

#[derive(SimpleObject, Clone)]
pub struct UninhabitedPlanetDetails {
    mean_radius: CustomBigDecimal,
    mass: CustomBigInt,
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里你还可以看到，如果该对象没有任何复杂Resolver的字段，则可以使用<code>SimpleObject</code>宏来实现。</p>
<h3><a class="header" href="#自定义标量" id="自定义标量">自定义标量</a></h3>
<p>这个项目包含两个自定义标量定义的示例，两者都是数字类型的包装器（因为由于<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">孤儿规则</a>，你无法在外部类型上实现外部特征）。包装器的实现如下：</p>
<p><em>清单 13. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">自定义标量: 包装BigInt</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct CustomBigInt(BigDecimal);

#[Scalar(name = &quot;BigInt&quot;)]
impl ScalarType for CustomBigInt {
    fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; {
        match value {
            Value::String(s) =&gt; {
                let parsed_value = BigDecimal::from_str(&amp;s)?;
                Ok(CustomBigInt(parsed_value))
            }
            _ =&gt; Err(InputValueError::expected_type(value)),
        }
    }

    fn to_value(&amp;self) -&gt; Value {
        Value::String(format!(&quot;{:e}&quot;, &amp;self))
    }
}

impl LowerExp for CustomBigInt {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let val = &amp;self.0.to_f64().expect(&quot;Can't convert BigDecimal&quot;);
        LowerExp::fmt(val, f)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><em>清单 14. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">自定义标量: 包装BigDecimal</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct CustomBigDecimal(BigDecimal);

#[Scalar(name = &quot;BigDecimal&quot;)]
impl ScalarType for CustomBigDecimal {
    fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; {
        match value {
            Value::String(s) =&gt; {
                let parsed_value = BigDecimal::from_str(&amp;s)?;
                Ok(CustomBigDecimal(parsed_value))
            }
            _ =&gt; Err(InputValueError::expected_type(value)),
        }
    }

    fn to_value(&amp;self) -&gt; Value {
        Value::String(self.0.to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>前一个示例还支持使用指数表示大数。</p>
<h3><a class="header" href="#定义变更mutation" id="定义变更mutation">定义变更(Mutation)</a></h3>
<p>变更定义如下：</p>
<p><em>清单 15. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">定义变更</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutation;

#[Object]
impl Mutation {
    #[graphql(guard(RoleGuard(role = &quot;Role::Admin&quot;)))]
    async fn create_planet(&amp;self, ctx: &amp;Context&lt;'_&gt;, planet: PlanetInput) -&gt; Result&lt;Planet, Error&gt; {
        let new_planet = NewPlanetEntity {
            name: planet.name,
            planet_type: planet.planet_type.to_string(),
        };

        let details = planet.details;
        let new_planet_details = NewDetailsEntity {
            mean_radius: details.mean_radius.0,
            mass: BigDecimal::from_str(&amp;details.mass.0.to_string()).expect(&quot;Can't get BigDecimal from string&quot;),
            population: details.population.map(|wrapper| { wrapper.0 }),
            planet_id: 0,
        };

        let created_planet_entity = repository::create(new_planet, new_planet_details, &amp;get_conn_from_ctx(ctx))?;

        let producer = ctx.data::&lt;FutureProducer&gt;().expect(&quot;Can't get Kafka producer&quot;);
        let message = serde_json::to_string(&amp;Planet::from(&amp;created_planet_entity)).expect(&quot;Can't serialize a planet&quot;);
        kafka::send_message(producer, message).await;

        Ok(Planet::from(&amp;created_planet_entity))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Mutation.create_planet</code>输入参数需要定义以下结构：</p>
<p><em>清单 16: <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">定义输入类型</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(InputObject)]
struct PlanetInput {
    name: String,
    #[graphql(name = &quot;type&quot;)]
    planet_type: PlanetType,
    details: DetailsInput,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>create_planet</code>受<code>RoleGuard</code>保护，可确保只有具有<code>Admin</code>角色的用户才能访问它。要执行变异，如下所示：</p>
<pre><code class="language-graphql">mutation {
  createPlanet(
    planet: {
      name: &quot;test_planet&quot;
      type: TERRESTRIAL_PLANET
      details: { meanRadius: &quot;10.5&quot;, mass: &quot;8.8e24&quot;, population: &quot;0.5&quot; }
    }
  ) {
    id
  }
}
</code></pre>
<p>你需要从<code>auth-service</code>获得JWT，并指定<code>Authorization</code>作为HTTP请求的标头（稍后将对此进行描述）。</p>
<h3><a class="header" href="#定义订阅subscription" id="定义订阅subscription">定义订阅(Subscription)</a></h3>
<p>在上面的Mutation定义中，你可以看到在<code>planet</code>创建过程中发送了一条消息：</p>
<p><em>清单 18. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">发送消息到Kafka</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let producer = ctx.data::&lt;FutureProducer&gt;().expect(&quot;Can't get Kafka producer&quot;);
let message = serde_json::to_string(&amp;Planet::from(&amp;created_planet_entity)).expect(&quot;Can't serialize a planet&quot;);
kafka::send_message(producer, message).await;
<span class="boring">}
</span></code></pre></pre>
<p>使用者可以通过监听Kafka订阅将事件通知给API客户端：</p>
<p><em>清单 19. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">订阅定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Subscription;

#[Subscription]
impl Subscription {
    async fn latest_planet&lt;'ctx&gt;(&amp;self, ctx: &amp;'ctx Context&lt;'_&gt;) -&gt; impl Stream&lt;Item=Planet&gt; + 'ctx {
        let kafka_consumer_counter = ctx.data::&lt;Mutex&lt;i32&gt;&gt;().expect(&quot;Can't get Kafka consumer counter&quot;);
        let consumer_group_id = kafka::get_kafka_consumer_group_id(kafka_consumer_counter);
        let consumer = kafka::create_consumer(consumer_group_id);

        async_stream::stream! {
            let mut stream = consumer.start();

            while let Some(value) = stream.next().await {
                yield match value {
                    Ok(message) =&gt; {
                        let payload = message.payload().expect(&quot;Kafka message should contain payload&quot;);
                        let message = String::from_utf8_lossy(payload).to_string();
                        serde_json::from_str(&amp;message).expect(&quot;Can't deserialize a planet&quot;)
                    }
                    Err(e) =&gt; panic!(&quot;Error while Kafka message processing: {}&quot;, e)
                };
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>订阅可以像查询(Query)和变更(Mutation)一样使用：</p>
<p><em>清单 20. 订阅使用例子</em></p>
<pre><code class="language-graphql">subscription {
  latestPlanet {
    id
    name
    type
    details {
      meanRadius
    }
  }
}
</code></pre>
<p>订阅的URL是<code>ws://localhost:8001</code>。</p>
<h3><a class="header" href="#集成测试" id="集成测试">集成测试</a></h3>
<p>查询和变更的测试可以这样写：</p>
<p><em>清单 21. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">查询测试</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_get_planets() {
    let docker = Cli::default();
    let (_pg_container, pool) = common::setup(&amp;docker);

    let mut service = test::init_service(App::new()
        .configure(configure_service)
        .data(create_schema_with_context(pool))
    ).await;

    let query = &quot;
        {
            getPlanets {
                id
                name
                type
                details {
                    meanRadius
                    mass
                    ... on InhabitedPlanetDetails {
                        population
                    }
                }
            }
        }
        &quot;.to_string();

    let request_body = GraphQLCustomRequest {
        query,
        variables: Map::new(),
    };

    let request = test::TestRequest::post().uri(&quot;/&quot;).set_json(&amp;request_body).to_request();

    let response: GraphQLCustomResponse = test::read_response_json(&amp;mut service, request).await;

    fn get_planet_as_json(all_planets: &amp;serde_json::Value, index: i32) -&gt; &amp;serde_json::Value {
        jsonpath::select(all_planets, &amp;format!(&quot;$.getPlanets[{}]&quot;, index)).expect(&quot;Can't get planet by JSON path&quot;)[0]
    }

    let mercury_json = get_planet_as_json(&amp;response.data, 0);
    common::check_planet(mercury_json, 1, &quot;Mercury&quot;, &quot;TERRESTRIAL_PLANET&quot;, &quot;2439.7&quot;);

    let earth_json = get_planet_as_json(&amp;response.data, 2);
    common::check_planet(earth_json, 3, &quot;Earth&quot;, &quot;TERRESTRIAL_PLANET&quot;, &quot;6371.0&quot;);

    let neptune_json = get_planet_as_json(&amp;response.data, 7);
    common::check_planet(neptune_json, 8, &quot;Neptune&quot;, &quot;ICE_GIANT&quot;, &quot;24622.0&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果查询的一部分可以在另一个查询中重用，则可以使用<a href="https://graphql.org/learn/queries/#fragments">片段(Fragment)</a>：</p>
<p><em>清单 22. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">查询测试（使用片段）</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PLANET_FRAGMENT: &amp;str = &quot;
    fragment planetFragment on Planet {
        id
        name
        type
        details {
            meanRadius
            mass
            ... on InhabitedPlanetDetails {
                population
            }
        }
    }
&quot;;

#[actix_rt::test]
async fn test_get_planet_by_id() {
    ...

    let query = &quot;
        {
            getPlanet(id: 3) {
                ... planetFragment
            }
        }
        &quot;.to_string() + PLANET_FRAGMENT;

    let request_body = GraphQLCustomRequest {
        query,
        variables: Map::new(),
    };

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>要使用<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">变量</a>，你可以通过以下方式编写测试：</p>
<p><em>清单 23. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/tests/query_tests.rs">查询测试（使用片段和变量）</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_get_planet_by_id_with_variable() {
    ...

    let query = &quot;
        query testPlanetById($planetId: String!) {
            getPlanet(id: $planetId) {
                ... planetFragment
            }
        }&quot;.to_string() + PLANET_FRAGMENT;

    let jupiter_id = 5;
    let mut variables = Map::new();
    variables.insert(&quot;planetId&quot;.to_string(), jupiter_id.into());

    let request_body = GraphQLCustomRequest {
        query,
        variables,
    };

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>在这个项目中，<code>Testcontainers-rs</code>库用于准备测试环境，创建一个临时PostgreSQL数据库。</p>
<h3><a class="header" href="#graphql客户端" id="graphql客户端">GraphQL客户端</a></h3>
<p>你可以使用上一部分中的代码段来创建外部GraphQL API的客户端。另外，有一些库可用于此目的，例如<code>graphql-client</code>，但我还没有使用它们。</p>
<h3><a class="header" href="#api安全" id="api安全">API安全</a></h3>
<p>GraphQL API有一些不同程度的安全威胁（请参阅此<a href="https://leapgraph.com/graphql-api-security">清单</a>以了解更多信息），让我们考虑其中的一些方面。</p>
<h4><a class="header" href="#限制查询的深度和复杂度" id="限制查询的深度和复杂度">限制查询的深度和复杂度</a></h4>
<p>如果<code>Satellite</code>对象容纳<code>planet</code>字段，则可能有以下查询：</p>
<p><em>清单 24. 昂贵查询的例子</em></p>
<pre><code class="language-graphql">{
  getPlanet(id: &quot;1&quot;) {
    satellites {
      planet {
        satellites {
          planet {
            satellites {
              ... # 更深的嵌套！
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>为了使这样的查询无效，我们可以指定：</p>
<p><em>清单 25. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">限制查询深度和复杂度的例子</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_schema_with_context(pool: PgPool) -&gt; Schema&lt;Query, Mutation, Subscription&gt; {
    ...

    Schema::build(Query, Mutation, Subscription)
        .limit_depth(3)
        .limit_complexity(15)

    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>请注意，如果你指定深度或复杂度限制，则API文档可能不能在GraphQL IDE中显示，这是因为IDE尝试执行具有相当深度和复杂度的自省查询。</p>
<h4><a class="header" href="#认证" id="认证">认证</a></h4>
<p>使用<code>argonautica</code>和<code>jsonwebtoken</code>库在<code>auth-service</code>中实现此功能。 前一个库负责使用<a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a>算法对用户的密码进行哈希处理。<strong>身份验证和授权功能仅用于演示，请针对生产用途进行更多研究。</strong></p>
<p>让我们看看登录的实现方式：</p>
<p><em>清单 26. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/auth-service/src/graphql.rs">实现登录</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutation;

#[Object]
impl Mutation {

    async fn sign_in(&amp;self, ctx: &amp;Context&lt;'_&gt;, input: SignInInput) -&gt; Result&lt;String, Error&gt; {
        let maybe_user = repository::get_user(&amp;input.username, &amp;get_conn_from_ctx(ctx)).ok();

        if let Some(user) = maybe_user {
            if let Ok(matching) = verify_password(&amp;user.hash, &amp;input.password) {
                if matching {
                    let role = AuthRole::from_str(user.role.as_str()).expect(&quot;Can't convert &amp;str to AuthRole&quot;);
                    return Ok(common_utils::create_token(user.username, role));
                }
            }
        }

        Err(Error::new(&quot;Can't authenticate a user&quot;))
    }
}

#[derive(InputObject)]
struct SignInInput {
    username: String,
    password: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以在<code>utils</code><a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/auth-service/src/utils.rs">模块</a>中查看<code>verify_password</code>函数的实现，在<code>common_utils</code><a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/common-utils/src/lib.rs">模块</a>中查看<code>create_token</code>函数的实现。如你所料，<code>sign_in</code>函数将颁发JWT，该JWT可进一步用于其他服务中的授权。</p>
<p>要获得JWT，你需要执行以下变更：</p>
<p><em>清单 27. 获取JWT</em></p>
<pre><code class="language-graphql">mutation {
  signIn(input: { username: &quot;john_doe&quot;, password: &quot;password&quot; })
}
</code></pre>
<p>使用 <em>john_doe/password</em> ，将获得的JWT用于在进一步的请求中，可以访问受保护的资源（请参阅下一节）。</p>
<h4><a class="header" href="#鉴权" id="鉴权">鉴权</a></h4>
<p>要请求受保护的数据，你需要以<code>Authorization：Bearer $ JWT</code>格式向HTTP请求中添加标头。 <code>index</code>函数将从请求中提取用户的角色，并将其添加到查询数据中：</p>
<p><em>清单 28. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/lib.rs">角色提取</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn index(schema: web::Data&lt;AppSchema&gt;, http_req: HttpRequest, req: Request) -&gt; Response {
    let mut query = req.into_inner();

    let maybe_role = common_utils::get_role(http_req);
    if let Some(role) = maybe_role {
        query = query.data(role);
    }

    schema.execute(query).await.into()
}
<span class="boring">}
</span></code></pre></pre>
<p>以下属性应用于先前定义的<code>create_planet</code>变更：</p>
<p><em>清单 29. 使用字段守卫</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[graphql(guard(RoleGuard(role = &quot;Role::Admin&quot;)))]
<span class="boring">}
</span></code></pre></pre>
<p>这个守卫自身实现如下：</p>
<p><em>清单 30. 守卫实现</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RoleGuard {
    role: Role,
}

#[async_trait::async_trait]
impl Guard for RoleGuard {
    async fn check(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        if ctx.data_opt::&lt;Role&gt;() == Some(&amp;self.role) {
            Ok(())
        } else {
            Err(&quot;Forbidden&quot;.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样如果你未指定角色，则服务器将返回<code>Forbidden</code>的消息。</p>
<h3><a class="header" href="#定义枚举" id="定义枚举">定义枚举</a></h3>
<p>GraphQL枚举可以通过以下方式定义：</p>
<p><em>清单 31. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/satellites-service/src/graphql.rs">定义枚举</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
struct Satellite {
    ...
    life_exists: LifeExists,
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, Enum, EnumString)]
#[strum(serialize_all = &quot;SCREAMING_SNAKE_CASE&quot;)]
pub enum LifeExists {
    Yes,
    OpenQuestion,
    NoData,
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#日期处理" id="日期处理">日期处理</a></h4>
<p><code>Async-graphql</code>支持<code>chrono</code>库中的日期/时间类型，因此你可以照常定义以下字段：</p>
<p><em>清单 32. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/satellites-service/src/graphql.rs">日期字段定义</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
struct Satellite {
    ...
    first_spacecraft_landing_date: Option&lt;NaiveDate&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#支持apollofederation" id="支持apollofederation">支持ApolloFederation</a></h3>
<p><code>satellites-service</code>的目的之一是演示如何在两个（或多个）服务中解析分布式GraphQL<a href="https://www.apollographql.com/docs/federation/entities/">实体</a>（<code>Planet</code>），然后通过Apollo Server对其进行访问。</p>
<p><code>Plant</code>类型之前是通过<code>planets-service</code>定义的：</p>
<p><em>清单 33. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs">在<code>planets-service</code>里定义<code>Planet</code>类型</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct Planet {
    id: ID,
    name: String,
    planet_type: PlanetType,
}
<span class="boring">}
</span></code></pre></pre>
<p>另外，在<code>planets-service</code>中，<code>Planet</code>类型是一个实体：</p>
<p>_清单 34. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/planets-service/src/graphql.rs"><code>Planet</code>实体定义</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl Query {
    #[graphql(entity)]
    async fn find_planet_by_id(&amp;self, ctx: &amp;Context&lt;'_&gt;, id: ID) -&gt; Option&lt;Planet&gt; {
        find_planet_by_id_internal(ctx, id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>satellites-service</code>向<code>Planet</code>对象扩展了<code>satellites</code>字段：</p>
<p><em>清单 35. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/satellites-service/src/graphql.rs"><code>satellites-service</code>中<code>Plant</code>对象的扩展</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Planet {
    id: ID
}

#[Object(extends)]
impl Planet {
    #[graphql(external)]
    async fn id(&amp;self) -&gt; &amp;ID {
        &amp;self.id
    }

    async fn satellites(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Vec&lt;Satellite&gt; {
        let id = self.id.to_string().parse::&lt;i32&gt;().expect(&quot;Can't get id from String&quot;);
        repository::get_by_planet_id(id, &amp;get_conn_from_ctx(ctx)).expect(&quot;Can't get satellites of planet&quot;)
            .iter()
            .map(|e| { Satellite::from(e) })
            .collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>你还应该为扩展类型提供查找函数（此处只是创建了<code>Planet</code>的新实例）：</p>
<p><em>清单 36. <code>Planet</code>对象的查找函数</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl Query {

    #[graphql(entity)]
    async fn get_planet_by_id(&amp;self, id: ID) -&gt; Planet {
        Planet { id }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Async-graphql</code>生成两个附加查询（<code>_service</code>和<code>_entities</code>），这些查询将由Apollo Server使用。这些查询是内部查询，也就是说Apollo Server不会公开这些查询。当然，具有Apollo Federation支持的服务仍可以独立运行。</p>
<h3><a class="header" href="#apolloserver" id="apolloserver">ApolloServer</a></h3>
<p>Apollo Server和Apollo Federation可以实现两个主要目标：</p>
<ul>
<li>
<p>创建单个端点以访问由多个服务提供的GraphQL API</p>
</li>
<li>
<p>从分布式服务创建单个GraphQL模式</p>
</li>
</ul>
<p>也就是说即使你不使用联合实体，前端开发人员也可以使用单个端点而不是多个端点，使用起来更加的方便。</p>
<p>还有一种创建单个GraphQL模式的方法，即<a href="https://www.graphql-tools.com/docs/schema-stitching/">模式缝合</a>，但是我没有使用这种方法。</p>
<p>该模块包括以下代码：</p>
<p><em>清单 37. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/apollo-server/package.json">元信息和依赖</a></em></p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;api-gateway&quot;,
  &quot;main&quot;: &quot;gateway.js&quot;,
  &quot;scripts&quot;: {
    &quot;start-gateway&quot;: &quot;nodemon gateway.js&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;concurrently&quot;: &quot;5.3.0&quot;,
    &quot;nodemon&quot;: &quot;2.0.6&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@apollo/gateway&quot;: &quot;0.21.3&quot;,
    &quot;apollo-server&quot;: &quot;2.19.0&quot;,
    &quot;graphql&quot;: &quot;15.4.0&quot;
  }
}
</code></pre>
<p>_清单 38. <a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/apollo-server/gateway.js">Apollo Server定义</a></p>
<pre><code class="language-javascript">const {ApolloServer} = require(&quot;apollo-server&quot;);
const {ApolloGateway, RemoteGraphQLDataSource} = require(&quot;@apollo/gateway&quot;);

class AuthenticatedDataSource extends RemoteGraphQLDataSource {
    willSendRequest({request, context}) {
        if (context.authHeaderValue) {
            request.http.headers.set('Authorization', context.authHeaderValue);
        }
    }
}

let node_env = process.env.NODE_ENV;

function get_service_url(service_name, port) {
    let host;
    switch (node_env) {
        case 'docker':
            host = service_name;
            break;
        case 'local': {
            host = 'localhost';
            break
        }
    }

    return &quot;http://&quot; + host + &quot;:&quot; + port;
}

const gateway = new ApolloGateway({
    serviceList: [
        {name: &quot;planets-service&quot;, url: get_service_url(&quot;planets-service&quot;, 8001)},
        {name: &quot;satellites-service&quot;, url: get_service_url(&quot;satellites-service&quot;, 8002)},
        {name: &quot;auth-service&quot;, url: get_service_url(&quot;auth-service&quot;, 8003)},
    ],
    buildService({name, url}) {
        return new AuthenticatedDataSource({url});
    },
});

const server = new ApolloServer({
    gateway, subscriptions: false, context: ({req}) =&gt; ({
        authHeaderValue: req.headers.authorization
    })
});

server.listen({host: &quot;0.0.0.0&quot;, port: 4000}).then(({url}) =&gt; {
    console.log(`🚀 Server ready at ${url}`);
});
</code></pre>
<p>如果以上代码可以简化，请随时与我联系以进行更改。</p>
<p><code>apollo-service</code>中的授权工作如先前Rust服务所述（你只需指定<code>Authorization</code>标头及其值）即可。</p>
<p>如果采用<a href="https://www.apollographql.com/docs/federation/federation-spec/">Federation规范</a>，则可以将用任何语言或框架编写的应用程序作为下游服务添加到Apollo Server。这个<a href="https://www.apollographql.com/docs/federation/other-servers/">文档</a>中提供了提供此类支持的库列表。</p>
<p>在实现此模块时，我遇到了一些限制：</p>
<ul>
<li>
<p>Apollo Gateway<a href="https://github.com/apollographql/apollo-server/issues/3357">不支持订阅</a>（但它们仍可在独立的Rust GraphQL应用程序中使用）</p>
</li>
<li>
<p>试图扩展GraphQL接口的服务需要<a href="https://github.com/apollographql/apollo-server/issues/2849">了解具体的实现</a></p>
</li>
</ul>
<h3><a class="header" href="#数据库交互" id="数据库交互">数据库交互</a></h3>
<p>持久层是使用PostgreSQL和Diesel实现的。如果你不在本地使用Docker，你应该在每个服务的文件夹中运行<code>diesel setup</code>。这将创建一个空数据库，然后将应用Migrations创建表和插入数据。</p>
<h3><a class="header" href="#运行和api测试" id="运行和api测试">运行和API测试</a></h3>
<p>如前面所述，对于在本地启动项目，你有两个选择。</p>
<ul>
<li>
<p>使用Docker Compose (<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/docker-compose.yml">docker-compose.yml</a>)</p>
<p>这里也有两个选择</p>
<ul>
<li>
<p>开发模式 （使用本地生成的镜像）</p>
<p><code>docker-compose up</code></p>
</li>
<li>
<p>生产模式 （使用已发布的镜像）</p>
<p><code>docker-compose -f docker-compose.yml up</code></p>
</li>
</ul>
</li>
<li>
<p>不使用Docker</p>
<p>用<code>cargo run</code>启动每个服务，然后启动Apollo Server:</p>
<ul>
<li>进入 <code>apollo-server</code> 目录</li>
<li>定义 <code>NODE_ENV</code> 环境变量， 例如<code>set NODE_ENV=local</code>(Windows)</li>
<li><code>npm install</code></li>
<li><code>npm run start-gateway</code></li>
</ul>
</li>
</ul>
<p>当<code>apollo-server</code>成功运行应该输出以下信息:</p>
<p><em>清单 39. Apollo Server启动日志</em></p>
<pre><code>[nodemon] 2.0.6
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node gateway.js`
Server ready at http://0.0.0.0:4000/
</code></pre>
<p>你可以在浏览器中打开<code>http://localhost:4000</code>，并使用内置的Playground IDE。</p>
<p><img src="chapter_1/graphql_in_rust/playground.png" alt="playground" /></p>
<p>在这里你可以执行下游服务中定义的查询、变更和订阅。另外，这些服务也都有自己的Playground IDE。</p>
<h3><a class="header" href="#订阅测试" id="订阅测试">订阅测试</a></h3>
<p>要测试订阅是否正常工作，可以在GraphQL IDE中打开两个Tab，第一个请求如下。</p>
<p><em>清单 40. 订阅请求</em></p>
<pre><code class="language-graphql">subscription {
  latestPlanet {
    name
    type
  }
}
</code></pre>
<p>第二个请求指定如上所述的<code>Authorization</code>标头，并执行这样的变更。</p>
<p><em>清单 41. 变更请求</em></p>
<pre><code class="language-graphql">mutation {
  createPlanet(
    planet: {
      name: &quot;Pluto&quot;
      type: DWARF_PLANET
      details: { meanRadius: &quot;1188&quot;, mass: &quot;1.303e22&quot; }
    }
  ) {
    id
  }
}
</code></pre>
<p>订阅的客户端会收到<code>Plant</code>创建的通知。</p>
<p><img src="chapter_1/graphql_in_rust/subscription-demo.gif" alt="subscription-demo" /></p>
<h3><a class="header" href="#cicd" id="cicd">CI/CD</a></h3>
<p>CI/CD是使用GitHub Actions（<a href="https://github.com/rkudryashov/graphql-rust-demo/blob/master/.github/workflows/workflow.yml">workflow</a>）配置的，它可以运行应用程序的测试，构建它们的Docker镜像，并在Google Cloud Platform上部署它们。</p>
<p>你可以在<a href="http://graphql-rust.romankudryashov.com/">这里</a>试试已部署的服务。</p>
<p><strong>注意：</strong> 在<code>生产</code>环境下，为了防止更改初始数据，密码与前面指定的不同。</p>
<h3><a class="header" href="#结论" id="结论">结论</a></h3>
<p>在这篇文章中，我考虑了如何解决在Rust中开发GraphQL API时可能出现的最常见问题。此外，我还展示了如何将使用Rust开发的GraphQL微服务API结合起来，以提供统一的GraphQL接口。在这样的架构中，一个实体可以分布在几个微服务之间，它是通过Apollo Server、Apollo Federation和Async-graphql库来实现的。项目的源代码在<a href="https://github.com/rkudryashov/graphql-rust-demo">GitHub</a>上。如果你发现文章或源代码中有任何错误，欢迎<a href="chapter_1/graphql_in_rust/rskudryashov@gmail.com">联系</a>我。谢谢阅读!</p>
<h3><a class="header" href="#有用的链接" id="有用的链接">有用的链接</a></h3>
<ul>
<li><a href="https://graphql.org/">graphql.org</a></li>
<li><a href="https://spec.graphql.org/">spec.graphql.org</a></li>
<li><a href="https://graphql.org/learn/best-practices/">graphql.org/learn/best-practices</a></li>
<li><a href="https://www.howtographql.com/">howtographql.com</a></li>
<li><a href="https://github.com/async-graphql/async-graphql">Async-graphql</a></li>
<li><a href="https://async-graphql.github.io/async-graphql/zh-CN/index.html">Async-graphql使用手册</a></li>
<li><a href="https://github.com/chentsulin/awesome-graphql">Awesome GraphQL</a></li>
<li><a href="https://github.com/APIs-guru/graphql-apis">Public GraphQL APIs</a></li>
<li><a href="https://github.com/apollographql/federation-demo">Apollo Federation demo</a></li>
</ul>
<h1><a class="header" href="#图解-rust-所有权与生命周期" id="图解-rust-所有权与生命周期">图解 Rust 所有权与生命周期</a></h1>
<p>作者：肖猛</p>
<p>后期编辑：高宪凤</p>
<hr />
<p>作者简介：</p>
<p>肖猛</p>
<p>二十年从桌面到云端到嵌入式的软件架构经验，跨通讯、游戏、金融、智能网联汽车多个行业，领域系统分析专家、全栈软件架构专家。</p>
<p>目前致力于智能驾驶基础软件开发。历任吉利亿咖通自动驾驶软件平台总监，国汽智控自动驾驶软件研发总监。对在汽车领域推广 Rust 技术栈有浓厚兴趣，并有实际的量产实践。</p>
<hr />
<h2><a class="header" href="#1引言" id="1引言">1.引言</a></h2>
<p><strong>所有权</strong>与<strong>生命周期</strong>是  <code>Rust</code>  语言非常核心的内容。其实不仅仅是 <code>Rust</code> 有这两个概念，在<code>C/C++</code> 中也一样是存在的。而几乎所有的内存安全问题也源于对所有权和生命周期的错误使用。只要是不采用垃圾回收来管理内存的程序语言，都会有这个问题。只是 <code>Rust</code> 在语言级明确了这两个概念，并提供了相关的语言特性让用户可以显式控制所有权的转移与生命周期的声明。同时编译器会对各种错误使用进行检查，提高了程序的内存安全性。</p>
<p>所有权和生命周期其涉及的语言概念很多，本文主要是对梳理出与“所有权与生命周期”相关的概念，并使用  <code>UML</code> 的类图表达概念间的关系，帮助更好的理解和掌握。</p>
<p><strong>图例说明</strong></p>
<p>本文附图都是 <code>UML</code> 类图，<code>UML</code> 类图可以用来表示对概念的分析。表达概念之间的依赖、继承、聚合、组成等关系。图中的每一个矩形框都是一个语义概念，有的是抽象的语言概念，有的是 <code>Rust</code> 库中的结构和 <code>Trait</code>。</p>
<p>所有图中使用的符号也只有最基础的几个。图 1 对符号体系做简单说明，主要解释一下表达概念之间的关系的符号语言。</p>
<div align=center>
    <img width="544" height="306" src="chapter_1/./rust_ownership/rust_ownership_1.jpg">
</div>
<center>图 1UML 符号</center>
<p><strong>依赖关系：</strong></p>
<p>依赖是 <code>UML</code> 中最基础的关系语义。 以带箭头的虚线表示，<code>A</code> 依赖与 <code>B</code> 表达如下图。直观理解可以是 <code>A</code> “看的见” <code>B</code>，而 <code>B</code> 可以对 <code>A</code> 一无所知。比如在代码中 结构体 <code>A</code> 中有 结构体 <code>B</code> 的成员变量，或者 <code>A</code> 的实现代码中有 <code>B</code> 的局部变量。这样如果找不到 <code>B</code>，<code>A</code> 是无法编译通过的。</p>
<p><strong>关联关系：</strong></p>
<p>一条实线连接表示两个类型直接有关联，有箭头表示单向&quot;可见&quot;,无箭头表示相互之间可见。关联关系也是一种依赖，但是更具体。有时候两个类型之间的关联关系太复杂，需要用一个类型来表达，叫做关联类型，如例图中的 <code>H</code>.</p>
<p><strong>聚合与组成：</strong></p>
<p>聚合与组成都是表示的是整体和部分的关系。差别在于“聚合”的整体与部分可以分开，部分可以在多个整体之间共享。而“组成”关系中整体对部分有更强的独占性，部分不能被拆开，部分与整体有相同的生命周期。</p>
<p><strong>继承与接口实现：</strong></p>
<p>继承与接口实现都是一种泛化关系，<code>C</code> 继承自 <code>A</code>，表示 <code>A</code> 是更泛化的概念。<code>UML</code> 中各种关系语义也可以用 <code>UML</code> 自身来表达，如图 2：“关联”和“继承”都是“依赖”的具体体现方式。</p>
<div align=center>
    <img width="544" height="306" src="chapter_1/./rust_ownership/rust_ownership_2.jpg">
</div>
<center>图 2用 UML表达UML自身</center>
<p><strong>总图</strong></p>
<p>图 3 是本文的总图，后续各节分局部介绍。
<img src="chapter_1/./rust_ownership/rust_ownership_3.png"></p>
<center>图 3Rust 所有权与生命周期总图</center>
<h2><a class="header" href="#2所有权与生命周期期望解决的问题" id="2所有权与生命周期期望解决的问题">2.所有权与生命周期期望解决的问题</a></h2>
<p>我们从图中间部分开始看起，所谓“所有权”是指对一个变量拥有了一块“内存区域”。这个内存区域，可以在堆上，可以在栈上，也可以在代码段，还有些内存地址是直接用于 <code>I/O</code> 地址映射的。这些都是内存区域可能存在的位置。</p>
<p>在高级语言中，这个内存位置要在程序中要能被访问，必然就会与一个或多个变量建立关联关系（低级语言如汇编语言，可以直接访问内存地址）。也就是说，通过这一个或多个变量，就能访问这个内存地址。</p>
<p>这就引出三个问题：</p>
<ol>
<li>内存的不正确访问引发的内存安全问题</li>
<li>由于多个变量指向同一块内存区域导致的数据一致性问题</li>
<li>由于变量在多个线程中传递，导致的数据竞争的问题</li>
</ol>
<p>由第一个问题引发的内存安全问题一般有 5 个典型情况：</p>
<ul>
<li>使用未初始化的内存</li>
<li>对空指针解引用</li>
<li>悬垂指针(使用已经被释放的内存)</li>
<li>缓冲区溢出</li>
<li>非法释放内存(释放未分配的指针或重复释放指针)</li>
</ul>
<img src="chapter_1/./rust_ownership/rust_ownership_4.jpg">
<center>图 4变量绑定与内存安全的基本概念</center>
<p>这些问题在 <code>C/C++</code> 中是需要开发者非常小心的自己处理。 比如我们可以写一段 <code>C++</code> 代码，把这五个内存安全错误全部犯一遍。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

struct Point {
	int x;
	int y;
};

Point* newPoint(int x,int y) {
	Point p { .x=x,.y=y };
	return &amp;p; //悬垂指针
}

int main() {
	int values[3]= { 1,2,3 };
	std::cout&lt;&lt;values[0]&lt;&lt;&quot;,&quot;&lt;&lt;values[3]&lt;&lt;std::endl; //缓冲区溢出

	Point *p1 = (Point*)malloc(sizeof(Point));
	std::cout&lt;&lt;p1-&gt;x&lt;&lt;&quot;,&quot;&lt;&lt;p1-&gt;y&lt;&lt;std::endl; //使用未初始化内存

	Point *p2 = newPoint(10,10); //悬垂指针
	delete p2; //非法释放内存

	p1 = NULL;
	std::cout&lt;&lt;p1-&gt;x&lt;&lt;std::endl; //对空指针解引用
	return 0;
}
</code></pre>
<p>这段代码是可以编译通过的，当然，编译器还是会给出警告信息。这段代码也是可以运行的，也会输出信息，直到执行到最后一个错误处“对空指针解引用时”才会发生段错误退出。</p>
<p><code>Rust</code> 的语言特性为上述问题提供了解决方案，如下表所示：</p>
<table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody>
<tr><td><div style="width: 200px">使用未初始化的内存</div></td><td>编译器禁止变量读取未赋值变量</td></tr>
<tr><td><div style="width: 200px">对空指针解引用</div></td><td>使用 Option<T> 枚举替代空指针</td></tr>
<tr><td><div style="width: 200px">悬垂指针</div></td><td>生命周期标识与编译器检查</td></tr>
<tr><td><div style="width: 200px">缓冲区溢出</div></td><td>编译器检查，拒绝超越缓冲区边界的数据访问</td></tr>
<tr><td><div style="width: 200px">非法释放内存</div></td><td>语言级的 RAII 机制，只有唯一的所有者才有权释放内存</td></tr>
<tr><td><div style="width: 200px">多个变量修改同一块内存区域</div></td><td>允许多个变量借用所有权，但是同一时间只允许一个可变借用</td></tr>
<tr><td><div style="width: 200px">变量在多个线程中传递时的安全问题</div></td><td>对基本数据类型用 Sync 和 Send 两个 Trait 标识其线程安全特性，即能否转移所有权或传递可变借用，把这作为基本事实。再利用泛型限定语法和 Trait impl 语法描述出类型线程安全的规则。编译期间使用类似规则引擎的机制，基于基本事实和预定义规则为用户代码中的跨线程数据传递做推理检查。</td></tr>
</tbody></table>
<h2><a class="header" href="#3变量绑定与所有权的赋予" id="3变量绑定与所有权的赋予">3.变量绑定与所有权的赋予</a></h2>
<p><code>Rust</code> 中为什么叫“变量绑定”而不叫“变量赋值&quot;。我们先来看一段 <code>C++</code> 代码，以及对应的 <code>Rust</code> 代码。</p>
<p>C++:</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
int main()
{
	int a = 1;
	std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;   /* 输出 0x62fe1c */
	a = 2;
	std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;   /* 输出 0x62fe1c */
}
</code></pre>
<p>Rust:</p>
<pre><code class="language-Rust">fn main() {
	let a = 1;
	println!(&quot;a:{}&quot;,a);     // 输出1
	println!(&quot;&amp;a:{:p}&quot;,&amp;a); // 输出0x9cf974
	//a=2;                  // 编译错误，不可变绑定不能修改绑定的值
	let a = 2;              // 重新绑定
	println!(&quot;&amp;a:{:p}&quot;,&amp;a); // 输出0x9cfa14地址发生了变化
	let mut b = 1;          // 创建可变绑定
	println!(&quot;b:{}&quot;,b);     // 输出1
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfa6c
	b = 2;
	println!(&quot;b:{}&quot;,b);     // 输出2
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfa6c地址没有变化
	let b = 2;              // 重新绑定新值
	println!(&quot;&amp;b:{:p}&quot;,&amp;b); // 输出0x9cfba4地址发生了变化
}
</code></pre>
<p>我们可以看到，在 <code>C++</code> 代码中，变量 <code>a</code> 先赋值为 1，后赋值为 2，但其地址没有发生变化。<code>Rust</code> 代码中，<code>a</code> 是一个不可变绑定，执行<code>a=2</code>动作被编译器拒绝。但是可以使用 <code>let</code> 重新绑定，但这时 <code>a</code> 的地址跟之前发生了变化，说明 a 被绑定到了另一个内存地址。<code>b</code> 是一个可变绑定，可以使用<code>b = 2</code>重新给它指向的内存赋值，<code>b</code> 的地址不变。但使用 <code>let</code> 重新绑定后，<code>b</code> 指向了新的内存区域。</p>
<p>可以看出，&quot;赋值&quot; 是将值写入变量关联的内存区域，&quot;绑定&quot; 是建立变量与内存区域的关联关系，<code>Rust</code> 里，还会把这个内存区域的所有权赋予这个变量。</p>
<p>不可变绑定的含义是：将变量绑定到一个内存地址，并赋予所有权，通过改变量只能读取该地址的数据，不能修改该地址的数据。对应的，可变绑定就可以通过变量修改关联内存区域的数据。从语法上看，有 <code>let</code> 关键字是绑定, 没有就是赋值.。</p>
<p>这里我们能看出 <code>Rust</code> 与 <code>C++</code> 的一个不同之处。<code>C++</code> 里是没有“绑定”概念的。<code>Rust</code> 的变量绑定概念是一个很关键的概念，它是所有权的起点。有了明确的绑定才有了所有权的归属，同时解绑定的时机也确定了资源释放的时机。</p>
<p>所有权规则：</p>
<ul>
<li>每一个值都有其所有者变量</li>
<li>同一时间所有者变量只能有一个</li>
<li>所有者离开作用域，值被丢弃(释放/析构)</li>
</ul>
<p>作为所有者，它有如下权利：</p>
<ul>
<li>控制资源的释放</li>
<li>出借所有权</li>
<li>转移所有权</li>
</ul>
<h2><a class="header" href="#4所有权的转移" id="4所有权的转移">4.所有权的转移</a></h2>
<p>所有者的重要权利之一就是“转移所有权”。这引申出三个问题：</p>
<ol>
<li>为什么要转移？</li>
<li>什么时候转移？</li>
<li>什么方式转移？</li>
</ol>
<p>相关的语言概念如下图。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_5.jpg">
<center>图 5所有权转移</center>
<p><strong>为什么要转移所有权？</strong>
我们知道，C/C++/Rust 的变量关联了某个内存区域，但变量总会在表达式中进行操作再赋值给另一个变量，或者在函数间传递。实际上期望被传递的是变量绑定的内存区域的内容，如果这块内存区域比较大，复制内存数据到给新的变量就是开销很大的操作。所以需要把所有权转移给新的变量，同时当前变量放弃所有权。所以归根结底，转移所有权还是为了性能。</p>
<p><strong>所有权转移的时机总结下来有以下两种情况：</strong></p>
<ol>
<li>位置表达式出现在值上下文时转移所有权</li>
<li>变量跨作用域传递时转移所有权</li>
</ol>
<p>第一条规则是一个精确的学术表达，涉及到位置表达式，值表达式，位置上下文，值上下文等语言概念。它的简单理解就是各种各样的赋值行为。能明确指向某一个内存区域位置的表达式是位置表达式，其它的都是值表达式。各种带有赋值语义的操作的左侧是位置上下文，右侧是值上下文。</p>
<p>当位置表达式出现在值上下文时，其程序语义就是要把这边位置表达式所指向的数据赋给新的变量，所有权发生转移。</p>
<p>第二条规则是“变量跨作用域时转移所有权”。</p>
<p>图上列举出了几种常见的跨作用域行为，能涵盖大多数情况，也有简单的示例代码</p>
<ul>
<li>变量被花括号内使用</li>
<li>match 匹配</li>
<li>if let 和 While let</li>
<li>移动语义函数参数传递</li>
<li>闭包捕获移动语义变量</li>
<li>变量从函数内部返回</li>
</ul>
<p>为什么变量跨作用域要转移所有权？在 <code>C/C++</code> 代码中，是否转移所有权是程序员自己隐式或显式指定的。</p>
<p>试想，在 <code>C/C++</code> 代码中，函数 <code>Fun1</code> 在栈上创建一个 类型 <code>A</code> 的实例 <code>a</code>， 把它的指针 <code>&amp;a</code> 传递给函数 <code>void fun2(A* param)</code> 我们不会希望 <code>fun2</code> 释放这个内存，因为 <code>fun1</code> 返回时，栈上的空间会自动被释放。</p>
<p>如果 <code>fun1</code> 在堆上创建 <code>A</code> 的实例 <code>a</code>， 把它的指针 <code>&amp;a</code> 传递给函数 <code>fun2(A* param)</code>,那么关于 <code>a</code> 的内存空间的释放，<code>fun1</code> 和 <code>fun2</code> 之间需要有个商量，由谁来释放。<code>fun1</code> 可能期望由 <code>fun2</code> 来释放，如果由 <code>fun2</code> 释放，则 <code>fun2</code> 并不能判断这个指针是在堆上还是栈上。归根结底，还是谁拥有 <code>a</code> 指向内存区的所有权问题。 <code>C/C++</code> 在语言层面上并没有强制约束。<code>fun2</code> 函数设计的时候，需要对其被调用的上下文做假定，在文档中对对谁释放这个变量的内存做约定。这样编译器实际上很难对错误的使用方式给出警告。</p>
<p><code>Rust</code> 要求变量在跨越作用域时明确转移所有权，编译器可以很清楚作用域边界内外哪个变量拥有所有权，能对变量的非法使用作出明确无误的检查，增加的代码的安全性。</p>
<p><strong>所有权转移的方式有两种：</strong></p>
<ul>
<li>移动语义-执行所有权转移</li>
<li>复制语义-不执行转移，只按位复制变量</li>
</ul>
<p>这里我把 ”复制语义“定义为所有权转移的方式之一，也就是说“不转移”也是一种转移方式。看起来很奇怪。实际上逻辑是一致的，因为触发复制执行的时机跟触发转移的时机是一致的。只是这个数据类型被打上了 <code>Copy</code> 标签 <code>trait</code>, 在应该执行转移动作的时候，编译器改为执行按位复制。</p>
<p><code>Rust</code> 的标准库中为所有基础类型实现的 <code>Copy Trait</code>。</p>
<p>这里要注意，标准库中的</p>
<pre><code class="language-Rust"> impl&lt;T: ?Sized&gt; Copy for &amp;T {}
</code></pre>
<p>为所有引用类型实现了 <code>Copy</code>, 这意味着我们使用引用参数调用某个函数时，引用变量本身是按位复制的。标准库没有为可变借用 <code>&amp;mut T</code> 实现“Copy” <code>Trait</code> , 因为可变借用只能有一个。后文讲闭包捕获变量的所有权时我们可以看到例子。</p>
<h2><a class="header" href="#5所有权的借用" id="5所有权的借用">5.所有权的借用</a></h2>
<p>变量拥有一个内存区域所有权，其所有者权利之一就是“出借所有权”。</p>
<p>与出借所有权相关的概念关系如图 6</p>
<img src="chapter_1/./rust_ownership/rust_ownership_6.jpg">
<center>图 6出借所有权</center>
<p>拥有所有权的变量借出其所有权有“引用”和“智能指针”两种方式：</p>
<ul>
<li>
<p>引用（包含可变借用和不可变借用)</p>
</li>
<li>
<p>智能指针</p>
<ul>
<li>独占式智能指针 <code>Box&lt;T&gt;</code></li>
<li>非线程安全的引用计数智能指针 <code>Rc&lt;T&gt;</code></li>
<li>线程安全的引用计数智能指针 <code>Arc&lt;T&gt;</code></li>
<li>弱指针 <code>Weak&lt;T&gt;</code></li>
</ul>
</li>
</ul>
<p>引用实际上也是指针，指向的是实际的内存位置。</p>
<p>借用有两个重要的安全规则：</p>
<ol>
<li>代表借用的变量，其生命周期不能比被借用的变量(所有者)的生命周期长</li>
<li>同一个变量的可变借用只能有一个</li>
</ol>
<p>第一条规则就是确保不出现“悬垂指针”的内存安全问题。如果这条规则被违反，例如：变量 <code>a</code> 拥有存储区域的所有权，变量 <code>b</code> 是 <code>a</code> 的某种借用形式，如果 <code>b</code> 的生命周期比 <code>a</code> 长，那么 <code>a</code> 被析构后存储空间被释放，而 <code>b</code> 仍然可以使用，则 <code>b</code> 就成为了悬垂指针。</p>
<p>第二条是不允许有两个可变借用，避免出现数据一致性问题。</p>
<pre><code class="language-Rust">Struct Foo{v:i32}
fn main(){
    let mut f = Foo{v:10};
    let im_ref = &amp;f;        // 获取不可变引用
    let mut_ref = &amp; mut f;  // 获取可变引用
    //println!(&quot;{}&quot;,f.v);
    //println!(&quot;{}&quot;,im_ref.v);
    //println!(&quot;{}&quot;,mut_ref.v);
}
</code></pre>
<p>变量 <code>f</code> 拥有值的所有权，<code>im_ref</code> 是其不可变借用，<code>mut_ref</code> 是其可变借用。以上代码是可以编译过去的，但是这几个变量都没有被使用，这种情况下编译器并不禁止你同时拥有可变借用和不可变借用。最后的三行被注释掉的代码(6,7,8)使用了这些变量。打开一行或多行这些注释的代码，编译器会报告不同形式的错误：</p>
<table><thead><tr><th>开放注释行</th><th>编译器报告</th></tr></thead><tbody>
<tr><td>6</td><td>正确</td></tr>
<tr><td>7</td><td>第 5 行错误：不能获得 f 的可变借用，因为已经存在不可变借用</td></tr>
<tr><td>8</td><td>正确</td></tr>
<tr><td>6, 7</td><td>第 5 行错误：不能获得 f 的可变借用，因为已经存在不可变借用</td></tr>
<tr><td>6,8</td><td>第 6 行错误：不能获得 f 的不可变借用，因为已经存在可变借用</td></tr>
</tbody></table>
<p><strong>对&quot;借用&quot; 的抽象表达</strong></p>
<p><code>Rust</code> 的核心包中有两个泛型 <code>trait</code> ，<a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">core::borrow::Borrow</a> 与 <a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html">core::borrow::BorrowMut</a>，可以用来表达&quot;借用&quot;的抽象含义，分别代表可变借用和不可变借用。
前面提到，“借用”有多种表达形式 <code>（&amp;T,Box&lt;T&gt;，Rc&lt;T&gt; 等等）</code>，在不同的使用场景中会选择合适的借用表达方式。它们的抽象形式就可以用 <a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">core::borrow::Borrow</a> 来代表. 从类型关系上， <code>Borrow</code> 是&quot;借用&quot; 概念的抽象形式。从实际应用上，某些场合我们希望获得某个类型的“借用”，同时希望能支持所有可能的“借用”形式，<code>Borrow Trait</code> 就有用武之地。</p>
<p>Borrow 的定义如下：</p>
<pre><code class="language-Rust">pub trait Borrow&lt;Borrowed: ?Sized&gt; {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
</code></pre>
<p>它只有一个方法，要求返回指定类型的引用。</p>
<p><code>Borrow</code> 的文档中有提供例子</p>
<pre><code class="language-Rust">use std::borrow::Borrow;

fn check&lt;T: Borrow&lt;str&gt;&gt;(s: T) {
    assert_eq!(&quot;Hello&quot;, s.borrow());
}

fn main(){
    let s: String = &quot;Hello&quot;.to_string(); 
    check(s);

    lets: &amp;str = &quot;Hello&quot;; 
    check(s);
}
</code></pre>
<p><code>check</code> 函数的参数表示它希望接收一个 “str”类型的任何形式的“借用”，然后取出其中的值与 “Hello”进行比较。</p>
<p>标准库中为 <code>String</code> 类型实现了 <code>Borrow&lt;str&gt;</code>,代码如下</p>
<pre><code class="language-Rust">impl Borrow&lt;str&gt; for String{
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str{
        &amp;self[..]
    }
}
</code></pre>
<p>所以 <code>String</code> 类型可以作为 <code>check</code> 函数的参数。</p>
<p>从图上可以看出，标准库为所有类型 <code>T</code> 实现了 <code>Borrow Trait</code>, 也为 <code>&amp;T</code> 实现了 <code>Borrow Trait</code>。</p>
<p>代码如下 ，这如何理解。</p>
<pre><code class="language-Rust">impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for T {
    fn borrow(&amp;self) -&gt; &amp;T { // 是 fn borrow(self: &amp;Self）的缩写，所以 self 的类型就是 &amp;T
        self
    }
}

impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for &amp;T {
    fn borrow(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
</code></pre>
<p>这正是 <code>Rust</code> 语言很有意思的地方，非常巧妙的体现了语言的一致性。既然 <code>Borrow&lt;T&gt;</code> 的方法是为了能获取 <code>T</code> 的引用，那么类型 <code>T</code> 和 <code>&amp;T</code> 当然也可以做到这一点。在 <code>Borrow for T</code> 的实现中，</p>
<p><code>fn borrow(&amp;self)-&gt;&amp;T</code> 是 <code>fn borrow(self: &amp;Self)-&gt;&amp;T</code> 的缩写，所以 <code>self</code> 的类型就是 <code>&amp;T</code>,可以直接被返回。在 <code>Borrow for &amp;T</code> 的实现中，<code>fn borrow(&amp;self)-&gt;&amp;T</code> 是 <code>fn borrow(self: &amp;Self)-&gt;&amp;T</code> 的缩写，所以 <code>self</code> 的类型就是 <code>&amp;&amp;T</code>, 需要被两次解引用得到 <code>T</code>, 再返回其引用。</p>
<p>智能指针 <code>Box&lt;T&gt;</code>,<code>Rc&lt;T&gt;</code>,<code>Arc&lt;T&gt;</code>,都实现了 <code>Borrow&lt;T&gt;</code> ，其获取 <code>&amp;T</code> 实例的方式都是两次解引用在取引用。<code>Weak&lt;T&gt;</code> 没有实现 <code>Borrow&lt;T&gt;</code>, 它需要升级成 <code>Rc&lt;T&gt;</code> 才能获取数据。</p>
<h2><a class="header" href="#6生命周期参数" id="6生命周期参数">6.生命周期参数</a></h2>
<p>变量的生命周期主要跟变量的作用域有关，在大部分程序语言中都是隐式定义的。<code>Rust</code> 中能显式声明变量的生命周期参数，这是非常独特的设计，其语法特性在其他语言也是不太可能见到的。以下是生命周期概念相关的图示。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_7.jpg">
<center>图 7生命周期</center>
<p><strong>生命周期参数的作用</strong></p>
<p>生命周期参数的核心作用就是解决悬垂指针问题。就是让编译器帮助检查变量的生命周期，防止出现变量指向的内存区域被释放后，变量仍然可以使用的问题。那么什么情况下会让编译器无法判断生命周期，而必须引入一个特定语法来对生命周期进行标识？</p>
<p>我们来看看最常见的悬垂指针问题，函数以引用方式返回函数内部的局部变量：</p>
<pre><code class="language-Rust">struct V{v:i32}
 
fn bad_fn() -&gt; &amp;V{  //编译错误：期望一个命名的生命周期参数
    let a = V{v:10};
    &amp;a
}
let  res = bad_fn();
</code></pre>
<p>这个代码是一个典型的悬垂指针错误，<code>a</code> 是函数内的局部变量，函数返回后 <code>a</code> 就被销毁，把 <code>a</code> 的引用赋值给 <code>res</code> ，如果能执行成功，<code>res</code> 绑定的就是未定义的值。</p>
<p>但编译器并不是报告悬垂指针错误，而是说返回类型 <code>&amp;V</code> 没有指定生命周期参数。<code>C++</code> 的类似代码编译器会给出悬垂指针的警告（警告内容:局部变量的地址被返回了）。</p>
<p>那我们指定一个生命周期参数看看：</p>
<pre><code class="language-Rust">fn bad_fn&lt;'a&gt;() -&gt; &amp;'a V{
    let a = V{v:10};
    let ref_a = &amp;a;
    ref_a   //编译错误：不能返回局部变量的引用
}
</code></pre>
<p>这次编译器报告的是悬垂指针错误了。那么编译器的分析逻辑是什么？</p>
<p>首先我们明确一下 <font color=#fa8919>'a 在这里的精确语义到底是什么？</font></p>
<p>函数将要返回的引用会代表一个内存数据，这个数据有其生命周期范围，<code>'a</code> 参数是对这个生命周期范围提出的要求。就像 <code>&amp;V</code> 是对返回值类型提的要求类似，<strong>'a 是对返回值生命周期提的要求</strong>。编译器需要检查的就是实际返回的数据，其生命是否符合要求。</p>
<p>那么 <font color=#fa8919>'a 参数对返回值的生命周期到底提出了什么要求？</font></p>
<p>我们先区分一下&quot;函数上下文&quot;和“调用者上下文”，函数上下文是指函数体内部的作用域范围，调用者上下文是指该函数被调用的位置。上述的悬垂指针错误其实并不会影响函数上下文范围的程序执行，出问题的地方是调用者上下文拿到一个无效引用并使用时，会出现不可预测的错误。</p>
<p>函数返回的引用会在“调用者上下文”中赋予某个变量，如：</p>
<pre><code class="language-Rust">let res = bod_fn();
</code></pre>
<p><code>res</code> 获得了返回的引用, 函数内的 <code>ref_a</code> 引用会按位复制给变量 <code>res</code> （标准库中 <code>impl&lt;T: ?Sized&gt; Copy for &amp;T {}</code> 指定了此规则）<code>res</code> 会指向 函数内 <code>res_a</code> 同样的数据。为了保证将来在调用者上下文不出悬垂指针，编译器真正要确保的是 <code>res</code> 所指向的数据的生命周期，不短于 <code>res</code> 变量自己的生命周期。否则如果数据的生命周期短，先被释放，<code>res</code> 就成为悬垂指针。</p>
<p>可以把这里的 <code>'a</code> 参数理解为调用者上下文中接收函数返回值的变量 <code>res</code> 的生命周期，那么 <code>'a</code> 对函数体内部返回引用的要求是：<strong>返回引用所指代数据的生命周期不短于 'a ，也就是不短于调用者上下文接收返回值的变量的生命周期。</strong></p>
<p>上述例子中函数内 <code>ref_a</code> 指代的数据生命周期就是函数作用域，函数返回前，数据被销毁，生命周期小于调用者上下文的 <code>res</code>, 编译器根据 返回值的生命周期要求与实际返回值做比较，发现了错误。</p>
<p>实际上，返回的引用或者是静态生命周期，或者是根据函数输入的引用参数通过运算变换得来的，否则都是这个结果，因为都是对局部数据的引用。</p>
<p><strong>静态生命周期</strong></p>
<p>看函数</p>
<pre><code class="language-Rust">fn get_str&lt;'a&gt;() -&gt; &amp;'a str {
    let s = &quot;hello&quot;;
    s
}
</code></pre>
<p>这个函数可以编译通过，返回的引用虽然不是从输入参数推导，不过是静态生命周期，可以通过检查。</p>
<p>因为静态生命周期可以理解为“无穷大”的语义，实际是跟进程的生命周期一致，也就是在程序运行期间始终有效。</p>
<p><code>Rust</code> 的字符串字面量是存储在程序代码中，程序加载后在代码空间，始终有效。可以通过一个简单试验验证这一点：</p>
<pre><code class="language-Rust">let s1=&quot;Hello&quot;;
println!(&quot;&amp;s1:{:p}&quot;, &amp;s1);//&amp;s1:0x9cf918

let s2=&quot;Hello&quot;;
println!(&quot;&amp;s2:{:p}&quot;,&amp;s2);//&amp;s2:0x9cf978
//s1,s2是一样的值但是地址不一样，是两个不同的引用变量

let ptr1: *const u8 = s1.as_ptr();
println!(&quot;ptr1:{:p}&quot;, ptr1);//ptr1:0x4ca0a0

let ptr2: *const u8 = s2.as_ptr();
println!(&quot;ptr2:{:p}&quot;, ptr2);//ptr2:0x4ca0a0
</code></pre>
<p><code>s1</code>,<code>s2</code> 的原始指针都指向同一个地址，说明编译器为 &quot;Hello&quot; 字面量只保存了一份拷贝，所有引用都指向它。</p>
<p><code>get_str</code> 函数中静态生命周期长于返回值要求的<code>'a</code>，所以是合法的。</p>
<p>如果把 <code>get_str</code> 改成</p>
<pre><code class="language-Rust">fn get_str&lt;'a&gt;() -&gt; &amp;'static str
</code></pre>
<p>即把对返回值生命周期的要求改为无穷大，那就只能返回静态字符串引用了。</p>
<p><strong>函数参数的生命周期</strong></p>
<p>前面的例子为了简单起见，没有输入参数，这并不是一个典型的情况。大多数情况下，函数返回的引用是根据输入的引用参数通过运算变换而来。比如下面的例子：</p>
<pre><code class="language-Rust">fn  remove_prefix&lt;'a&gt;(content:&amp;'a str,prefix:&amp;str) -&gt; &amp;'a str{
    if content.starts_with(prefix){
        let start:usize = prefix.len();
        let end:usize = content.len();
        let sub = content.get(start..end).unwrap();
        sub
    }else{
        content
    }
}
let  s = &quot;reload&quot;;
let sub = remove_prefix(&amp;s0,&quot;re&quot;);
println!(&quot;{}&quot;,sub); // 输出: load
</code></pre>
<p><code>remove_prefix</code> 函数从输入的 <code>content</code> 字符串中判断是否有 <code>prefix</code> 代表的前缀。 如果有就返回 <code>content</code> 不包含前缀的切片，没有就返回 <code>content</code> 本身。</p>
<p>无论如何这个函数都不会返回前缀 <code>prefix</code> ，所以 <code>prefix</code> 变量不需要指定生命周期。</p>
<p>函数两个分支返回的都是通过 <code>content</code> 变量变换出来的，并作为函数的返回值。所以 <code>content</code> 必须标注生命周期参数，编译器要根据 <code>content</code> 的生命周期参数与返回值的要求进行比较，判断是否符合要求。即：<strong>实际返回数据的生命周期，大于或等于返回参数要求的生命周期。</strong></p>
<p>前面说到，我们把返回参数中指定的生命周期参数 <code>'a</code> 看做调用者上下文中接收返回值的变量的生命周期，在这个例子中就是字符串引用 <code>sub</code>，<font color=#fa8919>那么输入参数中的 'a 代表什么意思 ？</font></p>
<p>这在 <code>Rust</code> 语法设计上是一个很让人困惑的地方，输入参数和输出参数的生命周期都标志为 <code>'a</code> ，似乎是要求两者的生命周期要求一致，但实际上并不是这样。</p>
<p>我们先看看如果输入参数的生命周期跟输出参数期待的不一样是什么情况，例如下面两个例子：</p>
<pre><code class="language-Rust">fn echo&lt;'a, 'b&gt;(content: &amp;'b str) -&gt; &amp;'a str {
    content //编译错误：引用变量本身的生命周期超过了它的借用目标
}
fn longer&lt;'a, 'b&gt;(s1: &amp;'a str, s2: &amp;'b str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len()
        { s1 }
    else
        { s2 }//编译错误：生命周期不匹配
}
</code></pre>
<p><code>echo</code> 函数输入参数生命周期标注为 <code>'b</code> , 返回值期待的是 <code>'a</code> .编译器报错信息是典型的“悬垂指针”错误。不过内容似乎并不明确。编译器指出查阅详细信息 <a href="https://doc.rust-lang.org/error-index.html#E0312">--explain E0312</a> ，这里的解释是&quot;借用内容的生命周期与期待的不一致&quot;。这个错误描述就与实际的错误情况是相符合的了。</p>
<p><code>longer</code> 函数两个参数分别具有生命周期 <code>'a</code> 和 <code>'b</code> , 返回值期待 <code>'a</code> ,当返回 <code>s2</code> 时，编译器报告生命周期不匹配。把 <code>longer</code> 函数中的生命周期 <code>'b</code> 标识为比 <code>'a</code> 长，就可以正确编译了。</p>
<pre><code class="language-Rust">fn longer&lt;'a, 'b: 'a&gt;(s1: &amp;'a str, s2: &amp;'b str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len()
        { s1 }
    else
        { s2 }//编译通过
}
</code></pre>
<p>回到我们前面的问题，<font color=#fa8919>那么输入参数中的 'a 代表什么意思 ？</font></p>
<p>我们知道编译器在函数定义上下文中所做的生命周期检查就是要确保”<strong>实际返回数据的生命周期，大于或等于返参数要求的生命周期</strong>“。当输入参数给出与返回值一样的生命周期参数 <code>'a</code> 时，实际上是人为地向编译器保证：<strong>在调用者上下文中，实际给出的函数输入参数的生命周期，不小于将来用于接收返回值的变量的生命周期。</strong></p>
<p>当有两个生命周期参数 <code>'a</code> <code>'b</code> , 而 <code>'b</code> 大于 <code>'a</code>，当然 也保证了在调用者上下文 <code>'b</code> 代表的输入参数生命周期也足够长。</p>
<p>在函数定义中，编译器并不知道将来实际调用这个函数的上下文是怎么样的。生命周期参数相当是函数上下文与调用者上下文之间关于参数生命周期的协议。</p>
<p>就像函数签名中的类型声明一样，类型声明约定了与调用者之间输入输出参数的类型，编译器编译函数时，会检查函数体返回的数据类型与声明的返回值是否一致。同样对与参数与返回值的生命周期，函数也会检查函数体中返回的变量生命周期与声明的是否一致。</p>
<p>前面说的是编译器在“<strong>函数定义上下文的生命周期检查</strong>”机制，这只是生命周期检查的一部分，还有另一部分就是“<strong>调用者上下文对生命周期的检查</strong>”机制。两者检查的规则如下：</p>
<p><strong>函数定义上下文的生命周期检查：</strong></p>
<p>函数签名中返回值的生命周期标注可以是输入标注的任何一个，只要保证由输入参数推导出来的返回的临时变量的生命周期，比函数签名中返回值标注的生命周期相等或更长。这样保证了调用者上下文中，接收返回值的变量，不会因为输入参数失效而成为悬垂指针。</p>
<p><strong>调用者上下文对生命周期的检查：</strong></p>
<p>调用者上下文中，接收函数返回借用的变量 <code>res</code> ，其生命周期不能长于返回的借用的生命周期(实际是根据输入借用参数推导出来的)。否则 <code>res</code> 会在输入参数失效后成为悬垂指针。</p>
<p>前面 <code>remove_prefix</code> 函数编译器已经校验合格，那么我们在调用者上下文中构建如下例子</p>
<pre><code class="language-Rust">let res: &amp;str;
{
    let s = String::from(&quot;reload&quot;);
    res = remove_prefix(&amp;s, &quot;re&quot;) //编译错误：s 的生命周期不够长
}
println!(&quot;{}&quot;, res);
</code></pre>
<p>这个例子中 <code>remove_prefix</code> 被调用这一行，编译器会报错 “s 的生命周期不够长”。代码中的 大括号创建了一个新的词法作用域，导致 <code>res</code> 的生命周期比大括号内部的 <code>s</code> 更长。这不符合函数签名中对生命周期的要求。函数签名要求输入参数的生命周期不短于返回值要求的生命周期。</p>
<p><strong>结构体定义中的生命周期</strong></p>
<p>结构体中有引用成员时，就会有潜在的悬垂指针问题，需要标识生命周期参数来让编译器帮助检查。</p>
<pre><code class="language-Rust">struct G&lt;'a&gt;{ m:&amp;'a str}
 
fn get_g() -&gt; () {
    let g: G;
    {
        let  s0 = &quot;Hi&quot;.to_string();
        let  s1 = s0.as_str();              //编译错误：借用值存活时间不够长
        g = G{ m: s1 };
    }
    println!(&quot;{}&quot;, g.m);
}
</code></pre>
<p>上面的例子中，结构体 <code>G</code> 包含了引用成员，不指定生命周期参数是无法编译的。函数 <code>get_g</code> 演示了在使用者上下文中如何出现生命周期不匹配的情况。</p>
<p>结构体的生命周期定义就是要保证在一个结构体实例中，其引用成员的生命周期不短于结构体实例自身的生命周期。否则如果结构体实例存活期间，其引用成员的数据先被销毁，那么访问这个引用成员时就构成了对悬垂指针的访问。</p>
<p>实际上结构体的生命周期参数可以和函数生命周期参数做类比，成员的生命周期相当函数的输入参数的生命周期，结构体整体的生命周期相当函数返回值的生命周期。这样所有之前对函数生命周期参数的分析一样可以适用。</p>
<p>如果结构体有方法成员会返回引用参数，方法同样需要填写生命周期参数。返回的引用来源可以是方法的输入引用参数，也可以是结构体的引用成员。在做生命周期分析的时候，可以把“方法的输入引用参数”和“结构体的引用成员”都看做普通函数的输入参数，这样前面对普通函数参数和返回值的生命周期分析方法可以继续套用。</p>
<p><strong>泛型的生命周期限定</strong></p>
<p>前文说过生命周期参数跟类型限定很像，比如在代码</p>
<pre><code class="language-Rust">fn longer&lt;'a&gt;(s1:&amp;'a str, s2:&amp;'a str) -&gt; &amp;'a str
 
struct G&lt;'a&gt;{ m:&amp;'a str }
</code></pre>
<p>中，<code>'a</code> 出现的位置参数类型旁边，一个对参数的静态类型做限定，一个对参数的动态时间做限定。<code>'a</code> 使用前需要先声明，声明的位置与模板参数的位置一样，在 <code>&lt;&gt;</code> 括号内，也是用来放泛型的类型参数的地方。</p>
<p>那么，<font color=#fa8919>把类型换成泛型可以吗，语义是什么？使用场景是什么？</font></p>
<p>我们看看代码例子：</p>
<pre><code class="language-Rust">use std::cmp::Ordering;

#[derive(Eq, PartialEq, PartialOrd, Ord)]
struct G&lt;'a, T:Ord&gt;{ m: &amp;'a T }
 
#[derive(Eq, PartialEq, PartialOrd, Ord)]
struct Value{ v: i32 }
 
fn longer&lt;'a, T:Ord&gt;(s1: &amp;'a T, s2: &amp;'a T) -&gt; &amp;'a T {
    if s1 &gt; s2 { s1 } else { s2 }
}
 
fn main(){
    let v0 = Value{ v:12 };
    let v1 = Value{ v:15 };
    let res_v = longer(&amp;v0, &amp;v1);
    println!(&quot;{}&quot;, res_v.v);//15
     
    let g0 = G{ m: &amp;v0 };
    let g1 = G{ m: &amp;v1 };
    let res_g = longer(&amp;g0, &amp;g1);//15
    println!(&quot;{}&quot;, res_g.m.v);
}
</code></pre>
<p>这个例子扩展了 <code>longer</code> 函数，可以对任何实现了 <code>Ord trait</code> 的类型进行操作。 <code>Ord</code> 是核心包中的一个用于实现比较操作的内置 <code>trait</code>. 这里不细说明。<code>longer</code> 函数跟前一个版本比较，只是把 <code>str</code> 类型换成了泛型参数 <code>T</code>, 并给 <code>T</code> 增加了类型限定 <code>T:Ord</code>.</p>
<p>结构体 <code>G</code> 也扩展成可以容纳泛型 <code>T</code>,但要求 <code>T</code> 实现了 <code>Ord trait</code>.</p>
<p>从代码及执行结果看，跟 把 <code>T</code> 当成普通类型一样，没有什么特别，生命周期参数依然是他原来的语义。</p>
<p>但实际上 &quot;<code>&amp;'a T</code>&quot; 还隐含另一层语义：<strong>如果 <code>T</code> 内部含有引用成员，那么其中的引用成员的生命周期要求不短于 <code>T</code> 实例的生命周期。</strong></p>
<p>老规矩，我们来构造一个反例。结构体 <code>G</code> 内部包含一个泛型的引用成员，我们将 <code>G</code> 用于 <code>longer</code> 函数，但是让 <code>G</code> 内部的引用成员生命周期短于 <code>G</code>。代码如下：</p>
<pre><code class="language-Rust">fn  main(){
    let v0 = Value{ v:12 };
    let v1_ref: &amp;Value;      // 将 v1 的引用定义在下面大括号之外，有意延长变量的生命周期范围
    let res_g: &amp;G&lt;Value&gt;;

    {
        let v1 = Value{ v:15 };
        v1_ref = &amp;v1;      //编译错误：v1的生命周期不够长。
        let res_v = longer(&amp;v0,v1_ref);
        println!(&quot;{}&quot;,res_v.v);
    }

    let g0 = G{ m:&amp;v0 };
    let g1 = G{ m:v1_ref };   // 这时候 v1_ref 已经是悬垂指针
    res_g = longer(&amp;g0, &amp;g1);
    println!(&quot;{}&quot;, res_g.m.v);
}
</code></pre>
<p>变量 <code>g1</code> 自身的生命周期是满足 <code>longer</code> 函数要求的，但是其内部的引用成员，生命周期过短。</p>
<p>这个范例是在“调用者上下文”检查时触发的，对泛型参数的生命周期限定比较难设计出在“函数定义或结构体定义上下文”触发的范例。毕竟 <code>T</code> 只是类型指代，定义时还没有具体类型。</p>
<p>实际上要把在 “<code>struct G&lt;'a,T&gt;{m:&amp;'a T}</code>中，<code>T</code> 的所有引用成员的生命周期不短于<code>'a</code> ”这个语义准确表达，应该写成：</p>
<pre><code class="language-Rust">struct G&lt;'a,T:'a&gt;{m:&amp;'a T}
</code></pre>
<p>因为 <code>T:'a</code> 才是这个语义的明确表述。但是第一种表达方式也是足够的(我用反证法证明了这一点)。所以编译器也接受第一种比较简化的表达形式。</p>
<p>总而言之，泛型参数的生命周期限定是两层含义，一层是泛型类型当做一个普通类型时一样的含义，一层是对泛型内部引用成员的生命周期约束。</p>
<p><strong>Trait 对象的生命周期</strong></p>
<p>看如下代码</p>
<pre><code class="language-Rust">trait Foo{}
struct Bar{v:i32}
struct Qux&lt;'a&gt;{m:&amp;'a  i32}
struct Baz&lt;'a,T&gt;{v:&amp;'a T}
 
impl Foo for Bar{}
impl&lt;'a&gt; Foo for Qux&lt;'a&gt;{}
impl&lt;'a,T&gt; Foo for Baz&lt;'a,T&gt;{}
</code></pre>
<p>结构体 <code>Bar</code>,<code>Qux</code>,<code>Baz</code> 都实现了 <code>trait Foo</code>, 那么 <code>&amp;Foo</code> 类型可以接受这三个结构体的任何一个的引用类型。</p>
<p>我们把 <code>&amp;Foo</code> 称为 <code>Trait</code> 对象。</p>
<p><code>Trait</code> 对象可以理解为类似其它面向对象语言中，指向接口或基类的指针或引用。其它<code>OO</code>语言指向基类的指针在运行时确定其实际类型。<code>Rust</code> 没有类继承，指向 <code>trait</code> 的指针或引用起到类似的效果，运行时被确定具体类型。所以编译期间不知道大小。</p>
<p><code>Rust</code> 的 <code>Trait</code> 不能有非静态数据成员，所以 <code>Trait</code> 本身就不会出现引用成员的生命周期小于对象自身，所以 <code>Trait</code> 对象默认的生命周期是静态生命周期。我们看下面三个函数：</p>
<pre><code class="language-Rust">fn check0() -&gt; &amp;'static Foo { // 如果不指定 'static , 编译器会报错，要求指定生命周期命参数, 并建议 'static
    const b:Bar = Bar{v:0};
    &amp;b
}
fn check1&lt;'a&gt;() -&gt; &amp;'a Foo { //如果不指定 'a , 编译器会报错
    const b:Bar = Bar{v:0};
    &amp;b
}
fn check2(foo:&amp;Foo) -&gt; &amp;Foo {//生命周期参数被省略，不要求静态生命周期
    foo
}
fn check3(foo:&amp;'static Foo) -&gt; &amp;'static Foo {
    foo
}
fn main(){
    let bar= Bar{v:0};
    check2(&amp;bar);                               //能编译通过，说明 chenk2 的输入输出参数都不是静态生命周期
    //check3(&amp;bar);                          //编译错误：bar的生命周期不够长
    const bar_c:Bar =Bar{v:0};
    check3(&amp;bar_c);                         // check3 只能接收静态参数
}
</code></pre>
<p><code>check0</code> 和 <code>check1</code> 说明将 <code>Trait</code> 对象的引用作为 函数参数返回时，跟返回其他引用类型一样，都需要指定生命周期参数。函数 <code>check2</code> 的生命周期参数只是被省略了(编译器可以推断)，但这个函数里的 <code>Trait</code> 对象并不是静态生命周期，这可以从 <code>main</code> 函数内能成功执行 <code>check2(bar)</code> 分析出来，因为 <code>bar</code> 不是静态生命周期.</p>
<p>实际上在运行时，<code>Trait</code> 对象总会动态绑定到一个实现了该 <code>Trait</code> 的具体结构体类型(如 <code>Bar</code>,<code>Qux</code>,<code>Baz</code> 等)，这个具体类型的在其上下文中有它的生命周期，可以是静态的，更多情况下是非静态生命周期 <code>'a</code> ，那么 <code>Trait</code> 对象的生命周期也是 <code>'a</code>.</p>
<table><thead><tr><th></th><th>结构体或成员生命周期</th><th>Trait 对象生命周期</th></tr></thead><tbody>
<tr><td>Foo</td><td>无</td><td>'static</td></tr>
<tr><td>Bar</td><td>'a</td><td>'a</td></tr>
<tr><td>Qux&lt;'a&gt;{m:&amp;'a str}</td><td>'a</td><td>'a</td></tr>
<tr><td>Baz&lt;'a,T&gt;{v:&amp;'a T}</td><td>'a</td><td>'a</td></tr>
</tbody></table>
<pre><code class="language-Rust">fn qux_update&lt;'a&gt;(qux: &amp;'a mut Qux&lt;'a&gt;, new_value: &amp;'a i32)-&gt;&amp;'a Foo {
    qux.v = new_value;
    qux
}

let value = 100;
let mut qux = Qux{v: &amp;value};
let new_value = 101;
let muted: &amp;dyn Foo = qux_update(&amp; mut qux, &amp;new_value);
qux_update 函数的智能指针版本如下：
 
fn qux_box&lt;'a&gt;(new_value: &amp;'a  i32) -&gt; Box&lt;Foo +'a&gt; {
    Box::new(Qux{v:new_value})
}
 
let new_value = 101;
let boxed_qux:Box&lt;dyn Foo&gt; = qux_box(&amp;new_value);
</code></pre>
<p>返回的智能指针中，<code>Box</code> 装箱的类型包含了引用成员，也需要给被装箱的数据指定生命周期，语法形式是在被装箱的类型位置增加生命周期参数，用 &quot;+&quot; 号连接。</p>
<p>这两个版本的代码其实都说明一个问题，就是 <code>Trait</code> 虽然默认是静态生命周期，但实际上，其生命周期是由具体实现这个 <code>Trait</code> 的结构体的生命周期决定，推断方式跟之前叙述的函数参数生命周期并无太大区别。</p>
<h2><a class="header" href="#7智能指针的所有权与生命周期" id="7智能指针的所有权与生命周期">7.智能指针的所有权与生命周期</a></h2>
<p>如图 6，在 <code>Rust</code> 中引用和智能指针都算是“指针”的一种形态，所以他们都可以实现 <a href="https://doc.rust-lang.org/beta/core/borrow/trait.Borrow.html">std::borrow::Borrow</a> <code>Trait</code>。一般情况下，我们对栈中的变量获取引用，栈中的变量存续时间一般比较短，当前的作用域退出时，作用域范围内的栈变量就会被回收。如果我们希望变量的生命周期能跨越当前的作用域，甚至在线程之间传递，最好是把变量绑定的数据区域创建在堆上。</p>
<p>栈上的变量其作用域在编译期间就是明确的，所以编译器能够确定栈上的变量何时会被释放，结合生命周期参数生命，编译器能找到绝大部分对栈上变量的错误引用。</p>
<p>堆上变量其的内存管理比栈变量要复杂很多。在堆上分配一块内存之后，编译器无法根据作用域来判断这块内存的存活时间，必须由使用者显式指定。<code>C</code> 语言中就是对于每一块通过 <code>malloc</code> 分配到的内存，需要显式的使用 <code>free</code> 进行释放。<code>C++</code>中是 <code>new / delete</code>。但是什么时候调用 <code>free</code> 或 <code>delete</code> 就是一个难题。尤其当代码复杂，分配内存的代码和释放内存的代码不在同一个代码文件，甚至不在同一个线程的时候，仅仅靠人工跟踪代码的逻辑关系来维护分配与释放就难免出错。</p>
<p>智能指针的核心思想是让系统自动帮我们决定回收内存的时机。其主要手段就是“<strong>将内存分配在堆上，但指向该内存的指针变量本身是在栈上，这样编译器就可以捕捉指针变量离开作用域的时机。在这时决定内存回收动作，如果该指针变量拥有内存区的所有权就释放内存，如果是一个引用计数指针就减少计数值，计数为 0 就回收内存</strong>”。</p>
<p><code>Rust</code> 的 <code>Box&lt;T&gt;</code> 为独占所有权指针，<code>Rc&lt;T&gt;</code>为引用计数指针，但其计数过程不是线程安全的，<code>Arc&lt;T&gt;</code>提供了线程安全的引用计数动作,可以跨线程使用。</p>
<p>我们看 <code>Box&lt;T&gt;</code> 的定义</p>
<pre><code class="language-Rust">pub struct Box&lt;T: ?Sized&gt;(Unique&lt;T&gt;);
pub struct Unique&lt;T: ?Sized&gt;{
    pointer: *const T,
    _marker: PhantomData&lt;T&gt;,
} 
</code></pre>
<p><code>Box</code> 本身是一个元组结构体，包装了一个 <code>Unique&lt;T&gt;</code>， <code>Unique&lt;T&gt;</code>内部有一个原生指针。</p>
<p><em>(注：Rust 最新版本的 Box<T> 实现还可以通过泛型参数指定内存分配器，让用户可以自己控制实际内存的分配。还有为什么通过 Unique<T>多层封装，这涉及智能指针实现的具体问题，这里不详述。）</em></p>
<p><code>Box</code> 没有实现 <code>Copy Trait</code>,它在所有权转移时会执行移动语意。</p>
<p>示例代码：</p>
<pre><code class="language-Rust">Struct Foo {v:i32}
fn inc(v:&amp; mut Foo) -&gt; &amp;Foo {//省略了生命周期参数
    v.v = v.v + 1;
    v
}
//返回Box指针不需要生命周期参数，因为Box指针拥有了所有权，不会成为悬垂指针
fn inc_ptr(mut foo_ptr:Box&lt;Foo&gt;) -&gt; Box&lt;Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    foo_ptr.v = foo_ptr.v + 1;
    println!(&quot;ininc_ptr：{:p}-{:p}&quot;, &amp;foo_ptr, &amp;*foo_ptr);
    foo_ptr
}
fn main() {
    let foo_ptr1 = Box::new(Foo{v:10});
    println!(&quot;foo_ptr1：{:p}-{:p}&quot;, &amp;foo_ptr1, &amp;*foo_ptr1);
    let mut foo_ptr2 = inc_ptr(foo_ptr1);
    //println!(&quot;{}&quot;,foo_ptr1.v);//编译错误，f0_ptr所有权已经丢失
    println!(&quot;foo_ptr2：{:p}-{:p}&quot;, &amp;foo_ptr2, &amp;*foo_ptr2);
     
    inc(foo_ptr2.borrow_mut());//获得指针内数据的引用，调用引用版本的inc函数
    println!(&quot;{}&quot;,foo_ptr2.v);
}
</code></pre>
<p><code>inc</code> 为引用版本，<code>inc_ptr</code> 是指针版本。改代码的输出为：</p>
<pre><code>foo_ptr1：0x8dfad0-0x93a5e0
in inc_ptr：0x8df960-0x93a5e0
foo_ptr2：0x8dfb60-0x93a5e0
12
</code></pre>
<p>可以看到 <code>foo_ptr1</code> 进入函数 <code>inc_ptr</code> 时,执行了一次所有权转移，函数返回时又执行了一次。所以三个 <code>Box&lt;Foo&gt;</code> 的变量地址都不一样，但是它们内部的数据地址都是一样的，指向同一个内存区。</p>
<p><code>Box</code> 类型自身是没有引用成员的，但是如果 <code>T</code> 包含引用成员，那么其相关的生命周期问题会是怎样的？</p>
<p>我们把 <code>Foo</code> 的成员改成引用成员试试，代码如下：</p>
<pre><code class="language-Rust">use std::borrow::BorrowMut;
struct Foo&lt;'a&gt;{v:&amp;'a mut i32}
    fn inc&lt;'a&gt;(foo:&amp;'a mut Foo&lt;'a&gt;) -&gt;&amp;'a Foo&lt;'a&gt; {//生命周期不能省略
    *foo.v=*foo.v + 1; // 解引用后执行加法操作
    foo
}
fn inc_ptr(mut foo_ptr:Box&lt;Foo&gt;) -&gt; Box&lt;Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    *foo_ptr.v = *foo_ptr.v + 1; / 解引用后执行加法操作
    println!(&quot;ininc_ptr：{:p}-{:p}&quot;, &amp;foo_ptr, &amp;*foo_ptr);
    foo_ptr
}
fn main(){
    let mut value = 10;
    let foo_ptr1 = Box::new(Foo{v:&amp; mut value});
    println!(&quot;foo_ptr1：{:p}-{:p}&quot;, &amp;foo_ptr1, &amp;*foo_ptr1);
    let mut foo_ptr2 = inc_ptr(foo_ptr1);
    //println!(&quot;{}&quot;,foo_ptr1.v);//编译错误，f0_ptr所有权已经丢失
    println!(&quot;foo_ptr2：{:p}-{:p}&quot;, &amp;foo_ptr2, &amp;*foo_ptr2);
     
    let foo_ref = inc(foo_ptr2.borrow_mut());//获得指针内数据的引用，调用引用版本的inc函数
    //println!(&quot;{}&quot;,foo_ptr2.v);//编译错误，无法获取foo_ptr2.v的不可变借用，因为已经存在可变借用
    println!(&quot;{}&quot;, foo_ref.v);
}
</code></pre>
<p>引用版本的 <code>inc</code> 函数生命周期不能再省略了。因为返回 <code>Foo</code> 的引用时，有两个生命周期值，一个是<code>Foo</code> 实例的生命周期，一个是 <code>Foo</code> 中引用成员的生命周期，编译器无法做推断，需要指定。但是智能指针版本 <code>inc_ptr</code> 函数的生命周期依然不用指定。<code>Foo</code> 的实例被智能指针包装，生命周期由 <code>Box</code> 负责管理。</p>
<p>如果 <code>Foo</code> 是一个 <code>Trait</code> ，而实现它的结构体有引用成员，那么 <code>Box&lt;Foo&gt;</code> 的生命周期会有什么情况。示例代码如下：</p>
<pre><code class="language-Rust">trait Foo{
    fn inc(&amp;mut self);
    fn value(&amp;self)-&gt;i32;
}

struct Bar&lt;'a&gt;{v:&amp;'amuti32}

impl&lt;'a&gt; Foo for Bar&lt;'a&gt; {
    fn inc(&amp;mutself){
        *(self.v)=*(self.v)+1
    }
    fn value(&amp;self)-&gt;i32{
        *self.v
    }
}

fn inc(foo:&amp; mut dyn Foo)-&gt;&amp; dyn Foo {//生命周期参数被省略
    foo.inc();
    foo
}

fn inc_ptr(mut foo_ptr:Box&lt;dyn Foo&gt;) -&gt; Box&lt; dyn Foo&gt; {//输入参数和返回参数各经历一次所有权转移
    foo_ptr.inc();
    foo_ptr
}

fn main() {
}
</code></pre>
<p>引用版本和智能指针版本都没生命周期参数，可以编译通过。不过 <code>main</code> 函数里是空的，也就是没有使用这些函数，只是定义编译通过了。我先试试使用引用版本：</p>
<pre><code class="language-Rust">fn main(){
    let mut value = 10;
    let mut foo1= Bar{v:&amp; mut value};
    let foo2 =inc(&amp;mut foo1);
    println!(&quot;{}&quot;, foo2.value());  // 输出 11
}
</code></pre>
<p>可以编译通过并正常输出。再试智能指针版本：</p>
<pre><code class="language-Rust">fn main(){
    let mut value = 10;
    let foo_ptr1 = Box::new(Bar{v:&amp;mut value});   //编译错误：value生命周期太短
    let mut foo_ptr2 = inc_ptr(foo_ptr1); //编译器提示：类型转换需要value为静态生命周期
}
</code></pre>
<p>编译失败。提示的错误信息是 <code>value</code> 的生命周期太短，需要为 <code>'static</code> 。因为 <code>Trait</code> 对象（ <code>Box&lt; dyn Foo&gt;</code>）默认是静态生命周期，编译器推断出返回数据的生命周期太短。去掉最后一行 <code>inc_ptr</code> 是可以正常编译的。</p>
<p>如果将 <code>inc_ptr</code> 的定义加上生命周期参数上述代码就可以编译通过。修改后的 <code>inc_ptr</code> 如下：</p>
<pre><code class="language-Rust">fn inc_ptr&lt;'a&gt;(mut foo_ptr:Box&lt;dyn Foo+'a&gt;) -&gt; Box&lt;dyn Foo+'a&gt; {
    foo_ptr.inc();
    foo_ptr
}
</code></pre>
<p>为什么指针版本不加生命周期参数会出错，而引用版没有生命周期参数却没有问题？</p>
<p>因为引用版是省略了生命周期参数，完整写法是：</p>
<pre><code class="language-Rust">fn inc&lt;'a&gt;(foo:&amp;'a mut dyn Foo)-&gt;&amp;'a dyn Foo {
    foo.inc();
    foo
}
</code></pre>
<h2><a class="header" href="#8-闭包与所有权" id="8-闭包与所有权">8. 闭包与所有权</a></h2>
<p>这里不介绍闭包的使用，只说与所有权相关的内容。闭包与普通函数相比，除了输入参数，还可以捕获上线文中的变量。闭包还支持一个 <code>move</code> 关键字，来强制转移捕获变量的所有权。</p>
<p>我们先来看 <code>move</code> 对输入参数有没有影响：</p>
<pre><code class="language-Rust">//结构 Value 没有实现Copy Trait
struct Value{x:i32}
 
//没有作为引用传递参数，所有权被转移
let mut v = Value{x:0};
let fun = |p:Value| println!(&quot;in closure:{}&quot;, p.x);
fun(v);
//println!(&quot;callafterclosure:{}&quot;,point.x);//编译错误：所有权已经丢失
 
//作为闭包的可变借用入参，闭包定义没有move,所有权没有转移
let mut v = Value{x:0};
let fun = |p:&amp;mut Value| println!(&quot;in closure:{}&quot;, p.x);
fun(&amp; mut v);
println!(&quot;call after closure:{}&quot;, v.x);
 
//可变借用作为闭包的输入参数，闭包定义增加move,所有权没有转移
let mut v = Value{x:0};
let fun = move |p:&amp; mut Value| println!(&quot;in closure:{}&quot;, p.x);
fun(&amp; mut v);
println!(&quot;call after closure:{}&quot;, v.x);
</code></pre>
<p>可以看出，变量作为输入参数传递给闭包时，所有权转移规则跟普通函数是一样的，<strong>move 关键字对闭包输入参数的引用形式不起作用，输入参数的所有权没有转移。</strong></p>
<p>对于闭包捕获的上下文变量，所有权是否转移就稍微复杂一些。</p>
<p>下表列出了 10 多个例子，每个例子跟它前后的例子都略有不同，分析这些差别，我们能得到更清晰的结论。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_9.jpg">
<p>首先要明确被捕获的变量是哪个，这很重要。比如例 8 中，<code>ref_v</code> 是 <code>v</code> 的不可变借用，闭包捕获的是 <code>ref_v</code> ，那么所有权转移的事情跟 <code>v</code> 没有关系，<code>v</code> 不会发生与闭包相关的所有权转移事件。</p>
<p>明确了被捕获的变量后，是否转移所有权受三个因素联合影响：</p>
<ol>
<li>变量被捕获的方式（值，不可变借用，可变借用）</li>
<li>闭包是否有 move 限定</li>
<li>被捕获变量的类型是否实现了 &quot;Copy&quot; Trait</li>
</ol>
<p>是用伪代码描述是否转移所有权的规则如下：</p>
<pre><code>if 捕获方式 == 值传递 {
    if 被捕获变量的类型实现了 &quot;Copy&quot;
        不转移所有权 // 例 ：9
    else
        转移所有权 // 例 ：1
    }
}
else { // 捕获方式是借用
    if 闭包没有 move 限定
        不转移所有权 // 例：2,3,6,10,12
    else { // 有 move
        if 被捕获变量的类型实现了 &quot;Copy&quot;
            不转移所有权 // 例: 8
        else
            转移所有权 // 例: 4,5,7,11,13,14
    }
}
</code></pre>
<p>先判断捕获方式，如果是值传递，相当于变量跨域了作用域，触发转移所有权的时机。<code>move</code> 是对借用捕获起作用，要求对借用捕获也触发所有权转移。是否实现 &quot;Copy&quot; 是最后一步判断。 前文提到，我们可以把 <code>Copy Trait</code> 限定的位拷贝语义当成一种转移执行的方式。<code>Copy Trait</code> 不参与转移时机的判定，只在最后转移执行的时候起作用。</p>
<ul>
<li>例 1 和(例 2、例 3) 的区别在于捕获方式不同。</li>
<li>(例 2、例 3) 和例 4 的区别在于 move 关键字。</li>
<li>例 6 和例 7 的区别 演示了 move 关键字对借用方式捕获的影响。</li>
<li>例 8 说明了捕获不可变借用变量，无论如何都不会转移，因为不可变借用实现了 Copy.</li>
<li>例 8 和例 11 的区别就在于例 11 捕获的 &quot;不可变借用&quot;没有实现 &quot;Copy&quot; Trait 。</li>
<li>例 10 和例 11 是以“不可变借用的方式”捕获了一个“可变借用变量”</li>
<li>例 12，13，14 演示了对智能指针的效果，判断逻辑也是一致的。</li>
</ul>
<p><code>C++11</code> 的闭包需要在闭包声明中显式指定是按值还是按引用捕获，<code>Rust</code> 不一样。<code>Rust</code> 闭包如何捕获上下文变量，不取决与闭包的声明，取决于闭包内部如何使用被捕获的变量。实际上编译器会尽可能以借用的方式去捕获变量（例，除非实在不行，如例 1.)</p>
<p>这里刻意没有提及闭包背后的实现机制，即 <code>Fn</code>,<code>FnMut</code>,<code>FnOnce</code> 三个 <code>Trait</code>。因为我们只用闭包语法时是看不到编译器对闭包的具体实现的。所以我们仅从闭包语法本身去判断所有权转移的规则。</p>
<h2><a class="header" href="#9多线程环境下的所有权问题" id="9多线程环境下的所有权问题">9.多线程环境下的所有权问题</a></h2>
<p>我们把前面的例 1 再改一下，上下文与闭包的实现都没有变化，但是闭包在另一个线程中执行。</p>
<pre><code class="language-Rust">let v = Value{x:1};
let child = thread::spawn(||{  // 编译器报错，要求添加 move 关键字
    let p = v;
    println!(&quot;inclosure:{}&quot;,p.x)
});
child.join();
</code></pre>
<p>这时，编译器报错，要求给闭包增加 <code>move</code> 关键字。也就是说，闭包作为线程的入口函数时，强制要求对被捕获的上下文变量执行移动语义。下面我们看看多线程环境下的所有权系统。</p>
<p>前面的讨论都不涉及变量在跨线程间的共享，一旦多个线程可以访问同一个变量时，情况又复杂了一些。这里有两个问题，一个仍然是内存安全问题，即“悬垂指针”等 5 个典型的内存安全问题，另一个是线程的执行顺序导致执行结果不可预测的问题。这里我们只关注内存安全问题。</p>
<p>首先，多个线程如何共享变量？前面的例子演示了启动新线程时，通过闭包捕获上下文中的变量来实现多个线程共享变量。这是一个典型的形式，我们以这个形式为基础来阐述多线程环境下的所有权问题。</p>
<p>我们来看例子代码：</p>
<pre><code class="language-Rust">//结构 Value 没有实现Copy Trait
struct Value{x:i32}
 
let v = Value{x:1};
let child = thread::spawn(move||{
    let p = v;
    println!(&quot;in closure:{}&quot;,p.x)
});
child.join();
//println!(&quot;{}&quot;,v.x);//编译错误：所有权已经丢失
</code></pre>
<p>这是前面例子的正确实现，变量 <code>v</code> 被传递到另一个线程(闭包内)，执行了所有权转移</p>
<pre><code class="language-Rust">//闭包捕获的是一个引用变量，无论如何也拿不到所有权。那么多线程环境下所有引用都可以这么传递吗？
let v = Value{x:0};
let ref_v = &amp;v;
let fun = move ||{
    let p = ref_v;
    println!(&quot;inclosure:{}&quot;,p.x)
};
fun();
println!(&quot;callafterclosure:{}&quot;,v.x);//编译执行成功
</code></pre>
<p>这个例子中，闭包捕获的是一个变量的引用，<code>Rust</code> 的引用都是实现了 <code>Copy Trait</code>，会被按位拷贝到闭包内的变量 <code>p.p</code> 只是不可变借用，没有获得所有权，但是变量 <code>v</code> 的不可变借用在闭包内外进行了传递。那么把它改成多线程方式会如何呢？这是多线程下的实现和编译器给出的错误提示：</p>
<pre><code class="language-Rust">let  v:Value = Value{x:1};
let ref_v = &amp;v;           // 编译错误：被借用的值 v0 生命周期不够长
let child = thread::spawn(move||{
    let p = ref_v;
    println!(&quot;in closure:{}&quot;,p.x)
});                                // 编译器提示：参数要求 v0 被借用时为 'static 生命周期
child.join();
</code></pre>
<p>编译器的核心意思就是 <code>v</code> 的生命周期不够长。当 <code>v</code> 的不可变借用被传递到闭包中，并在另一个线程中使用时，主线程继续执行， <code>v</code> 随时可能超出作用域范围被回收，那么子线程中的引用变量就变成了悬垂指针。 如果 <code>v</code> 为静态生命周期，这段代码就可以正常编译执行。即把第一行改为：</p>
<pre><code class="language-Rust">const  v:Value = Value{x:1};
</code></pre>
<p>当然只能传递静态生命周期的引用实际用途有限，多数情况下我们还是希望能把非静态的数据传递给另一个线程。可以采用 <code>Arc&lt;T&gt;</code>来包装数据。 <code>Arc&lt;T&gt;</code> 是引用计数的智能指针，指针计数的增减操作是线程安全的原子操作，保证计数的变化是线程安全的。</p>
<pre><code class="language-Rust">//线程安全的引用计数智能指针Arc可以在线程间传递
let v1 = Arc::new(Value{x:1});
let arc_v = v1.clone();
let child = thread::spawn(move||{
    let p = arc_v;
    println!(&quot;Arc&lt;Value&gt;in closure:{}&quot;,p.x)
});
child.join();
//println!(&quot;Arc&lt;Value&gt;inclosure:{}&quot;,arc_v.x);//编译错误，指针变量的所有权丢失
</code></pre>
<p>如果把上面的 <code>Arc&lt;T&gt;</code> 换成 <code>Rc&lt;T&gt;</code> ,编译器会报告错误，说&quot;<code>Rc&lt;T&gt;</code> 不能在线程间安全的传递&quot;。</p>
<p>通过上面的例子我们可以总结出来一点，因为闭包定义中的 <code>move</code> 关键字，以闭包启动新线程时，被闭包捕获的变量本身的所有权必然会发生转移。无论捕获的变量是 &quot;值变量&quot;还是引用变量或智能指针（上述例子中 <code>v</code>,<code>ref_v</code>,<code>arc_v</code> 本身的所有权被转移）。但是对于引用或指针，它们所指代的数据的所有权并不一定被转移。</p>
<p>那么对于上面的类型 <code>struct Value{x:i32}</code>, <strong>它的值可以在多个线程间传递</strong>(转移所有权)，它的<strong>多个不可变借用可以在多个线程间同时存在</strong>。同时 <code>&amp;Value</code> 和 <code>Arc&lt;Value&gt;</code> 可以在多个线程间传递（转移引用变量或指针变量自身的所有权），但是 <code>Rc&lt;T&gt;</code> 不行。</p>
<p>要知道，<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 只是 <code>Rust</code> 标准库(<code>std</code>)实现的，甚至不在核心库(<code>core</code>)里。也就是说，它们并不是 <code>Rust</code> 语言机制的一部分。那么，<font color=#fa8919>编译器是如何来判断 Arc<T> 可以安全的跨线程传递，而 Rc<T> 不行呢？</font></p>
<p><code>Rust</code> 核心库 的 <code>marker.rs</code> 文件中定义了两个标签 <code>Trait</code>:</p>
<pre><code class="language-Rust">pub unsafe auto trait Sync{}
pub unsafe auto trait Send{}
</code></pre>
<p>标签 <code>Trait</code> 的实现是空的，但编译器会分析某个类型是否实现了这个标签 <code>Trait</code>.</p>
<ul>
<li>如果一个类型 <code>T</code>实现了“<strong>Sync</strong>”，其含义是 <code>T</code> 可以安全的通过引用可以在多个线程间被共享。</li>
<li>如果一个类型 <code>T</code>实现了“<strong>Send</strong>”，其含义是 <code>T</code> 可以安全的跨线程边界被传递。</li>
</ul>
<p>那么上面的例子中的类型，<code>Value</code> ，<code>&amp;Value</code>，<code>Arc&lt;Value&gt;</code> 类型一定都实现了“<code>Send</code>”<code>Trait</code>. 我们看看如何实现的。</p>
<p><code>marker.rs</code> 文件还定义了两条规则：</p>
<pre><code class="language-Rust">unsafe impl&lt;T:Sync + ?Sized&gt; Send for &amp;T{}
unsafe impl&lt;T:Send + ?Sized&gt; Send for &amp; mut T{}
</code></pre>
<p>其含义分别是：</p>
<ul>
<li>如果类型 T 实现了“<strong>Sync</strong>”，则自动为类型 <code>&amp;T</code> 实现“<strong>Send</strong>”.</li>
<li>如果类型 T 实现了“<strong>Send</strong>”，则自动为类型 <code>&amp;mut T</code> 实现“<strong>Send</strong>”.</li>
</ul>
<p>这两条规则都可以直观的理解。比如：对第一条规则 <code>T</code> 实现了 “<strong>Sync</strong>”, 意味则可以在很多个线程中出现同一个 <code>T</code> 实例的 <code>&amp;T</code> 类型实例。如果线程 <code>A</code> 中先有有 <code>&amp;T</code> 实例，线程 <code>B</code> 中怎么得到 <code>&amp;T</code> 的实例呢？必须要有在线程 <code>A</code> 中通过某种方式 <code>send</code> 过来，比如闭包的捕获上下文变量。而且 <code>&amp;T</code> 实现了 &quot;<code>Copy</code>&quot; <code>Trait</code>, 不会有所有权风险，数据是只读的不会有数据竞争风险，非常安全。逻辑上也是正确的。<font color=#fa8919>那为什么还会别标记为 unsafe ?</font> 我们先把这个问题暂时搁置，来看看为智能指针设计的另外几条规则。</p>
<pre><code class="language-Rust">impl &lt;T:?Sized&gt;!marker::Send for Rc&lt;T&gt;{}
impl &lt;T:?Sized&gt;!marker::Sync for Rc&lt;T&gt;{}
impl&lt;T:?Sized&gt;!marker::Send for Weak&lt;T&gt;{}
impl&lt;T:?Sized&gt;!marker::Sync for Weak&lt;T&gt;{}
unsafe impl&lt;T:?Sized+Sync+Send&gt;Send  for Arc&lt;T&gt;{}
unsafe impl&lt;T:?Sized+Sync+Send&gt;Sync for Arc&lt;T&gt;{}
</code></pre>
<p>这几条规则明确指定 <code>Rc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code> 不能实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”。</p>
<p>同时规定如果类型 <code>T</code> 实现了 “<strong>Sync</strong>”和 “<strong>Send</strong>”，则自动为 <code>Arc&lt;T&gt;</code> 实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”。<code>Arc&lt;T&gt;</code> 对引用计数增减是原子操作，所以它的克隆体可以在多个线程中使用(即可以为 <code>Arc&lt;T&gt;</code> 实现”<strong>Sync</strong>”和“<strong>Send</strong>”)，但为什么其前提条件是要求 <code>T</code> 也要实现&quot;<strong>Sync</strong>”和 “<strong>Send</strong>”呢。</p>
<p>我们知道，<code>Arc&lt;T&gt;</code>实现了 <code>std::borrow</code>，可以通过 <code>Arc&lt;T&gt;</code>获取 <code>&amp;T</code> 的实例，多个线程中的 <code>Arc&lt;T&gt;</code> 实例当然也可以获取到多个线程中的 <code>&amp;T</code> 实例，这就要求 <code>T</code> 必须实现“<strong>Sync</strong>”。<code>Arc&lt;T&gt;</code> 是引用计数的智能指针，任何一个线程中的 <code>Arc&lt;T&gt;</code>的克隆体都有可能成为最后一个克隆体，要负责内存的释放，必须获得被 <code>Arc&lt;T&gt;</code>指针包装的 <code>T</code> 实例的所有权，这就要求 <code>T</code> 必须能跨线程传递，必须实现 “<strong>Send</strong>”。</p>
<p><code>Rust</code> 编译器并没有为 <code>Rc&lt;T&gt;</code>或 <code>Arc&lt;T&gt;</code> 做特殊处理，甚至在语言级并不知道它们的存在，编译器本身只是根据类型是否实现了 “<strong>Sync</strong>”和 “<strong>Send</strong>”标签来进行推理。实际上可以认为编译器实现了一个检查变量跨线程传递安全性的规则引擎，编译器为基本类型直接实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”，这作为“公理”存在，然后在标准库代码中增加一些“定理”，也就是上面列举的那些规则。用户自己实现的类型可以自己指定是否实现 “<strong>Sync</strong>”和 “<strong>Send</strong>”，多数情况下编译器会根据情况默认选择是否实现。代码编译时编译器就可以根据这些公理和规则进行推理。这就是 <code>Rust</code> 编译器支持跨线程所有权安全的秘密。</p>
<p>对于规则引擎而言，&quot;公理&quot;和&quot;定理&quot;是不言而喻无需证明的，由设计者自己声明，设计者自己保证其安全性，编译器只保证只要定理和公理没错误，它的推理也没错误。所以的&quot;公理&quot;和&quot;定理&quot;都标注为 <code>unsafe</code>,提醒声明着检查其安全性，用户也可以定义自己的&quot;定理&quot;，有自己保证安全。反而否定类规则 （实现 <code>!Send</code> 或 <code>!Sync</code>）不用标注为 <code>unsafe</code> , 因为它们直接拒绝了变量跨线程传递，没有安全问题。</p>
<p>当编译器确定 “<strong>Sync</strong>”和 “<strong>Send</strong>”适合某个类型时，会自动为其实现此。</p>
<p>比如编译器默认为以下类型实现了 <code>Sync</code> ：</p>
<ul>
<li>[u8] 和 [f64] 这样的基本类型都是 [Sync]，</li>
<li>包含它们的简单聚合类型（如元组、结构和名号）也是[Sync] 。</li>
<li>&quot;不可变&quot; 类型（如 &amp;T）</li>
<li>具有简单继承可变性的类型，如 Box <T>、Vec<T></li>
<li>大多数其他集合类型（如果泛型参数是 [Sync]，其容器就是 [Sync]。</li>
</ul>
<p>用户也可以手动使用 <code>unsafe</code> 的方式直接指定。</p>
<p>下图是与跨线程所有权相关的概念和类型的 <code>UML</code> 图。</p>
<img src="chapter_1/./rust_ownership/rust_ownership_8.jpg">
<center>图 8与多线程相关的所有权转移</center>
<hr />
<p>编辑简介：</p>
<p>高宪凤(.nil?)，软件开发工程师，Rust 语言爱好者，喜欢有计划、有条理、有效率的工作，热爱开源文化，愿意为 Rust 中文社区的发展尽绵薄之力。</p>
<h1><a class="header" href="#嵌入式领域的rust语言" id="嵌入式领域的rust语言">嵌入式领域的Rust语言</a></h1>
<p>作者：洛佳</p>
<hr />
<p>Rust语言是二十一世纪的语言新星。Rust被人广泛承认的一点，就是因为它能运行在多样的目标上，
从桌面和服务器设备，到资源有限的嵌入式设备。</p>
<p>我们可以用适合来评价一门语言和技术。Rust非常适合开发嵌入式应用，它是一种和C相仿的、
能应用于嵌入式设备开发的编程语言。</p>
<p>操作系统都是从裸机设备开始运行的，Rust语言的这一点也意味着，它能很好地用于编写操作系统。
无论是应用层还是内核本身，Rust都是极富竞争力、值得投入时间的技术选项。</p>
<h2><a class="header" href="#裸机上的rust语言" id="裸机上的rust语言">裸机上的Rust语言</a></h2>
<p>开发裸机应用时，通常希望使用的语言速度快、可靠性强。此外们还希望语言的生态较好，
有利于提高生产效率，而且适用范围较广。Rust语言能满足以上的要求，适合裸机应用的开发。</p>
<p>运用在裸机场合时，Rust语言拥有许多优点。除了效率和安全，Rust还将传统上不用于裸机开发的编程技术引入到裸机，
让开发者有更多的选择，更灵活、高效地编写裸机应用代码。</p>
<h3><a class="header" href="#二十一世纪的裸机编程语言" id="二十一世纪的裸机编程语言">二十一世纪的裸机编程语言</a></h3>
<p>在这个互联网全面普及、性价比设备应用更广的时代，安全和可靠性成为一门语言必须考虑的因素。
Rust语言采用移动语义，拥有严格的代数类型系统以及生命周期、所有权模型；
相比传统的编程语言，这些模型能在合适的时候释放所用资源，减少漏洞的出现。
此外，通过语义检查，Rust能在编译期有效寻找内存和线程安全问题，降低开发和测试的负担。</p>
<p>Rust语言是的运行效率高、开发效率好、适用范围广。作为一门编译型语言，它直接编译输出到汇编代码，
通常公认裸机的Rust语言性能在C语言级别，拥有较高的运行效率。
Rust语言的开发效率很高，文档完善、编译器提示有帮助，能节省软件开发所需的时间。
它能应用在多个平台和指令集中，这包括裸机平台；处理核、操作系统厂家还可以提供自己的编译目标，
无需厂家自己重新开发、提供工具链。</p>
<p>Rust语言出彩的地方在于，它向嵌入式平台引入了大量新的编程技术。
这包括了闭包、过程宏等传统上用于函数式编程的技术，和多态、虚函数表等面向对象语言的技术。
新编程技术的引入，扩充了开发者的选择。即使彻底理解Rust的编程概念有一定难度，但这些易用的新技术，
让开发者只需阅读实例代码，便可快速进入开发状态。这些新技术的引入，是嵌入式平台从未有过的，
Rust能提高开发者的工作效率，降低平台间迁移的学习时间和成本。</p>
<h3><a class="header" href="#裸机上的过程宏" id="裸机上的过程宏">裸机上的过程宏</a></h3>
<p>传统用于嵌入式平台的编程，我们加快开发速度使用的宏，常常基于语法字符串的替换和修改。
Rust语言扩充了宏的概念，提出了基于语法树的“过程宏”编程方法，让宏语法更容易使用、编写更方便。</p>
<p>“过程宏”是接收Rust代码作为输入，操作这些代码，然后产生另一些代码的过程。
它和字符串的替换不同，是从语法树到语法树的替换。开发一个过程宏，可以使用简单的定义过程，
或者有工作量的属性宏定义过程。简单的定义中，我们编写代码，给出宏的输入有哪些，要翻译到哪些输出代码，
这样就完成了一个宏的定义。属性宏定义则允许完成语法树分析、代码生成甚至代码优化的过程，
就需要编写专门的“属性宏库”，借用Rust编译器的一部分，完成宏代码的转化和输出。</p>
<p>过程宏是基于语法树的分析过程，借助“树”的结构我们能理解它的一些特点。因为Rust语法树的子树也是Rust代码，
所以宏的定义内也可以完成语法分析，这就为代码编辑器的提示和补全提供了便利。
一个语法项目不可能同时属于两颗不是亲子关系的子树，因为如果属于两颗子树，将和语法树的树根产生环，
就和语法树的定义相违背，所以语法项目都是独立的，宏内代码的解析不会影响外界代码的解析。</p>
<p>这样的独立性也就是“卫生宏”思想的提出，Rust的过程宏可以理解为代码的“内部展开”，不影响代码的上下文。
正因为Rust过程宏产生完整的语法子树，它的定义不需要额外的界符，因此只需要满足Rust语法就可以了。</p>
<p>在过程宏的定义之外，Rust语言提供了大量便于嵌入式开发的标签。“align”标签定义内存对齐的方式，
“link_section”标签给定代码要链接到的段或区。这样，过程宏可以包装各种各样的标签，
Rust语言的用户可以方便地使用，而不需要深入宏了解代码的具体要求。
Rust语言定义的过程宏可以导出到包外，给其它的库使用，这有利于嵌入式Rust生态的搭建和共享。
Rust语言宏灵活的特性，让宏在更多的领域有可用之处，更好地服务嵌入式平台的开发工作。</p>
<h3><a class="header" href="#嵌入式中的模块化编程" id="嵌入式中的模块化编程">嵌入式中的模块化编程</a></h3>
<p>Rust语言拥有很好的模块化编程概念。传统平台的Rust语言中，社区总结出了“模块-包-项目”的模型。
这个模型也适用于嵌入式平台，增加协作开发的效率，更好地共享生态。</p>
<p>Rust的模块化编程分为模块、包、项目三级。模块是Rust语言可见性分划的最小单位，
语言中提供了专门的关键字，来区分不同模块的代码和可见性，是由Rust语言本身确定的。
在Rust语法中，“mod”是定义模块的关键字，“pub”是定义可见性的关键字。</p>
<p>包是Rust项目的二进制目标，这个等级是由Rust工具链给定的。每个包有版本号、作者和许可协议等元数据，
要依赖和使用的库也要登记到包中，以便共同编译。库的特性有点像传统语言的条件编译，
也是以包为单位规定的，每个包使用的库可以开启不同的特性，但库在同一个包中开启的特性是相同的。</p>
<p>“项目”这一层并非由Rust语言给定；人们开发软件时，发现一个解决方案中包含多个二进制目标是非常好的，
总结之后就出现了项目的抽象模型。项目由核心和外围包组成，或者是功能相近的一组包，
它通常由同一个团队组织和维护，可以在项目上添加扩展。项目在习惯上由核心包到功能包，以依赖的形式构成。
实践中，“项目”可以放在同一个工作空间里，以统一管理和发布编译版本。</p>
<p>Rust将模块化编程引入到嵌入式开发中，也可以方便地编写测试和性能检测代码。
模块化编程能提高Rust嵌入式开发者的工作效率，适应现代化嵌入式软件的需求。</p>
<h2><a class="header" href="#搭建rust嵌入式生态" id="搭建rust嵌入式生态">搭建Rust嵌入式生态</a></h2>
<p>生态是软件不可或缺的一部分。从编译器到软件支持，嵌入式Rust目前已经拥有良好的基础生态。
此外，操作系统内核也是嵌入式编程的重要部分，嵌入式Rust和内核开发也有较好的相容度。</p>
<p><img src="chapter_1/embedded_rust/ecosystem.png" alt="截至2020年12月的嵌入式生态架构图" /></p>
<h3><a class="header" href="#你的架构和指令集" id="你的架构和指令集">你的架构和指令集</a></h3>
<p>嵌入式Rust的应用支持分为两个部分：一个是目标处理核的支持，一个是芯片外设的支持。</p>
<p>针对目标处理核，首先我们要编译Rust到这个指令集架构。Rust语言提供丰富的编译目标，
主流的编译目标都有很好的支持；此外，如果有自主研发的指令集架构，可以为Rust添加自己的编译目标。
编译完成后，还需要编写微架构支持库和微架构运行时。微架构运行时提供最小的启动代码实现，
能搭建一个适合Rust代码运行的环境。微架构支持库简单包装汇编代码，允许应用代码操作寄存器、运行特殊的指令，
作为编译器系统的补充。这之后，Rust对这个指令集架构的代码运行支持就完成了。</p>
<p>嵌入式应用定义了各有特点的中断控制器，有些是指令集架构定义的，有些是芯片设计厂家自己定义的。
嵌入式Rust要支持这些中断控制器，需要在微架构运行时中添加处理和封装部分，或者作为通用架构的补充，
在专用架构的支持库中添加专有架构的中断运行时。架构虽然定义了标准，但基地址、中断数量等配置可能相互不同。
这些元数据配置可以放在外设访问库的中断部分，和架构支持库共同构成中断控制器的支持。</p>
<p>目标的处理核定义了调试接口和闪存烧写算法，我们需要在调试器软件中编写这些算法。
社区通用的软件“probe-rs”是很好的调试器实现，可以替代OpenOCD，作为非常好的Rust语言调试软件。
如果自己的操作系统有软件调试接口，可以添加操作系统调试器的载荷，共同完成调试软件的部分。
只要处理器厂商实现了调试接口，提供相关的文档，配套的Rust软件可以尽快完成，方便各种技术的开发者调试和使用。</p>
<h3><a class="header" href="#嵌入式生态的标准" id="嵌入式生态的标准">嵌入式生态的标准</a></h3>
<p>起初嵌入式开发者会为每个芯片都编写一次代码。随着生态的发展，大家认识到，需要提供一个基本的抽象，
大家都围绕着抽象去编写，就能剩下大量外设反复操作的时间。embedded-hal就是这样的标准，
它是Rust语言的嵌入式外设抽象，支持大量的片内和片外外设，包括传感器等，很好地扩充了嵌入式的生态。</p>
<p>embedded-hal是统一的Rust语言标准，它是针对外设功能本身的抽象，是抽象的集合，具体实现由实现库去完成。
它的扩展性很好，比如“SPI-GPIO扩展器”外设输入SPI接口抽象，输出GPIO的抽象，很多模块都是抽象到抽象的过程，
就可以方便的极联、衔接和嵌套，整合更多的项目；这就非常容易为新的芯片编写支持库。</p>
<p>市场上海量的芯片都支持embedded-hal标准。K210、GD32V和BL602系列的芯片都提供很好的embedded-hal实现库。
要编写embedded-hal标准的支持库，只需要机器生成外设库，然后编写中间层库，就能完成对此标准的原厂支持。</p>
<h3><a class="header" href="#rust与操作系统内核" id="rust与操作系统内核">Rust与操作系统内核</a></h3>
<p>操作系统也是嵌入式应用。常见的操作系统如按是否包含虚拟内存区分，有不含虚拟内存的实时系统，
和包含虚拟内存传统操作系统。基于微架构的支持库和运行时库，操作系统内核可以很方便地编写。</p>
<p>社区中提供了大量成熟的操作系统运行时。
如rCore系列操作系统是第一个基于RISC-V架构的完整Rust操作系统，尤其适合教学使用。
RTIC框架是中断驱动的异步实时系统，完全针对应用使用Rust的宏语法生成，拥有极高的效率。
Tock系统是针对微处理器的安全实时系统，已经用于手表、智能路标和加密狗等产品。</p>
<p>针对操作系统和应用程序开发，Rust是适合编写硬件驱动的语言。
如果使用有产权的代码，可以以混合链接的形式，与Rust代码联合编译为二进制使用。
系统模块、插件和动态链接库等等都能受益于Rust语言内存安全的特性，适合现在对安全敏感的开发需求。</p>
<p>物联网系统要求嵌入式的操作系统能够连上网络。Rust嵌入式社区也在探索射频连接的技术标准，
包括蓝牙、WiFi等硬件标准。smoltcp是社区提供的非常好的TCP协议栈实现，它可以代替lwip，
在嵌入式系统领域高效、安全地完成网络传输。搭配缓冲区和协议库，物联网操作系统就可以连上网了。</p>
<h2><a class="header" href="#rustsbi新型操作系统引导软件" id="rustsbi新型操作系统引导软件">RustSBI：新型操作系统引导软件</a></h2>
<p>我们在开发操作系统内核时，有的内核直接运行在裸机上，有的还依托于一个运行环境。
在RISC-V上，“SBI”就是这样的运行环境。它除了引导启动内核，还将常驻后台，提供操作系统需要的实用功能。</p>
<p>RISC-V标准中，“SBI”意味着“操作系统二进制接口”，运行在其上的操作系统会通过环境调用“ecall”指令，
陷入到二进制接口的实现中，由其调用具体硬件的实现功能。这种实现被称作“SBI实现”，社区常用的实现有开源的OpenSBI。
RustSBI是鹏城实验室“rCore代码之夏-2020”活动提出的SBI实现，它是全新的操作系统引导软件。</p>
<h3><a class="header" href="#实现与模块组成" id="实现与模块组成">实现与模块组成</a></h3>
<p>RustSBI由几个功能模块组成。硬件环境接口实现了RISC-V SBI v0.2版本的接口，能运行支持此版本的操作系统。
硬件运行时则是SBI实现运行在裸机环境的必要模块，它将由硬件启动，开始运行所有的RustSBI模块。
SBI的初始化完成后，将进入引导启动模块，这里将发挥SBI标准“引导启动”的功能，最终启动操作系统内核。
另外，兼容性模块能完成硬件到硬件间的支持，能模拟旧版硬件不存在的指令、寄存器，进一步延长操作系统的生命周期。</p>
<p>去年12月，RustSBI的0.1版本在深圳的Rust中国社区2020年年会上发布。使用目前最新的0.1.1版本，
RustSBI已经支持大量SBI标准提出的功能，支持大量自定义的扩展功能；完全使用安全的Rust语言编写，提高开发效率。
开发Rust语言的操作系统内核，可以统一编译工具链。另外，RustSBI已经被RISC-V组织收录入RISC-V SBI标准，
它的实现编号为4。</p>
<p>RustSBI是一个库，它以库的形式设计的初衷是，便于平台开发者“积木”式地引入库的模块，为自己的硬件目标开发SBI支持。
虽然RustSBI提供了QEMU、K210平台的参考实现，但应用开发者不应当将自己的目标也加入参考实现中，
而是在自己的仓库里引用RustSBI的模块，可以选择参考这些实现的内容，最终完成完全可控的开发过程。
这两个平台的使用范围较广，参考实现也会长期维护，以发现RustSBI本身可能的少量问题，并及时修补完善。</p>
<p>为什么用Rust开发RustSBI呢？我们认为，相比使用C语言，嵌入式Rust的生态圈在协调发展阶段，它容易支持新硬件，
Rust语言较强的编译约束也提高了硬件代码的安全性。</p>
<h3><a class="header" href="#硬件到硬件的兼容性" id="硬件到硬件的兼容性">硬件到硬件的兼容性</a></h3>
<p>RISC-V是快速更迭的指令集规范。我们为新版RISC-V硬件编写软件，会遇到与旧版硬件不兼容的情况。
硬件和硬件之间的兼容性，也能通过软件完成——这是RustSBI提供的功能与亮点之一。</p>
<p>RustSBI实现的硬件兼容性，是靠捕获指令异常完成的。例如，K210平台实现的是1.9.1版本的RISC-V特权级标准，
它规定了旧版的页表刷新指令；而目前最新的1.11版标准，规定的是新版的刷新指令。为新标准编写的操作系统内核，
使用新版刷新指令，会因为K210硬件无法找到新版指令，抛出非法指令异常。这个非法指令异常被RustSBI捕获，
它解析后，发现是新版的页表刷新指令，便直接在硬件上运行旧版的指令，完成指令的页表刷新功能。</p>
<p>这种硬件兼容性，目前能支持新增的指令和寄存器。一切情况下，指令、寄存器在仍然存在，但新版中修改了它们的功能和意义。
只靠RustSBI软件本身，就不足以提供兼容性支持了。如果RISC-V芯片实现提供特定的兼容性外设，
比如这个外设能拦截特定CSR寄存器的访问指令，就可以在功能修改的寄存器访问时，产生一个可供软件捕获的中断。
这样的外设设计之后，使用RustSBI软件，将能支持功能修改的指令和寄存器，将进一步提升操作系统内核的硬件兼容性。</p>
<p>兼容旧硬件，也是兼容未来新硬件的过程。未来的RISC-V标准快速发展，将与目前的硬件标准产生一定的差异；
在硬件不变的前提下，未来软件能对当前的硬件兼容，就能延长软件的生命周期。
或许，我们未来升级RISC-V上的操作系统，只需要更换硬件中的RustSBI固件，就能完美兼容最新标准的操作系统了。
升级原有系统的硬件也非常容易，替换RustSBI固件就能达到升级效果。</p>
<p>另外，硬件兼容性也意味着实现硬件上缺少的指令集。当这些指令集运行时，就会陷入到软件中，由RustSBI软件模拟这些指令，
最终返回，这个过程应用软件不会有感知。当然，这种软件模拟过程可以满足正确性，效率不如新版的硬件，
但临时运行一个新版的软件、体验新版的指令集还是足够的。当模拟指令的过程多到影响性能时，也就是硬件该升级的时候了。</p>
<h3><a class="header" href="#rustsbi与嵌入式rust生态" id="rustsbi与嵌入式rust生态">RustSBI与嵌入式Rust生态</a></h3>
<p>在RustSBI的实现中，多次使用“embedded-hal”的实现完成编写过程。“embedded-hal”是Rust嵌入式的外设规范，
它对大量厂家的外设提供了软件支持。只要厂家的硬件支持“embedded-hal”，只需要编写部分抽象接口代码，
RustSBI支持就可以快速地开发完成。</p>
<p>硬件处理核和SoC系统的开发也受益于设计好的RustSBI软件架构。“RustSBI很快速地实现了仿真环境的双核测试，”
华中科技大学的社区贡献者车春池说，“这能为处理核提供丰富的测试环境，在开发高性能RISC-V处理核中非常重要。”</p>
<p>无论硬件和软件，我们都乐于看到各个应用领域积极互动，嵌入式Rust生态的发展过程得到加快。
“embedded-hal”本是裸机外设的标准，RustSBI将这个标准运用在引导软件上，能加速裸机外设的开发和建设，
也能更快适配SBI标准到平台上。</p>
<p>借这个项目，我们很高兴能参与嵌入式领域Rust语言的建设，希望这些微小的技术更新和迭代，最终能回馈到我们美好的生活中去。</p>
<hr />
<p>作者简介：</p>
<p><strong>洛佳</strong></p>
<p>华中科技大学网络空间安全学院本科生，热爱操作系统、嵌入式开发。RustSBI项目作者，3年Rust语言开发经验，社区活跃贡献者。目前致力于向产业、教学等更多的领域推广Rust语言。</p>
<h1><a class="header" href="#用rust写操作系统--清华-rcore-os-教程介绍" id="用rust写操作系统--清华-rcore-os-教程介绍">用<code>Rust</code>写操作系统 | 清华 rCore OS 教程介绍</a></h1>
<p>编辑：张汉东</p>
<h2><a class="header" href="#rcore-os-教程简介" id="rcore-os-教程简介">rCore OS 教程简介</a></h2>
<p>众所周知，清华大学的操作系统课程是国家级精品课程。清华大学也是是国内首个使用 Rust 进行操作系统教学的高校。目前，陈渝教授和他的学生吴一凡正在编写新的操作系统教材。该教材相关的文档都是网络公开的，教程地址：<a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">https://rcore-os.github.io/rCore-Tutorial-Book-v3/</a>。</p>
<p>这本教程旨在一步一步展示如何 <strong>从零开始</strong> <strong>用 Rust 语言写一个基于 RISC-V 架构的类 Unix 内核</strong>。值得注意的是， 本项目不仅支持模拟器环境（如 Qemu/terminus 等），还支持在真实硬件平台 Kendryte K210 上运行。</p>
<p>该教程目前已经发布了近 20 万字，每一章都是一个能完整运行的内核。目前已经完成了前四章分别可以让内核能在裸机打印字符、支持系统调用和特权级切换、任务切换和虚拟存储。后面还会依次支持进程、进程间通信和数据持久化，代码已经写完，有待更新教程文档。陈渝教授和吴一凡也希望能够通过该教程吸引更多对 Rust 和 OS 感兴趣的读者，可以在教程的基础上自己从头实现一遍或者能做一些拓展，也能提供一些反馈，让教程的质量越来越高。</p>
<p>以教程目前的内容进度，正是大家从零开始学习编写操作系统的最佳时期。</p>
<h2><a class="header" href="#为什么要学习操作系统" id="为什么要学习操作系统">为什么要学习操作系统？</a></h2>
<p>一名程序员的绝大部分工作都是在操作系统上面进行的。学习操作系统，深入了解操作系统原理，是每个合格的程序员必须要经历的。</p>
<p>很多人学习 Rust 语言感到很吃力，基本上就是因为操作系统基础知识薄弱造成的。</p>
<p>通过自己实现一个操作系统，可以让你对操作系统的理解不仅仅是停留在概念上。而且用 Rust 实现操作系统，对于 Rust 爱好者来说，更有意思。</p>
<p>希望社区的朋友可以根据该教程实现自己的操作系统，如果需要交流，可以联系我（张汉东），我们可以一起建立学习小组，并且可以直接向陈渝教授和吴一凡反馈学习中的问题。</p>
<p><strong>以下内容节选自rCore OS 教程第零章</strong>。</p>
<h2><a class="header" href="#目前常见的操作系统内核都是基于c语言的为何要推荐rust语言" id="目前常见的操作系统内核都是基于c语言的为何要推荐rust语言">目前常见的操作系统内核都是基于C语言的，为何要推荐Rust语言？</a></h2>
<p>没错，C语言就是为写UNIX而诞生的。Dennis Ritchie和KenThompson没有期望设计一种新语言能帮助高效简洁地开发复杂的应用业务逻辑，只是希望用一种简洁的方式抽象出计算机的行为，便于编写控制计算机硬件的操作系统，最终的结果就是C语言。</p>
<p>C语言的指针的天使与魔鬼，且C语言缺少有效的并发支持，导致内存和并发漏洞成为当前操作系统的噩梦。</p>
<p>Rust语言具有与C一样的硬件控制能力，且大大强化了安全编程。从某种角度上看，新出现的Rust语言的核心目标是解决C的短板，取代C。所以用Rust写OS具有很好的开发和运行的体验。</p>
<p>用 Rust 写 OS 的代价仅仅是学会用 Rust 编程。</p>
<h2><a class="header" href="#目前常见的cpu是x86和arm为何要推荐risc-v" id="目前常见的cpu是x86和arm为何要推荐risc-v">目前常见的CPU是x86和ARM，为何要推荐RISC-V？</a></h2>
<p>没错，最常见的的CPU是x86和ARM，他们已广泛应用在服务器，台式机，移动终端和很多嵌入式系统中。它们需要支持非常多的软件系统和应用需求，导致它们越来越复杂。</p>
<p>x86的向过去兼容的策略确保了它的江湖地位，但导致其丢不掉很多已经比较过时的硬件设计，让操作系统疲于适配这些硬件特征。</p>
<p>x86和ARM都很成功，这主要是在商业上，其广泛使用是的其CPU硬件逻辑越来越复杂，且不够开放，不能改变，不是开源的，提高了操作系统开发者的学习难度。</p>
<p>从某种角度上看，新出现的RISC-V的核心目标是灵活适应未来的AIoT场景，保证基本功能，提供可配置的扩展功能。其开源特征使得学生都可以方便地设计一个RISC-V CPU。</p>
<p>写面向RISC-V的OS的代价仅仅是你了解RISC-V的Supevisor特权模式，知道OS在Supevisor特权模式下的控制能力。</p>
<h2><a class="header" href="#清华大学为何要写这本操作系统书" id="清华大学为何要写这本操作系统书">清华大学为何要写这本操作系统书?</a></h2>
<p>现在国内外已有一系列优秀的操作系统教材,例如 William Stallings 的《Operating Systems Internals and Design Principles》，Avi Silberschatz、Peter Baer Galvin 和 Greg Gagne 的《Operating System Concepts》，Remzi H. Arpaci-Dusseau 和 Andrea C. Arpaci-Dusseau 的《Operating Systems: Three Easy Pieces》等。然而,从我们从2000年以来的教学实践来看,某些经典教材对操作系统的概念和原理很重视，但还有如下一些问题有待改进：</p>
<p>原理与实践脱节：缺乏在操作系统的概念/原理与操作系统的设计/实现之间建立联系的桥梁，导致学生发现操作系统实现相关的实验与操作系统的概念相比，有较大的鸿沟。</p>
<p>缺少历史发展的脉络：操作系统的概念和原理是从实际操作系统设计与实现过程中，从无到有逐步演进而产生的，有其发展的历史渊源和规律。但目前的大部分教材只提及当前主流操作系统的概念和原理，有“凭空出现”的感觉，学生并不知道这些内容出现的前因后果。</p>
<p>忽视硬件细节或用复杂硬件：很多教材忽视或抽象硬件细节，是的操作系统概念难以落地。部分教材把 x86 作为的操作系统实验的硬件参考平台，缺乏对当前快速发展的RISC-V等体系结构的实验支持，使得学生在操作系统实验中可能需要花较大代价了解相对繁杂的x86硬件细节，影响操作系统实验的效果。</p>
<p>这些问题增加了学生学习和掌握操作系统的难度。我们想通过尝试解决上面三个问题，来缓解学生学习操作系统的压力，提升他们的兴趣，让他们能够在一个学期内比较好地掌握操作系统。为应对“原理与实践脱节”的问题，我们强调了实践先行，实践引领原理的理念。MIT教授 Frans Kaashoek等师生设计实现了基于UNIX v6的xv6教学操作系统用于每年的本科操作系统课的实验中，并在课程讲解中把原理和实验结合起来，在国际上得到了广泛的认可。这些都给了我们很好的启发，经过十多年的实践，对一个计算机专业的本科生而言，设计实现一个操作系统（包括CPU）有挑战但可行，前提是实际操作系统要小巧并能体现操作系统的核心思想。这样就能够让学生加深对操作系统原理和概念的理解，能让操作系统原理和概念落地。</p>
<p>为应对“缺少历史发展的脉络”的问题，我们重新设计操作系统实验和教学内容，按照操作系统的历史发展过程来建立多个相对独立的小实验，每个实验体现了操作系统的一个微缩的历史，并从中归纳总结出操作系统相关的概念与原理，并在教学中引导学生理解这些概念和原理是如何一步一步演进的。</p>
<p>为应对“忽视硬件细节或用复杂硬件”的问题，我们在硬件（x86, ARM, MIPS, RISC-V等）和编程语言（C, C++, Go, Rust等）选择方面进行了多年尝试。在2017年引入了RISC-V CPU作为操作系统实验的硬件环境，在2018年引入Rust编程语言作为开发操作系统的编程语言，使得学生以相对较小的开发和调试代价能够用Rust语言编写运行在RISC-V上的操作系统。而且方便和简化了让操作系统的概念和原理形象化，可视化的过程。学生可以吧操作系统的概念和原理直接对应到程序代码、硬件规范和操作系统的实际执行中，加强了学生对操作系统内涵的实际体验和感受。</p>
<p>所以本书的目标是以简洁的RISC-V CPU为底层硬件基础，根据上层应用从小到大的需求，按OS发展的历史脉络，逐步讲解如何设计并实现满足这些需求的“从小到大”的多个“小”操作系统。并在设计实现操作系统的过程中，逐步解析操作系统各种概念与原理的知识点，对应的做到有“理”可循和有“码”可查，最终让读者通过主动的操作系统设计与实现来深入地掌握操作系统的概念与原理。</p>
<p>在具体撰写过程中，第零章是对操作系统的一个概述，让读者对操作系统的历史、定义、特征等概念上有一个大致的了解。后面的每个章节体现了操作系统的一个微缩的历史发展过程，即从对应用由简到繁的支持的角度出发，每章会讲解如何设计一个可运行应用的操作系统，满足应用的阶段性需求。从而读者可以通过对应配套的操作系统设计实验，了解如何从一个微不足道的“小”操作系统，根据应用需求，添加或增强操作系统功能，逐步形成一个类似UNIX的相对完善的“小”操作系统。每一步都小到足以让人感觉到易于掌控，而在每一步结束时，你都有一个可以工作的“小”操作系统。另外，通过足够详尽的测试程序 ，可以随时验证读者实现的操作系统在每次更新后是否正常工作。由于实验的代码规模和实现复杂度在一个逐步递增的可控范围内，读者可以结合对应于操作系统设计实验的进一步的原理讲解，来建立操作系统概念原理和实际实现的对应关系，从而能够通过操作系统实验的实践过程来加强对理论概念的理解，通过理论概念来进一步指导操作系统实验的实现与改进。</p>
<p>在你开始阅读与实践本书讲解的内容之前，你需要决定用什么编程语言来完成操作系统实验。你可以用任何你喜欢的编程语言和你喜欢的CPU上来实现操作系统。我们推荐的编程语言是Rust，我们推荐的CPU是RISC-V。</p>
<h1><a class="header" href="#rust生态安全漏洞总结系列--part-1" id="rust生态安全漏洞总结系列--part-1"><code>Rust</code>生态安全漏洞总结系列 | Part 1</a></h1>
<p>作者：张汉东
后期编辑：张汉东</p>
<p>本系列主要是分析<a href="https://rustsec.org/advisories/"><code>RustSecurity</code> 安全数据库库</a>中记录的<code>Rust</code>生态社区中发现的安全问题，从中总结一些教训，学习<code>Rust</code>安全编程的经验。</p>
<hr />
<p>作为本系列文章的首篇文章，我节选了<a href="https://rustsec.org/advisories/"><code>RustSecurity</code> 安全数据库库</a>中 2021 年 1 月份记录的前五个安全漏洞来进行分析。</p>
<p><img src="chapter_1/./rust_security/0.png" alt="img" /></p>
<h2><a class="header" href="#01--mdbook-xss-漏洞-rustsec-2021-0001" id="01--mdbook-xss-漏洞-rustsec-2021-0001">01 | Mdbook XSS 漏洞 (RUSTSEC-2021-0001)</a></h2>
<p><img src="chapter_1/./rust_security/1.png" alt="img" /></p>
<p>正好《Rust 中文精选（RustMagazine）》也用了 mdbook，不过读者朋友不用害怕，本刊用的 mdbook 是修补了该漏洞的版本。</p>
<p>该漏洞并非 Rust 导致，而是生成的网页中 JS 函数使用错误的问题。</p>
<p>漏洞描述：</p>
<p>问题版本的 mdBook 中搜索功能（在版本<code>0.1.4</code>中引入）受到跨站点脚本漏洞的影响，该漏洞使攻击者可以通过诱使用户键入恶意搜索查询或诱使用户进入用户浏览器来执行任意<code>JavaScript</code>代码。</p>
<p>漏洞成因分析：</p>
<p>XSS的漏洞主要成因是后端接收参数时未经过滤，导致参数改变了HTML的结构。而<code>mdbook</code>中提供的<code>js</code>函数<code>encodeURIComponent</code>会转义除<code>'</code>之外的所有可能允许<code>XSS</code>的字符。 因此，还需要手动将<code>'</code>替换为其<code>url</code>编码表示形式（％27）才能解决该问题。</p>
<p><a href="https://github.com/rust-lang/mdBook/commit/648c9ae772bec83f0a5954d17b4287d5bb1d6606">修复 PR</a> 也很简单。</p>
<h2><a class="header" href="#02--暴露裸指针导致段错误-rustsec-2021-0006" id="02--暴露裸指针导致段错误-rustsec-2021-0006">02 | 暴露裸指针导致段错误 (RUSTSEC-2021-0006)</a></h2>
<p><img src="chapter_1/./rust_security/2.png" alt="img" /></p>
<p>该漏洞诞生于第三方库<a href="https://crates.io/crates/cache">cache</a>，该库虽然已经两年没有更新了，但是它里面出现的安全漏洞的警示作用还是有的。该库<a href="https://github.com/krl/cache/issues/2">问题<code>issue</code></a>中说明了具体的安全漏洞。</p>
<p>该安全漏洞的特点是，因为库接口中将裸指针（raw pointer) 公开了出来，所以该裸指针可能被用户修改为空指针，从而有段错误风险。因为这个隐患是导致 Safe Rust 出现 UB，所以是不合理的。</p>
<p>以下代码的注释分析了漏洞的产生。</p>
<pre><pre class="playground"><code class="language-rust">use cache;


/**

    `cache crate` 内部代码：

    ```rust
    pub enum Cached&lt;'a, V: 'a&gt; {
        /// Value could not be put on the cache, and is returned in a box
        /// as to be able to implement `StableDeref`
        Spilled(Box&lt;V&gt;),
        /// Value resides in cache and is read-locked.
        Cached {
            /// The readguard from a lock on the heap
            guard: RwLockReadGuard&lt;'a, ()&gt;,
            /// A pointer to a value on the heap
            // 漏洞风险
            ptr: *const ManuallyDrop&lt;V&gt;,
        },
        /// A value that was borrowed from outside the cache.
        Borrowed(&amp;'a V),
    }

    ```
**/
fn main() {
    let c = cache::Cache::new(8, 4096);
    c.insert(1, String::from(&quot;test&quot;));
    let mut e = c.get::&lt;String&gt;(&amp;1).unwrap();

    match &amp;mut e {
        cache::Cached::Cached { ptr, .. } =&gt; {
            // 将 ptr 设置为 空指针，导致段错误
            *ptr = std::ptr::null();
        },
        _ =&gt; panic!(),
    }
    // 输出：3851，段错误
    println!(&quot;Entry: {}&quot;, *e);
}

</code></pre></pre>
<p>启示：</p>
<p>所以，这里我们得到一个教训，就是不能随便在公开的 API 中暴露裸指针。值得注意的是，该库处于失去维护状态，所以这个漏洞还没有被修正。</p>
<h2><a class="header" href="#03--读取未初始化内存导致ub-rustsec-2021-0008" id="03--读取未初始化内存导致ub-rustsec-2021-0008">03 | 读取未初始化内存导致<code>UB</code> (RUSTSEC-2021-0008)</a></h2>
<p><img src="chapter_1/./rust_security/3.png" alt="img" /></p>
<p>该漏洞诞生于 <a href="https://crates.io/crates/bra">bra</a> 库。该库这个安全漏洞属于逻辑 Bug 。因为错误使用 标准库 API，从而可能让用户读取未初始化内存导致 UB。</p>
<p>披露该漏洞的<a href="https://github.com/Enet4/bra-rs/issues/1">issue</a>。目前该漏洞已经被修复。</p>
<p>以下代码注释保护了对漏洞成因对分析：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下是有安全风险的代码示例：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        let buf = unsafe {
            // safe because it's within the buffer's limits
            // and we won't be reading uninitialized memory
            // 这里虽然没有读取未初始化内存，但是会导致用户读取
            std::slice::from_raw_parts_mut(
                self.buf.as_mut_ptr().offset(b as isize),
                self.buf.capacity() - b)
        };

        match self.inner.read(buf) {
            Ok(o) =&gt; {
                unsafe {
                    // reset the size to include the written portion,
                    // safe because the extra data is initialized
                    self.buf.set_len(b + o);
                }

                Ok(&amp;self.buf[self.consumed..])
            }
            Err(e) =&gt; Err(e),
        }
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>GreedyAccessReader::fill_buf</code>方法创建了一个未初始化的缓冲区,并将其传递给用户提供的Read实现（<code>self.inner.read（buf）</code>）。这是不合理的，因为它允许<code>Safe Rust</code>代码表现出未定义的行为（从未初始化的内存读取）。</p>
<p>在标准库<code>Read</code> trait 的 <code>read</code> 方法文档中所示：</p>
<blockquote>
<p>您有责任在调用<code>read</code>之前确保<code>buf</code>已初始化。
用未初始化的<code>buf</code>（通过<code>MaybeUninit &lt;T&gt;</code>获得的那种）调用<code>read</code>是不安全的，并且可能导致未定义的行为。
https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read</p>
</blockquote>
<p>解决方法：</p>
<p>在<code>read</code>之前将新分配的<code>u8</code>缓冲区初始化为零是安全的，以防止用户提供的<code>Read</code>读取新分配的堆内存的旧内容。</p>
<p>修正代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码示例，去掉了未初始化的buf：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        self.buf.resize(self.buf.capacity(), 0);
        let buf = &amp;mut self.buf[b..];
        let o = self.inner.read(buf)?;

        // truncate to exclude non-written portion
        self.buf.truncate(b + o);

        Ok(&amp;self.buf[self.consumed..])
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>启示：</p>
<p>该漏洞给我们对启示是，要写出安全的 Rust 代码，还必须掌握每一个标准库里 API 的细节。否则，逻辑上的错误使用也会造成<code>UB</code>。</p>
<h2><a class="header" href="#04--读取未初始化内存导致ub--rustsec-2021-0012" id="04--读取未初始化内存导致ub--rustsec-2021-0012">04 | 读取未初始化内存导致<code>UB</code>  (RUSTSEC-2021-0012)</a></h2>
<p><img src="chapter_1/./rust_security/4.png" alt="img" /></p>
<p>该漏洞诞生于第三方库[cdr-rs]中，漏洞相关<a href="https://github.com/hrektts/cdr-rs/issues/10">issue</a>中。</p>
<p>该漏洞和 RUSTSEC-2021-0008 所描述漏洞风险是相似的。</p>
<p><code>cdr-rs</code> 中的 <code>Deserializer::read_vec</code>方法创建一个未初始化的缓冲区，并将其传递给用户提供的<code>Read</code>实现（self.reader.read_exact）。</p>
<p>这是不合理的，因为它允许安全的<code>Rust</code>代码表现出未定义的行为（从未初始化的内存读取）。</p>
<p>漏洞代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    unsafe { buf.set_len(len as usize) }
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p>修正：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    // 初始化为 0；
    buf.resize(len as usize, 0);
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p>启示：同上。</p>
<h2><a class="header" href="#05--panic-safety--double-free-rustsec-2021-0011" id="05--panic-safety--double-free-rustsec-2021-0011">05 | Panic Safety &amp;&amp; Double free (RUSTSEC-2021-0011)</a></h2>
<p><img src="chapter_1/./rust_security/5.png" alt="img" /></p>
<p>该漏洞诞生于<a href="https://crates.io/crates/ocl">ocl</a>库，漏洞相关<a href="https://github.com/cogciprocate/ocl/issues/194">issue</a>。该库已经处于不再维护状态，但是这个漏洞背后的成因需要引起我们重视。</p>
<p>该库中使用了<code>ptr::read</code>，并且没有考虑好<code>Panic Safety</code>的情况，所以会导致双重释放（double free)。</p>
<p>以下两段代码是漏洞展示，注意注释部分都解释：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//case 1
macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
                fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                    let mut el = EventList::with_capacity(events.len());
                    for idx in 0..events.len() {
                    // 这个 unsafe 用法在 `event.into()`调用panic的时候会导致双重释放
                        let event_opt = unsafe { ptr::read(events.get_unchecked(idx)) };
                        if let Some(event) = event_opt { el.push::&lt;Event&gt;(event.into()); }
                    }
                    // 此处 mem::forget 就是为了防止 `dobule free`。
                    // 因为 `ptr::read` 也会制造一次 drop。
                    // 所以上面如果发生了panic，那就相当于注释了 `mem::forget`，导致`dobule free`
                    mem::forget(events);
                    el
                }
        }
    )
);

// case2

impl&lt;'e, E&gt; From&lt;[E; $len]&gt; for EventList where E: Into&lt;Event&gt; {
    fn from(events: [E; $len]) -&gt; EventList {
        let mut el = EventList::with_capacity(events.len());
        for idx in 0..events.len() {
        // 同上
            let event = unsafe { ptr::read(events.get_unchecked(idx)) };
            el.push(event.into());
        }
        // Ownership has been unsafely transfered to the new event
        // list without modifying the event reference count. Not
        // forgetting the source array would cause a double drop.
        mem::forget(events);
        el
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>以下是一段该漏洞都复现代码（我本人没有尝试过，但是提交issue都作者试过了），注意下面注释部分的说明：</p>
<pre><pre class="playground"><code class="language-rust">// POC:以下代码证明了上面两个case会发生dobule free 问题

use fil_ocl::{Event, EventList};
use std::convert::Into;

struct Foo(Option&lt;i32&gt;);

impl Into&lt;Event&gt; for Foo {
    fn into(self) -&gt; Event {
        /*
        根据文档，`Into &lt;T&gt;`实现不应出现 panic。但是rustc不会检查Into实现中是否会发生恐慌，
        因此用户提供的`into（）`可能会出现风险
        */
        println!(&quot;LOUSY PANIC : {}&quot;, self.0.unwrap()); // unwrap 是有 panic 风险

        Event::empty()
    }
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;I'm dropping&quot;);
    }
}

fn main() {
    let eventlist: EventList = [Foo(None)].into();
    dbg!(eventlist);
}

</code></pre></pre>
<p>以下是 Fix 漏洞的代码，使用了<code>ManuallyDrop</code>，注意注释说明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
            fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                let mut el = ManuallyDrop::new(
                    EventList::with_capacity(events.len())
                );

                for idx in 0..events.len() {
                    let event_opt = unsafe {
                        ptr::read(events.get_unchecked(idx))
                    };

                    if let Some(event) = event_opt {
                        // Use `ManuallyDrop` to guard against
                        // potential panic within `into()`.
                        // 当 into 方法发生 panic 当时候，这里 ManuallyDrop 可以保护其不会`double free`
                        let event = ManuallyDrop::into_inner(
                            ManuallyDrop::new(event)
                            .into()
                        );
                        el.push(event);
                    }
                }
                mem::forget(events);
                ManuallyDrop::into_inner(el)
            }
        }
    )
);

<span class="boring">}
</span></code></pre></pre>
<p>启示：</p>
<p>在使用 <code>std::ptr</code> 模块中接口需要注意，容易产生 UB 问题，要多多查看 API 文档。</p>
<h1><a class="header" href="#rustc-dev-guide-中文翻译启动" id="rustc-dev-guide-中文翻译启动">Rustc Dev Guide 中文翻译启动</a></h1>
<p>作者：张汉东</p>
<hr />
<p><a href="https://github.com/rust-lang/rustc-dev-guide">Rust编译器开发指南（Rustc Dev Guide）</a> 的中文翻译已经启动。因为原项目还在变动期，为了翻译方便，所以此翻译项目组织结构就不和原项目保持一致了。</p>
<ul>
<li><a href="https://rustc-dev-guide.rust-lang.org/">官方原文在线阅读</a></li>
<li><a href="https://rustcrustc.github.io/rustc-dev-guide-zh/">中文版在线阅读</a></li>
<li><a href="https://github.com/RustcRustc/rustc-dev-guide-zh">中文版翻译仓库地址</a></li>
</ul>
<h4><a class="header" href="#志愿者招募要求" id="志愿者招募要求">志愿者招募要求：</a></h4>
<ul>
<li>热爱 Rust，对 Rust 已经有一定了解</li>
<li>想深入了解 Rust 编译器</li>
<li>想为 Rust 编译器做贡献</li>
<li>业余时间充足</li>
</ul>
<h4><a class="header" href="#如何参与" id="如何参与">如何参与</a></h4>
<ol>
<li>认领感兴趣到章节</li>
<li>找到对应到 markdown 文件</li>
<li>直接发 PR</li>
<li>或者帮忙审校别人的 PR</li>
</ol>
<h3><a class="header" href="#q--a" id="q--a">Q &amp; A:</a></h3>
<ol>
<li>
<p>如何避免每个人翻译上的冲突呢，需要提前pr说翻译哪一章节吗？</p>
<p>其实没必要怕冲突，对于参与翻译的来说，翻译本身也是一次学习过程，是有收获的。了解编译器工作原理对理解 Rust 概念也有帮助的。如果同一篇有多个翻译，那我这边选翻译更好的就可以了。</p>
<p>这个项目倡导参与者自组织，但为了更加方便大家协作，还是来设置一个规则避免大家冲突。为了大家认领方便，特别创建了认领打卡的 issues，都去这里打一下卡：<a href="https://github.com/RustcRustc/rustc-dev-guide-zh/issues/1">【翻译认领】避免翻译冲突，来此打卡</a>。</p>
<p>如果你想发一个自己专属的「认领issue」也没问题，可以给该issue打上「已认领」标签。开一个独立的issue好处是可以有一个专属的地方讨论你翻译章节内容里的各种问题。</p>
</li>
<li>
<p>为什么要翻译 《Rust 编译器开发指南》  ？</p>
<p>年初的时候，我立下一个五年的 Flag ： 五年内要为 Rust 语言发 1000 个 PR。</p>
<p>然后社区里的朋友就帮我做了一个计算：五年 1000 个，那么每年 200 个，那么一天就得 0.5 个。也有朋友说，Rust 的 PR 每次 Review 周期都很长，就算你能一年提 200 个 PR，官方也不可能给你合并那么多。</p>
<p>这样的计算，确实很有道理。这个目标，确实很难完成。但其实这个 Flag 我并没有打算个人完成，而是想推动社区对 Rust 感兴趣对朋友一起完成。如果五年内，我能推动 1000 个人参与，那么每个人只提交一个 PR，那么这个 1000 个 PR 的 Flag 就轻松完成了。</p>
<p>所以，翻译 《Rust 编译器开发指南》就成了我完成这个 Flag 的第一步。希望大家踊跃参与。</p>
</li>
</ol>
<h1><a class="header" href="#图解-rust-编译器与语言设计--part-1-rust-编译过程与宏展开" id="图解-rust-编译器与语言设计--part-1-rust-编译过程与宏展开">图解 Rust 编译器与语言设计 | Part 1 ：Rust 编译过程与宏展开</a></h1>
<p>作者：张汉东</p>
<hr />
<h2><a class="header" href="#说明" id="说明">说明</a></h2>
<p>《图解 Rust 编译器与语言设计》系列文章特点：</p>
<ol>
<li>重在图解。图解的目的，是为了帮助开发者从整体结构、语义层面来掌握 Rust 编译器与语言设计。</li>
<li>边实践边总结，不一定会每月都有，但争取吧。</li>
<li>希望是众人合力编写，我只是抛砖引玉。硬骨头，一起啃。</li>
</ol>
<h2><a class="header" href="#引子" id="引子">引子</a></h2>
<p>想必读者朋友们都已经看到了 《Rust 日报》里的消息：微软、亚马逊、Facebook等巨头，都在组建自己的 Rust 编译器团队，都在战略性布局针对 Rust 语言。并且 Rust 基金会也已经进入了最后都流程，由此可以猜想，这些巨头很可能已经加入了基金会。</p>
<p>我在 RustChinaConf 2020 年大会分享《Rust 这五年》中盘点了 Rust 这五年多都发展，虽然 Rust 势头很好，但大部分贡献其实都是国外社区带来的，国内社区则是处于学习和观望的状态，等待着所谓的杀手级应用出现来引领 Rust 的“走红”。为什么国内社区不能为 Rust 多做点实质性的贡献呢？</p>
<p>因此，2020 新年到来的时候，我立下一个五年的 Flag ： 五年内要为 Rust 语言发 1000 个 PR。</p>
<p>然后社区里的朋友就帮我做了一个计算：五年 1000 个，那么每年 200 个，那么一天就得 0.5 个。也有朋友说，Rust 的 PR 每次 Review 周期都很长，就算你能一年提 200 个 PR，官方也不可能给你合并那么多。</p>
<p>这样的计算，确实很有道理。这个目标，确实很难完成。但其实这个 Flag 我并没有打算个人完成，而是想推动社区对 Rust 感兴趣对朋友一起完成。如果五年内，我能推动 1000 个人参与，那么每个人只提交一个 PR，那么这个 1000 个 PR 的 Flag 就轻松完成了。</p>
<p>所以，为了完成这个 Flag ，我把未来五年划分成三个阶段：</p>
<ol>
<li>第一阶段：2021 年。该阶段的目标是「上道」。</li>
<li>第二阶段：2022 ～ 2023 年。该阶段的目标是「进阶」。</li>
<li>第三阶段：2024 ~ 2025 年。该阶段目标是「达标」。</li>
</ol>
<p>也就是说，今年是想要「上道」的一年。那么要达成这个目标，我做了以下计划：</p>
<ol>
<li>组织社区力量来翻译官方的《Rust 编译器开发指南》。</li>
<li>组织 Rust 编译器小组，开始为 Rust 语言做点贡献，并且将在此过程中自己的学习和经验沉淀为《图解 Rust 编译器与语言设计》系列文章。</li>
</ol>
<p>通过这两份文档，希望可以帮助和影响到更多的人，来为 Rust 语言做贡献。</p>
<p>我知道，编译器作为程序员的三大浪漫之一，水很深。你也可能会说，人家搞编译器的都是 PL 出生，一般人哪有那种本事。诚然如你所想，编译器很难。但幸亏，难不等于不可能。不会，我们可以学。况且，也不是让你从零开始去实现一个 Rust 编译器。</p>
<p>为 Rust 语言做贡献，并不是 KPI 驱动，而是兴趣驱动。可能你看完了编译原理龙书虎书鲸书三大经典，也可能你实现过自己的一门语言。但其收获可能永远也比不上实际参与到 Rust 这样一个现代化语言项目中来。</p>
<p>所以，《图解 Rust 编译器与语言设计》系列文章，不仅仅会记录我自己学习 Rust 编译器的沉淀，还会记录你的沉淀，如果你愿意投稿的话。在这浮躁的世界，给自己一片净土，找回技术初心。</p>
<hr />
<h2><a class="header" href="#图解-rust-编译过程" id="图解-rust-编译过程">图解 Rust 编译过程</a></h2>
<p>对于学习，我通常习惯先从整体和外围下手，去了解一个东西的全貌和结构之后，再逐步深入细节。否则的话，很容易迷失到细节中。</p>
<p>所以，必须先来了解 Rust 编译过程。如下图：</p>
<p><img src="chapter_1/./rustc/rust-complie-process.png" alt="rust-complie-process" /></p>
<p>上图中间部分为 Rust 代码的整体编译过程，左右两边分别为过程宏和声明宏的解释过程。</p>
<p>Rust 语言是基于 LLVM 后端实现的编程语言。在编译器层面来说，Rust编译器仅仅是一个编译器前端，它负责从文本代码一步步编译到<code>LLVM</code>中间码(<code>LLVM IR</code>)，然后再交给<code>LLVM</code>来最终编译生成机器码，所以<code>LLVM</code>就是编译后端。</p>
<h3><a class="header" href="#rust-语言编译整体流程" id="rust-语言编译整体流程">Rust 语言编译整体流程</a></h3>
<ol>
<li>Rust 文本代码首先要经过「词法分析」阶段。</li>
</ol>
<p>将文本语法中的元素，识别为对 Rust 编译器有意义的「词条」，即<code>token</code>。</p>
<ol start="2">
<li>
<p>经过词法分析之后，再通过语法分析将词条流转成「抽象语法树（AST）」。</p>
</li>
<li>
<p>在得到 AST 之后，Rust 编译器会对其进行「语义分析」。</p>
</li>
</ol>
<p>一般来说，语义分析是为了检查源程序是否符合语言的定义。在 Rust 中，语义分析阶段将会持续在两个中间码层级中进行。</p>
<ol start="4">
<li>语义分析 HIR 阶段。</li>
</ol>
<p>HIR 是抽象语法树（AST）对编译器更友好的表示形式，很多 Rust 语法糖在这一阶段，已经被脱糖（desugared）处理。比如 <code>for</code> 循环在这个阶段会被转为<code>loop</code>，<code>if let</code> 被转为<code>match</code>，等等。HIR 相对于 AST 更有利于编译器的分析工作，它主要被用于 「类型检查（type check）、推断（type inference）」。</p>
<ol start="5">
<li>语义分析 MIR 阶段。</li>
</ol>
<p>MIR 是 Rust 代码的中级中间代表，基于 HIR 进一步简化构建。MIR 是在<code>RFC 1211</code>中引入的。</p>
<p>MIR 主要用于借用检查。早期在没有 MIR 的时候，借用检查是在 HIR 阶段来做的，所以主要问题就是生命周期检查的粒度太粗，只能根据词法作用域来进行判断，导致很多正常代码因为粗粒度的借用检查而无法通过编译。Rust 2018 edition 中引入的 非词法作用域生命周期（NLL）就是为来解决这个问题，让借用检查更加精细。NLL 就是因为 MIR 的引入，将借用检查下放到 MIR 而出现的一个术语，这个术语随着 Rust 的发展终将消失。</p>
<p>MIR 这一层其实担负的工作很多，除了借用检查，还有代码优化、增量编译、Unsafe 代码中 UB 检查、生成<code>LLVM IR</code>等等。关于 MIR 还需要了解它的三个关键特性：</p>
<blockquote>
<ul>
<li>它是基于控制流图（编译原理：Control Flow Graph）的。</li>
<li>它没有嵌套表达式。</li>
<li>MIR 中的所有类型都是完全明确的，不存在隐性表达。人类也可读，所以在 Rust 学习过程中，可以通过查看 MIR 来了解 Rust 代码的一些行为。</li>
</ul>
</blockquote>
<ol start="6">
<li>
<p>图中没有画出来的，还有一个从 HIR 到 MIR 的一个过渡中间代码表示 THIR（Typed HIR） 。THIR 是对 HIR 的进一步降级简化，用于更方便地构建 MIR 。在源码层级中，它属于 MIR 的一部分。</p>
</li>
<li>
<p>生成 <code>LLVM IR</code> 阶段。<code>LLVM IR</code>是<code>LLVM</code>中间语言。<code>LLVM</code>会对<code>LLVM IR</code>进行优化，再生成为机器码。</p>
</li>
</ol>
<p>后端为什么要用 <code>LLVM</code> ？不仅仅是 Rust 使用 <code>LLVM</code>，还有很多其他语言也使用它，比如 Swift 等。 <code>LLVM</code> 的优点：</p>
<blockquote>
<ul>
<li>LLVM后端支持的平台很多，我们不需要担心CPU、操作系统的问题（运行库除外）。</li>
<li>LLVM后端的优化水平较高，我们只需要将代码编译成LLVM IR，就可以由LLVM后端作相应的优化。</li>
<li>LLVM IR本身比较贴近汇编语言，同时也提供了许多ABI层面的定制化功能。</li>
</ul>
</blockquote>
<p>Rust 核心团队也会帮忙维护 <code>LLVM</code>，发现了 Bug 也会提交补丁。虽然<code>LLVM</code>有这么多优点，但它也有一些缺点，比如编译比较慢。所以，Rust 团队在去年引入了新的后端 Cranelift ，用于加速 Debug 模式的编译。Rust 编译器内部组件 <code>rustc_codegen_ssa</code> 会生成后端无关的中间表示，然后由 Cranelift 来处理。从2021年1月开始，通过<code>rustc_codegen_ssa</code> 又为所有后端提供了一个抽象接口以实现，以允许其他代码源后端（例如 Cranelift），这意味着，Rust 语言将来可以接入多个编译后端（如果有的话）。</p>
<p>以上是 Rust 整体编译流程。但 Rust 语言还包含来强大的元编程：「宏（Macro）」，宏代码是如何在编译期展开的呢？请继续往下看。</p>
<h3><a class="header" href="#rust-宏展开" id="rust-宏展开">Rust 宏展开</a></h3>
<p>Rust 本质上存在两类宏：<strong>声明宏（Declarative Macros）</strong> 与 <strong>过程宏（Procedural Macros）</strong> 。很多人可能搞不清楚它们的差异，也许看完这部分内容就懂了。</p>
<p><strong>声明宏</strong></p>
<p>回头再看看上面的图右侧部分。我们知道，Rust 在最初解析文本代码都时候会将代码进行词法分析生成词条流（TokenStream）。在这个过程中，如果遇到了宏代码（不管是声明宏还是过程宏），则会使用专门的「宏解释器（Macro Parser）」 来解析宏代码，将宏代码展开为 TokenStream，然后再合并到普通文本代码生成的 TokenSteam 中。</p>
<p>你可能会有疑问，其他语言的宏都是直接操作 AST ，为什么 Rust 的宏在 Token 层面来处理呢？</p>
<p>这是因为 Rust 语言还在高速迭代期，内部 AST 变动非常频繁，所以无法直接暴露 AST API 供开发者使用。而词法分析相对而言很稳定，所以目前 Rust 宏机制都是基于词条流来完成的。</p>
<p>那么声明宏，就是完全基于词条流（TokenStream)。声明宏的展开过程，其实就是根据指定的匹配规则（类似于正则表达式），将匹配的 Token 替换为指定的 Token 从而达到代码生成的目的。因为仅仅是 Token 的替换（这种替换依然比 C 语言里的那种宏强大），所以你无法在这个过程中进行各种类型计算。</p>
<p><strong>过程宏</strong></p>
<p>声明宏非常方便，但因为它只能做到替换，所以还是非常有局限的。所以后来 Rust 引入了过程宏。过程宏允许你在宏展开过程中进行任意计算。但我们不是说，Rust 没有暴露 AST API 吗？为什么过程宏可以做到这么强大？</p>
<p>其实，过程宏也是基于 TokenSteam API的，只不过由第三方库作者 dtolnay 设计了一套语言外的 AST ，经过这一层 AST 的操作，就实现了想要的结果。</p>
<p>没有什么问题不是可以通过加一层解决的，如果解决不了那就加两层。</p>
<p>dtolnay 在社区内被誉为最佳 API 设计天才。他创造了不少库，比如 Serde，是 Rust 生态中被应用最多的一个库。</p>
<p>话说回来。过程宏的工作机制就如上面图中左侧展示的那样。主要是利用三个库，我称之为 「过程宏三件套」：</p>
<ol>
<li>proc_macro2。该库是对 proc_macro 的封装，是由 Rust 官方提供的。</li>
<li>syn。该库是 dtolnay 实现的，基于 proc_macro2 中暴露的 TokenStream API 来生成 AST 。该库提供来方便的 AST 操作接口。</li>
<li>quote。该库配合 syn，将 AST 转回 TokenSteam，回归到普通文本代码生成的 TokenSteam 中。</li>
</ol>
<p>过程宏的整个过程，就像是水的生态循环。 蒸汽从大海（TokenSteam）中来，然后通过大雨(Syn)，降到地上(Quote)，形成涓涓细流(proc_macro2::TokenStream)最终汇入大海（TokenSteam）。</p>
<p>理解过程宏的展开原理，将有助于你学习过程宏。</p>
<h2><a class="header" href="#小结" id="小结">小结</a></h2>
<p>本篇文章主要介绍了 Rust 代码的编译过程，以及 Rust 宏代码的展开机制，学习这些内容，将有助于你深入理解 Rust 的概念。不知道这篇内容是否激发起你对 Rust 编译器对兴趣呢？编译器是一个深坑，让我们慢慢挖掘它。</p>
<p>感谢阅读。</p>
<h1><a class="header" href="#二月刊february" id="二月刊february">二月刊（February）</a></h1>
<h1><a class="header" href="#三月刊march" id="三月刊march">三月刊（March）</a></h1>
<h1><a class="header" href="#四月刊april" id="四月刊april">四月刊（April）</a></h1>
<h1><a class="header" href="#五月刊may" id="五月刊may">五月刊（May）</a></h1>
<h1><a class="header" href="#六月刊june" id="六月刊june">六月刊（June）</a></h1>
<h1><a class="header" href="#七月刊july" id="七月刊july">七月刊（July）</a></h1>
<h1><a class="header" href="#八月刊august" id="八月刊august">八月刊（August）</a></h1>
<h1><a class="header" href="#九月刊september" id="九月刊september">九月刊（September）</a></h1>
<h1><a class="header" href="#十月刊october" id="十月刊october">十月刊（October）</a></h1>
<h1><a class="header" href="#十一月刊november" id="十一月刊november">十一月刊（November）</a></h1>
<h1><a class="header" href="#十二月刊december" id="十二月刊december">十二月刊（December）</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
